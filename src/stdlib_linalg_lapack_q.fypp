#:include "common.fypp" 
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
module stdlib_linalg_lapack_${ri}$
     use stdlib_linalg_constants
     use stdlib_linalg_blas
     use stdlib_linalg_lapack_aux
     use stdlib_linalg_lapack_s
     use stdlib_linalg_lapack_c
     use stdlib_linalg_lapack_d
     use stdlib_linalg_lapack_z
     implicit none(type,external)
     private


     public :: sp,dp,${rk}$,lk,ilp
     public :: stdlib_${ri}$bbcsd
     public :: stdlib_${ri}$bdsdc
     public :: stdlib_${ri}$bdsqr
     public :: stdlib_${ri}$disna
     public :: stdlib_${ri}$gbbrd
     public :: stdlib_${ri}$gbcon
     public :: stdlib_${ri}$gbequ
     public :: stdlib_${ri}$gbequb
     public :: stdlib_${ri}$gbrfs
     public :: stdlib_${ri}$gbsv
     public :: stdlib_${ri}$gbsvx
     public :: stdlib_${ri}$gbtf2
     public :: stdlib_${ri}$gbtrf
     public :: stdlib_${ri}$gbtrs
     public :: stdlib_${ri}$gebak
     public :: stdlib_${ri}$gebal
     public :: stdlib_${ri}$gebd2
     public :: stdlib_${ri}$gebrd
     public :: stdlib_${ri}$gecon
     public :: stdlib_${ri}$geequ
     public :: stdlib_${ri}$geequb
     public :: stdlib_${ri}$gees
     public :: stdlib_${ri}$geesx
     public :: stdlib_${ri}$geev
     public :: stdlib_${ri}$geevx
     public :: stdlib_${ri}$gehd2
     public :: stdlib_${ri}$gehrd
     public :: stdlib_${ri}$gejsv
     public :: stdlib_${ri}$gelq
     public :: stdlib_${ri}$gelq2
     public :: stdlib_${ri}$gelqf
     public :: stdlib_${ri}$gelqt
     public :: stdlib_${ri}$gelqt3
     public :: stdlib_${ri}$gels
     public :: stdlib_${ri}$gelsd
     public :: stdlib_${ri}$gelss
     public :: stdlib_${ri}$gelsy
     public :: stdlib_${ri}$gemlq
     public :: stdlib_${ri}$gemlqt
     public :: stdlib_${ri}$gemqr
     public :: stdlib_${ri}$gemqrt
     public :: stdlib_${ri}$geql2
     public :: stdlib_${ri}$geqlf
     public :: stdlib_${ri}$geqp3
     public :: stdlib_${ri}$geqr
     public :: stdlib_${ri}$geqr2
     public :: stdlib_${ri}$geqr2p
     public :: stdlib_${ri}$geqrf
     public :: stdlib_${ri}$geqrfp
     public :: stdlib_${ri}$geqrt
     public :: stdlib_${ri}$geqrt2
     public :: stdlib_${ri}$geqrt3
     public :: stdlib_${ri}$gerfs
     public :: stdlib_${ri}$gerq2
     public :: stdlib_${ri}$gerqf
     public :: stdlib_${ri}$gesc2
     public :: stdlib_${ri}$gesdd
     public :: stdlib_${ri}$gesv
     public :: stdlib_${ri}$gesvd
     public :: stdlib_${ri}$gesvdq
     public :: stdlib_${ri}$gesvj
     public :: stdlib_${ri}$gesvx
     public :: stdlib_${ri}$getc2
     public :: stdlib_${ri}$getf2
     public :: stdlib_${ri}$getrf
     public :: stdlib_${ri}$getrf2
     public :: stdlib_${ri}$getri
     public :: stdlib_${ri}$getrs
     public :: stdlib_${ri}$getsls
     public :: stdlib_${ri}$getsqrhrt
     public :: stdlib_${ri}$ggbak
     public :: stdlib_${ri}$ggbal
     public :: stdlib_${ri}$gges
     public :: stdlib_${ri}$gges3
     public :: stdlib_${ri}$ggesx
     public :: stdlib_${ri}$ggev
     public :: stdlib_${ri}$ggev3
     public :: stdlib_${ri}$ggevx
     public :: stdlib_${ri}$ggglm
     public :: stdlib_${ri}$gghd3
     public :: stdlib_${ri}$gghrd
     public :: stdlib_${ri}$gglse
     public :: stdlib_${ri}$ggqrf
     public :: stdlib_${ri}$ggrqf
     public :: stdlib_${ri}$gsvj0
     public :: stdlib_${ri}$gsvj1
     public :: stdlib_${ri}$gtcon
     public :: stdlib_${ri}$gtrfs
     public :: stdlib_${ri}$gtsv
     public :: stdlib_${ri}$gtsvx
     public :: stdlib_${ri}$gttrf
     public :: stdlib_${ri}$gttrs
     public :: stdlib_${ri}$gtts2
     public :: stdlib_${ri}$hgeqz
     public :: stdlib_${ri}$hsein
     public :: stdlib_${ri}$hseqr
     public :: stdlib_${ri}$isnan
     public :: stdlib_${ri}$la_gbamv
     public :: stdlib_${ri}$la_gbrcond
     public :: stdlib_${ri}$la_gbrpvgrw
     public :: stdlib_${ri}$la_geamv
     public :: stdlib_${ri}$la_gercond
     public :: stdlib_${ri}$la_gerpvgrw
     public :: stdlib_${ri}$la_lin_berr
     public :: stdlib_${ri}$la_porcond
     public :: stdlib_${ri}$la_porpvgrw
     public :: stdlib_${ri}$la_syamv
     public :: stdlib_${ri}$la_syrcond
     public :: stdlib_${ri}$la_syrpvgrw
     public :: stdlib_${ri}$la_wwaddw
     public :: stdlib_${ri}$labad
     public :: stdlib_${ri}$labrd
     public :: stdlib_${ri}$lacn2
     public :: stdlib_${ri}$lacon
     public :: stdlib_${ri}$lacpy
     public :: stdlib_${ri}$ladiv
     public :: stdlib_${ri}$ladiv1
     public :: stdlib_${ri}$ladiv2
     public :: stdlib_${ri}$lae2
     public :: stdlib_${ri}$laebz
     public :: stdlib_${ri}$laed0
     public :: stdlib_${ri}$laed1
     public :: stdlib_${ri}$laed2
     public :: stdlib_${ri}$laed3
     public :: stdlib_${ri}$laed4
     public :: stdlib_${ri}$laed5
     public :: stdlib_${ri}$laed6
     public :: stdlib_${ri}$laed7
     public :: stdlib_${ri}$laed8
     public :: stdlib_${ri}$laed9
     public :: stdlib_${ri}$laeda
     public :: stdlib_${ri}$laein
     public :: stdlib_${ri}$laev2
     public :: stdlib_${ri}$laexc
     public :: stdlib_${ri}$lag2
     public :: stdlib_${ri}$lag2s
     public :: stdlib_dlag2${ri}$
     public :: stdlib_${ri}$lags2
     public :: stdlib_${ri}$lagtf
     public :: stdlib_${ri}$lagtm
     public :: stdlib_${ri}$lagts
     public :: stdlib_${ri}$lagv2
     public :: stdlib_${ri}$lahqr
     public :: stdlib_${ri}$lahr2
     public :: stdlib_${ri}$laic1
     public :: stdlib_${ri}$laisnan
     public :: stdlib_${ri}$laln2
     public :: stdlib_${ri}$lals0
     public :: stdlib_${ri}$lalsa
     public :: stdlib_${ri}$lalsd
     public :: stdlib_${ri}$lamch
     public :: stdlib_${ri}$lamc3
     public :: stdlib_${ri}$lamrg
     public :: stdlib_${ri}$lamswlq
     public :: stdlib_${ri}$lamtsqr
     public :: stdlib_${ri}$laneg
     public :: stdlib_${ri}$langb
     public :: stdlib_${ri}$lange
     public :: stdlib_${ri}$langt
     public :: stdlib_${ri}$lanhs
     public :: stdlib_${ri}$lansb
     public :: stdlib_${ri}$lansf
     public :: stdlib_${ri}$lansp
     public :: stdlib_${ri}$lanst
     public :: stdlib_${ri}$lansy
     public :: stdlib_${ri}$lantb
     public :: stdlib_${ri}$lantp
     public :: stdlib_${ri}$lantr
     public :: stdlib_${ri}$lanv2
     public :: stdlib_${ri}$laorhr_col_getrfnp
     public :: stdlib_${ri}$laorhr_col_getrfnp2
     public :: stdlib_${ri}$lapll
     public :: stdlib_${ri}$lapmr
     public :: stdlib_${ri}$lapmt
     public :: stdlib_${ri}$lapy2
     public :: stdlib_${ri}$lapy3
     public :: stdlib_${ri}$laqgb
     public :: stdlib_${ri}$laqge
     public :: stdlib_${ri}$laqp2
     public :: stdlib_${ri}$laqps
     public :: stdlib_${ri}$laqr0
     public :: stdlib_${ri}$laqr1
     public :: stdlib_${ri}$laqr2
     public :: stdlib_${ri}$laqr3
     public :: stdlib_${ri}$laqr4
     public :: stdlib_${ri}$laqr5
     public :: stdlib_${ri}$laqsb
     public :: stdlib_${ri}$laqsp
     public :: stdlib_${ri}$laqsy
     public :: stdlib_${ri}$laqtr
     public :: stdlib_${ri}$laqz0
     public :: stdlib_${ri}$laqz1
     public :: stdlib_${ri}$laqz2
     public :: stdlib_${ri}$laqz3
     public :: stdlib_${ri}$laqz4
     public :: stdlib_${ri}$lar1v
     public :: stdlib_${ri}$lar2v
     public :: stdlib_${ri}$larf
     public :: stdlib_${ri}$larfb
     public :: stdlib_${ri}$larfb_gett
     public :: stdlib_${ri}$larfg
     public :: stdlib_${ri}$larfgp
     public :: stdlib_${ri}$larft
     public :: stdlib_${ri}$larfx
     public :: stdlib_${ri}$larfy
     public :: stdlib_${ri}$largv
     public :: stdlib_${ri}$larnv
     public :: stdlib_${ri}$larra
     public :: stdlib_${ri}$larrb
     public :: stdlib_${ri}$larrc
     public :: stdlib_${ri}$larrd
     public :: stdlib_${ri}$larre
     public :: stdlib_${ri}$larrf
     public :: stdlib_${ri}$larrj
     public :: stdlib_${ri}$larrk
     public :: stdlib_${ri}$larrr
     public :: stdlib_${ri}$larrv
     public :: stdlib_${ri}$lartg
     public :: stdlib_${ri}$lartgp
     public :: stdlib_${ri}$lartgs
     public :: stdlib_${ri}$lartv
     public :: stdlib_${ri}$laruv
     public :: stdlib_${ri}$larz
     public :: stdlib_${ri}$larzb
     public :: stdlib_${ri}$larzt
     public :: stdlib_${ri}$las2
     public :: stdlib_${ri}$lascl
     public :: stdlib_${ri}$lasd0
     public :: stdlib_${ri}$lasd1
     public :: stdlib_${ri}$lasd2
     public :: stdlib_${ri}$lasd3
     public :: stdlib_${ri}$lasd4
     public :: stdlib_${ri}$lasd5
     public :: stdlib_${ri}$lasd6
     public :: stdlib_${ri}$lasd7
     public :: stdlib_${ri}$lasd8
     public :: stdlib_${ri}$lasda
     public :: stdlib_${ri}$lasdq
     public :: stdlib_${ri}$lasdt
     public :: stdlib_${ri}$laset
     public :: stdlib_${ri}$lasq1
     public :: stdlib_${ri}$lasq2
     public :: stdlib_${ri}$lasq3
     public :: stdlib_${ri}$lasq4
     public :: stdlib_${ri}$lasq5
     public :: stdlib_${ri}$lasq6
     public :: stdlib_${ri}$lasr
     public :: stdlib_${ri}$lasrt
     public :: stdlib_${ri}$lassq
     public :: stdlib_${ri}$lasv2
     public :: stdlib_${ri}$laswlq
     public :: stdlib_${ri}$laswp
     public :: stdlib_${ri}$lasy2
     public :: stdlib_${ri}$lasyf
     public :: stdlib_${ri}$lasyf_aa
     public :: stdlib_${ri}$lasyf_rk
     public :: stdlib_${ri}$lasyf_rook
     public :: stdlib_${ri}$lat2s
     public :: stdlib_${ri}$latbs
     public :: stdlib_${ri}$latdf
     public :: stdlib_${ri}$latps
     public :: stdlib_${ri}$latrd
     public :: stdlib_${ri}$latrs
     public :: stdlib_${ri}$latrz
     public :: stdlib_${ri}$latsqr
     public :: stdlib_${ri}$lauu2
     public :: stdlib_${ri}$lauum
     public :: stdlib_${ri}$opgtr
     public :: stdlib_${ri}$opmtr
     public :: stdlib_${ri}$orbdb
     public :: stdlib_${ri}$orbdb1
     public :: stdlib_${ri}$orbdb2
     public :: stdlib_${ri}$orbdb3
     public :: stdlib_${ri}$orbdb4
     public :: stdlib_${ri}$orbdb5
     public :: stdlib_${ri}$orbdb6
     public :: stdlib_${ri}$orcsd
     public :: stdlib_${ri}$orcsd2by1
     public :: stdlib_${ri}$org2l
     public :: stdlib_${ri}$org2r
     public :: stdlib_${ri}$orgbr
     public :: stdlib_${ri}$orghr
     public :: stdlib_${ri}$orgl2
     public :: stdlib_${ri}$orglq
     public :: stdlib_${ri}$orgql
     public :: stdlib_${ri}$orgqr
     public :: stdlib_${ri}$orgr2
     public :: stdlib_${ri}$orgrq
     public :: stdlib_${ri}$orgtr
     public :: stdlib_${ri}$orgtsqr
     public :: stdlib_${ri}$orgtsqr_row
     public :: stdlib_${ri}$orhr_col
     public :: stdlib_${ri}$orm22
     public :: stdlib_${ri}$orm2l
     public :: stdlib_${ri}$orm2r
     public :: stdlib_${ri}$ormbr
     public :: stdlib_${ri}$ormhr
     public :: stdlib_${ri}$orml2
     public :: stdlib_${ri}$ormlq
     public :: stdlib_${ri}$ormql
     public :: stdlib_${ri}$ormqr
     public :: stdlib_${ri}$ormr2
     public :: stdlib_${ri}$ormr3
     public :: stdlib_${ri}$ormrq
     public :: stdlib_${ri}$ormrz
     public :: stdlib_${ri}$ormtr
     public :: stdlib_${ri}$pbcon
     public :: stdlib_${ri}$pbequ
     public :: stdlib_${ri}$pbrfs
     public :: stdlib_${ri}$pbstf
     public :: stdlib_${ri}$pbsv
     public :: stdlib_${ri}$pbsvx
     public :: stdlib_${ri}$pbtf2
     public :: stdlib_${ri}$pbtrf
     public :: stdlib_${ri}$pbtrs
     public :: stdlib_${ri}$pftrf
     public :: stdlib_${ri}$pftri
     public :: stdlib_${ri}$pftrs
     public :: stdlib_${ri}$pocon
     public :: stdlib_${ri}$poequ
     public :: stdlib_${ri}$poequb
     public :: stdlib_${ri}$porfs
     public :: stdlib_${ri}$posv
     public :: stdlib_${ri}$posvx
     public :: stdlib_${ri}$potf2
     public :: stdlib_${ri}$potrf
     public :: stdlib_${ri}$potrf2
     public :: stdlib_${ri}$potri
     public :: stdlib_${ri}$potrs
     public :: stdlib_${ri}$ppcon
     public :: stdlib_${ri}$ppequ
     public :: stdlib_${ri}$pprfs
     public :: stdlib_${ri}$ppsv
     public :: stdlib_${ri}$ppsvx
     public :: stdlib_${ri}$pptrf
     public :: stdlib_${ri}$pptri
     public :: stdlib_${ri}$pptrs
     public :: stdlib_${ri}$pstf2
     public :: stdlib_${ri}$pstrf
     public :: stdlib_${ri}$ptcon
     public :: stdlib_${ri}$pteqr
     public :: stdlib_${ri}$ptrfs
     public :: stdlib_${ri}$ptsv
     public :: stdlib_${ri}$ptsvx
     public :: stdlib_${ri}$pttrf
     public :: stdlib_${ri}$pttrs
     public :: stdlib_${ri}$ptts2
     public :: stdlib_${ri}$rscl
     public :: stdlib_${ri}$sb2st_kernels
     public :: stdlib_${ri}$sbev
     public :: stdlib_${ri}$sbevd
     public :: stdlib_${ri}$sbevx
     public :: stdlib_${ri}$sbgst
     public :: stdlib_${ri}$sbgv
     public :: stdlib_${ri}$sbgvd
     public :: stdlib_${ri}$sbgvx
     public :: stdlib_${ri}$sbtrd
     public :: stdlib_${ri}$sfrk
     public :: stdlib_${ri}$sgesv
     public :: stdlib_${ri}$spcon
     public :: stdlib_${ri}$spev
     public :: stdlib_${ri}$spevd
     public :: stdlib_${ri}$spevx
     public :: stdlib_${ri}$spgst
     public :: stdlib_${ri}$spgv
     public :: stdlib_${ri}$spgvd
     public :: stdlib_${ri}$spgvx
     public :: stdlib_${ri}$sposv
     public :: stdlib_${ri}$sprfs
     public :: stdlib_${ri}$spsv
     public :: stdlib_${ri}$spsvx
     public :: stdlib_${ri}$sptrd
     public :: stdlib_${ri}$sptrf
     public :: stdlib_${ri}$sptri
     public :: stdlib_${ri}$sptrs
     public :: stdlib_${ri}$stebz
     public :: stdlib_${ri}$stedc
     public :: stdlib_${ri}$stegr
     public :: stdlib_${ri}$stein
     public :: stdlib_${ri}$stemr
     public :: stdlib_${ri}$steqr
     public :: stdlib_${ri}$sterf
     public :: stdlib_${ri}$stev
     public :: stdlib_${ri}$stevd
     public :: stdlib_${ri}$stevr
     public :: stdlib_${ri}$stevx
     public :: stdlib_${ri}$sycon
     public :: stdlib_${ri}$sycon_rook
     public :: stdlib_${ri}$syconv
     public :: stdlib_${ri}$syconvf
     public :: stdlib_${ri}$syconvf_rook
     public :: stdlib_${ri}$syequb
     public :: stdlib_${ri}$syev
     public :: stdlib_${ri}$syevd
     public :: stdlib_${ri}$syevr
     public :: stdlib_${ri}$syevx
     public :: stdlib_${ri}$sygs2
     public :: stdlib_${ri}$sygst
     public :: stdlib_${ri}$sygv
     public :: stdlib_${ri}$sygvd
     public :: stdlib_${ri}$sygvx
     public :: stdlib_${ri}$syrfs
     public :: stdlib_${ri}$sysv
     public :: stdlib_${ri}$sysv_aa
     public :: stdlib_${ri}$sysv_rk
     public :: stdlib_${ri}$sysv_rook
     public :: stdlib_${ri}$sysvx
     public :: stdlib_${ri}$syswapr
     public :: stdlib_${ri}$sytd2
     public :: stdlib_${ri}$sytf2
     public :: stdlib_${ri}$sytf2_rk
     public :: stdlib_${ri}$sytf2_rook
     public :: stdlib_${ri}$sytrd
     public :: stdlib_${ri}$sytrd_sb2st
     public :: stdlib_${ri}$sytrd_sy2sb
     public :: stdlib_${ri}$sytrf
     public :: stdlib_${ri}$sytrf_aa
     public :: stdlib_${ri}$sytrf_rk
     public :: stdlib_${ri}$sytrf_rook
     public :: stdlib_${ri}$sytri
     public :: stdlib_${ri}$sytri_rook
     public :: stdlib_${ri}$sytrs
     public :: stdlib_${ri}$sytrs2
     public :: stdlib_${ri}$sytrs_3
     public :: stdlib_${ri}$sytrs_aa
     public :: stdlib_${ri}$sytrs_rook
     public :: stdlib_${ri}$tbcon
     public :: stdlib_${ri}$tbrfs
     public :: stdlib_${ri}$tbtrs
     public :: stdlib_${ri}$tfsm
     public :: stdlib_${ri}$tftri
     public :: stdlib_${ri}$tfttp
     public :: stdlib_${ri}$tfttr
     public :: stdlib_${ri}$tgevc
     public :: stdlib_${ri}$tgex2
     public :: stdlib_${ri}$tgexc
     public :: stdlib_${ri}$tgsen
     public :: stdlib_${ri}$tgsja
     public :: stdlib_${ri}$tgsna
     public :: stdlib_${ri}$tgsy2
     public :: stdlib_${ri}$tgsyl
     public :: stdlib_${ri}$tpcon
     public :: stdlib_${ri}$tplqt
     public :: stdlib_${ri}$tplqt2
     public :: stdlib_${ri}$tpmlqt
     public :: stdlib_${ri}$tpmqrt
     public :: stdlib_${ri}$tpqrt
     public :: stdlib_${ri}$tpqrt2
     public :: stdlib_${ri}$tprfb
     public :: stdlib_${ri}$tprfs
     public :: stdlib_${ri}$tptri
     public :: stdlib_${ri}$tptrs
     public :: stdlib_${ri}$tpttf
     public :: stdlib_${ri}$tpttr
     public :: stdlib_${ri}$trcon
     public :: stdlib_${ri}$trevc
     public :: stdlib_${ri}$trevc3
     public :: stdlib_${ri}$trexc
     public :: stdlib_${ri}$trrfs
     public :: stdlib_${ri}$trsen
     public :: stdlib_${ri}$trsna
     public :: stdlib_${ri}$trsyl
     public :: stdlib_${ri}$trti2
     public :: stdlib_${ri}$trtri
     public :: stdlib_${ri}$trtrs
     public :: stdlib_${ri}$trttf
     public :: stdlib_${ri}$trttp
     public :: stdlib_${ri}$tzrzf
     public :: stdlib_${ri}$zsum1

     ! 128-bit real constants 
     real(${rk}$),    parameter, private ::     negone = -1.00_${rk}$
     real(${rk}$),    parameter, private ::       zero = 0.00_${rk}$
     real(${rk}$),    parameter, private ::       half = 0.50_${rk}$
     real(${rk}$),    parameter, private ::        one = 1.00_${rk}$
     real(${rk}$),    parameter, private ::        two = 2.00_${rk}$
     real(${rk}$),    parameter, private ::      three = 3.00_${rk}$
     real(${rk}$),    parameter, private ::       four = 4.00_${rk}$
     real(${rk}$),    parameter, private ::      eight = 8.00_${rk}$
     real(${rk}$),    parameter, private ::        ten = 10.00_${rk}$

     ! 128-bit complex constants 
     complex(${rk}$), parameter, private :: czero   = ( 0.0_${rk}$,0.0_${rk}$)
     complex(${rk}$), parameter, private :: chalf   = ( 0.5_${rk}$,0.0_${rk}$)
     complex(${rk}$), parameter, private :: cone    = ( 1.0_${rk}$,0.0_${rk}$)
     complex(${rk}$), parameter, private :: cnegone = (-1.0_${rk}$,0.0_${rk}$)

     ! 128-bit scaling constants 
     integer,     parameter, private :: maxexp = maxexponent(zero) 
     integer,     parameter, private :: minexp = minexponent(zero) 
     real(${rk}$),    parameter, private :: rradix = real(radix(zero),${rk}$) 
     real(${rk}$),    parameter, private :: ulp    = epsilon(zero) 
     real(${rk}$),    parameter, private :: eps    = ulp*half 
     real(${rk}$),    parameter, private :: safmin = rradix**max(minexp-1,1-maxexp) 
     real(${rk}$),    parameter, private :: safmax = one/safmin 
     real(${rk}$),    parameter, private :: smlnum = safmin/ulp 
     real(${rk}$),    parameter, private :: bignum = safmax*ulp 
     real(${rk}$),    parameter, private :: rtmin  = sqrt(smlnum) 
     real(${rk}$),    parameter, private :: rtmax  = sqrt(bignum) 

     ! 128-bit Blue's scaling constants 
     ! ssml>=1/s and sbig==1/S with s,S as defined in https://doi.org/10.1145/355769.355771 
     real(${rk}$),    parameter, private :: tsml   = rradix**ceiling((minexp-1)*half) 
     real(${rk}$),    parameter, private :: tbig   = rradix**floor((maxexp-digits(zero)+1)*half) 
     real(${rk}$),    parameter, private :: ssml   = rradix**(-floor((minexp-digits(zero))*half)) 
     real(${rk}$),    parameter, private :: sbig   = rradix**(-ceiling((maxexp+digits(zero)-1)*half)) 


     contains


     pure subroutine stdlib_${ri}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     !! DBBCSD: computes the CS decomposition of an orthogonal matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See DORCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The orthogonal matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, &
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           ! Array Arguments 
           real(${rk}$), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(${rk}$), intent(inout) :: phi(*), theta(*)
           real(${rk}$), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(${rk}$), parameter :: hundred = 100.0_${rk}$
           real(${rk}$), parameter :: meighth = -0.125_${rk}$
           real(${rk}$), parameter :: piover2 = 1.57079632679489661923132169163975144210_${rk}$
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lworkmin, lworkopt, maxit, mini
           real(${rk}$) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           intrinsic :: abs,atan2,cos,max,min,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lworkmin = 1
              work(1) = lworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lworkopt = iv2tsn + q - 1
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_${ri}$las2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_${ri}$las2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_${rk}$ - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_${ri}$lartgs( b11d(imin), b11e(imin), mu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              else
                 call stdlib_${ri}$lartgs( b21d(imin), b21e(imin), nu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              end if
              temp = work(iv1tcs+imin-1)*b11d(imin) +work(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = work(iv1tcs+imin-1)*b11e(imin) -work(iv1tsn+imin-1)*b11d(imin)
              b11d(imin) = temp
              b11bulge = work(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iv1tcs+imin-1)*b11d(imin+1)
              temp = work(iv1tcs+imin-1)*b21d(imin) +work(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = work(iv1tcs+imin-1)*b21e(imin) -work(iv1tsn+imin-1)*b21d(imin)
              b21d(imin) = temp
              b21bulge = work(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_${ri}$lartgp( b11bulge, b11d(imin), work(iu1sn+imin-1),work(iu1cs+imin-1),&
                            r )
              else if( mu <= nu ) then
                 call stdlib_${ri}$lartgs( b11e( imin ), b11d( imin + 1 ), mu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              else
                 call stdlib_${ri}$lartgs( b12d( imin ), b12e( imin ), nu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_${ri}$lartgp( b21bulge, b21d(imin), work(iu2sn+imin-1),work(iu2cs+imin-1),&
                            r )
              else if( nu < mu ) then
                 call stdlib_${ri}$lartgs( b21e( imin ), b21d( imin + 1 ), nu,work(iu2cs+imin-1), work(&
                           iu2sn+imin-1) )
              else
                 call stdlib_${ri}$lartgs( b22d(imin), b22e(imin), mu,work(iu2cs+imin-1), work(iu2sn+&
                           imin-1) )
              end if
              work(iu2cs+imin-1) = -work(iu2cs+imin-1)
              work(iu2sn+imin-1) = -work(iu2sn+imin-1)
              temp = work(iu1cs+imin-1)*b11e(imin) +work(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iu1cs+imin-1)*b11d(imin+1) -work(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = work(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = work(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = work(iu1cs+imin-1)*b12d(imin) +work(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = work(iu1cs+imin-1)*b12e(imin) -work(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = work(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = work(iu1cs+imin-1)*b12d(imin+1)
              temp = work(iu2cs+imin-1)*b21e(imin) +work(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iu2cs+imin-1)*b21d(imin+1) -work(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = work(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = work(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = work(iu2cs+imin-1)*b22d(imin) +work(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = work(iu2cs+imin-1)*b22e(imin) -work(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = work(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = work(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_${ri}$lartgp( x2, x1, work(iv1tsn+i-1), work(iv1tcs+i-1),r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_${ri}$lartgp( b11bulge, b11e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_${ri}$lartgp( b21bulge, b21e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_${ri}$lartgs( b11d(i), b11e(i), mu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 else
                    call stdlib_${ri}$lartgs( b21d(i), b21e(i), nu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 end if
                 work(iv1tcs+i-1) = -work(iv1tcs+i-1)
                 work(iv1tsn+i-1) = -work(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( y2, y1, work(iv2tsn+i-1-1),work(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_${ri}$lartgp( b12bulge, b12d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( b22bulge, b22d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( nu < mu ) then
                    call stdlib_${ri}$lartgs( b12e(i-1), b12d(i), nu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 else
                    call stdlib_${ri}$lartgs( b22e(i-1), b22d(i), mu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 end if
                 temp = work(iv1tcs+i-1)*b11d(i) + work(iv1tsn+i-1)*b11e(i)
                 b11e(i) = work(iv1tcs+i-1)*b11e(i) -work(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = work(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iv1tcs+i-1)*b11d(i+1)
                 temp = work(iv1tcs+i-1)*b21d(i) + work(iv1tsn+i-1)*b21e(i)
                 b21e(i) = work(iv1tcs+i-1)*b21e(i) -work(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = work(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iv1tcs+i-1)*b21d(i+1)
                 temp = work(iv2tcs+i-1-1)*b12e(i-1) +work(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = work(iv2tcs+i-1-1)*b12d(i) -work(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = work(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = work(iv2tcs+i-1-1)*b12e(i)
                 temp = work(iv2tcs+i-1-1)*b22e(i-1) +work(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = work(iv2tcs+i-1-1)*b22d(i) -work(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = work(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = work(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_${ri}$lartgp( x2, x1, work(iu1sn+i-1), work(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_${ri}$lartgp( b11bulge, b11d(i), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_${ri}$lartgp( b12bulge, b12e(i-1), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( mu <= nu ) then
                    call stdlib_${ri}$lartgs( b11e(i), b11d(i+1), mu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 else
                    call stdlib_${ri}$lartgs( b12d(i), b12e(i), nu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( y2, y1, work(iu2sn+i-1), work(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_${ri}$lartgp( b21bulge, b21d(i), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( b22bulge, b22e(i-1), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( nu < mu ) then
                    call stdlib_${ri}$lartgs( b21e(i), b21e(i+1), nu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 else
                    call stdlib_${ri}$lartgs( b22d(i), b22e(i), mu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 end if
                 work(iu2cs+i-1) = -work(iu2cs+i-1)
                 work(iu2sn+i-1) = -work(iu2sn+i-1)
                 temp = work(iu1cs+i-1)*b11e(i) + work(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iu1cs+i-1)*b11d(i+1) -work(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = work(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = work(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = work(iu2cs+i-1)*b21e(i) + work(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iu2cs+i-1)*b21d(i+1) -work(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = work(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = work(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = work(iu1cs+i-1)*b12d(i) + work(iu1sn+i-1)*b12e(i)
                 b12e(i) = work(iu1cs+i-1)*b12e(i) - work(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = work(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = work(iu1cs+i-1)*b12d(i+1)
                 temp = work(iu2cs+i-1)*b22d(i) + work(iu2sn+i-1)*b22e(i)
                 b22e(i) = work(iu2cs+i-1)*b22e(i) - work(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = work(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = work(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_${ri}$lartgp( y2, y1, work(iv2tsn+imax-1-1),work(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_${ri}$lartgp( b12bulge, b12d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_${ri}$lartgp( b22bulge, b22d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_${ri}$lartgs( b12e(imax-1), b12d(imax), nu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_${ri}$lartgs( b22e(imax-1), b22d(imax), mu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              end if
              temp = work(iv2tcs+imax-1-1)*b12e(imax-1) +work(iv2tsn+imax-1-1)*b12d(imax)
              b12d(imax) = work(iv2tcs+imax-1-1)*b12d(imax) -work(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = work(iv2tcs+imax-1-1)*b22e(imax-1) +work(iv2tsn+imax-1-1)*b22d(imax)
              b22d(imax) = work(iv2tcs+imax-1-1)*b22d(imax) -work(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', p, imax-imin+1,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, p,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', m-p, imax-imin+1,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, m-p,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, q,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', q, imax-imin+1,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, m-q,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', m-q, imax-imin+1,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( q, negone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_${ri}$scal( q, negone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( p, negone, u1(1,imax), 1 )
                    else
                       call stdlib_${ri}$scal( p, negone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( m-p, negone, u2(1,imax), 1 )
                    else
                       call stdlib_${ri}$scal( m-p, negone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( m-q, negone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_${ri}$scal( m-q, negone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_${ri}$swap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_${ri}$swap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_${ri}$swap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_${ri}$swap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_${ri}$swap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_${ri}$swap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_${ri}$swap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_${ri}$swap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_${ri}$bbcsd


     pure subroutine stdlib_${ri}$bdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! DBDSDC: computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. DBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLASD3 for details.
     !! The code currently calls DLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(${rk}$) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,log,sign
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_${ri}$copy( n, d, 1, q( 1 ), 1 )
              call stdlib_${ri}$copy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_${ri}$lasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_${ri}$lasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_${ri}$lasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_${ri}$lasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_${ri}$laset( 'A', n, n, zero, one, u, ldu )
              call stdlib_${ri}$laset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = (0.9e+0_${rk}$)*stdlib_${ri}$lamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=${rk}$) / real( smlsiz+1,KIND=${rk}$) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
                    ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_${ri}$lasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_${ri}$lasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_${ri}$swap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_${ri}$swap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_${ri}$lasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_${ri}$bdsdc


     pure subroutine stdlib_${ri}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! DBDSQR: computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by DGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: hndrth = 0.01_${rk}$
           real(${rk}$), parameter :: hndrd = 100.0_${rk}$
           real(${rk}$), parameter :: meigth = -0.125_${rk}$
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(${rk}$) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_${ri}$lasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=${rk}$) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_${ri}$lasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_${ri}$rot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_${ri}$rot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_${ri}$rot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_${ri}$las2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_${ri}$las2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_${ri}$lartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_${ri}$lartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_${ri}$lartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_${ri}$lartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_${ri}$lartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_${ri}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_${ri}$lartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_${ri}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_${ri}$scal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_${ri}$swap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_${ri}$swap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_${ri}$swap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_${ri}$bdsqr


     pure subroutine stdlib_${ri}$disna( job, m, n, d, sep, info )
     !! DDISNA: computes the reciprocal condition numbers for the eigenvectors
     !! of a real symmetric or complex Hermitian matrix or for the left or
     !! right singular vectors of a general m-by-n matrix. The reciprocal
     !! condition number is the 'gap' between the corresponding eigenvalue or
     !! singular value and the nearest other one.
     !! The bound on the error, measured by angle in radians, in the I-th
     !! computed vector is given by
     !! DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
     !! where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
     !! to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
     !! the error bound.
     !! DDISNA may also be used to compute error bounds for eigenvectors of
     !! the generalized symmetric definite eigenproblem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: m, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(out) :: sep(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: decr, eigen, incr, left, right, sing
           integer(ilp) :: i, k
           real(${rk}$) :: anorm, eps, newgap, oldgap, safmin, thresh
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           eigen = stdlib_lsame( job, 'E' )
           left = stdlib_lsame( job, 'L' )
           right = stdlib_lsame( job, 'R' )
           sing = left .or. right
           if( eigen ) then
              k = m
           else if( sing ) then
              k = min( m, n )
           end if
           if( .not.eigen .and. .not.sing ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( k<0 ) then
              info = -3
           else
              incr = .true.
              decr = .true.
              do i = 1, k - 1
                 if( incr )incr = incr .and. d( i )<=d( i+1 )
                 if( decr )decr = decr .and. d( i )>=d( i+1 )
              end do
              if( sing .and. k>0 ) then
                 if( incr )incr = incr .and. zero<=d( 1 )
                 if( decr )decr = decr .and. d( k )>=zero
              end if
              if( .not.( incr .or. decr ) )info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DDISNA', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! compute reciprocal condition numbers
           if( k==1 ) then
              sep( 1 ) = stdlib_${ri}$lamch( 'O' )
           else
              oldgap = abs( d( 2 )-d( 1 ) )
              sep( 1 ) = oldgap
              do i = 2, k - 1
                 newgap = abs( d( i+1 )-d( i ) )
                 sep( i ) = min( oldgap, newgap )
                 oldgap = newgap
              end do
              sep( k ) = oldgap
           end if
           if( sing ) then
              if( ( left .and. m>n ) .or. ( right .and. m<n ) ) then
                 if( incr )sep( 1 ) = min( sep( 1 ), d( 1 ) )
                 if( decr )sep( k ) = min( sep( k ), d( k ) )
              end if
           end if
           ! ensure that reciprocal condition numbers are not less than
           ! threshold, in order to limit the size of the error bound
           eps = stdlib_${ri}$lamch( 'E' )
           safmin = stdlib_${ri}$lamch( 'S' )
           anorm = max( abs( d( 1 ) ), abs( d( k ) ) )
           if( anorm==zero ) then
              thresh = eps
           else
              thresh = max( eps*anorm, safmin )
           end if
           do i = 1, k
              sep( i ) = max( sep( i ), thresh )
           end do
           return
     end subroutine stdlib_${ri}$disna


     pure subroutine stdlib_${ri}$gbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
     !! DGBBRD: reduces a real general m-by-n band matrix A to upper
     !! bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
     !! The routine computes B, and optionally forms Q or P**T, or computes
     !! Q**T*C for a given matrix C.
               ldc, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), c(ldc,*)
           real(${rk}$), intent(out) :: d(*), e(*), pt(ldpt,*), q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantb, wantc, wantpt, wantq
           integer(ilp) :: i, inca, j, j1, j2, kb, kb1, kk, klm, klu1, kun, l, minmn, ml, ml0, mn,&
                      mu, mu0, nr, nrt
           real(${rk}$) :: ra, rb, rc, rs
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           wantb = stdlib_lsame( vect, 'B' )
           wantq = stdlib_lsame( vect, 'Q' ) .or. wantb
           wantpt = stdlib_lsame( vect, 'P' ) .or. wantb
           wantc = ncc>0
           klu1 = kl + ku + 1
           info = 0
           if( .not.wantq .and. .not.wantpt .and. .not.stdlib_lsame( vect, 'N' ) )then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ncc<0 ) then
              info = -4
           else if( kl<0 ) then
              info = -5
           else if( ku<0 ) then
              info = -6
           else if( ldab<klu1 ) then
              info = -8
           else if( ldq<1 .or. wantq .and. ldq<max( 1, m ) ) then
              info = -12
           else if( ldpt<1 .or. wantpt .and. ldpt<max( 1, n ) ) then
              info = -14
           else if( ldc<1 .or. wantc .and. ldc<max( 1, m ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBBRD', -info )
              return
           end if
           ! initialize q and p**t to the unit matrix, if needed
           if( wantq )call stdlib_${ri}$laset( 'FULL', m, m, zero, one, q, ldq )
           if( wantpt )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, pt, ldpt )
           ! quick return if possible.
           if( m==0 .or. n==0 )return
           minmn = min( m, n )
           if( kl+ku>1 ) then
              ! reduce to upper bidiagonal form if ku > 0; if ku = 0, reduce
              ! first to lower bidiagonal form and then transform to upper
              ! bidiagonal
              if( ku>0 ) then
                 ml0 = 1
                 mu0 = 2
              else
                 ml0 = 2
                 mu0 = 1
              end if
              ! wherever possible, plane rotations are generated and applied in
              ! vector operations of length nr over the index set j1:j2:klu1.
              ! the sines of the plane rotations are stored in work(1:max(m,n))
              ! and the cosines in work(max(m,n)+1:2*max(m,n)).
              mn = max( m, n )
              klm = min( m-1, kl )
              kun = min( n-1, ku )
              kb = klm + kun
              kb1 = kb + 1
              inca = kb1*ldab
              nr = 0
              j1 = klm + 2
              j2 = 1 - kun
              loop_90: do i = 1, minmn
                 ! reduce i-th column and i-th row of matrix to bidiagonal form
                 ml = klm + 1
                 mu = kun + 1
                 loop_80: do kk = 1, kb
                    j1 = j1 + kb
                    j2 = j2 + kb
                    ! generate plane rotations to annihilate nonzero elements
                    ! which have been created below the band
                    if( nr>0 )call stdlib_${ri}$largv( nr, ab( klu1, j1-klm-1 ), inca,work( j1 ), kb1, &
                              work( mn+j1 ), kb1 )
                    ! apply plane rotations from the left
                    do l = 1, kb
                       if( j2-klm+l-1>n ) then
                          nrt = nr - 1
                       else
                          nrt = nr
                       end if
                       if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( klu1-l, j1-klm+l-1 ), inca,ab( &
                                 klu1-l+1, j1-klm+l-1 ), inca,work( mn+j1 ), work( j1 ), kb1 )
                    end do
                    if( ml>ml0 ) then
                       if( ml<=m-i+1 ) then
                          ! generate plane rotation to annihilate a(i+ml-1,i)
                          ! within the band, and apply rotation from the left
                          call stdlib_${ri}$lartg( ab( ku+ml-1, i ), ab( ku+ml, i ),work( mn+i+ml-1 ), &
                                    work( i+ml-1 ),ra )
                          ab( ku+ml-1, i ) = ra
                          if( i<n )call stdlib_${ri}$rot( min( ku+ml-2, n-i ),ab( ku+ml-2, i+1 ), ldab-&
                                    1,ab( ku+ml-1, i+1 ), ldab-1,work( mn+i+ml-1 ), work( i+ml-1 ) )
                       end if
                       nr = nr + 1
                       j1 = j1 - kb1
                    end if
                    if( wantq ) then
                       ! accumulate product of plane rotations in q
                       do j = j1, j2, kb1
                          call stdlib_${ri}$rot( m, q( 1, j-1 ), 1, q( 1, j ), 1,work( mn+j ), work( j &
                                    ) )
                       end do
                    end if
                    if( wantc ) then
                       ! apply plane rotations to c
                       do j = j1, j2, kb1
                          call stdlib_${ri}$rot( ncc, c( j-1, 1 ), ldc, c( j, 1 ), ldc,work( mn+j ), &
                                    work( j ) )
                       end do
                    end if
                    if( j2+kun>n ) then
                       ! adjust j2 to keep within the bounds of the matrix
                       nr = nr - 1
                       j2 = j2 - kb1
                    end if
                    do j = j1, j2, kb1
                       ! create nonzero element a(j-1,j+ku) above the band
                       ! and store it in work(n+1:2*n)
                       work( j+kun ) = work( j )*ab( 1, j+kun )
                       ab( 1, j+kun ) = work( mn+j )*ab( 1, j+kun )
                    end do
                    ! generate plane rotations to annihilate nonzero elements
                    ! which have been generated above the band
                    if( nr>0 )call stdlib_${ri}$largv( nr, ab( 1, j1+kun-1 ), inca,work( j1+kun ), kb1,&
                               work( mn+j1+kun ),kb1 )
                    ! apply plane rotations from the right
                    do l = 1, kb
                       if( j2+l-1>m ) then
                          nrt = nr - 1
                       else
                          nrt = nr
                       end if
                       if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l+1, j1+kun-1 ), inca,ab( l, j1+&
                                 kun ), inca,work( mn+j1+kun ), work( j1+kun ),kb1 )
                    end do
                    if( ml==ml0 .and. mu>mu0 ) then
                       if( mu<=n-i+1 ) then
                          ! generate plane rotation to annihilate a(i,i+mu-1)
                          ! within the band, and apply rotation from the right
                          call stdlib_${ri}$lartg( ab( ku-mu+3, i+mu-2 ),ab( ku-mu+2, i+mu-1 ),work( &
                                    mn+i+mu-1 ), work( i+mu-1 ),ra )
                          ab( ku-mu+3, i+mu-2 ) = ra
                          call stdlib_${ri}$rot( min( kl+mu-2, m-i ),ab( ku-mu+4, i+mu-2 ), 1,ab( ku-&
                                    mu+3, i+mu-1 ), 1,work( mn+i+mu-1 ), work( i+mu-1 ) )
                       end if
                       nr = nr + 1
                       j1 = j1 - kb1
                    end if
                    if( wantpt ) then
                       ! accumulate product of plane rotations in p**t
                       do j = j1, j2, kb1
                          call stdlib_${ri}$rot( n, pt( j+kun-1, 1 ), ldpt,pt( j+kun, 1 ), ldpt, work( &
                                    mn+j+kun ),work( j+kun ) )
                       end do
                    end if
                    if( j2+kb>m ) then
                       ! adjust j2 to keep within the bounds of the matrix
                       nr = nr - 1
                       j2 = j2 - kb1
                    end if
                    do j = j1, j2, kb1
                       ! create nonzero element a(j+kl+ku,j+ku-1) below the
                       ! band and store it in work(1:n)
                       work( j+kb ) = work( j+kun )*ab( klu1, j+kun )
                       ab( klu1, j+kun ) = work( mn+j+kun )*ab( klu1, j+kun )
                    end do
                    if( ml>ml0 ) then
                       ml = ml - 1
                    else
                       mu = mu - 1
                    end if
                 end do loop_80
              end do loop_90
           end if
           if( ku==0 .and. kl>0 ) then
              ! a has been reduced to lower bidiagonal form
              ! transform lower bidiagonal form to upper bidiagonal by applying
              ! plane rotations from the left, storing diagonal elements in d
              ! and off-diagonal elements in e
              do i = 1, min( m-1, n )
                 call stdlib_${ri}$lartg( ab( 1, i ), ab( 2, i ), rc, rs, ra )
                 d( i ) = ra
                 if( i<n ) then
                    e( i ) = rs*ab( 1, i+1 )
                    ab( 1, i+1 ) = rc*ab( 1, i+1 )
                 end if
                 if( wantq )call stdlib_${ri}$rot( m, q( 1, i ), 1, q( 1, i+1 ), 1, rc, rs )
                 if( wantc )call stdlib_${ri}$rot( ncc, c( i, 1 ), ldc, c( i+1, 1 ), ldc, rc,rs )
                           
              end do
              if( m<=n )d( m ) = ab( 1, m )
           else if( ku>0 ) then
              ! a has been reduced to upper bidiagonal form
              if( m<n ) then
                 ! annihilate a(m,m+1) by applying plane rotations from the
                 ! right, storing diagonal elements in d and off-diagonal
                 ! elements in e
                 rb = ab( ku, m+1 )
                 do i = m, 1, -1
                    call stdlib_${ri}$lartg( ab( ku+1, i ), rb, rc, rs, ra )
                    d( i ) = ra
                    if( i>1 ) then
                       rb = -rs*ab( ku, i )
                       e( i-1 ) = rc*ab( ku, i )
                    end if
                    if( wantpt )call stdlib_${ri}$rot( n, pt( i, 1 ), ldpt, pt( m+1, 1 ), ldpt,rc, rs )
                              
                 end do
              else
                 ! copy off-diagonal elements to e and diagonal elements to d
                 do i = 1, minmn - 1
                    e( i ) = ab( ku, i+1 )
                 end do
                 do i = 1, minmn
                    d( i ) = ab( ku+1, i )
                 end do
              end if
           else
              ! a is diagonal. set elements of e to zero and copy diagonal
              ! elements to d.
              do i = 1, minmn - 1
                 e( i ) = zero
              end do
              do i = 1, minmn
                 d( i ) = ab( 1, i )
              end do
           end if
           return
     end subroutine stdlib_${ri}$gbbrd


     pure subroutine stdlib_${ri}$gbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
     !! DGBCON: estimates the reciprocal of the condition number of a real
     !! general band matrix A, in either the 1-norm or the infinity-norm,
     !! using the LU factorization computed by DGBTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lnoti, onenrm
           character :: normin
           integer(ilp) :: ix, j, jp, kase, kase1, kd, lm
           real(${rk}$) :: ainvnm, scale, smlnum, t
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<2*kl+ku+1 ) then
              info = -6
           else if( anorm<zero ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! estimate the norm of inv(a).
           ainvnm = zero
           normin = 'N'
           if( onenrm ) then
              kase1 = 1
           else
              kase1 = 2
           end if
           kd = kl + ku + 1
           lnoti = kl>0
           kase = 0
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==kase1 ) then
                 ! multiply by inv(l).
                 if( lnoti ) then
                    do j = 1, n - 1
                       lm = min( kl, n-j )
                       jp = ipiv( j )
                       t = work( jp )
                       if( jp/=j ) then
                          work( jp ) = work( j )
                          work( j ) = t
                       end if
                       call stdlib_${ri}$axpy( lm, -t, ab( kd+1, j ), 1, work( j+1 ), 1 )
                    end do
                 end if
                 ! multiply by inv(u).
                 call stdlib_${ri}$latbs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,kl+ku, ab, &
                           ldab, work, scale, work( 2*n+1 ),info )
              else
                 ! multiply by inv(u**t).
                 call stdlib_${ri}$latbs( 'UPPER', 'TRANSPOSE', 'NON-UNIT', normin, n,kl+ku, ab, ldab, &
                           work, scale, work( 2*n+1 ),info )
                 ! multiply by inv(l**t).
                 if( lnoti ) then
                    do j = n - 1, 1, -1
                       lm = min( kl, n-j )
                       work( j ) = work( j ) - stdlib_${ri}$dot( lm, ab( kd+1, j ), 1,work( j+1 ), 1 )
                                 
                       jp = ipiv( j )
                       if( jp/=j ) then
                          t = work( jp )
                          work( jp ) = work( j )
                          work( j ) = t
                       end if
                    end do
                 end if
              end if
              ! divide x by 1/scale if doing so will not cause overflow.
              normin = 'Y'
              if( scale/=one ) then
                 ix = stdlib_i${ri}$amax( n, work, 1 )
                 if( scale<abs( work( ix ) )*smlnum .or. scale==zero )go to 40
                 call stdlib_${ri}$rscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           40 continue
           return
     end subroutine stdlib_${ri}$gbcon


     pure subroutine stdlib_${ri}$gbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
     !! DGBEQU: computes row and column scalings intended to equilibrate an
     !! M-by-N band matrix A and reduce its condition number.  R returns the
     !! row scale factors and C the column scale factors, chosen to try to
     !! make the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
     !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
     !! number and BIGNUM = largest safe number.  Use of these scaling
     !! factors is not guaranteed to reduce the condition number of A but
     !! works well in practice.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           real(${rk}$), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: c(*), r(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, kd
           real(${rk}$) :: bignum, rcmax, rcmin, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+ku+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBEQU', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           kd = ku + 1
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 r( i ) = max( r( i ), abs( ab( kd+i-j, j ) ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i))
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           kd = ku + 1
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 c( j ) = max( c( j ), abs( ab( kd+i-j, j ) )*r( i ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j))
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_${ri}$gbequ


     pure subroutine stdlib_${ri}$gbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
     !! DGBEQUB: computes row and column scalings intended to equilibrate an
     !! M-by-N matrix A and reduce its condition number.  R returns the row
     !! scale factors and C the column scale factors, chosen to try to make
     !! the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
     !! the radix.
     !! R(i) and C(j) are restricted to be a power of the radix between
     !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
     !! of these scaling factors is not guaranteed to reduce the condition
     !! number of A but works well in practice.
     !! This routine differs from DGEEQU by restricting the scaling factors
     !! to a power of the radix.  Barring over- and underflow, scaling by
     !! these factors introduces no additional rounding errors.  However, the
     !! scaled entries' magnitudes are no longer approximately 1 but lie
     !! between sqrt(radix) and 1/sqrt(radix).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           real(${rk}$), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: c(*), r(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, kd
           real(${rk}$) :: bignum, rcmax, rcmin, smlnum, radix, logrdx
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,log
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+ku+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBEQUB', -info )
              return
           end if
           ! quick return if possible.
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.  assume smlnum is a power of the radix.
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           radix = stdlib_${ri}$lamch( 'B' )
           logrdx = log(radix)
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           kd = ku + 1
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 r( i ) = max( r( i ), abs( ab( kd+i-j, j ) ) )
              end do
           end do
           do i = 1, m
              if( r( i )>zero ) then
                 r( i ) = radix**int( log( r( i ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i)).
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors.
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 c( j ) = max( c( j ), abs( ab( kd+i-j, j ) )*r( i ) )
              end do
              if( c( j )>zero ) then
                 c( j ) = radix**int( log( c( j ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j)).
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_${ri}$gbequb


     pure subroutine stdlib_${ri}$gbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, x, &
     !! DGBRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is banded, and provides
     !! error bounds and backward error estimates for the solution.
               ldx, ferr, berr, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ab(ldab,*), afb(ldafb,*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: notran
           character :: transt
           integer(ilp) :: count, i, j, k, kase, kk, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldab<kl+ku+1 ) then
              info = -7
           else if( ldafb<2*kl+ku+1 ) then
              info = -9
           else if( ldb<max( 1, n ) ) then
              info = -12
           else if( ldx<max( 1, n ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = min( kl+ku+2, n+1 )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$gbmv( trans, n, n, kl, ku, -one, ab, ldab, x( 1, j ), 1,one, work( n+1 &
                        ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(op(a))*abs(x) + abs(b).
              if( notran ) then
                 do k = 1, n
                    kk = ku + 1 - k
                    xk = abs( x( k, j ) )
                    do i = max( 1, k-ku ), min( n, k+kl )
                       work( i ) = work( i ) + abs( ab( kk+i, k ) )*xk
                    end do
                 end do
              else
                 do k = 1, n
                    s = zero
                    kk = ku + 1 - k
                    do i = max( 1, k-ku ), min( n, k+kl )
                       s = s + abs( ab( kk+i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$gbtrs( trans, n, kl, ku, 1, afb, ldafb, ipiv,work( n+1 ), n, info )
                           
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**t).
                    call stdlib_${ri}$gbtrs( transt, n, kl, ku, 1, afb, ldafb, ipiv,work( n+1 ), n, &
                              info )
                    do i = 1, n
                       work( n+i ) = work( n+i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( n+i ) = work( n+i )*work( i )
                    end do
                    call stdlib_${ri}$gbtrs( trans, n, kl, ku, 1, afb, ldafb, ipiv,work( n+1 ), n, &
                              info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$gbrfs


     pure subroutine stdlib_${ri}$gbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
     !! DGBSV: computes the solution to a real system of linear equations
     !! A * X = B, where A is a band matrix of order N with KL subdiagonals
     !! and KU superdiagonals, and X and B are N-by-NRHS matrices.
     !! The LU decomposition with partial pivoting and row interchanges is
     !! used to factor A as A = L * U, where L is a product of permutation
     !! and unit lower triangular matrices with KL subdiagonals, and U is
     !! upper triangular with KL+KU superdiagonals.  The factored form of A
     !! is then used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( kl<0 ) then
              info = -2
           else if( ku<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<2*kl+ku+1 ) then
              info = -6
           else if( ldb<max( n, 1 ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBSV ', -info )
              return
           end if
           ! compute the lu factorization of the band matrix a.
           call stdlib_${ri}$gbtrf( n, n, kl, ku, ab, ldab, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$gbtrs( 'NO TRANSPOSE', n, kl, ku, nrhs, ab, ldab, ipiv,b, ldb, info )
                        
           end if
           return
     end subroutine stdlib_${ri}$gbsv


     subroutine stdlib_${ri}$gbsvx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,ldafb, ipiv, equed, r, &
     !! DGBSVX: uses the LU factorization to compute the solution to a real
     !! system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
     !! where A is a band matrix of order N with KL subdiagonals and KU
     !! superdiagonals, and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               c, b, ldb, x, ldx,rcond, ferr, berr, work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), afb(ldafb,*), b(ldb,*), c(*), r(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: colequ, equil, nofact, notran, rowequ
           character :: norm
           integer(ilp) :: i, infequ, j, j1, j2
           real(${rk}$) :: amax, anorm, bignum, colcnd, rcmax, rcmin, rowcnd, rpvgrw, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           notran = stdlib_lsame( trans, 'N' )
           if( nofact .or. equil ) then
              equed = 'N'
              rowequ = .false.
              colequ = .false.
           else
              rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
              colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kl<0 ) then
              info = -4
           else if( ku<0 ) then
              info = -5
           else if( nrhs<0 ) then
              info = -6
           else if( ldab<kl+ku+1 ) then
              info = -8
           else if( ldafb<2*kl+ku+1 ) then
              info = -10
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rowequ .or. colequ .or. stdlib_lsame( &
                     equed, 'N' ) ) ) then
              info = -12
           else
              if( rowequ ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, r( j ) )
                    rcmax = max( rcmax, r( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -13
                 else if( n>0 ) then
                    rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    rowcnd = one
                 end if
              end if
              if( colequ .and. info==0 ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, c( j ) )
                    rcmax = max( rcmax, c( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -14
                 else if( n>0 ) then
                    colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    colcnd = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -16
                 else if( ldx<max( 1, n ) ) then
                    info = -18
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_${ri}$gbequ( n, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, infequ )
                        
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_${ri}$laqgb( n, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
                           
                 rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
                 colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              end if
           end if
           ! scale the right hand side.
           if( notran ) then
              if( rowequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       b( i, j ) = r( i )*b( i, j )
                    end do
                 end do
              end if
           else if( colequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = c( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the lu factorization of the band matrix a.
              do j = 1, n
                 j1 = max( j-ku, 1 )
                 j2 = min( j+kl, n )
                 call stdlib_${ri}$copy( j2-j1+1, ab( ku+1-j+j1, j ), 1,afb( kl+ku+1-j+j1, j ), 1 )
                           
              end do
              call stdlib_${ri}$gbtrf( n, n, kl, ku, afb, ldafb, ipiv, info )
              ! return if info is non-zero.
              if( info>0 ) then
                 ! compute the reciprocal pivot growth factor of the
                 ! leading rank-deficient info columns of a.
                 anorm = zero
                 do j = 1, info
                    do i = max( ku+2-j, 1 ), min( n+ku+1-j, kl+ku+1 )
                       anorm = max( anorm, abs( ab( i, j ) ) )
                    end do
                 end do
                 rpvgrw = stdlib_${ri}$lantb( 'M', 'U', 'N', info, min( info-1, kl+ku ),afb( max( 1, &
                           kl+ku+2-info ), 1 ), ldafb,work )
                 if( rpvgrw==zero ) then
                    rpvgrw = one
                 else
                    rpvgrw = anorm / rpvgrw
                 end if
                 work( 1 ) = rpvgrw
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a and the
           ! reciprocal pivot growth factor rpvgrw.
           if( notran ) then
              norm = '1'
           else
              norm = 'I'
           end if
           anorm = stdlib_${ri}$langb( norm, n, kl, ku, ab, ldab, work )
           rpvgrw = stdlib_${ri}$lantb( 'M', 'U', 'N', n, kl+ku, afb, ldafb, work )
           if( rpvgrw==zero ) then
              rpvgrw = one
           else
              rpvgrw = stdlib_${ri}$langb( 'M', n, kl, ku, ab, ldab, work ) / rpvgrw
           end if
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$gbcon( norm, n, kl, ku, afb, ldafb, ipiv, anorm, rcond,work, iwork, info )
                     
           ! compute the solution matrix x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$gbtrs( trans, n, kl, ku, nrhs, afb, ldafb, ipiv, x, ldx,info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_${ri}$gbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv,b, ldb, x, ldx, &
                     ferr, berr, work, iwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( notran ) then
              if( colequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       x( i, j ) = c( i )*x( i, j )
                    end do
                 end do
                 do j = 1, nrhs
                    ferr( j ) = ferr( j ) / colcnd
                 end do
              end if
           else if( rowequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = r( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / rowcnd
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = rpvgrw
           return
     end subroutine stdlib_${ri}$gbsvx


     pure subroutine stdlib_${ri}$gbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
     !! DGBTF2: computes an LU factorization of a real m-by-n band matrix A
     !! using partial pivoting with row interchanges.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, jp, ju, km, kv
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! kv is the number of superdiagonals in the factor u, allowing for
           ! fill-in.
           kv = ku + kl
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+kv+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBTF2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! gaussian elimination with partial pivoting
           ! set fill-in elements in columns ku+2 to kv to zero.
           do j = ku + 2, min( kv, n )
              do i = kv - j + 2, kl
                 ab( i, j ) = zero
              end do
           end do
           ! ju is the index of the last column affected by the current stage
           ! of the factorization.
           ju = 1
           loop_40: do j = 1, min( m, n )
              ! set fill-in elements in column j+kv to zero.
              if( j+kv<=n ) then
                 do i = 1, kl
                    ab( i, j+kv ) = zero
                 end do
              end if
              ! find pivot and test for singularity. km is the number of
              ! subdiagonal elements in the current column.
              km = min( kl, m-j )
              jp = stdlib_i${ri}$amax( km+1, ab( kv+1, j ), 1 )
              ipiv( j ) = jp + j - 1
              if( ab( kv+jp, j )/=zero ) then
                 ju = max( ju, min( j+ku+jp-1, n ) )
                 ! apply interchange to columns j to ju.
                 if( jp/=1 )call stdlib_${ri}$swap( ju-j+1, ab( kv+jp, j ), ldab-1,ab( kv+1, j ), ldab-&
                           1 )
                 if( km>0 ) then
                    ! compute multipliers.
                    call stdlib_${ri}$scal( km, one / ab( kv+1, j ), ab( kv+2, j ), 1 )
                    ! update trailing submatrix within the band.
                    if( ju>j )call stdlib_${ri}$ger( km, ju-j, -one, ab( kv+2, j ), 1,ab( kv, j+1 ), &
                              ldab-1, ab( kv+1, j+1 ),ldab-1 )
                 end if
              else
                 ! if pivot is zero, set info to the index of the pivot
                 ! unless a zero pivot has already been found.
                 if( info==0 )info = j
              end if
           end do loop_40
           return
     end subroutine stdlib_${ri}$gbtf2


     pure subroutine stdlib_${ri}$gbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
     !! DGBTRF: computes an LU factorization of a real m-by-n band matrix A
     !! using partial pivoting with row interchanges.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldwork = nbmax+1
           
           
           ! Local Scalars 
           integer(ilp) :: i, i2, i3, ii, ip, j, j2, j3, jb, jj, jm, jp, ju, k2, km, kv, nb, &
                     nw
           real(${rk}$) :: temp
           ! Local Arrays 
           real(${rk}$) :: work13(ldwork,nbmax), work31(ldwork,nbmax)
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! kv is the number of superdiagonals in the factor u, allowing for
           ! fill-in
           kv = ku + kl
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+kv+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBTRF', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! determine the block size for this environment
           nb = stdlib_ilaenv( 1, 'DGBTRF', ' ', m, n, kl, ku )
           ! the block size must not exceed the limit set by the size of the
           ! local arrays work13 and work31.
           nb = min( nb, nbmax )
           if( nb<=1 .or. nb>kl ) then
              ! use unblocked code
              call stdlib_${ri}$gbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
           else
              ! use blocked code
              ! zero the superdiagonal elements of the work array work13
              do j = 1, nb
                 do i = 1, j - 1
                    work13( i, j ) = zero
                 end do
              end do
              ! zero the subdiagonal elements of the work array work31
              do j = 1, nb
                 do i = j + 1, nb
                    work31( i, j ) = zero
                 end do
              end do
              ! gaussian elimination with partial pivoting
              ! set fill-in elements in columns ku+2 to kv to zero
              do j = ku + 2, min( kv, n )
                 do i = kv - j + 2, kl
                    ab( i, j ) = zero
                 end do
              end do
              ! ju is the index of the last column affected by the current
              ! stage of the factorization
              ju = 1
              loop_180: do j = 1, min( m, n ), nb
                 jb = min( nb, min( m, n )-j+1 )
                 ! the active part of the matrix is partitioned
                    ! a11   a12   a13
                    ! a21   a22   a23
                    ! a31   a32   a33
                 ! here a11, a21 and a31 denote the current block of jb columns
                 ! which is about to be factorized. the number of rows in the
                 ! partitioning are jb, i2, i3 respectively, and the numbers
                 ! of columns are jb, j2, j3. the superdiagonal elements of a13
                 ! and the subdiagonal elements of a31 lie outside the band.
                 i2 = min( kl-jb, m-j-jb+1 )
                 i3 = min( jb, m-j-kl+1 )
                 ! j2 and j3 are computed after ju has been updated.
                 ! factorize the current block of jb columns
                 loop_80: do jj = j, j + jb - 1
                    ! set fill-in elements in column jj+kv to zero
                    if( jj+kv<=n ) then
                       do i = 1, kl
                          ab( i, jj+kv ) = zero
                       end do
                    end if
                    ! find pivot and test for singularity. km is the number of
                    ! subdiagonal elements in the current column.
                    km = min( kl, m-jj )
                    jp = stdlib_i${ri}$amax( km+1, ab( kv+1, jj ), 1 )
                    ipiv( jj ) = jp + jj - j
                    if( ab( kv+jp, jj )/=zero ) then
                       ju = max( ju, min( jj+ku+jp-1, n ) )
                       if( jp/=1 ) then
                          ! apply interchange to columns j to j+jb-1
                          if( jp+jj-1<j+kl ) then
                             call stdlib_${ri}$swap( jb, ab( kv+1+jj-j, j ), ldab-1,ab( kv+jp+jj-j, j )&
                                       , ldab-1 )
                          else
                             ! the interchange affects columns j to jj-1 of a31
                             ! which are stored in the work array work31
                             call stdlib_${ri}$swap( jj-j, ab( kv+1+jj-j, j ), ldab-1,work31( jp+jj-j-&
                                       kl, 1 ), ldwork )
                             call stdlib_${ri}$swap( j+jb-jj, ab( kv+1, jj ), ldab-1,ab( kv+jp, jj ), &
                                       ldab-1 )
                          end if
                       end if
                       ! compute multipliers
                       call stdlib_${ri}$scal( km, one / ab( kv+1, jj ), ab( kv+2, jj ),1 )
                       ! update trailing submatrix within the band and within
                       ! the current block. jm is the index of the last column
                       ! which needs to be updated.
                       jm = min( ju, j+jb-1 )
                       if( jm>jj )call stdlib_${ri}$ger( km, jm-jj, -one, ab( kv+2, jj ), 1,ab( kv, jj+&
                                 1 ), ldab-1,ab( kv+1, jj+1 ), ldab-1 )
                    else
                       ! if pivot is zero, set info to the index of the pivot
                       ! unless a zero pivot has already been found.
                       if( info==0 )info = jj
                    end if
                    ! copy current column of a31 into the work array work31
                    nw = min( jj-j+1, i3 )
                    if( nw>0 )call stdlib_${ri}$copy( nw, ab( kv+kl+1-jj+j, jj ), 1,work31( 1, jj-j+1 )&
                              , 1 )
                 end do loop_80
                 if( j+jb<=n ) then
                    ! apply the row interchanges to the other blocks.
                    j2 = min( ju-j+1, kv ) - jb
                    j3 = max( 0, ju-j-kv+1 )
                    ! use stdlib_${ri}$laswp to apply the row interchanges to a12, a22, and
                    ! a32.
                    call stdlib_${ri}$laswp( j2, ab( kv+1-jb, j+jb ), ldab-1, 1, jb,ipiv( j ), 1 )
                              
                    ! adjust the pivot indices.
                    do i = j, j + jb - 1
                       ipiv( i ) = ipiv( i ) + j - 1
                    end do
                    ! apply the row interchanges to a13, a23, and a33
                    ! columnwise.
                    k2 = j - 1 + jb + j2
                    do i = 1, j3
                       jj = k2 + i
                       do ii = j + i - 1, j + jb - 1
                          ip = ipiv( ii )
                          if( ip/=ii ) then
                             temp = ab( kv+1+ii-jj, jj )
                             ab( kv+1+ii-jj, jj ) = ab( kv+1+ip-jj, jj )
                             ab( kv+1+ip-jj, jj ) = temp
                          end if
                       end do
                    end do
                    ! update the relevant part of the trailing submatrix
                    if( j2>0 ) then
                       ! update a12
                       call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT',jb, j2, one, ab(&
                                  kv+1, j ), ldab-1,ab( kv+1-jb, j+jb ), ldab-1 )
                       if( i2>0 ) then
                          ! update a22
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i2, j2,jb, -one, ab( &
                          kv+1+jb, j ), ldab-1,ab( kv+1-jb, j+jb ), ldab-1, one,ab( kv+1, j+jb ), &
                                    ldab-1 )
                       end if
                       if( i3>0 ) then
                          ! update a32
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i3, j2,jb, -one, &
                          work31, ldwork,ab( kv+1-jb, j+jb ), ldab-1, one,ab( kv+kl+1-jb, j+jb ), &
                                    ldab-1 )
                       end if
                    end if
                    if( j3>0 ) then
                       ! copy the lower triangle of a13 into the work array
                       ! work13
                       do jj = 1, j3
                          do ii = jj, jb
                             work13( ii, jj ) = ab( ii-jj+1, jj+j+kv-1 )
                          end do
                       end do
                       ! update a13 in the work array
                       call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT',jb, j3, one, ab(&
                                  kv+1, j ), ldab-1,work13, ldwork )
                       if( i2>0 ) then
                          ! update a23
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i2, j3,jb, -one, ab( &
                          kv+1+jb, j ), ldab-1,work13, ldwork, one, ab( 1+jb, j+kv ),ldab-1 )
                                    
                       end if
                       if( i3>0 ) then
                          ! update a33
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i3, j3,jb, -one, &
                                    work31, ldwork, work13,ldwork, one, ab( 1+kl, j+kv ), ldab-1 )
                       end if
                       ! copy the lower triangle of a13 back into place
                       do jj = 1, j3
                          do ii = jj, jb
                             ab( ii-jj+1, jj+j+kv-1 ) = work13( ii, jj )
                          end do
                       end do
                    end if
                 else
                    ! adjust the pivot indices.
                    do i = j, j + jb - 1
                       ipiv( i ) = ipiv( i ) + j - 1
                    end do
                 end if
                 ! partially undo the interchanges in the current block to
                 ! restore the upper triangular form of a31 and copy the upper
                 ! triangle of a31 back into place
                 do jj = j + jb - 1, j, -1
                    jp = ipiv( jj ) - jj + 1
                    if( jp/=1 ) then
                       ! apply interchange to columns j to jj-1
                       if( jp+jj-1<j+kl ) then
                          ! the interchange does not affect a31
                          call stdlib_${ri}$swap( jj-j, ab( kv+1+jj-j, j ), ldab-1,ab( kv+jp+jj-j, j ),&
                                     ldab-1 )
                       else
                          ! the interchange does affect a31
                          call stdlib_${ri}$swap( jj-j, ab( kv+1+jj-j, j ), ldab-1,work31( jp+jj-j-kl, &
                                    1 ), ldwork )
                       end if
                    end if
                    ! copy the current column of a31 back into place
                    nw = min( i3, jj-j+1 )
                    if( nw>0 )call stdlib_${ri}$copy( nw, work31( 1, jj-j+1 ), 1,ab( kv+kl+1-jj+j, jj )&
                              , 1 )
                 end do
              end do loop_180
           end if
           return
     end subroutine stdlib_${ri}$gbtrf


     pure subroutine stdlib_${ri}$gbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )
     !! DGBTRS: solves a system of linear equations
     !! A * X = B  or  A**T * X = B
     !! with a general band matrix A using the LU factorization computed
     !! by DGBTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lnoti, notran
           integer(ilp) :: i, j, kd, l, lm
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldab<( 2*kl+ku+1 ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGBTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           kd = ku + kl + 1
           lnoti = kl>0
           if( notran ) then
              ! solve  a*x = b.
              ! solve l*x = b, overwriting b with x.
              ! l is represented as a product of permutations and unit lower
              ! triangular matrices l = p(1) * l(1) * ... * p(n-1) * l(n-1),
              ! where each transformation l(i) is a rank-one modification of
              ! the identity matrix.
              if( lnoti ) then
                 do j = 1, n - 1
                    lm = min( kl, n-j )
                    l = ipiv( j )
                    if( l/=j )call stdlib_${ri}$swap( nrhs, b( l, 1 ), ldb, b( j, 1 ), ldb )
                    call stdlib_${ri}$ger( lm, nrhs, -one, ab( kd+1, j ), 1, b( j, 1 ),ldb, b( j+1, 1 )&
                              , ldb )
                 end do
              end if
              do i = 1, nrhs
                 ! solve u*x = b, overwriting b with x.
                 call stdlib_${ri}$tbsv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, kl+ku,ab, ldab, b( 1, &
                           i ), 1 )
              end do
           else
              ! solve a**t*x = b.
              do i = 1, nrhs
                 ! solve u**t*x = b, overwriting b with x.
                 call stdlib_${ri}$tbsv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, kl+ku, ab,ldab, b( 1, i )&
                           , 1 )
              end do
              ! solve l**t*x = b, overwriting b with x.
              if( lnoti ) then
                 do j = n - 1, 1, -1
                    lm = min( kl, n-j )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', lm, nrhs, -one, b( j+1, 1 ),ldb, ab( kd+1, j )&
                              , 1, one, b( j, 1 ), ldb )
                    l = ipiv( j )
                    if( l/=j )call stdlib_${ri}$swap( nrhs, b( l, 1 ), ldb, b( j, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$gbtrs


     pure subroutine stdlib_${ri}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! DGEBAK: forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by DGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: scale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(${rk}$) :: s
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_${ri}$scal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_${ri}$scal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_${ri}$gebak


     pure subroutine stdlib_${ri}$gebal( job, n, a, lda, ilo, ihi, scale, info )
     !! DGEBAL: balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sclfac = 2.0e+0_${rk}$
           real(${rk}$), parameter :: factor = 0.95e+0_${rk}$
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(${rk}$) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_${ri}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ri}$swap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_${ri}$nrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_${ri}$nrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_i${ri}$amax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_i${ri}$amax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_${ri}$isnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'DGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_${ri}$scal( n-k+1, g, a( i, k ), lda )
              call stdlib_${ri}$scal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_${ri}$gebal


     pure subroutine stdlib_${ri}$gebd2( m, n, a, lda, d, e, tauq, taup, work, info )
     !! DGEBD2: reduces a real general m by n matrix A to upper or lower
     !! bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
     !! If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info<0 ) then
              call stdlib_xerbla( 'DGEBD2', -info )
              return
           end if
           if( m>=n ) then
              ! reduce to upper bidiagonal form
              do i = 1, n
                 ! generate elementary reflector h(i) to annihilate a(i+1:m,i)
                 call stdlib_${ri}$larfg( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,tauq( i ) )
                           
                 d( i ) = a( i, i )
                 a( i, i ) = one
                 ! apply h(i) to a(i:m,i+1:n) from the left
                 if( i<n )call stdlib_${ri}$larf( 'LEFT', m-i+1, n-i, a( i, i ), 1, tauq( i ),a( i, i+&
                           1 ), lda, work )
                 a( i, i ) = d( i )
                 if( i<n ) then
                    ! generate elementary reflector g(i) to annihilate
                    ! a(i,i+2:n)
                    call stdlib_${ri}$larfg( n-i, a( i, i+1 ), a( i, min( i+2, n ) ),lda, taup( i ) )
                              
                    e( i ) = a( i, i+1 )
                    a( i, i+1 ) = one
                    ! apply g(i) to a(i+1:m,i+1:n) from the right
                    call stdlib_${ri}$larf( 'RIGHT', m-i, n-i, a( i, i+1 ), lda,taup( i ), a( i+1, i+1 &
                              ), lda, work )
                    a( i, i+1 ) = e( i )
                 else
                    taup( i ) = zero
                 end if
              end do
           else
              ! reduce to lower bidiagonal form
              do i = 1, m
                 ! generate elementary reflector g(i) to annihilate a(i,i+1:n)
                 call stdlib_${ri}$larfg( n-i+1, a( i, i ), a( i, min( i+1, n ) ), lda,taup( i ) )
                           
                 d( i ) = a( i, i )
                 a( i, i ) = one
                 ! apply g(i) to a(i+1:m,i:n) from the right
                 if( i<m )call stdlib_${ri}$larf( 'RIGHT', m-i, n-i+1, a( i, i ), lda,taup( i ), a( i+&
                           1, i ), lda, work )
                 a( i, i ) = d( i )
                 if( i<m ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:m,i)
                    call stdlib_${ri}$larfg( m-i, a( i+1, i ), a( min( i+2, m ), i ), 1,tauq( i ) )
                              
                    e( i ) = a( i+1, i )
                    a( i+1, i ) = one
                    ! apply h(i) to a(i+1:m,i+1:n) from the left
                    call stdlib_${ri}$larf( 'LEFT', m-i, n-i, a( i+1, i ), 1, tauq( i ),a( i+1, i+1 ), &
                              lda, work )
                    a( i+1, i ) = e( i )
                 else
                    tauq( i ) = zero
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$gebd2


     pure subroutine stdlib_${ri}$gebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
     !! DGEBRD: reduces a general real M-by-N matrix A to upper or lower
     !! bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
     !! If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, ldwrkx, ldwrky, lwkopt, minmn, nb, nbmin, nx, ws
           ! Intrinsic Functions 
           intrinsic :: real,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           nb = max( 1, stdlib_ilaenv( 1, 'DGEBRD', ' ', m, n, -1, -1 ) )
           lwkopt = ( m+n )*nb
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( lwork<max( 1, m, n ) .and. .not.lquery ) then
              info = -10
           end if
           if( info<0 ) then
              call stdlib_xerbla( 'DGEBRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           minmn = min( m, n )
           if( minmn==0 ) then
              work( 1 ) = 1
              return
           end if
           ws = max( m, n )
           ldwrkx = m
           ldwrky = n
           if( nb>1 .and. nb<minmn ) then
              ! set the crossover point nx.
              nx = max( nb, stdlib_ilaenv( 3, 'DGEBRD', ' ', m, n, -1, -1 ) )
              ! determine when to switch from blocked to unblocked code.
              if( nx<minmn ) then
                 ws = ( m+n )*nb
                 if( lwork<ws ) then
                    ! not enough work space for the optimal nb, consider using
                    ! a smaller block size.
                    nbmin = stdlib_ilaenv( 2, 'DGEBRD', ' ', m, n, -1, -1 )
                    if( lwork>=( m+n )*nbmin ) then
                       nb = lwork / ( m+n )
                    else
                       nb = 1
                       nx = minmn
                    end if
                 end if
              end if
           else
              nx = minmn
           end if
           do i = 1, minmn - nx, nb
              ! reduce rows and columns i:i+nb-1 to bidiagonal form and return
              ! the matrices x and y which are needed to update the unreduced
              ! part of the matrix
              call stdlib_${ri}$labrd( m-i+1, n-i+1, nb, a( i, i ), lda, d( i ), e( i ),tauq( i ), &
                        taup( i ), work, ldwrkx,work( ldwrkx*nb+1 ), ldwrky )
              ! update the trailing submatrix a(i+nb:m,i+nb:n), using an update
              ! of the form  a := a - v*y**t - x*u**t
              call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m-i-nb+1, n-i-nb+1,nb, -one, a( i+&
                        nb, i ), lda,work( ldwrkx*nb+nb+1 ), ldwrky, one,a( i+nb, i+nb ), lda )
              call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m-i-nb+1, n-i-nb+1,nb, -one, &
                        work( nb+1 ), ldwrkx, a( i, i+nb ), lda,one, a( i+nb, i+nb ), lda )
              ! copy diagonal and off-diagonal elements of b back into a
              if( m>=n ) then
                 do j = i, i + nb - 1
                    a( j, j ) = d( j )
                    a( j, j+1 ) = e( j )
                 end do
              else
                 do j = i, i + nb - 1
                    a( j, j ) = d( j )
                    a( j+1, j ) = e( j )
                 end do
              end if
           end do
           ! use unblocked code to reduce the remainder of the matrix
           call stdlib_${ri}$gebd2( m-i+1, n-i+1, a( i, i ), lda, d( i ), e( i ),tauq( i ), taup( i ), &
                     work, iinfo )
           work( 1 ) = ws
           return
     end subroutine stdlib_${ri}$gebrd


     pure subroutine stdlib_${ri}$gecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
     !! DGECON: estimates the reciprocal of the condition number of a general
     !! real matrix A, in either the 1-norm or the infinity-norm, using
     !! the LU factorization computed by DGETRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: onenrm
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(${rk}$) :: ainvnm, scale, sl, smlnum, su
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGECON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! estimate the norm of inv(a).
           ainvnm = zero
           normin = 'N'
           if( onenrm ) then
              kase1 = 1
           else
              kase1 = 2
           end if
           kase = 0
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==kase1 ) then
                 ! multiply by inv(l).
                 call stdlib_${ri}$latrs( 'LOWER', 'NO TRANSPOSE', 'UNIT', normin, n, a,lda, work, sl, &
                           work( 2*n+1 ), info )
                 ! multiply by inv(u).
                 call stdlib_${ri}$latrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,a, lda, work, &
                           su, work( 3*n+1 ), info )
              else
                 ! multiply by inv(u**t).
                 call stdlib_${ri}$latrs( 'UPPER', 'TRANSPOSE', 'NON-UNIT', normin, n, a,lda, work, su,&
                            work( 3*n+1 ), info )
                 ! multiply by inv(l**t).
                 call stdlib_${ri}$latrs( 'LOWER', 'TRANSPOSE', 'UNIT', normin, n, a,lda, work, sl, &
                           work( 2*n+1 ), info )
              end if
              ! divide x by 1/(sl*su) if doing so will not cause overflow.
              scale = sl*su
              normin = 'Y'
              if( scale/=one ) then
                 ix = stdlib_i${ri}$amax( n, work, 1 )
                 if( scale<abs( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_${ri}$rscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_${ri}$gecon


     pure subroutine stdlib_${ri}$geequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
     !! DGEEQU: computes row and column scalings intended to equilibrate an
     !! M-by-N matrix A and reduce its condition number.  R returns the row
     !! scale factors and C the column scale factors, chosen to try to make
     !! the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
     !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
     !! number and BIGNUM = largest safe number.  Use of these scaling
     !! factors is not guaranteed to reduce the condition number of A but
     !! works well in practice.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           real(${rk}$), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: c(*), r(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: bignum, rcmax, rcmin, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEQU', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           do j = 1, n
              do i = 1, m
                 r( i ) = max( r( i ), abs( a( i, j ) ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i))
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           do j = 1, n
              do i = 1, m
                 c( j ) = max( c( j ), abs( a( i, j ) )*r( i ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j))
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_${ri}$geequ


     pure subroutine stdlib_${ri}$geequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
     !! DGEEQUB: computes row and column scalings intended to equilibrate an
     !! M-by-N matrix A and reduce its condition number.  R returns the row
     !! scale factors and C the column scale factors, chosen to try to make
     !! the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
     !! the radix.
     !! R(i) and C(j) are restricted to be a power of the radix between
     !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
     !! of these scaling factors is not guaranteed to reduce the condition
     !! number of A but works well in practice.
     !! This routine differs from DGEEQU by restricting the scaling factors
     !! to a power of the radix.  Barring over- and underflow, scaling by
     !! these factors introduces no additional rounding errors.  However, the
     !! scaled entries' magnitudes are no longer approximately 1 but lie
     !! between sqrt(radix) and 1/sqrt(radix).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           real(${rk}$), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: c(*), r(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: bignum, rcmax, rcmin, smlnum, radix, logrdx
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,log
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEQUB', -info )
              return
           end if
           ! quick return if possible.
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.  assume smlnum is a power of the radix.
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           radix = stdlib_${ri}$lamch( 'B' )
           logrdx = log( radix )
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           do j = 1, n
              do i = 1, m
                 r( i ) = max( r( i ), abs( a( i, j ) ) )
              end do
           end do
           do i = 1, m
              if( r( i )>zero ) then
                 r( i ) = radix**int( log( r( i ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i)).
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           do j = 1, n
              do i = 1, m
                 c( j ) = max( c( j ), abs( a( i, j ) )*r( i ) )
              end do
              if( c( j )>zero ) then
                 c( j ) = radix**int( log( c( j ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j)).
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_${ri}$geequb


     subroutine stdlib_${ri}$gees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
     !! DGEES: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A matrix is in real Schur form if it is upper quasi-triangular with
     !! 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
     !! form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_${ri}$) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_${ri}$hseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need n)
           ibal = 1
           call stdlib_${ri}$gebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (workspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_${ri}$hseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (workspace: none needed)
              call stdlib_${ri}$trsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, s, sep, &
                        work( iwrk ), lwork-iwrk+1, idum, 1,icond )
              if( icond>0 )info = n + icond
           end if
           if( wantvs ) then
              ! undo balancing
              ! (workspace: need n)
              call stdlib_${ri}$gebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_${ri}$lascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$copy( n, a, lda+1, wr, 1 )
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi,max( ilo-1, 1 ), &
                              ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_${ri}$swap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_${ri}$swap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                             call stdlib_${ri}$swap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              ! undo scaling for the imaginary part of the eigenvalues
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gees


     subroutine stdlib_${ri}$geesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
     !! DGEESX: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_${rk}$ of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A real matrix is in real Schur form if it is upper quasi-triangular
     !! with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
     !! the form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, liwork, lwork, n
           real(${rk}$), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_${ri}$) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantsb, wantse, wantsn, wantst, &
                     wantsv, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, liwrk, lwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "rworkspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! iworkspace refers to integer workspace.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_${ri}$trsen later
             ! in the code.)
           if( info==0 ) then
              liwrk = 1
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_${ri}$hseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, n + ( n*n )/2 )
                 if( wantsv .or. wantsb )liwrk = ( n*n )/4
              end if
              iwork( 1 ) = liwrk
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -16
              else if( liwork<1 .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_${ri}$gebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (rworkspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (rworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (rworkspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_${ri}$hseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (rworkspace: if sense is not 'n', need n+2*sdim*(n-sdim)
                           ! otherwise, need n )
              ! (iworkspace: if sense is 'v' or 'b', need sdim*(n-sdim)
                           ! otherwise, need 0 )
              call stdlib_${ri}$trsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,iwork, liwork, icond )
              if( .not.wantsn )maxwrk = max( maxwrk, n+2*sdim*( n-sdim ) )
              if( icond==-15 ) then
                 ! not enough real workspace
                 info = -16
              else if( icond==-17 ) then
                 ! not enough integer workspace
                 info = -18
              else if( icond>0 ) then
                 ! stdlib_${ri}$trsen failed to reorder or to restore standard schur form
                 info = icond + n
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (rworkspace: need n)
              call stdlib_${ri}$gebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_${ri}$lascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$copy( n, a, lda+1, wr, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_${ri}$swap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_${ri}$swap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                            call stdlib_${ri}$swap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           if( wantsv .or. wantsb ) then
              iwork( 1 ) = max( 1, sdim*( n-sdim ) )
           else
              iwork( 1 ) = 1
           end if
           return
     end subroutine stdlib_${ri}$geesx


     subroutine stdlib_${ri}$geev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
     !! DGEEV: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, itau, iwrk, k, lwork_trevc, maxwrk, &
                     minwrk, nout
           real(${rk}$) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -9
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_${ri}$trevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else if( wantvr ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_${ri}$trevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else
                    minwrk = 3*n
                    call stdlib_${ri}$hseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (workspace: need n)
           ibal = 1
           call stdlib_${ri}$gebal( 'B', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = ibal + n
           iwrk = itau + n
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_${ri}$lacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'E', 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_${ri}$hseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 4*n, prefer n + n + 2*n*nb)
              call stdlib_${ri}$trevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (workspace: need n)
              call stdlib_${ri}$gebak( 'B', 'L', n, ilo, ihi, work( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work( iwrk ), 1 )
                    call stdlib_${ri}$lartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (workspace: need n)
              call stdlib_${ri}$gebak( 'B', 'R', n, ilo, ihi, work( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work( iwrk ), 1 )
                    call stdlib_${ri}$lartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info>0 ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$geev


     subroutine stdlib_${ri}$geevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
     !! DGEEVX: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_${rk}$ of the LAPACK
     !! Users' Guide.
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${rk}$), intent(out) :: abnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(${rk}$) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ).or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_${ri}$trevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                 else if( wantvr ) then
                    call stdlib_${ri}$trevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                 else
                    if( wntsnn ) then
                       call stdlib_${ri}$hseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    else
                       call stdlib_${ri}$hseqr( 'S', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.wntsnn )minwrk = max( minwrk, n*n+6*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.wntsnn )maxwrk = max( maxwrk, n*n + 6*n )
                 else
                    minwrk = 3*n
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )minwrk = max( minwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'DORGHR',' ', n, 1, n, -&
                              1 ) )
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )maxwrk = max( maxwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, 3*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_${ri}$gebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_${ri}$lange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (workspace: need 2*n, prefer n+n*nb)
           itau = 1
           iwrk = itau + n
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_${ri}$lacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( job, 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_${ri}$hseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 3*n, prefer n + 2*n*nb)
              call stdlib_${ri}$trevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           ! compute condition numbers if desired
           ! (workspace: need n*n+6*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_${ri}$trsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, iwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_${ri}$gebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work, 1 )
                    call stdlib_${ri}$lartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_${ri}$gebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work, 1 )
                    call stdlib_${ri}$lartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_${ri}$lascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$geevx


     pure subroutine stdlib_${ri}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! DGEHD2: reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_${ri}$larfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_${ri}$larf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_${ri}$larf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$gehd2


     pure subroutine stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DGEHRD: reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_${ri}$lahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_${ri}$axpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_${ri}$larfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_${ri}$gehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$gehrd


     pure subroutine stdlib_${ri}$gejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! DGEJSV: computes the singular value decomposition (SVD) of a real M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^t,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
     !! [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
     !! DGEJSV can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               v, ldv,work, lwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lsvec, l2aber, l2kill, &
                     l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           ! Intrinsic Functions 
           intrinsic :: abs,log,max,min,real,idnint,sign,sqrt
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec  .or. stdlib_lsame( jobu, 'N' ) .or.stdlib_lsame( jobu, 'W' )) )&
                      then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.stdlib_lsame( jobv, 'W' )) &
                     .or. ( jracc .and. (.not.lsvec) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( l2tran .or. stdlib_lsame( jobt, 'N' ) ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else if ( (.not.(lsvec .or. rsvec .or. errest).and.(lwork < max(7,4*n+1,2*m+n))) .or.(&
           .not.(lsvec .or. rsvec) .and. errest .and.(lwork < max(7,4*n+n*n,2*m+n))) .or.(lsvec &
           .and. (.not.rsvec) .and. (lwork < max(7,2*m+n,4*n+1))).or.(rsvec .and. (.not.lsvec) &
           .and. (lwork < max(7,2*m+n,4*n+1))).or.(lsvec .and. rsvec .and. (.not.jracc) .and.(&
           lwork<max(2*m+n,6*n+2*n*n))).or. (lsvec .and. rsvec .and. jracc .and.lwork<max(2*m+n,&
                     4*n+n*n,2*n+n*n+6)))then
              info = - 17
           else
              ! #:)
              info = 0
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'DGEJSV', - info )
              return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:3) = 0
              work(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_${ri}$lamch() does not fail on the target architecture.
           epsln = stdlib_${ri}$lamch('EPSILON')
           sfmin = stdlib_${ri}$lamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_${ri}$lamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=${rk}$)*real(n,KIND=${rk}$))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_${ri}$lassq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'DGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_${ri}$scal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_${ri}$laset( 'G', m, n1, zero, one, u, ldu )
              if ( rsvec ) call stdlib_${ri}$laset( 'G', n, n,  zero, one, v, ldv )
              work(1) = one
              work(2) = one
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_${ri}$lascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_${ri}$lacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                    call stdlib_${ri}$geqrf( m, n, u,ldu, work, work(n+1),lwork-n,ierr )
                    call stdlib_${ri}$orgqr( m,n1,1, u,ldu,work,work(n+1),lwork-n,ierr )
                    call stdlib_${ri}$copy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = one
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              work(1) = one / scalem
              work(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              return
           end if
           transp = .false.
           l2tran = l2tran .and. ( m == n )
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^t and a^t * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_${ri}$lassq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_${ri}$lassq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    work(m+n+p)  = xsc * scalem
                    work(n+p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, work(n+p) )
                    if (work(n+p) /= zero) aatmin = min(aatmin,work(n+p))
                 end do
              else
                 do p = 1, m
                    work(m+n+p) = scalem*abs( a(p,stdlib_i${ri}$amax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, work(m+n+p) )
                    aatmin = min( aatmin, work(m+n+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^t  would be  better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_${ri}$lassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=${rk}$))
              ! now, sva().^2/trace(a^t * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^t * a.  do the same with the
              ! diagonal of a * a^t, compute the entropy of the corresponding
              ! probability distribution. note that a * a^t and a^t * a have the
              ! same trace.
              entrat = zero
              do p = n+1, n+m
                 big1 = ( ( work(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=${rk}$))
              ! analyze the entropies and decide a or a^t. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^t is better than a, transpose a.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    do q = p + 1, n
                        temp1 = a(q,p)
                       a(q,p) = a(p,q)
                       a(p,q) = temp1
                    end do
                 end do
                 do p = 1, n
                    work(m+n+p) = sva(p)
                    sva(p)      = work(n+p)
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_${ri}$gejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_${ri}$gesvj will compute them. so, in that case,
           ! one should use stdlib_${ri}$gesvj instead of stdlib_${ri}$gejsv.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=${rk}$) )
           call stdlib_${ri}$lascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_${ri}$lascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_${ri}$gesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_${ri}$laset( 'A', m, 1, zero, zero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              do p = 1, m - 1
                 q = stdlib_i${ri}$amax( m-p+1, work(m+n+p), 1 ) + p - 1
                 iwork(2*n+p) = q
                 if ( p /= q ) then
                    temp1       = work(m+n+p)
                    work(m+n+p) = work(m+n+q)
                    work(m+n+q) = temp1
                 end if
              end do
              call stdlib_${ri}$laswp( n, a, lda, 1, m-1, iwork(2*n+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_${ri}$geqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in sgeqpx from toms # 782). good results will be obtained using
           ! sgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_${ri}$geqp3 improves overall performance of stdlib_${ri}$gejsv.
           ! a * p1 = q1 * [ r1^t 0]^t:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_${ri}$geqp3( m,n,a,lda, iwork,work, work(n+1),lwork-n, ierr )
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_${ri}$gejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=${rk}$))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=${rk}$)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ri}$scal( p, one/temp1, v(1,p), 1 )
                    end do
                    call stdlib_${ri}$pocon( 'U', n, v, ldv, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ri}$scal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_${ri}$pocon( 'U', n, u, ldu, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work(n+1), n )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ri}$scal( p, one/temp1, work(n+(p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
                    call stdlib_${ri}$pocon( 'U', n, work(n+1), n, one, temp1,work(n+n*n+1), iwork(2*n+&
                              m+1), ierr )
                 end if
                 sconda = one / sqrt(temp1)
                 ! sconda is an estimate of sqrt(||(r^t * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_${ri}$copy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
              end do
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=${rk}$)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_${ri}$geqrf( n,nr, a,lda, work, work(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_${ri}$copy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                 end do
              end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=${rk}$)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1, nr-1, zero, zero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_${ri}$gesvj( 'L', 'NOU', 'NOV', nr, nr, a, lda, sva,n, v, ldv, work, &
                           lwork, info )
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
           else if ( rsvec .and. ( .not. lsvec ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_${ri}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_${ri}$gesvj( 'L','U','N', n, nr, v,ldv, sva, nr, a,lda,work, lwork, info )
                           
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 call stdlib_${ri}$laset( 'LOWER', nr-1, nr-1, zero, zero, a(2,1), lda )
                 call stdlib_${ri}$gelqf( nr, n, a, lda, work, work(n+1), lwork-n, ierr)
                 call stdlib_${ri}$lacpy( 'LOWER', nr, nr, a, lda, v, ldv )
                 call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_${ri}$geqrf( nr, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_${ri}$copy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                 end do
                 call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_${ri}$gesvj( 'LOWER', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, work(n+1), &
                           lwork, info )
                 scalem  = work(n+1)
                 numrank = nint(work(n+2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_${ri}$laset( 'A',n-nr, nr, zero,zero, v(nr+1,1),   ldv )
                    call stdlib_${ri}$laset( 'A',nr, n-nr, zero,zero, v(1,nr+1),   ldv )
                    call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one, v(nr+1,nr+1), ldv )
                 end if
              call stdlib_${ri}$ormlq( 'LEFT', 'TRANSPOSE', n, n, nr, a, lda, work,v, ldv, work(n+1), &
                        lwork-n, ierr )
              end if
              do p = 1, n
                 call stdlib_${ri}$copy( n, v(p,1), ldv, a(iwork(p),1), lda )
              end do
              call stdlib_${ri}$lacpy( 'ALL', n, n, a, lda, v, ldv )
              if ( transp ) then
                 call stdlib_${ri}$lacpy( 'ALL', n, n, v, ldv, u, ldu )
              end if
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_${ri}$copy( n-p+1, a(p,p), lda, u(p,p), 1 )
              end do
              call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_${ri}$geqrf( n, nr, u, ldu, work(n+1), work(2*n+1),lwork-2*n, ierr )
              do p = 1, nr - 1
                 call stdlib_${ri}$copy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
              end do
              call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_${ri}$gesvj( 'LOWER', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, work(n+1), &
                        lwork-n, info )
              scalem  = work(n+1)
              numrank = nint(work(n+2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_${ri}$laset( 'A',  m-nr, nr,zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_${ri}$laset( 'A',nr, n1-nr, zero, zero, u(1,nr+1), ldu )
                    call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                 end if
              end if
              call stdlib_${ri}$ormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
              if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_${ri}$nrm2( m, u(1,p), 1 )
                 call stdlib_${ri}$scal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_${ri}$lacpy( 'ALL', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_${ri}$gejsv.
                 do p = 1, nr
                    call stdlib_${ri}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       temp1 = xsc*abs( v(q,q) )
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    sign( temp1, v(p,q) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_${ri}$lacpy( 'L', nr, nr, v, ldv, work(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_${ri}$nrm2(nr-p+1,work(2*n+(p-1)*nr+p),1)
                    call stdlib_${ri}$scal(nr-p+1,one/temp1,work(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_${ri}$pocon('LOWER',nr,work(2*n+1),nr,one,temp1,work(2*n+nr*nr+1),iwork(m+&
                           2*n+1),ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=${rk}$)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=${rk}$))
                 cond_ok = sqrt(real(nr,KIND=${rk}$))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^t = q2 * r2
                    call stdlib_${ri}$geqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_${ri}$lacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_${ri}$copy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                    end do
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_${ri}$geqp3
                    ! should be replaced with eg. call sgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^t * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_${ri}$geqp3( n, nr, v, ldv, iwork(n+1), work(n+1),work(2*n+1), lwork-&
                              2*n, ierr )
      ! *               call stdlib_${ri}$geqrf( n, nr, v, ldv, work(n+1), work(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    call stdlib_${ri}$lacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             v(p,q) = - sign( temp1, v(q,p) )
                          end do
                       end do
                    else
                       call stdlib_${ri}$laset( 'L',nr-1,nr-1,zero,zero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_${ri}$gelqf( nr, nr, v, ldv, work(2*n+n*nr+1),work(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_${ri}$lacpy( 'L',nr,nr,v,ldv,work(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_${ri}$nrm2( p, work(2*n+n*nr+nr+p), nr )
                       call stdlib_${ri}$scal( p, one/temp1, work(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_${ri}$pocon( 'L',nr,work(2*n+n*nr+nr+1),nr,one,temp1,work(2*n+n*nr+nr+&
                              nr*nr+1),iwork(m+2*n+1),ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_${ri}$lacpy( 'U', nr, nr, v, ldv, work(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       temp1 = xsc * v(q,q)
                       do p = 1, q - 1
                          ! v(p,q) = - sign( temp1, v(q,p) )
                          v(p,q) = - sign( temp1, v(p,q) )
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_${ri}$gesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u,ldu,work(2*n+n*nr+nr+1),&
                              lwork-2*n-n*nr-nr,info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_${ri}$copy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_${ri}$scal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_${ri}$gesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_${ri}$trsm( 'L','U','N','N', nr,nr,one, a,lda, v,ldv )
                    else
                       ! .. r1 is well conditioned, but non-square. transpose(r2)
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_${ri}$gesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_${ri}$trsm('L','U','T','N',nr,nr,one,work(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                         call stdlib_${ri}$laset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                         call stdlib_${ri}$laset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                         call stdlib_${ri}$laset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_${ri}$ormqr('L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                                 n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
       ! :)           .. the input matrix a is very likely a relative of
                    ! the kahan matrix :)
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^t*v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_${ri}$gesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_${ri}$copy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_${ri}$scal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_${ri}$trsm('L','U','N','N',nr,nr,one,work(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_${ri}$laset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_${ri}$laset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_${ri}$ormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_${ri}$gejsv completes the task.
                    ! compute the full svd of l3 using stdlib_${ri}$gesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_${ri}$gesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_${ri}$laset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_${ri}$laset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_${ri}$ormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_${ri}$ormlq( 'L', 'T', nr, nr, nr, work(2*n+1), n,work(2*n+n*nr+1), u, &
                              ldu, work(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=${rk}$)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_${ri}$nrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_${ri}$laset( 'A', m-nr, nr, zero, zero, u(nr+1,1), ldu )
                    if ( nr < n1 ) then
                       call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                       call stdlib_${ri}$laset('A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_${ri}$ormqr( 'LEFT', 'NO_TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=${rk}$)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_${ri}$nrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_${ri}$lacpy( 'UPPER', n, n, a, lda, work(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       temp1 = xsc * work( n + (p-1)*n + p )
                       do q = 1, p - 1
                          work(n+(q-1)*n+p)=-sign(temp1,work(n+(p-1)*n+q))
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'LOWER',n-1,n-1,zero,zero,work(n+2),n )
                 end if
                 call stdlib_${ri}$gesvj( 'UPPER', 'U', 'N', n, n, work(n+1), n, sva,n, u, ldu, work(n+&
                           n*n+1), lwork-n-n*n, info )
                 scalem  = work(n+n*n+1)
                 numrank = nint(work(n+n*n+2),KIND=ilp)
                 do p = 1, n
                    call stdlib_${ri}$copy( n, work(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_${ri}$scal( n, sva(p), work(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'NOTRANS', 'NO UD', n, n,one, a, lda, work(n+&
                           1), n )
                 do p = 1, n
                    call stdlib_${ri}$copy( n, work(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=${rk}$))*epsln
                 do p = 1, n
                    xsc = one / stdlib_${ri}$nrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( n, xsc, &
                              v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_${ri}$laset( 'A',  m-n, n, zero, zero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_${ri}$laset( 'A',n,  n1-n, zero, zero,  u(1,n+1),ldu )
                       call stdlib_${ri}$laset( 'A',m-n,n1-n, zero, one,u(n+1,n+1),ldu )
                    end if
                 end if
                 call stdlib_${ri}$ormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 temp1 = sqrt(real(m,KIND=${rk}$))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_${ri}$nrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values. since that is not always the case, ...
              do p = 1, nr
                 call stdlib_${ri}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    temp1 = xsc*abs( v(q,q) )
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = sign(&
                                  temp1, v(p,q) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 call stdlib_${ri}$laset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
              end if
              call stdlib_${ri}$geqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
              call stdlib_${ri}$lacpy( 'L', n, nr, v, ldv, work(2*n+1), n )
              do p = 1, nr
                 call stdlib_${ri}$copy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       temp1 = xsc * min(abs(u(p,p)),abs(u(q,q)))
                       u(p,q) = - sign( temp1, u(q,p) )
                    end do
                 end do
              else
                 call stdlib_${ri}$laset('U', nr-1, nr-1, zero, zero, u(1,2), ldu )
              end if
              call stdlib_${ri}$gesvj( 'G', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, work(2*n+n*nr+1), &
                        lwork-2*n-n*nr, info )
              scalem  = work(2*n+n*nr+1)
              numrank = nint(work(2*n+n*nr+2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_${ri}$laset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                 call stdlib_${ri}$laset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                 call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
              end if
              call stdlib_${ri}$ormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+n*nr+nr+1)&
                        ,lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=${rk}$)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_${ri}$nrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_${ri}$laset( 'A',  m-nr, nr, zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_${ri}$laset( 'A',nr,  n1-nr, zero, zero,  u(1,nr+1),ldu )
                    call stdlib_${ri}$laset( 'A',m-nr,n1-nr, zero, one,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_${ri}$ormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
                 if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^t
                 do p = 1, n
                    call stdlib_${ri}$swap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           work(1) = uscal2 * scalem
           work(2) = uscal1
           if ( errest ) work(3) = sconda
           if ( lsvec .and. rsvec ) then
              work(4) = condr1
              work(5) = condr2
           end if
           if ( l2tran ) then
              work(6) = entra
              work(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           return
     end subroutine stdlib_${ri}$gejsv


     pure subroutine stdlib_${ri}$gelq( m, n, a, lda, t, tsize, work, lwork,info )
     !! DGELQ: computes an LQ factorization of a real M-by-N matrix A:
     !! A = ( L 0 ) *  Q
     !! where:
     !! Q is a N-by-N orthogonal matrix;
     !! L is a lower-triangular M-by-M matrix;
     !! 0 is a M-by-(N-M) zero matrix, if M < N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, tsize, lwork
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, lminws, mint, minw
           integer(ilp) :: mb, nb, mintsz, nblcks, lwmin, lwopt, lwreq
           ! Intrinsic Functions 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( tsize==-1 .or. tsize==-2 .or.lwork==-1 .or. lwork==-2 )
           mint = .false.
           minw = .false.
           if( tsize==-2 .or. lwork==-2 ) then
             if( tsize/=-1 ) mint = .true.
             if( lwork/=-1 ) minw = .true.
           end if
           ! determine the block size
           if( min( m, n )>0 ) then
             mb = stdlib_ilaenv( 1, 'DGELQ ', ' ', m, n, 1, -1 )
             nb = stdlib_ilaenv( 1, 'DGELQ ', ' ', m, n, 2, -1 )
           else
             mb = 1
             nb = n
           end if
           if( mb>min( m, n ) .or. mb<1 ) mb = 1
           if( nb>n .or. nb<=m ) nb = n
           mintsz = m + 5
           if ( nb>m .and. n>m ) then
             if( mod( n - m, nb - m )==0 ) then
               nblcks = ( n - m ) / ( nb - m )
             else
               nblcks = ( n - m ) / ( nb - m ) + 1
             end if
           else
             nblcks = 1
           end if
           ! determine if the workspace size satisfies minimal size
           if( ( n<=m ) .or. ( nb<=m ) .or. ( nb>=n ) ) then
              lwmin = max( 1, n )
              lwopt = max( 1, mb*n )
           else
              lwmin = max( 1, m )
              lwopt = max( 1, mb*m )
           end if
           lminws = .false.
           if( ( tsize<max( 1, mb*m*nblcks + 5 ) .or. lwork<lwopt ).and. ( lwork>=lwmin ) .and. ( &
                     tsize>=mintsz ).and. ( .not.lquery ) ) then
             if( tsize<max( 1, mb*m*nblcks + 5 ) ) then
                 lminws = .true.
                 mb = 1
                 nb = n
             end if
             if( lwork<lwopt ) then
                 lminws = .true.
                 mb = 1
             end if
           end if
           if( ( n<=m ) .or. ( nb<=m ) .or. ( nb>=n ) ) then
              lwreq = max( 1, mb*n )
           else
              lwreq = max( 1, mb*m )
           end if
           if( m<0 ) then
             info = -1
           else if( n<0 ) then
             info = -2
           else if( lda<max( 1, m ) ) then
             info = -4
           else if( tsize<max( 1, mb*m*nblcks + 5 ).and. ( .not.lquery ) .and. ( .not.lminws ) ) &
                     then
             info = -6
           else if( ( lwork<lwreq ) .and.( .not.lquery ).and. ( .not.lminws ) ) then
             info = -8
           end if
           if( info==0 ) then
             if( mint ) then
               t( 1 ) = mintsz
             else
               t( 1 ) = mb*m*nblcks + 5
             end if
             t( 2 ) = mb
             t( 3 ) = nb
             if( minw ) then
               work( 1 ) = lwmin
             else
               work( 1 ) = lwreq
             end if
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DGELQ', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
             return
           end if
           ! the lq decomposition
           if( ( n<=m ) .or. ( nb<=m ) .or. ( nb>=n ) ) then
             call stdlib_${ri}$gelqt( m, n, mb, a, lda, t( 6 ), mb, work, info )
           else
             call stdlib_${ri}$laswlq( m, n, mb, nb, a, lda, t( 6 ), mb, work,lwork, info )
           end if
           work( 1 ) = lwreq
           return
     end subroutine stdlib_${ri}$gelq


     pure subroutine stdlib_${ri}$gelq2( m, n, a, lda, tau, work, info )
     !! DGELQ2: computes an LQ factorization of a real m-by-n matrix A:
     !! A = ( L 0 ) *  Q
     !! where:
     !! Q is a n-by-n orthogonal matrix;
     !! L is a lower-triangular m-by-m matrix;
     !! 0 is a m-by-(n-m) zero matrix, if m < n.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELQ2', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elementary reflector h(i) to annihilate a(i,i+1:n)
              call stdlib_${ri}$larfg( n-i+1, a( i, i ), a( i, min( i+1, n ) ), lda,tau( i ) )
              if( i<m ) then
                 ! apply h(i) to a(i+1:m,i:n) from the right
                 aii = a( i, i )
                 a( i, i ) = one
                 call stdlib_${ri}$larf( 'RIGHT', m-i, n-i+1, a( i, i ), lda, tau( i ),a( i+1, i ), &
                           lda, work )
                 a( i, i ) = aii
              end if
           end do
           return
     end subroutine stdlib_${ri}$gelq2


     pure subroutine stdlib_${ri}$gelqf( m, n, a, lda, tau, work, lwork, info )
     !! DGELQF: computes an LQ factorization of a real M-by-N matrix A:
     !! A = ( L 0 ) *  Q
     !! where:
     !! Q is a N-by-N orthogonal matrix;
     !! L is a lower-triangular M-by-M matrix;
     !! 0 is a M-by-(N-M) zero matrix, if M < N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'DGELQF', ' ', m, n, -1, -1 )
           lwkopt = m*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( lwork<max( 1, m ) .and. .not.lquery ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELQF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DGELQF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGELQF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially
              do i = 1, k - nx, nb
                 ib = min( k-i+1, nb )
                 ! compute the lq factorization of the current block
                 ! a(i:i+ib-1,i:n)
                 call stdlib_${ri}$gelq2( ib, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                 if( i+ib<=m ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_${ri}$larft( 'FORWARD', 'ROWWISE', n-i+1, ib, a( i, i ),lda, tau( i ), &
                              work, ldwork )
                    ! apply h to a(i+ib:m,i:n) from the right
                    call stdlib_${ri}$larfb( 'RIGHT', 'NO TRANSPOSE', 'FORWARD','ROWWISE', m-i-ib+1, n-&
                    i+1, ib, a( i, i ),lda, work, ldwork, a( i+ib, i ), lda,work( ib+1 ), ldwork )
                              
                 end if
              end do
           else
              i = 1
           end if
           ! use unblocked code to factor the last or only block.
           if( i<=k )call stdlib_${ri}$gelq2( m-i+1, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                     
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$gelqf


     pure subroutine stdlib_${ri}$gelqt( m, n, mb, a, lda, t, ldt, work, info )
     !! DGELQT: computes a blocked LQ factorization of a real M-by-N matrix A
     !! using the compact WY representation of Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n, mb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ib, iinfo, k
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( mb<1 .or. ( mb>min(m,n) .and. min(m,n)>0 ) )then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldt<mb ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELQT', -info )
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) return
           ! blocked loop of length k
           do i = 1, k,  mb
              ib = min( k-i+1, mb )
           ! compute the lq factorization of the current block a(i:m,i:i+ib-1)
              call stdlib_${ri}$gelqt3( ib, n-i+1, a(i,i), lda, t(1,i), ldt, iinfo )
              if( i+ib<=m ) then
           ! update by applying h**t to a(i:m,i+ib:n) from the right
              call stdlib_${ri}$larfb( 'R', 'N', 'F', 'R', m-i-ib+1, n-i+1, ib,a( i, i ), lda, t( 1, i &
                        ), ldt,a( i+ib, i ), lda, work , m-i-ib+1 )
              end if
           end do
           return
     end subroutine stdlib_${ri}$gelqt


     pure recursive subroutine stdlib_${ri}$gelqt3( m, n, a, lda, t, ldt, info )
     !! DGELQT3: recursively computes a LQ factorization of a real M-by-N
     !! matrix A, using the compact WY representation of Q.
     !! Based on the algorithm of Elmroth and Gustavson,
     !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, ldt
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, j, j1, m1, m2, iinfo
           ! Executable Statements 
           info = 0
           if( m < 0 ) then
              info = -1
           else if( n < m ) then
              info = -2
           else if( lda < max( 1, m ) ) then
              info = -4
           else if( ldt < max( 1, m ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELQT3', -info )
              return
           end if
           if( m==1 ) then
              ! compute householder transform when m=1
              call stdlib_${ri}$larfg( n, a(1,1), a( 1, min( 2, n ) ), lda, t(1,1) )
           else
              ! otherwise, split a into blocks...
              m1 = m/2
              m2 = m-m1
              i1 = min( m1+1, m )
              j1 = min( m+1, n )
              ! compute a(1:m1,1:n) <- (y1,r1,t1), where q1 = i - y1 t1 y1^h
              call stdlib_${ri}$gelqt3( m1, n, a, lda, t, ldt, iinfo )
              ! compute a(j1:m,1:n) = q1^h a(j1:m,1:n) [workspace: t(1:n1,j1:n)]
              do i=1,m2
                 do j=1,m1
                    t(  i+m1, j ) = a( i+m1, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'U', 'T', 'U', m2, m1, one,a, lda, t( i1, 1 ), ldt )
              call stdlib_${ri}$gemm( 'N', 'T', m2, m1, n-m1, one, a( i1, i1 ), lda,a( 1, i1 ), lda, &
                        one, t( i1, 1 ), ldt)
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'N', m2, m1, one,t, ldt, t( i1, 1 ), ldt )
              call stdlib_${ri}$gemm( 'N', 'N', m2, n-m1, m1, -one, t( i1, 1 ), ldt,a( 1, i1 ), lda, &
                        one, a( i1, i1 ), lda )
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'U', m2, m1 , one,a, lda, t( i1, 1 ), ldt )
                        
              do i=1,m2
                 do j=1,m1
                    a(  i+m1, j ) = a( i+m1, j ) - t( i+m1, j )
                    t( i+m1, j )=0
                 end do
              end do
              ! compute a(j1:m,j1:n) <- (y2,r2,t2) where q2 = i - y2 t2 y2^h
              call stdlib_${ri}$gelqt3( m2, n-m1, a( i1, i1 ), lda,t( i1, i1 ), ldt, iinfo )
              ! compute t3 = t(j1:n1,1:n) = -t1 y1^h y2 t2
              do i=1,m2
                 do j=1,m1
                    t( j, i+m1  ) = (a( j, i+m1 ))
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'U', 'T', 'U', m1, m2, one,a( i1, i1 ), lda, t( 1, i1 ), &
                        ldt )
              call stdlib_${ri}$gemm( 'N', 'T', m1, m2, n-m, one, a( 1, j1 ), lda,a( i1, j1 ), lda, &
                        one, t( 1, i1 ), ldt )
              call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', m1, m2, -one, t, ldt,t( 1, i1 ), ldt )
                        
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'N', m1, m2, one,t( i1, i1 ), ldt, t( 1, i1 ), &
                        ldt )
              ! y = (y1,y2); l = [ l1            0  ];  t = [t1 t3]
                               ! [ a(1:n1,j1:n)  l2 ]       [ 0 t2]
           end if
           return
     end subroutine stdlib_${ri}$gelqt3


     subroutine stdlib_${ri}$gels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
     !! DGELS: solves overdetermined or underdetermined real linear systems
     !! involving an M-by-N matrix A, or its transpose, using a QR or LQ
     !! factorization of A.  It is assumed that A has full rank.
     !! The following options are provided:
     !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A*X ||.
     !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
     !! an underdetermined system A * X = B.
     !! 3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
     !! an underdetermined system A**T * X = B.
     !! 4. If TRANS = 'T' and m < n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A**T * X ||.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, tpsd
           integer(ilp) :: brow, i, iascl, ibscl, j, mn, nb, scllen, wsize
           real(${rk}$) :: anrm, bignum, bnrm, smlnum
           ! Local Arrays 
           real(${rk}$) :: rwork(1)
           ! Intrinsic Functions 
           intrinsic :: real,max,min
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( .not.( stdlib_lsame( trans, 'N' ) .or. stdlib_lsame( trans, 'T' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldb<max( 1, m, n ) ) then
              info = -8
           else if( lwork<max( 1, mn+max( mn, nrhs ) ) .and. .not.lquery )then
              info = -10
           end if
           ! figure out optimal block size
           if( info==0 .or. info==-10 ) then
              tpsd = .true.
              if( stdlib_lsame( trans, 'N' ) )tpsd = .false.
              if( m>=n ) then
                 nb = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
                 if( tpsd ) then
                    nb = max( nb, stdlib_ilaenv( 1, 'DORMQR', 'LN', m, nrhs, n,-1 ) )
                 else
                    nb = max( nb, stdlib_ilaenv( 1, 'DORMQR', 'LT', m, nrhs, n,-1 ) )
                 end if
              else
                 nb = stdlib_ilaenv( 1, 'DGELQF', ' ', m, n, -1, -1 )
                 if( tpsd ) then
                    nb = max( nb, stdlib_ilaenv( 1, 'DORMLQ', 'LT', n, nrhs, m,-1 ) )
                 else
                    nb = max( nb, stdlib_ilaenv( 1, 'DORMLQ', 'LN', n, nrhs, m,-1 ) )
                 end if
              end if
              wsize = max( 1, mn+max( mn, nrhs )*nb )
              work( 1 ) = real( wsize,KIND=${rk}$)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELS ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( min( m, n, nrhs )==0 ) then
              call stdlib_${ri}$laset( 'FULL', max( m, n ), nrhs, zero, zero, b, ldb )
              return
           end if
           ! get machine parameters
           smlnum = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'P' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! scale a, b if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, rwork )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_${ri}$laset( 'F', max( m, n ), nrhs, zero, zero, b, ldb )
              go to 50
           end if
           brow = m
           if( tpsd )brow = n
           bnrm = stdlib_${ri}$lange( 'M', brow, nrhs, b, ldb, rwork )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, smlnum, brow, nrhs, b, ldb,info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bignum, brow, nrhs, b, ldb,info )
              ibscl = 2
           end if
           if( m>=n ) then
              ! compute qr factorization of a
              call stdlib_${ri}$geqrf( m, n, a, lda, work( 1 ), work( mn+1 ), lwork-mn,info )
              ! workspace at least n, optimally n*nb
              if( .not.tpsd ) then
                 ! least-squares problem min || a * x - b ||
                 ! b(1:m,1:nrhs) := q**t * b(1:m,1:nrhs)
                 call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', m, nrhs, n, a, lda,work( 1 ), b, ldb, &
                           work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 ! b(1:n,1:nrhs) := inv(r) * b(1:n,1:nrhs)
                 call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 scllen = n
              else
                 ! underdetermined system of equations a**t * x = b
                 ! b(1:n,1:nrhs) := inv(r**t) * b(1:n,1:nrhs)
                 call stdlib_${ri}$trtrs( 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(n+1:m,1:nrhs) = zero
                 do j = 1, nrhs
                    do i = n + 1, m
                       b( i, j ) = zero
                    end do
                 end do
                 ! b(1:m,1:nrhs) := q(1:n,:) * b(1:n,1:nrhs)
                 call stdlib_${ri}$ormqr( 'LEFT', 'NO TRANSPOSE', m, nrhs, n, a, lda,work( 1 ), b, ldb,&
                            work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 scllen = m
              end if
           else
              ! compute lq factorization of a
              call stdlib_${ri}$gelqf( m, n, a, lda, work( 1 ), work( mn+1 ), lwork-mn,info )
              ! workspace at least m, optimally m*nb.
              if( .not.tpsd ) then
                 ! underdetermined system of equations a * x = b
                 ! b(1:m,1:nrhs) := inv(l) * b(1:m,1:nrhs)
                 call stdlib_${ri}$trtrs( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', m, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(m+1:n,1:nrhs) = 0
                 do j = 1, nrhs
                    do i = m + 1, n
                       b( i, j ) = zero
                    end do
                 end do
                 ! b(1:n,1:nrhs) := q(1:n,:)**t * b(1:m,1:nrhs)
                 call stdlib_${ri}$ormlq( 'LEFT', 'TRANSPOSE', n, nrhs, m, a, lda,work( 1 ), b, ldb, &
                           work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 scllen = n
              else
                 ! overdetermined system min || a**t * x - b ||
                 ! b(1:n,1:nrhs) := q * b(1:n,1:nrhs)
                 call stdlib_${ri}$ormlq( 'LEFT', 'NO TRANSPOSE', n, nrhs, m, a, lda,work( 1 ), b, ldb,&
                            work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 ! b(1:m,1:nrhs) := inv(l**t) * b(1:m,1:nrhs)
                 call stdlib_${ri}$trtrs( 'LOWER', 'TRANSPOSE', 'NON-UNIT', m, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 scllen = m
              end if
           end if
           ! undo scaling
           if( iascl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, scllen, nrhs, b, ldb,info )
           else if( iascl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, scllen, nrhs, b, ldb,info )
           end if
           if( ibscl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, bnrm, scllen, nrhs, b, ldb,info )
           else if( ibscl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bignum, bnrm, scllen, nrhs, b, ldb,info )
           end if
           50 continue
           work( 1 ) = real( wsize,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$gels


     subroutine stdlib_${ri}$gelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, iwork, &
     !! DGELSD: computes the minimum-norm solution to a real linear least
     !! squares problem:
     !! minimize 2-norm(| b - A*x |)
     !! using the singular value decomposition (SVD) of A. A is an M-by-N
     !! matrix which may be rank-deficient.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
     !! The problem is solved in three steps:
     !! (1) Reduce the coefficient matrix A to bidiagonal form with
     !! Householder transformations, reducing the original problem
     !! into a "bidiagonal least squares problem" (BLS)
     !! (2) Solve the BLS using a divide and conquer approach.
     !! (3) Apply back all the Householder transformations to solve
     !! the original least squares problem.
     !! The effective rank of A is determined by treating as zero those
     !! singular values which are less than RCOND times the largest singular
     !! value.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(in) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: s(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: iascl, ibscl, ie, il, itau, itaup, itauq, ldwork, liwork, maxmn, &
                     maxwrk, minmn, minwrk, mm, mnthr, nlvl, nwork, smlsiz, wlalsd
           real(${rk}$) :: anrm, bignum, bnrm, eps, sfmin, smlnum
           ! Intrinsic Functions 
           intrinsic :: real,int,log,max,min
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           minmn = min( m, n )
           maxmn = max( m, n )
           mnthr = stdlib_ilaenv( 6, 'DGELSD', ' ', m, n, nrhs, -1 )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, maxmn ) ) then
              info = -7
           end if
           smlsiz = stdlib_ilaenv( 9, 'DGELSD', ' ', 0, 0, 0, 0 )
           ! compute workspace.
           ! (note: comments in the code beginning "workspace:" describe the
           ! minimal amount of workspace needed at that point in the code,
           ! as well as the preferred amount for good performance.
           ! nb refers to the optimal block size for the immediately
           ! following subroutine, as returned by stdlib_ilaenv.)
           minwrk = 1
           liwork = 1
           minmn = max( 1, minmn )
           nlvl = max( int( log( real( minmn,KIND=${rk}$) / real( smlsiz+1,KIND=${rk}$) ) /log( two ),&
                     KIND=ilp) + 1, 0 )
           if( info==0 ) then
              maxwrk = 0
              liwork = 3*minmn*nlvl + 11*minmn
              mm = m
              if( m>=n .and. m>=mnthr ) then
                 ! path 1a - overdetermined, with many more rows than columns.
                 mm = n
                 maxwrk = max( maxwrk, n+n*stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n,-1, -1 ) )
                           
                 maxwrk = max( maxwrk, n+nrhs*stdlib_ilaenv( 1, 'DORMQR', 'LT', m, nrhs, n, -1 ) )
                           
              end if
              if( m>=n ) then
                 ! path 1 - overdetermined or exactly determined.
                 maxwrk = max( maxwrk, 3*n+( mm+n )*stdlib_ilaenv( 1, 'DGEBRD', ' ', mm, n, -1, -&
                           1 ) )
                 maxwrk = max( maxwrk, 3*n+nrhs*stdlib_ilaenv( 1, 'DORMBR', 'QLT', mm, nrhs, n, -&
                           1 ) )
                 maxwrk = max( maxwrk, 3*n+( n-1 )*stdlib_ilaenv( 1, 'DORMBR', 'PLN', n, nrhs, n, &
                           -1 ) )
                 wlalsd = 9*n+2*n*smlsiz+8*n*nlvl+n*nrhs+(smlsiz+1)**2
                 maxwrk = max( maxwrk, 3*n+wlalsd )
                 minwrk = max( 3*n+mm, 3*n+nrhs, 3*n+wlalsd )
              end if
              if( n>m ) then
                 wlalsd = 9*m+2*m*smlsiz+8*m*nlvl+m*nrhs+(smlsiz+1)**2
                 if( n>=mnthr ) then
                    ! path 2a - underdetermined, with many more columns
                    ! than rows.
                    maxwrk = m + m*stdlib_ilaenv( 1, 'DGELQF', ' ', m, n, -1, -1 )
                    maxwrk = max( maxwrk, m*m+4*m+2*m*stdlib_ilaenv( 1, 'DGEBRD', ' ', m, m, -1, -&
                              1 ) )
                    maxwrk = max( maxwrk, m*m+4*m+nrhs*stdlib_ilaenv( 1, 'DORMBR', 'QLT', m, nrhs,&
                               m, -1 ) )
                    maxwrk = max( maxwrk, m*m+4*m+( m-1 )*stdlib_ilaenv( 1, 'DORMBR', 'PLN', m, &
                              nrhs, m, -1 ) )
                    if( nrhs>1 ) then
                       maxwrk = max( maxwrk, m*m+m+m*nrhs )
                    else
                       maxwrk = max( maxwrk, m*m+2*m )
                    end if
                    maxwrk = max( maxwrk, m+nrhs*stdlib_ilaenv( 1, 'DORMLQ', 'LT', n, nrhs, m, -1 &
                              ) )
                    maxwrk = max( maxwrk, m*m+4*m+wlalsd )
           ! xxx: ensure the path 2a case below is triggered.  the workspace
           ! calculation should use queries for all routines eventually.
                    maxwrk = max( maxwrk,4*m+m*m+max( m, 2*m-4, nrhs, n-3*m ) )
                 else
                    ! path 2 - remaining underdetermined cases.
                    maxwrk = 3*m + ( n+m )*stdlib_ilaenv( 1, 'DGEBRD', ' ', m, n,-1, -1 )
                    maxwrk = max( maxwrk, 3*m+nrhs*stdlib_ilaenv( 1, 'DORMBR', 'QLT', m, nrhs, n, &
                              -1 ) )
                    maxwrk = max( maxwrk, 3*m+m*stdlib_ilaenv( 1, 'DORMBR', 'PLN', n, nrhs, m, -1 &
                              ) )
                    maxwrk = max( maxwrk, 3*m+wlalsd )
                 end if
                 minwrk = max( 3*m+nrhs, 3*m+m, 3*m+wlalsd )
              end if
              minwrk = min( minwrk, maxwrk )
              work( 1 ) = maxwrk
              iwork( 1 ) = liwork
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELSD', -info )
              return
           else if( lquery ) then
              go to 10
           end if
           ! quick return if possible.
           if( m==0 .or. n==0 ) then
              rank = 0
              return
           end if
           ! get machine parameters.
           eps = stdlib_${ri}$lamch( 'P' )
           sfmin = stdlib_${ri}$lamch( 'S' )
           smlnum = sfmin / eps
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! scale a if max entry outside range [smlnum,bignum].
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, work )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum.
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum.
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_${ri}$laset( 'F', max( m, n ), nrhs, zero, zero, b, ldb )
              call stdlib_${ri}$laset( 'F', minmn, 1, zero, zero, s, 1 )
              rank = 0
              go to 10
           end if
           ! scale b if max entry outside range [smlnum,bignum].
           bnrm = stdlib_${ri}$lange( 'M', m, nrhs, b, ldb, work )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum.
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, smlnum, m, nrhs, b, ldb, info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum.
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bignum, m, nrhs, b, ldb, info )
              ibscl = 2
           end if
           ! if m < n make sure certain entries of b are zero.
           if( m<n )call stdlib_${ri}$laset( 'F', n-m, nrhs, zero, zero, b( m+1, 1 ), ldb )
           ! overdetermined case.
           if( m>=n ) then
              ! path 1 - overdetermined or exactly determined.
              mm = m
              if( m>=mnthr ) then
                 ! path 1a - overdetermined, with many more rows than columns.
                 mm = n
                 itau = 1
                 nwork = itau + n
                 ! compute a=q*r.
                 ! (workspace: need 2*n, prefer n+n*nb)
                 call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                           info )
                 ! multiply b by transpose(q).
                 ! (workspace: need n+nrhs, prefer n+nrhs*nb)
                 call stdlib_${ri}$ormqr( 'L', 'T', m, nrhs, n, a, lda, work( itau ), b,ldb, work( &
                           nwork ), lwork-nwork+1, info )
                 ! zero out below r.
                 if( n>1 ) then
                    call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                 end if
              end if
              ie = 1
              itauq = ie + n
              itaup = itauq + n
              nwork = itaup + n
              ! bidiagonalize r in a.
              ! (workspace: need 3*n+mm, prefer 3*n+(mm+n)*nb)
              call stdlib_${ri}$gebrd( mm, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), work(&
                         nwork ), lwork-nwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors of r.
              ! (workspace: need 3*n+nrhs, prefer 3*n+nrhs*nb)
              call stdlib_${ri}$ormbr( 'Q', 'L', 'T', mm, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
              ! solve the bidiagonal least squares problem.
              call stdlib_${ri}$lalsd( 'U', smlsiz, n, nrhs, s, work( ie ), b, ldb,rcond, rank, work( &
                        nwork ), iwork, info )
              if( info/=0 ) then
                 go to 10
              end if
              ! multiply b by right bidiagonalizing vectors of r.
              call stdlib_${ri}$ormbr( 'P', 'L', 'N', n, nrhs, n, a, lda, work( itaup ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
           else if( n>=mnthr .and. lwork>=4*m+m*m+max( m, 2*m-4, nrhs, n-3*m, wlalsd ) ) &
                     then
              ! path 2a - underdetermined, with many more columns than rows
              ! and sufficient workspace for an efficient algorithm.
              ldwork = m
              if( lwork>=max( 4*m+m*lda+max( m, 2*m-4, nrhs, n-3*m ),m*lda+m+m*nrhs, 4*m+m*lda+&
                        wlalsd ) )ldwork = lda
              itau = 1
              nwork = m + 1
              ! compute a=l*q.
              ! (workspace: need 2*m, prefer m+m*nb)
              call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, info )
                        
              il = nwork
              ! copy l to work(il), zeroing out above its diagonal.
              call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( il ), ldwork )
              call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, work( il+ldwork ),ldwork )
              ie = il + ldwork*m
              itauq = ie + m
              itaup = itauq + m
              nwork = itaup + m
              ! bidiagonalize l in work(il).
              ! (workspace: need m*m+5*m, prefer m*m+4*m+2*m*nb)
              call stdlib_${ri}$gebrd( m, m, work( il ), ldwork, s, work( ie ),work( itauq ), work( &
                        itaup ), work( nwork ),lwork-nwork+1, info )
              ! multiply b by transpose of left bidiagonalizing vectors of l.
              ! (workspace: need m*m+4*m+nrhs, prefer m*m+4*m+nrhs*nb)
              call stdlib_${ri}$ormbr( 'Q', 'L', 'T', m, nrhs, m, work( il ), ldwork,work( itauq ), b, &
                        ldb, work( nwork ),lwork-nwork+1, info )
              ! solve the bidiagonal least squares problem.
              call stdlib_${ri}$lalsd( 'U', smlsiz, m, nrhs, s, work( ie ), b, ldb,rcond, rank, work( &
                        nwork ), iwork, info )
              if( info/=0 ) then
                 go to 10
              end if
              ! multiply b by right bidiagonalizing vectors of l.
              call stdlib_${ri}$ormbr( 'P', 'L', 'N', m, nrhs, m, work( il ), ldwork,work( itaup ), b, &
                        ldb, work( nwork ),lwork-nwork+1, info )
              ! zero out below first m rows of b.
              call stdlib_${ri}$laset( 'F', n-m, nrhs, zero, zero, b( m+1, 1 ), ldb )
              nwork = itau + m
              ! multiply transpose(q) by b.
              ! (workspace: need m+nrhs, prefer m+nrhs*nb)
              call stdlib_${ri}$ormlq( 'L', 'T', n, nrhs, m, a, lda, work( itau ), b,ldb, work( nwork )&
                        , lwork-nwork+1, info )
           else
              ! path 2 - remaining underdetermined cases.
              ie = 1
              itauq = ie + m
              itaup = itauq + m
              nwork = itaup + m
              ! bidiagonalize a.
              ! (workspace: need 3*m+n, prefer 3*m+(m+n)*nb)
              call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), work( &
                        nwork ), lwork-nwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors.
              ! (workspace: need 3*m+nrhs, prefer 3*m+nrhs*nb)
              call stdlib_${ri}$ormbr( 'Q', 'L', 'T', m, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
              ! solve the bidiagonal least squares problem.
              call stdlib_${ri}$lalsd( 'L', smlsiz, m, nrhs, s, work( ie ), b, ldb,rcond, rank, work( &
                        nwork ), iwork, info )
              if( info/=0 ) then
                 go to 10
              end if
              ! multiply b by right bidiagonalizing vectors of a.
              call stdlib_${ri}$ormbr( 'P', 'L', 'N', n, nrhs, m, a, lda, work( itaup ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
           end if
           ! undo scaling.
           if( iascl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, n, nrhs, b, ldb, info )
              call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,info )
           else if( iascl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, n, nrhs, b, ldb, info )
              call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,info )
           end if
           if( ibscl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, bnrm, n, nrhs, b, ldb, info )
           else if( ibscl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bignum, bnrm, n, nrhs, b, ldb, info )
           end if
           10 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwork
           return
     end subroutine stdlib_${ri}$gelsd


     subroutine stdlib_${ri}$gelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )
     !! DGELSS: computes the minimum norm solution to a real linear least
     !! squares problem:
     !! Minimize 2-norm(| b - A*x |).
     !! using the singular value decomposition (SVD) of A. A is an M-by-N
     !! matrix which may be rank-deficient.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
     !! X.
     !! The effective rank of A is determined by treating as zero those
     !! singular values which are less than RCOND times the largest singular
     !! value.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(in) :: rcond
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: s(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: bdspac, bl, chunk, i, iascl, ibscl, ie, il, itau, itaup, itauq, iwork, &
                     ldwork, maxmn, maxwrk, minmn, minwrk, mm, mnthr
           integer(ilp) :: lwork_qgeqrf, lwork_qormqr, lwork_qgebrd, lwork_qormbr, lwork_qorgbr, &
                     lwork_qormlq, lwork_qgelqf
           real(${rk}$) :: anrm, bignum, bnrm, eps, sfmin, smlnum, thr
           ! Local Arrays 
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           maxmn = max( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, maxmn ) ) then
              info = -7
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( minmn>0 ) then
                 mm = m
                 mnthr = stdlib_ilaenv( 6, 'DGELSS', ' ', m, n, nrhs, -1 )
                 if( m>=n .and. m>=mnthr ) then
                    ! path 1a - overdetermined, with many more rows than
                              ! columns
                    ! compute space needed for stdlib_${ri}$geqrf
                    call stdlib_${ri}$geqrf( m, n, a, lda, dum(1), dum(1), -1, info )
                    lwork_qgeqrf=dum(1)
                    ! compute space needed for stdlib_${ri}$ormqr
                    call stdlib_${ri}$ormqr( 'L', 'T', m, nrhs, n, a, lda, dum(1), b,ldb, dum(1), -1, &
                              info )
                    lwork_qormqr=dum(1)
                    mm = n
                    maxwrk = max( maxwrk, n + lwork_qgeqrf )
                    maxwrk = max( maxwrk, n + lwork_qormqr )
                 end if
                 if( m>=n ) then
                    ! path 1 - overdetermined or exactly determined
                    ! compute workspace needed for stdlib_${ri}$bdsqr
                    bdspac = max( 1, 5*n )
                    ! compute space needed for stdlib_${ri}$gebrd
                    call stdlib_${ri}$gebrd( mm, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, info &
                              )
                    lwork_qgebrd=dum(1)
                    ! compute space needed for stdlib_${ri}$ormbr
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'T', mm, nrhs, n, a, lda, dum(1),b, ldb, dum(1),&
                               -1, info )
                    lwork_qormbr=dum(1)
                    ! compute space needed for stdlib_${ri}$orgbr
                    call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, dum(1),dum(1), -1, info )
                    lwork_qorgbr=dum(1)
                    ! compute total workspace needed
                    maxwrk = max( maxwrk, 3*n + lwork_qgebrd )
                    maxwrk = max( maxwrk, 3*n + lwork_qormbr )
                    maxwrk = max( maxwrk, 3*n + lwork_qorgbr )
                    maxwrk = max( maxwrk, bdspac )
                    maxwrk = max( maxwrk, n*nrhs )
                    minwrk = max( 3*n + mm, 3*n + nrhs, bdspac )
                    maxwrk = max( minwrk, maxwrk )
                 end if
                 if( n>m ) then
                    ! compute workspace needed for stdlib_${ri}$bdsqr
                    bdspac = max( 1, 5*m )
                    minwrk = max( 3*m+nrhs, 3*m+n, bdspac )
                    if( n>=mnthr ) then
                       ! path 2a - underdetermined, with many more columns
                       ! than rows
                       ! compute space needed for stdlib_${ri}$gelqf
                       call stdlib_${ri}$gelqf( m, n, a, lda, dum(1), dum(1),-1, info )
                       lwork_qgelqf=dum(1)
                       ! compute space needed for stdlib_${ri}$gebrd
                       call stdlib_${ri}$gebrd( m, m, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, &
                                 info )
                       lwork_qgebrd=dum(1)
                       ! compute space needed for stdlib_${ri}$ormbr
                       call stdlib_${ri}$ormbr( 'Q', 'L', 'T', m, nrhs, n, a, lda,dum(1), b, ldb, dum(&
                                 1), -1, info )
                       lwork_qormbr=dum(1)
                       ! compute space needed for stdlib_${ri}$orgbr
                       call stdlib_${ri}$orgbr( 'P', m, m, m, a, lda, dum(1),dum(1), -1, info )
                       lwork_qorgbr=dum(1)
                       ! compute space needed for stdlib_${ri}$ormlq
                       call stdlib_${ri}$ormlq( 'L', 'T', n, nrhs, m, a, lda, dum(1),b, ldb, dum(1), -&
                                 1, info )
                       lwork_qormlq=dum(1)
                       ! compute total workspace needed
                       maxwrk = m + lwork_qgelqf
                       maxwrk = max( maxwrk, m*m + 4*m + lwork_qgebrd )
                       maxwrk = max( maxwrk, m*m + 4*m + lwork_qormbr )
                       maxwrk = max( maxwrk, m*m + 4*m + lwork_qorgbr )
                       maxwrk = max( maxwrk, m*m + m + bdspac )
                       if( nrhs>1 ) then
                          maxwrk = max( maxwrk, m*m + m + m*nrhs )
                       else
                          maxwrk = max( maxwrk, m*m + 2*m )
                       end if
                       maxwrk = max( maxwrk, m + lwork_qormlq )
                    else
                       ! path 2 - underdetermined
                       ! compute space needed for stdlib_${ri}$gebrd
                       call stdlib_${ri}$gebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, &
                                 info )
                       lwork_qgebrd=dum(1)
                       ! compute space needed for stdlib_${ri}$ormbr
                       call stdlib_${ri}$ormbr( 'Q', 'L', 'T', m, nrhs, m, a, lda,dum(1), b, ldb, dum(&
                                 1), -1, info )
                       lwork_qormbr=dum(1)
                       ! compute space needed for stdlib_${ri}$orgbr
                       call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, dum(1),dum(1), -1, info )
                       lwork_qorgbr=dum(1)
                       maxwrk = 3*m + lwork_qgebrd
                       maxwrk = max( maxwrk, 3*m + lwork_qormbr )
                       maxwrk = max( maxwrk, 3*m + lwork_qorgbr )
                       maxwrk = max( maxwrk, bdspac )
                       maxwrk = max( maxwrk, n*nrhs )
                    end if
                 end if
                 maxwrk = max( minwrk, maxwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELSS', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              rank = 0
              return
           end if
           ! get machine parameters
           eps = stdlib_${ri}$lamch( 'P' )
           sfmin = stdlib_${ri}$lamch( 'S' )
           smlnum = sfmin / eps
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, work )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_${ri}$laset( 'F', max( m, n ), nrhs, zero, zero, b, ldb )
              call stdlib_${ri}$laset( 'F', minmn, 1, zero, zero, s, minmn )
              rank = 0
              go to 70
           end if
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', m, nrhs, b, ldb, work )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, smlnum, m, nrhs, b, ldb, info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bignum, m, nrhs, b, ldb, info )
              ibscl = 2
           end if
           ! overdetermined case
           if( m>=n ) then
              ! path 1 - overdetermined or exactly determined
              mm = m
              if( m>=mnthr ) then
                 ! path 1a - overdetermined, with many more rows than columns
                 mm = n
                 itau = 1
                 iwork = itau + n
                 ! compute a=q*r
                 ! (workspace: need 2*n, prefer n+n*nb)
                 call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                           info )
                 ! multiply b by transpose(q)
                 ! (workspace: need n+nrhs, prefer n+nrhs*nb)
                 call stdlib_${ri}$ormqr( 'L', 'T', m, nrhs, n, a, lda, work( itau ), b,ldb, work( &
                           iwork ), lwork-iwork+1, info )
                 ! zero out below r
                 if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
              end if
              ie = 1
              itauq = ie + n
              itaup = itauq + n
              iwork = itaup + n
              ! bidiagonalize r in a
              ! (workspace: need 3*n+mm, prefer 3*n+(mm+n)*nb)
              call stdlib_${ri}$gebrd( mm, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), work(&
                         iwork ), lwork-iwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors of r
              ! (workspace: need 3*n+nrhs, prefer 3*n+nrhs*nb)
              call stdlib_${ri}$ormbr( 'Q', 'L', 'T', mm, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        iwork ), lwork-iwork+1, info )
              ! generate right bidiagonalizing vectors of r in a
              ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
              call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-iwork+&
                        1, info )
              iwork = ie + n
              ! perform bidiagonal qr iteration
                ! multiply b by transpose of left singular vectors
                ! compute right singular vectors in a
              ! (workspace: need bdspac)
              call stdlib_${ri}$bdsqr( 'U', n, n, 0, nrhs, s, work( ie ), a, lda, dum,1, b, ldb, work( &
                        iwork ), info )
              if( info/=0 )go to 70
              ! multiply b by reciprocals of singular values
              thr = max( rcond*s( 1 ), sfmin )
              if( rcond<zero )thr = max( eps*s( 1 ), sfmin )
              rank = 0
              do i = 1, n
                 if( s( i )>thr ) then
                    call stdlib_${ri}$rscl( nrhs, s( i ), b( i, 1 ), ldb )
                    rank = rank + 1
                 else
                    call stdlib_${ri}$laset( 'F', 1, nrhs, zero, zero, b( i, 1 ), ldb )
                 end if
              end do
              ! multiply b by right singular vectors
              ! (workspace: need n, prefer n*nrhs)
              if( lwork>=ldb*nrhs .and. nrhs>1 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', n, nrhs, n, one, a, lda, b, ldb, zero,work, ldb )
                           
                 call stdlib_${ri}$lacpy( 'G', n, nrhs, work, ldb, b, ldb )
              else if( nrhs>1 ) then
                 chunk = lwork / n
                 do i = 1, nrhs, chunk
                    bl = min( nrhs-i+1, chunk )
                    call stdlib_${ri}$gemm( 'T', 'N', n, bl, n, one, a, lda, b( 1, i ),ldb, zero, work,&
                               n )
                    call stdlib_${ri}$lacpy( 'G', n, bl, work, n, b( 1, i ), ldb )
                 end do
              else
                 call stdlib_${ri}$gemv( 'T', n, n, one, a, lda, b, 1, zero, work, 1 )
                 call stdlib_${ri}$copy( n, work, 1, b, 1 )
              end if
           else if( n>=mnthr .and. lwork>=4*m+m*m+max( m, 2*m-4, nrhs, n-3*m ) ) then
              ! path 2a - underdetermined, with many more columns than rows
              ! and sufficient workspace for an efficient algorithm
              ldwork = m
              if( lwork>=max( 4*m+m*lda+max( m, 2*m-4, nrhs, n-3*m ),m*lda+m+m*nrhs ) )ldwork = &
                        lda
              itau = 1
              iwork = m + 1
              ! compute a=l*q
              ! (workspace: need 2*m, prefer m+m*nb)
              call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, info )
                        
              il = iwork
              ! copy l to work(il), zeroing out above it
              call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( il ), ldwork )
              call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, work( il+ldwork ),ldwork )
              ie = il + ldwork*m
              itauq = ie + m
              itaup = itauq + m
              iwork = itaup + m
              ! bidiagonalize l in work(il)
              ! (workspace: need m*m+5*m, prefer m*m+4*m+2*m*nb)
              call stdlib_${ri}$gebrd( m, m, work( il ), ldwork, s, work( ie ),work( itauq ), work( &
                        itaup ), work( iwork ),lwork-iwork+1, info )
              ! multiply b by transpose of left bidiagonalizing vectors of l
              ! (workspace: need m*m+4*m+nrhs, prefer m*m+4*m+nrhs*nb)
              call stdlib_${ri}$ormbr( 'Q', 'L', 'T', m, nrhs, m, work( il ), ldwork,work( itauq ), b, &
                        ldb, work( iwork ),lwork-iwork+1, info )
              ! generate right bidiagonalizing vectors of r in work(il)
              ! (workspace: need m*m+5*m-1, prefer m*m+4*m+(m-1)*nb)
              call stdlib_${ri}$orgbr( 'P', m, m, m, work( il ), ldwork, work( itaup ),work( iwork ), &
                        lwork-iwork+1, info )
              iwork = ie + m
              ! perform bidiagonal qr iteration,
                 ! computing right singular vectors of l in work(il) and
                 ! multiplying b by transpose of left singular vectors
              ! (workspace: need m*m+m+bdspac)
              call stdlib_${ri}$bdsqr( 'U', m, m, 0, nrhs, s, work( ie ), work( il ),ldwork, a, lda, b,&
                         ldb, work( iwork ), info )
              if( info/=0 )go to 70
              ! multiply b by reciprocals of singular values
              thr = max( rcond*s( 1 ), sfmin )
              if( rcond<zero )thr = max( eps*s( 1 ), sfmin )
              rank = 0
              do i = 1, m
                 if( s( i )>thr ) then
                    call stdlib_${ri}$rscl( nrhs, s( i ), b( i, 1 ), ldb )
                    rank = rank + 1
                 else
                    call stdlib_${ri}$laset( 'F', 1, nrhs, zero, zero, b( i, 1 ), ldb )
                 end if
              end do
              iwork = ie
              ! multiply b by right singular vectors of l in work(il)
              ! (workspace: need m*m+2*m, prefer m*m+m+m*nrhs)
              if( lwork>=ldb*nrhs+iwork-1 .and. nrhs>1 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', m, nrhs, m, one, work( il ), ldwork,b, ldb, zero, &
                           work( iwork ), ldb )
                 call stdlib_${ri}$lacpy( 'G', m, nrhs, work( iwork ), ldb, b, ldb )
              else if( nrhs>1 ) then
                 chunk = ( lwork-iwork+1 ) / m
                 do i = 1, nrhs, chunk
                    bl = min( nrhs-i+1, chunk )
                    call stdlib_${ri}$gemm( 'T', 'N', m, bl, m, one, work( il ), ldwork,b( 1, i ), ldb,&
                               zero, work( iwork ), m )
                    call stdlib_${ri}$lacpy( 'G', m, bl, work( iwork ), m, b( 1, i ),ldb )
                 end do
              else
                 call stdlib_${ri}$gemv( 'T', m, m, one, work( il ), ldwork, b( 1, 1 ),1, zero, work( &
                           iwork ), 1 )
                 call stdlib_${ri}$copy( m, work( iwork ), 1, b( 1, 1 ), 1 )
              end if
              ! zero out below first m rows of b
              call stdlib_${ri}$laset( 'F', n-m, nrhs, zero, zero, b( m+1, 1 ), ldb )
              iwork = itau + m
              ! multiply transpose(q) by b
              ! (workspace: need m+nrhs, prefer m+nrhs*nb)
              call stdlib_${ri}$ormlq( 'L', 'T', n, nrhs, m, a, lda, work( itau ), b,ldb, work( iwork )&
                        , lwork-iwork+1, info )
           else
              ! path 2 - remaining underdetermined cases
              ie = 1
              itauq = ie + m
              itaup = itauq + m
              iwork = itaup + m
              ! bidiagonalize a
              ! (workspace: need 3*m+n, prefer 3*m+(m+n)*nb)
              call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), work( &
                        iwork ), lwork-iwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors
              ! (workspace: need 3*m+nrhs, prefer 3*m+nrhs*nb)
              call stdlib_${ri}$ormbr( 'Q', 'L', 'T', m, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        iwork ), lwork-iwork+1, info )
              ! generate right bidiagonalizing vectors in a
              ! (workspace: need 4*m, prefer 3*m+m*nb)
              call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-iwork+&
                        1, info )
              iwork = ie + m
              ! perform bidiagonal qr iteration,
                 ! computing right singular vectors of a in a and
                 ! multiplying b by transpose of left singular vectors
              ! (workspace: need bdspac)
              call stdlib_${ri}$bdsqr( 'L', m, n, 0, nrhs, s, work( ie ), a, lda, dum,1, b, ldb, work( &
                        iwork ), info )
              if( info/=0 )go to 70
              ! multiply b by reciprocals of singular values
              thr = max( rcond*s( 1 ), sfmin )
              if( rcond<zero )thr = max( eps*s( 1 ), sfmin )
              rank = 0
              do i = 1, m
                 if( s( i )>thr ) then
                    call stdlib_${ri}$rscl( nrhs, s( i ), b( i, 1 ), ldb )
                    rank = rank + 1
                 else
                    call stdlib_${ri}$laset( 'F', 1, nrhs, zero, zero, b( i, 1 ), ldb )
                 end if
              end do
              ! multiply b by right singular vectors of a
              ! (workspace: need n, prefer n*nrhs)
              if( lwork>=ldb*nrhs .and. nrhs>1 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', n, nrhs, m, one, a, lda, b, ldb, zero,work, ldb )
                           
                 call stdlib_${ri}$lacpy( 'F', n, nrhs, work, ldb, b, ldb )
              else if( nrhs>1 ) then
                 chunk = lwork / n
                 do i = 1, nrhs, chunk
                    bl = min( nrhs-i+1, chunk )
                    call stdlib_${ri}$gemm( 'T', 'N', n, bl, m, one, a, lda, b( 1, i ),ldb, zero, work,&
                               n )
                    call stdlib_${ri}$lacpy( 'F', n, bl, work, n, b( 1, i ), ldb )
                 end do
              else
                 call stdlib_${ri}$gemv( 'T', m, n, one, a, lda, b, 1, zero, work, 1 )
                 call stdlib_${ri}$copy( n, work, 1, b, 1 )
              end if
           end if
           ! undo scaling
           if( iascl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, n, nrhs, b, ldb, info )
              call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,info )
           else if( iascl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, n, nrhs, b, ldb, info )
              call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,info )
           end if
           if( ibscl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, bnrm, n, nrhs, b, ldb, info )
           else if( ibscl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bignum, bnrm, n, nrhs, b, ldb, info )
           end if
           70 continue
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gelss


     subroutine stdlib_${ri}$gelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info )
     !! DGELSY: computes the minimum-norm solution to a real linear least
     !! squares problem:
     !! minimize || A * X - B ||
     !! using a complete orthogonal factorization of A.  A is an M-by-N
     !! matrix which may be rank-deficient.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
     !! The routine first computes a QR factorization with column pivoting:
     !! A * P = Q * [ R11 R12 ]
     !! [  0  R22 ]
     !! with R11 defined as the largest leading submatrix whose estimated
     !! condition number is less than 1/RCOND.  The order of R11, RANK,
     !! is the effective rank of A.
     !! Then, R22 is considered to be negligible, and R12 is annihilated
     !! by orthogonal transformations from the right, arriving at the
     !! complete orthogonal factorization:
     !! A * P = Q * [ T11 0 ] * Z
     !! [  0  0 ]
     !! The minimum-norm solution is then
     !! X = P * Z**T [ inv(T11)*Q1**T*B ]
     !! [        0         ]
     !! where Q1 consists of the first RANK columns of Q.
     !! This routine is basically identical to the original xGELSX except
     !! three differences:
     !! o The call to the subroutine xGEQPF has been substituted by the
     !! the call to the subroutine xGEQP3. This subroutine is a Blas-3
     !! version of the QR factorization with column pivoting.
     !! o Matrix B (the right hand side) is updated with Blas-3.
     !! o The permutation of matrix B (the right hand side) is faster and
     !! more simple.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(in) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: imax = 1
           integer(ilp), parameter :: imin = 2
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iascl, ibscl, ismax, ismin, j, lwkmin, lwkopt, mn, nb, nb1, nb2, &
                     nb3, nb4
           real(${rk}$) :: anrm, bignum, bnrm, c1, c2, s1, s2, smax, smaxpr, smin, sminpr, smlnum, &
                     wsize
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           mn = min( m, n )
           ismin = mn + 1
           ismax = 2*mn + 1
           ! test the input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, m, n ) ) then
              info = -7
           end if
           ! figure out optimal block size
           if( info==0 ) then
              if( mn==0 .or. nrhs==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', m, n, nrhs, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', m, n, nrhs, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = mn + max( 2*mn, n + 1, mn + nrhs )
                 lwkopt = max( lwkmin,mn + 2*n + nb*( n + 1 ), 2*mn + nb*nrhs )
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGELSY', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( mn==0 .or. nrhs==0 ) then
              rank = 0
              return
           end if
           ! get machine parameters
           smlnum = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'P' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! scale a, b if max entries outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, work )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_${ri}$laset( 'F', max( m, n ), nrhs, zero, zero, b, ldb )
              rank = 0
              go to 70
           end if
           bnrm = stdlib_${ri}$lange( 'M', m, nrhs, b, ldb, work )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, smlnum, m, nrhs, b, ldb, info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bignum, m, nrhs, b, ldb, info )
              ibscl = 2
           end if
           ! compute qr factorization with column pivoting of a:
              ! a * p = q * r
           call stdlib_${ri}$geqp3( m, n, a, lda, jpvt, work( 1 ), work( mn+1 ),lwork-mn, info )
                     
           wsize = mn + work( mn+1 )
           ! workspace: mn+2*n+nb*(n+1).
           ! details of householder rotations stored in work(1:mn).
           ! determine rank using incremental condition estimation
           work( ismin ) = one
           work( ismax ) = one
           smax = abs( a( 1, 1 ) )
           smin = smax
           if( abs( a( 1, 1 ) )==zero ) then
              rank = 0
              call stdlib_${ri}$laset( 'F', max( m, n ), nrhs, zero, zero, b, ldb )
              go to 70
           else
              rank = 1
           end if
           10 continue
           if( rank<mn ) then
              i = rank + 1
              call stdlib_${ri}$laic1( imin, rank, work( ismin ), smin, a( 1, i ),a( i, i ), sminpr, &
                        s1, c1 )
              call stdlib_${ri}$laic1( imax, rank, work( ismax ), smax, a( 1, i ),a( i, i ), smaxpr, &
                        s2, c2 )
              if( smaxpr*rcond<=sminpr ) then
                 do i = 1, rank
                    work( ismin+i-1 ) = s1*work( ismin+i-1 )
                    work( ismax+i-1 ) = s2*work( ismax+i-1 )
                 end do
                 work( ismin+rank ) = c1
                 work( ismax+rank ) = c2
                 smin = sminpr
                 smax = smaxpr
                 rank = rank + 1
                 go to 10
              end if
           end if
           ! workspace: 3*mn.
           ! logically partition r = [ r11 r12 ]
                                   ! [  0  r22 ]
           ! where r11 = r(1:rank,1:rank)
           ! [r11,r12] = [ t11, 0 ] * y
           if( rank<n )call stdlib_${ri}$tzrzf( rank, n, a, lda, work( mn+1 ), work( 2*mn+1 ),lwork-&
                     2*mn, info )
           ! workspace: 2*mn.
           ! details of householder rotations stored in work(mn+1:2*mn)
           ! b(1:m,1:nrhs) := q**t * b(1:m,1:nrhs)
           call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', m, nrhs, mn, a, lda, work( 1 ),b, ldb, work( &
                     2*mn+1 ), lwork-2*mn, info )
           wsize = max( wsize, 2*mn+work( 2*mn+1 ) )
           ! workspace: 2*mn+nb*nrhs.
           ! b(1:rank,1:nrhs) := inv(t11) * b(1:rank,1:nrhs)
           call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', rank,nrhs, one, a, lda,&
                      b, ldb )
           do j = 1, nrhs
              do i = rank + 1, n
                 b( i, j ) = zero
              end do
           end do
           ! b(1:n,1:nrhs) := y**t * b(1:n,1:nrhs)
           if( rank<n ) then
              call stdlib_${ri}$ormrz( 'LEFT', 'TRANSPOSE', n, nrhs, rank, n-rank, a,lda, work( mn+1 ),&
                         b, ldb, work( 2*mn+1 ),lwork-2*mn, info )
           end if
           ! workspace: 2*mn+nrhs.
           ! b(1:n,1:nrhs) := p * b(1:n,1:nrhs)
           do j = 1, nrhs
              do i = 1, n
                 work( jpvt( i ) ) = b( i, j )
              end do
              call stdlib_${ri}$copy( n, work( 1 ), 1, b( 1, j ), 1 )
           end do
           ! workspace: n.
           ! undo scaling
           if( iascl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, n, nrhs, b, ldb, info )
              call stdlib_${ri}$lascl( 'U', 0, 0, smlnum, anrm, rank, rank, a, lda,info )
           else if( iascl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, n, nrhs, b, ldb, info )
              call stdlib_${ri}$lascl( 'U', 0, 0, bignum, anrm, rank, rank, a, lda,info )
           end if
           if( ibscl==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, bnrm, n, nrhs, b, ldb, info )
           else if( ibscl==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bignum, bnrm, n, nrhs, b, ldb, info )
           end if
           70 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$gelsy


     pure subroutine stdlib_${ri}$gemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork, &
     !! DGEMLQ: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product
     !! of blocked elementary reflectors computed by short wide LQ
     !! factorization (DGELQ)
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, tsize, lwork, ldc
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), t(*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: mb, nb, lw, nblcks, mn
           ! Intrinsic Functions 
           intrinsic :: int,max,min,mod
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork==-1
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'T' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           mb = int( t( 2 ),KIND=ilp)
           nb = int( t( 3 ),KIND=ilp)
           if( left ) then
             lw = n * mb
             mn = m
           else
             lw = m * mb
             mn = n
           end if
           if( ( nb>k ) .and. ( mn>k ) ) then
             if( mod( mn - k, nb - k ) == 0 ) then
               nblcks = ( mn - k ) / ( nb - k )
             else
               nblcks = ( mn - k ) / ( nb - k ) + 1
             end if
           else
             nblcks = 1
           end if
           info = 0
           if( .not.left .and. .not.right ) then
             info = -1
           else if( .not.tran .and. .not.notran ) then
             info = -2
           else if( m<0 ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<0 .or. k>mn ) then
             info = -5
           else if( lda<max( 1, k ) ) then
             info = -7
           else if( tsize<5 ) then
             info = -9
           else if( ldc<max( 1, m ) ) then
             info = -11
           else if( ( lwork<max( 1, lw ) ) .and. ( .not.lquery ) ) then
             info = -13
           end if
           if( info==0 ) then
             work( 1 ) = lw
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DGEMLQ', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n, k )==0 ) then
             return
           end if
           if( ( left .and. m<=k ) .or. ( right .and. n<=k ).or. ( nb<=k ) .or. ( nb>=max( m, n, &
                     k ) ) ) then
             call stdlib_${ri}$gemlqt( side, trans, m, n, k, mb, a, lda,t( 6 ), mb, c, ldc, work, info &
                       )
           else
             call stdlib_${ri}$lamswlq( side, trans, m, n, k, mb, nb, a, lda, t( 6 ),mb, c, ldc, work, &
                       lwork, info )
           end if
           work( 1 ) = lw
           return
     end subroutine stdlib_${ri}$gemlq


     pure subroutine stdlib_${ri}$gemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, info )
     !! DGEMLQT: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q C            C Q
     !! TRANS = 'T':   Q**T C            C Q**T
     !! where Q is a real orthogonal matrix defined as the product of K
     !! elementary reflectors:
     !! Q = H(1) H(2) . . . H(K) = I - V T V**T
     !! generated using the compact WY representation as returned by DGELQT.
     !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, ldc, m, n, mb, ldt
           ! Array Arguments 
           real(${rk}$), intent(in) :: v(ldv,*), t(ldt,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, ldwork, kf, q
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'T' )
           notran = stdlib_lsame( trans, 'N' )
           if( left ) then
              ldwork = max( 1, n )
              q = m
           else if ( right ) then
              ldwork = max( 1, m )
              q = n
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>q ) then
              info = -5
           else if( mb<1 .or. (mb>k .and. k>0)) then
              info = -6
           else if( ldv<max( 1, k ) ) then
               info = -8
           else if( ldt<mb ) then
              info = -10
           else if( ldc<max( 1, m ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEMLQT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. notran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 call stdlib_${ri}$larfb( 'L', 'T', 'F', 'R', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. tran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 call stdlib_${ri}$larfb( 'R', 'N', 'F', 'R', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           else if( left .and. tran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 call stdlib_${ri}$larfb( 'L', 'N', 'F', 'R', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. notran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 call stdlib_${ri}$larfb( 'R', 'T', 'F', 'R', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           end if
           return
     end subroutine stdlib_${ri}$gemlqt


     pure subroutine stdlib_${ri}$gemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork, &
     !! DGEMQR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product
     !! of blocked elementary reflectors computed by tall skinny
     !! QR factorization (DGEQR)
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, tsize, lwork, ldc
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), t(*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: mb, nb, lw, nblcks, mn
           ! Intrinsic Functions 
           intrinsic :: int,max,min,mod
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork==-1
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'T' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           mb = int( t( 2 ),KIND=ilp)
           nb = int( t( 3 ),KIND=ilp)
           if( left ) then
             lw = n * nb
             mn = m
           else
             lw = mb * nb
             mn = n
           end if
           if( ( mb>k ) .and. ( mn>k ) ) then
             if( mod( mn - k, mb - k )==0 ) then
               nblcks = ( mn - k ) / ( mb - k )
             else
               nblcks = ( mn - k ) / ( mb - k ) + 1
             end if
           else
             nblcks = 1
           end if
           info = 0
           if( .not.left .and. .not.right ) then
             info = -1
           else if( .not.tran .and. .not.notran ) then
             info = -2
           else if( m<0 ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<0 .or. k>mn ) then
             info = -5
           else if( lda<max( 1, mn ) ) then
             info = -7
           else if( tsize<5 ) then
             info = -9
           else if( ldc<max( 1, m ) ) then
             info = -11
           else if( ( lwork<max( 1, lw ) ) .and. ( .not.lquery ) ) then
             info = -13
           end if
           if( info==0 ) then
             work( 1 ) = lw
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DGEMQR', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n, k )==0 ) then
             return
           end if
           if( ( left .and. m<=k ) .or. ( right .and. n<=k ).or. ( mb<=k ) .or. ( mb>=max( m, n, &
                     k ) ) ) then
             call stdlib_${ri}$gemqrt( side, trans, m, n, k, nb, a, lda, t( 6 ),nb, c, ldc, work, info &
                       )
           else
             call stdlib_${ri}$lamtsqr( side, trans, m, n, k, mb, nb, a, lda, t( 6 ),nb, c, ldc, work, &
                       lwork, info )
           end if
           work( 1 ) = lw
           return
     end subroutine stdlib_${ri}$gemqr


     pure subroutine stdlib_${ri}$gemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, info )
     !! DGEMQRT: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q C            C Q
     !! TRANS = 'T':   Q**T C            C Q**T
     !! where Q is a real orthogonal matrix defined as the product of K
     !! elementary reflectors:
     !! Q = H(1) H(2) . . . H(K) = I - V T V**T
     !! generated using the compact WY representation as returned by DGEQRT.
     !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, ldc, m, n, nb, ldt
           ! Array Arguments 
           real(${rk}$), intent(in) :: v(ldv,*), t(ldt,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, ldwork, kf, q
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'T' )
           notran = stdlib_lsame( trans, 'N' )
           if( left ) then
              ldwork = max( 1, n )
              q = m
           else if ( right ) then
              ldwork = max( 1, m )
              q = n
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>q ) then
              info = -5
           else if( nb<1 .or. (nb>k .and. k>0)) then
              info = -6
           else if( ldv<max( 1, q ) ) then
              info = -8
           else if( ldt<nb ) then
              info = -10
           else if( ldc<max( 1, m ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEMQRT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. tran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 call stdlib_${ri}$larfb( 'L', 'T', 'F', 'C', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. notran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 call stdlib_${ri}$larfb( 'R', 'N', 'F', 'C', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           else if( left .and. notran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 call stdlib_${ri}$larfb( 'L', 'N', 'F', 'C', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. tran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 call stdlib_${ri}$larfb( 'R', 'T', 'F', 'C', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           end if
           return
     end subroutine stdlib_${ri}$gemqrt


     pure subroutine stdlib_${ri}$geql2( m, n, a, lda, tau, work, info )
     !! DGEQL2: computes a QL factorization of a real m by n matrix A:
     !! A = Q * L.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQL2', -info )
              return
           end if
           k = min( m, n )
           do i = k, 1, -1
              ! generate elementary reflector h(i) to annihilate
              ! a(1:m-k+i-1,n-k+i)
              call stdlib_${ri}$larfg( m-k+i, a( m-k+i, n-k+i ), a( 1, n-k+i ), 1,tau( i ) )
              ! apply h(i) to a(1:m-k+i,1:n-k+i-1) from the left
              aii = a( m-k+i, n-k+i )
              a( m-k+i, n-k+i ) = one
              call stdlib_${ri}$larf( 'LEFT', m-k+i, n-k+i-1, a( 1, n-k+i ), 1, tau( i ),a, lda, work )
                        
              a( m-k+i, n-k+i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$geql2


     pure subroutine stdlib_${ri}$geqlf( m, n, a, lda, tau, work, lwork, info )
     !! DGEQLF: computes a QL factorization of a real M-by-N matrix A:
     !! A = Q * L.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt, mu, nb, nbmin, nu, &
                     nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              k = min( m, n )
              if( k==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'DGEQLF', ' ', m, n, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<max( 1, n ) .and. .not.lquery ) then
                 info = -7
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQLF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( k==0 ) then
              return
           end if
           nbmin = 2
           nx = 1
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DGEQLF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEQLF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially.
              ! the last kk columns are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              do i = k - kk + ki + 1, k - kk + 1, -nb
                 ib = min( k-i+1, nb )
                 ! compute the ql factorization of the current block
                 ! a(1:m-k+i+ib-1,n-k+i:n-k+i+ib-1)
                 call stdlib_${ri}$geql2( m-k+i+ib-1, ib, a( 1, n-k+i ), lda, tau( i ),work, iinfo )
                           
                 if( n-k+i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_${ri}$larft( 'BACKWARD', 'COLUMNWISE', m-k+i+ib-1, ib,a( 1, n-k+i ), &
                              lda, tau( i ), work, ldwork )
                    ! apply h**t to a(1:m-k+i+ib-1,1:n-k+i-1) from the left
                    call stdlib_${ri}$larfb( 'LEFT', 'TRANSPOSE', 'BACKWARD','COLUMNWISE', m-k+i+ib-1, &
                    n-k+i-1, ib,a( 1, n-k+i ), lda, work, ldwork, a, lda,work( ib+1 ), ldwork )
                              
                 end if
              end do
              mu = m - k + i + nb - 1
              nu = n - k + i + nb - 1
           else
              mu = m
              nu = n
           end if
           ! use unblocked code to factor the last or only block
           if( mu>0 .and. nu>0 )call stdlib_${ri}$geql2( mu, nu, a, lda, tau, work, iinfo )
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$geqlf


     pure subroutine stdlib_${ri}$geqp3( m, n, a, lda, jpvt, tau, work, lwork, info )
     !! DGEQP3: computes a QR factorization with column pivoting of a
     !! matrix A:  A*P = Q*R  using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: inb = 1
           integer(ilp), parameter :: inbmin = 2
           integer(ilp), parameter :: ixover = 3
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: fjb, iws, j, jb, lwkopt, minmn, minws, na, nb, nbmin, nfxd, nx, sm, &
                     sminmn, sn, topbmn
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test input arguments
        ! ====================
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              minmn = min( m, n )
              if( minmn==0 ) then
                 iws = 1
                 lwkopt = 1
              else
                 iws = 3*n + 1
                 nb = stdlib_ilaenv( inb, 'DGEQRF', ' ', m, n, -1, -1 )
                 lwkopt = 2*n + ( n + 1 )*nb
              end if
              work( 1 ) = lwkopt
              if( ( lwork<iws ) .and. .not.lquery ) then
                 info = -8
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQP3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! move initial columns up front.
           nfxd = 1
           do j = 1, n
              if( jpvt( j )/=0 ) then
                 if( j/=nfxd ) then
                    call stdlib_${ri}$swap( m, a( 1, j ), 1, a( 1, nfxd ), 1 )
                    jpvt( j ) = jpvt( nfxd )
                    jpvt( nfxd ) = j
                 else
                    jpvt( j ) = j
                 end if
                 nfxd = nfxd + 1
              else
                 jpvt( j ) = j
              end if
           end do
           nfxd = nfxd - 1
           ! factorize fixed columns
        ! =======================
           ! compute the qr factorization of fixed columns and update
           ! remaining columns.
           if( nfxd>0 ) then
              na = min( m, nfxd )
      ! cc      call stdlib_${ri}$geqr2( m, na, a, lda, tau, work, info )
              call stdlib_${ri}$geqrf( m, na, a, lda, tau, work, lwork, info )
              iws = max( iws, int( work( 1 ),KIND=ilp) )
              if( na<n ) then
      ! cc         call stdlib_${ri}$orm2r( 'left', 'transpose', m, n-na, na, a, lda,
      ! cc  $                   tau, a( 1, na+1 ), lda, work, info )
                 call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', m, n-na, na, a, lda, tau,a( 1, na+1 ), &
                           lda, work, lwork, info )
                 iws = max( iws, int( work( 1 ),KIND=ilp) )
              end if
           end if
           ! factorize free columns
        ! ======================
           if( nfxd<minmn ) then
              sm = m - nfxd
              sn = n - nfxd
              sminmn = minmn - nfxd
              ! determine the block size.
              nb = stdlib_ilaenv( inb, 'DGEQRF', ' ', sm, sn, -1, -1 )
              nbmin = 2
              nx = 0
              if( ( nb>1 ) .and. ( nb<sminmn ) ) then
                 ! determine when to cross over from blocked to unblocked code.
                 nx = max( 0, stdlib_ilaenv( ixover, 'DGEQRF', ' ', sm, sn, -1,-1 ) )
                 if( nx<sminmn ) then
                    ! determine if workspace is large enough for blocked code.
                    minws = 2*sn + ( sn+1 )*nb
                    iws = max( iws, minws )
                    if( lwork<minws ) then
                       ! not enough workspace to use optimal nb: reduce nb and
                       ! determine the minimum value of nb.
                       nb = ( lwork-2*sn ) / ( sn+1 )
                       nbmin = max( 2, stdlib_ilaenv( inbmin, 'DGEQRF', ' ', sm, sn,-1, -1 ) )
                                 
                    end if
                 end if
              end if
              ! initialize partial column norms. the first n elements of work
              ! store the exact column norms.
              do j = nfxd + 1, n
                 work( j ) = stdlib_${ri}$nrm2( sm, a( nfxd+1, j ), 1 )
                 work( n+j ) = work( j )
              end do
              if( ( nb>=nbmin ) .and. ( nb<sminmn ) .and.( nx<sminmn ) ) then
                 ! use blocked code initially.
                 j = nfxd + 1
                 ! compute factorization: while loop.
                 topbmn = minmn - nx
                 30 continue
                 if( j<=topbmn ) then
                    jb = min( nb, topbmn-j+1 )
                    ! factorize jb columns among columns j:n.
                    call stdlib_${ri}$laqps( m, n-j+1, j-1, jb, fjb, a( 1, j ), lda,jpvt( j ), tau( j )&
                              , work( j ), work( n+j ),work( 2*n+1 ), work( 2*n+jb+1 ), n-j+1 )
                    j = j + fjb
                    go to 30
                 end if
              else
                 j = nfxd + 1
              end if
              ! use unblocked code to factor the last or only block.
              if( j<=minmn )call stdlib_${ri}$laqp2( m, n-j+1, j-1, a( 1, j ), lda, jpvt( j ),tau( j ),&
                         work( j ), work( n+j ),work( 2*n+1 ) )
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$geqp3


     pure subroutine stdlib_${ri}$geqr( m, n, a, lda, t, tsize, work, lwork,info )
     !! DGEQR: computes a QR factorization of a real M-by-N matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix;
     !! R is an upper-triangular N-by-N matrix;
     !! 0 is a (M-N)-by-N zero matrix, if M > N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, tsize, lwork
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, lminws, mint, minw
           integer(ilp) :: mb, nb, mintsz, nblcks
           ! Intrinsic Functions 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( tsize==-1 .or. tsize==-2 .or.lwork==-1 .or. lwork==-2 )
           mint = .false.
           minw = .false.
           if( tsize==-2 .or. lwork==-2 ) then
             if( tsize/=-1 ) mint = .true.
             if( lwork/=-1 ) minw = .true.
           end if
           ! determine the block size
           if( min( m, n )>0 ) then
             mb = stdlib_ilaenv( 1, 'DGEQR ', ' ', m, n, 1, -1 )
             nb = stdlib_ilaenv( 1, 'DGEQR ', ' ', m, n, 2, -1 )
           else
             mb = m
             nb = 1
           end if
           if( mb>m .or. mb<=n ) mb = m
           if( nb>min( m, n ) .or. nb<1 ) nb = 1
           mintsz = n + 5
           if( mb>n .and. m>n ) then
             if( mod( m - n, mb - n )==0 ) then
               nblcks = ( m - n ) / ( mb - n )
             else
               nblcks = ( m - n ) / ( mb - n ) + 1
             end if
           else
             nblcks = 1
           end if
           ! determine if the workspace size satisfies minimal size
           lminws = .false.
           if( ( tsize<max( 1, nb*n*nblcks + 5 ) .or. lwork<nb*n ).and. ( lwork>=n ) .and. ( &
                     tsize>=mintsz ).and. ( .not.lquery ) ) then
             if( tsize<max( 1, nb*n*nblcks + 5 ) ) then
               lminws = .true.
               nb = 1
               mb = m
             end if
             if( lwork<nb*n ) then
               lminws = .true.
               nb = 1
             end if
           end if
           if( m<0 ) then
             info = -1
           else if( n<0 ) then
             info = -2
           else if( lda<max( 1, m ) ) then
             info = -4
           else if( tsize<max( 1, nb*n*nblcks + 5 ).and. ( .not.lquery ) .and. ( .not.lminws ) ) &
                     then
             info = -6
           else if( ( lwork<max( 1, n*nb ) ) .and. ( .not.lquery ).and. ( .not.lminws ) ) &
                     then
             info = -8
           end if
           if( info==0 ) then
             if( mint ) then
               t( 1 ) = mintsz
             else
               t( 1 ) = nb*n*nblcks + 5
             end if
             t( 2 ) = mb
             t( 3 ) = nb
             if( minw ) then
               work( 1 ) = max( 1, n )
             else
               work( 1 ) = max( 1, nb*n )
             end if
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DGEQR', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
             return
           end if
           ! the qr decomposition
           if( ( m<=n ) .or. ( mb<=n ) .or. ( mb>=m ) ) then
             call stdlib_${ri}$geqrt( m, n, nb, a, lda, t( 6 ), nb, work, info )
           else
             call stdlib_${ri}$latsqr( m, n, mb, nb, a, lda, t( 6 ), nb, work,lwork, info )
           end if
           work( 1 ) = max( 1, nb*n )
           return
     end subroutine stdlib_${ri}$geqr


     pure subroutine stdlib_${ri}$geqr2( m, n, a, lda, tau, work, info )
     !! DGEQR2: computes a QR factorization of a real m-by-n matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a m-by-m orthogonal matrix;
     !! R is an upper-triangular n-by-n matrix;
     !! 0 is a (m-n)-by-n zero matrix, if m > n.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQR2', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elementary reflector h(i) to annihilate a(i+1:m,i)
              call stdlib_${ri}$larfg( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,tau( i ) )
              if( i<n ) then
                 ! apply h(i) to a(i:m,i+1:n) from the left
                 aii = a( i, i )
                 a( i, i ) = one
                 call stdlib_${ri}$larf( 'LEFT', m-i+1, n-i, a( i, i ), 1, tau( i ),a( i, i+1 ), lda, &
                           work )
                 a( i, i ) = aii
              end if
           end do
           return
     end subroutine stdlib_${ri}$geqr2


     subroutine stdlib_${ri}$geqr2p( m, n, a, lda, tau, work, info )
     !! DGEQR2P: computes a QR factorization of a real m-by-n matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a m-by-m orthogonal matrix;
     !! R is an upper-triangular n-by-n matrix with nonnegative diagonal
     !! entries;
     !! 0 is a (m-n)-by-n zero matrix, if m > n.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQR2P', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elementary reflector h(i) to annihilate a(i+1:m,i)
              call stdlib_${ri}$larfgp( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,tau( i ) )
              if( i<n ) then
                 ! apply h(i) to a(i:m,i+1:n) from the left
                 aii = a( i, i )
                 a( i, i ) = one
                 call stdlib_${ri}$larf( 'LEFT', m-i+1, n-i, a( i, i ), 1, tau( i ),a( i, i+1 ), lda, &
                           work )
                 a( i, i ) = aii
              end if
           end do
           return
     end subroutine stdlib_${ri}$geqr2p


     pure subroutine stdlib_${ri}$geqrf( m, n, a, lda, tau, work, lwork, info )
     !! DGEQRF: computes a QR factorization of a real M-by-N matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix;
     !! R is an upper-triangular N-by-N matrix;
     !! 0 is a (M-N)-by-N zero matrix, if M > N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           k = min( m, n )
           info = 0
           nb = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( .not.lquery ) then
              if( lwork<=0 .or. ( m>0 .and. lwork<max( 1, n ) ) )info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQRF', -info )
              return
           else if( lquery ) then
              if( k==0 ) then
                 lwkopt = 1
              else
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DGEQRF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEQRF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially
              do i = 1, k - nx, nb
                 ib = min( k-i+1, nb )
                 ! compute the qr factorization of the current block
                 ! a(i:m,i:i+ib-1)
                 call stdlib_${ri}$geqr2( m-i+1, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 if( i+ib<=n ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_${ri}$larft( 'FORWARD', 'COLUMNWISE', m-i+1, ib,a( i, i ), lda, tau( i &
                              ), work, ldwork )
                    ! apply h**t to a(i:m,i+ib:n) from the left
                    call stdlib_${ri}$larfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE', m-i+1, n-i-&
                    ib+1, ib,a( i, i ), lda, work, ldwork, a( i, i+ib ),lda, work( ib+1 ), ldwork &
                              )
                 end if
              end do
           else
              i = 1
           end if
           ! use unblocked code to factor the last or only block.
           if( i<=k )call stdlib_${ri}$geqr2( m-i+1, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                     
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$geqrf


     subroutine stdlib_${ri}$geqrfp( m, n, a, lda, tau, work, lwork, info )
     !! DGEQR2P computes a QR factorization of a real M-by-N matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix;
     !! R is an upper-triangular N-by-N matrix with nonnegative diagonal
     !! entries;
     !! 0 is a (M-N)-by-N zero matrix, if M > N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
           lwkopt = n*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQRFP', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DGEQRF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEQRF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially
              do i = 1, k - nx, nb
                 ib = min( k-i+1, nb )
                 ! compute the qr factorization of the current block
                 ! a(i:m,i:i+ib-1)
                 call stdlib_${ri}$geqr2p( m-i+1, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 if( i+ib<=n ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_${ri}$larft( 'FORWARD', 'COLUMNWISE', m-i+1, ib,a( i, i ), lda, tau( i &
                              ), work, ldwork )
                    ! apply h**t to a(i:m,i+ib:n) from the left
                    call stdlib_${ri}$larfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE', m-i+1, n-i-&
                    ib+1, ib,a( i, i ), lda, work, ldwork, a( i, i+ib ),lda, work( ib+1 ), ldwork &
                              )
                 end if
              end do
           else
              i = 1
           end if
           ! use unblocked code to factor the last or only block.
           if( i<=k )call stdlib_${ri}$geqr2p( m-i+1, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                     
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$geqrfp


     pure subroutine stdlib_${ri}$geqrt( m, n, nb, a, lda, t, ldt, work, info )
     !! DGEQRT: computes a blocked QR factorization of a real M-by-N matrix A
     !! using the compact WY representation of Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk), parameter :: use_recursive_qr = .true.
           integer(ilp) :: i, ib, iinfo, k
           
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nb<1 .or. ( nb>min(m,n) .and. min(m,n)>0 ) )then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldt<nb ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQRT', -info )
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) return
           ! blocked loop of length k
           do i = 1, k,  nb
              ib = min( k-i+1, nb )
           ! compute the qr factorization of the current block a(i:m,i:i+ib-1)
              if( use_recursive_qr ) then
                 call stdlib_${ri}$geqrt3( m-i+1, ib, a(i,i), lda, t(1,i), ldt, iinfo )
              else
                 call stdlib_${ri}$geqrt2( m-i+1, ib, a(i,i), lda, t(1,i), ldt, iinfo )
              end if
              if( i+ib<=n ) then
           ! update by applying h**t to a(i:m,i+ib:n) from the left
                 call stdlib_${ri}$larfb( 'L', 'T', 'F', 'C', m-i+1, n-i-ib+1, ib,a( i, i ), lda, t( 1,&
                            i ), ldt,a( i, i+ib ), lda, work , n-i-ib+1 )
              end if
           end do
           return
     end subroutine stdlib_${ri}$geqrt


     pure subroutine stdlib_${ri}$geqrt2( m, n, a, lda, t, ldt, info )
     !! DGEQRT2: computes a QR factorization of a real M-by-N matrix A,
     !! using the compact WY representation of Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           real(${rk}$) :: aii, alpha
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( n<0 ) then
              info = -2
           else if( m<n ) then
              info = -1
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQRT2', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elem. refl. h(i) to annihilate a(i+1:m,i), tau(i) -> t(i,1)
              call stdlib_${ri}$larfg( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,t( i, 1 ) )
              if( i<n ) then
                 ! apply h(i) to a(i:m,i+1:n) from the left
                 aii = a( i, i )
                 a( i, i ) = one
                 ! w(1:n-i) := a(i:m,i+1:n)^h * a(i:m,i) [w = t(:,n)]
                 call stdlib_${ri}$gemv( 'T',m-i+1, n-i, one, a( i, i+1 ), lda,a( i, i ), 1, zero, t( &
                           1, n ), 1 )
                 ! a(i:m,i+1:n) = a(i:m,i+1:n) + alpha*a(i:m,i)*w(1:n-1)^h
                 alpha = -(t( i, 1 ))
                 call stdlib_${ri}$ger( m-i+1, n-i, alpha, a( i, i ), 1,t( 1, n ), 1, a( i, i+1 ), lda &
                           )
                 a( i, i ) = aii
              end if
           end do
           do i = 2, n
              aii = a( i, i )
              a( i, i ) = one
              ! t(1:i-1,i) := alpha * a(i:m,1:i-1)**t * a(i:m,i)
              alpha = -t( i, 1 )
              call stdlib_${ri}$gemv( 'T', m-i+1, i-1, alpha, a( i, 1 ), lda,a( i, i ), 1, zero, t( 1, &
                        i ), 1 )
              a( i, i ) = aii
              ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(1:i-1,i)
              call stdlib_${ri}$trmv( 'U', 'N', 'N', i-1, t, ldt, t( 1, i ), 1 )
                 ! t(i,i) = tau(i)
                 t( i, i ) = t( i, 1 )
                 t( i, 1) = zero
           end do
     end subroutine stdlib_${ri}$geqrt2


     pure recursive subroutine stdlib_${ri}$geqrt3( m, n, a, lda, t, ldt, info )
     !! DGEQRT3: recursively computes a QR factorization of a real M-by-N
     !! matrix A, using the compact WY representation of Q.
     !! Based on the algorithm of Elmroth and Gustavson,
     !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, ldt
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, j, j1, n1, n2, iinfo
           ! Executable Statements 
           info = 0
           if( n < 0 ) then
              info = -2
           else if( m < n ) then
              info = -1
           else if( lda < max( 1, m ) ) then
              info = -4
           else if( ldt < max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEQRT3', -info )
              return
           end if
           if( n==1 ) then
              ! compute householder transform when n=1
              call stdlib_${ri}$larfg( m, a(1,1), a( min( 2, m ), 1 ), 1, t(1,1) )
           else
              ! otherwise, split a into blocks...
              n1 = n/2
              n2 = n-n1
              j1 = min( n1+1, n )
              i1 = min( n+1, m )
              ! compute a(1:m,1:n1) <- (y1,r1,t1), where q1 = i - y1 t1 y1^h
              call stdlib_${ri}$geqrt3( m, n1, a, lda, t, ldt, iinfo )
              ! compute a(1:m,j1:n) = q1^h a(1:m,j1:n) [workspace: t(1:n1,j1:n)]
              do j=1,n2
                 do i=1,n1
                    t( i, j+n1 ) = a( i, j+n1 )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'L', 'T', 'U', n1, n2, one,a, lda, t( 1, j1 ), ldt )
              call stdlib_${ri}$gemm( 'T', 'N', n1, n2, m-n1, one, a( j1, 1 ), lda,a( j1, j1 ), lda, &
                        one, t( 1, j1 ), ldt)
              call stdlib_${ri}$trmm( 'L', 'U', 'T', 'N', n1, n2, one,t, ldt, t( 1, j1 ), ldt )
              call stdlib_${ri}$gemm( 'N', 'N', m-n1, n2, n1, -one, a( j1, 1 ), lda,t( 1, j1 ), ldt, &
                        one, a( j1, j1 ), lda )
              call stdlib_${ri}$trmm( 'L', 'L', 'N', 'U', n1, n2, one,a, lda, t( 1, j1 ), ldt )
              do j=1,n2
                 do i=1,n1
                    a( i, j+n1 ) = a( i, j+n1 ) - t( i, j+n1 )
                 end do
              end do
              ! compute a(j1:m,j1:n) <- (y2,r2,t2) where q2 = i - y2 t2 y2^h
              call stdlib_${ri}$geqrt3( m-n1, n2, a( j1, j1 ), lda,t( j1, j1 ), ldt, iinfo )
              ! compute t3 = t(1:n1,j1:n) = -t1 y1^h y2 t2
              do i=1,n1
                 do j=1,n2
                    t( i, j+n1 ) = (a( j+n1, i ))
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'L', 'N', 'U', n1, n2, one,a( j1, j1 ), lda, t( 1, j1 ), &
                        ldt )
              call stdlib_${ri}$gemm( 'T', 'N', n1, n2, m-n, one, a( i1, 1 ), lda,a( i1, j1 ), lda, &
                        one, t( 1, j1 ), ldt )
              call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', n1, n2, -one, t, ldt,t( 1, j1 ), ldt )
                        
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'N', n1, n2, one,t( j1, j1 ), ldt, t( 1, j1 ), &
                        ldt )
              ! y = (y1,y2); r = [ r1  a(1:n1,j1:n) ];  t = [t1 t3]
                               ! [  0        r2     ]       [ 0 t2]
           end if
           return
     end subroutine stdlib_${ri}$geqrt3


     pure subroutine stdlib_${ri}$gerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! DGERFS: improves the computed solution to a system of linear
     !! equations and provides error bounds and backward error estimates for
     !! the solution.
               berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: notran
           character :: transt
           integer(ilp) :: count, i, j, k, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGERFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$gemv( trans, n, n, -one, a, lda, x( 1, j ), 1, one,work( n+1 ), 1 )
                        
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(op(a))*abs(x) + abs(b).
              if( notran ) then
                 do k = 1, n
                    xk = abs( x( k, j ) )
                    do i = 1, n
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                    end do
                 end do
              else
                 do k = 1, n
                    s = zero
                    do i = 1, n
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$getrs( trans, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**t).
                    call stdlib_${ri}$getrs( transt, n, 1, af, ldaf, ipiv, work( n+1 ),n, info )
                              
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$getrs( trans, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$gerfs


     pure subroutine stdlib_${ri}$gerq2( m, n, a, lda, tau, work, info )
     !! DGERQ2: computes an RQ factorization of a real m by n matrix A:
     !! A = R * Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGERQ2', -info )
              return
           end if
           k = min( m, n )
           do i = k, 1, -1
              ! generate elementary reflector h(i) to annihilate
              ! a(m-k+i,1:n-k+i-1)
              call stdlib_${ri}$larfg( n-k+i, a( m-k+i, n-k+i ), a( m-k+i, 1 ), lda,tau( i ) )
              ! apply h(i) to a(1:m-k+i-1,1:n-k+i) from the right
              aii = a( m-k+i, n-k+i )
              a( m-k+i, n-k+i ) = one
              call stdlib_${ri}$larf( 'RIGHT', m-k+i-1, n-k+i, a( m-k+i, 1 ), lda,tau( i ), a, lda, &
                        work )
              a( m-k+i, n-k+i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$gerq2


     pure subroutine stdlib_${ri}$gerqf( m, n, a, lda, tau, work, lwork, info )
     !! DGERQF: computes an RQ factorization of a real M-by-N matrix A:
     !! A = R * Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt, mu, nb, nbmin, nu, &
                     nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              k = min( m, n )
              if( k==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
                 lwkopt = m*nb
              end if
              work( 1 ) = lwkopt
              if ( .not.lquery ) then
                 if( lwork<=0 .or. ( n>0 .and. lwork<max( 1, m ) ) )info = -7
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGERQF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( k==0 ) then
              return
           end if
           nbmin = 2
           nx = 1
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DGERQF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGERQF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially.
              ! the last kk rows are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              do i = k - kk + ki + 1, k - kk + 1, -nb
                 ib = min( k-i+1, nb )
                 ! compute the rq factorization of the current block
                 ! a(m-k+i:m-k+i+ib-1,1:n-k+i+ib-1)
                 call stdlib_${ri}$gerq2( ib, n-k+i+ib-1, a( m-k+i, 1 ), lda, tau( i ),work, iinfo )
                           
                 if( m-k+i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_${ri}$larft( 'BACKWARD', 'ROWWISE', n-k+i+ib-1, ib,a( m-k+i, 1 ), lda, &
                              tau( i ), work, ldwork )
                    ! apply h to a(1:m-k+i-1,1:n-k+i+ib-1) from the right
                    call stdlib_${ri}$larfb( 'RIGHT', 'NO TRANSPOSE', 'BACKWARD','ROWWISE', m-k+i-1, n-&
                    k+i+ib-1, ib,a( m-k+i, 1 ), lda, work, ldwork, a, lda,work( ib+1 ), ldwork )
                              
                 end if
              end do
              mu = m - k + i + nb - 1
              nu = n - k + i + nb - 1
           else
              mu = m
              nu = n
           end if
           ! use unblocked code to factor the last or only block
           if( mu>0 .and. nu>0 )call stdlib_${ri}$gerq2( mu, nu, a, lda, tau, work, iinfo )
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$gerqf


     pure subroutine stdlib_${ri}$gesc2( n, a, lda, rhs, ipiv, jpiv, scale )
     !! DGESC2: solves a system of linear equations
     !! A * X = scale* RHS
     !! with a general N-by-N matrix A using the LU factorization with
     !! complete pivoting computed by DGETC2.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*), jpiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: rhs(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: bignum, eps, smlnum, temp
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
            ! set constant to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! apply permutations ipiv to rhs
           call stdlib_${ri}$laswp( 1, rhs, lda, 1, n-1, ipiv, 1 )
           ! solve for l part
           do i = 1, n - 1
              do j = i + 1, n
                 rhs( j ) = rhs( j ) - a( j, i )*rhs( i )
              end do
           end do
           ! solve for u part
           scale = one
           ! check for scaling
           i = stdlib_i${ri}$amax( n, rhs, 1 )
           if( two*smlnum*abs( rhs( i ) )>abs( a( n, n ) ) ) then
              temp = ( one / two ) / abs( rhs( i ) )
              call stdlib_${ri}$scal( n, temp, rhs( 1 ), 1 )
              scale = scale*temp
           end if
           do i = n, 1, -1
              temp = one / a( i, i )
              rhs( i ) = rhs( i )*temp
              do j = i + 1, n
                 rhs( i ) = rhs( i ) - rhs( j )*( a( i, j )*temp )
              end do
           end do
           ! apply permutations jpiv to the solution (rhs)
           call stdlib_${ri}$laswp( 1, rhs, lda, 1, n-1, jpiv, -1 )
           return
     end subroutine stdlib_${ri}$gesc2


     subroutine stdlib_${ri}$gesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
     !! DGESDD: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and right singular
     !! vectors.  If singular vectors are desired, it uses a
     !! divide-and-conquer algorithm.
     !! The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**T, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, il, ir, iscl, itau, itaup, itauq, iu, &
                     ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, nwork, wrkbl
           integer(ilp) :: lwork_qgebrd_mn, lwork_qgebrd_mm, lwork_qgebrd_nn, lwork_qgelqf_mn, &
           lwork_qgeqrf_mn, lwork_qorgbr_p_mm, lwork_qorgbr_q_nn, lwork_qorglq_mn, &
           lwork_qorglq_nn, lwork_qorgqr_mm, lwork_qorgqr_mn, lwork_qormbr_prt_mm, &
           lwork_qormbr_qln_mm, lwork_qormbr_prt_mn, lwork_qormbr_qln_mn, lwork_qormbr_prt_nn, &
                     lwork_qormbr_qln_nn
           real(${rk}$) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: int,max,min,sqrt
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              bdspac = 0
              mnthr  = int( minmn*11.0_${rk}$ / 6.0_${rk}$,KIND=ilp)
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsdc
                 if( wntqn ) then
                    ! stdlib_${ri}$bdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_${rk}$)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*n
                 else
                    bdspac = 3*n*n + 4*n
                 end if
                 ! compute space preferred for each routine
                 call stdlib_${ri}$gebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_qgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$gebrd( n, n, dum(1), n, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_qgebrd_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$geqrf( m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_qgeqrf_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgbr( 'Q', n, n, n, dum(1), n, dum(1), dum(1), -1,ierr )
                 lwork_qorgbr_q_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgqr( m, m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgqr( m, n, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, n, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       maxwrk = max( wrkbl, bdspac + n )
                       minwrk = bdspac + n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_qorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + 2*n*n
                       minwrk = bdspac + 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_qorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = bdspac + n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_qorgqr_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = n*n + max( 3*n + bdspac, n + m )
                    end if
                 else
                    ! path 5 (m >= n, but not much larger)
                    wrkbl = 3*n + lwork_qgebrd_mn
                    if( wntqn ) then
                       ! path 5n (m >= n, jobz='n')
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqo ) then
                       ! path 5o (m >= n, jobz='o')
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*n + max( m, n*n + bdspac )
                    else if( wntqs ) then
                       ! path 5s (m >= n, jobz='s')
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqa ) then
                       ! path 5a (m >= n, jobz='a')
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsdc
                 if( wntqn ) then
                    ! stdlib_${ri}$bdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_${rk}$)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*m
                 else
                    bdspac = 3*m*m + 4*m
                 end if
                 ! compute space preferred for each routine
                 call stdlib_${ri}$gebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_qgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$gebrd( m, m, a, m, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_qgebrd_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$gelqf( m, n, a, m, dum(1), dum(1), -1, ierr )
                 lwork_qgelqf_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orglq( m, n, m, a, m, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgbr( 'P', m, m, m, a, n, dum(1), dum(1), -1, ierr )
                 lwork_qorgbr_p_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, n, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, m, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       maxwrk = max( wrkbl, bdspac + m )
                       minwrk = bdspac + m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_qorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + 2*m*m
                       minwrk = bdspac + 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_qorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = bdspac + m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_qorglq_nn )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = m*m + max( 3*m + bdspac, m + n )
                    end if
                 else
                    ! path 5t (n > m, but not much larger)
                    wrkbl = 3*m + lwork_qgebrd_mn
                    if( wntqn ) then
                       ! path 5tn (n > m, jobz='n')
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqo ) then
                       ! path 5to (n > m, jobz='o')
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mn )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*m + max( n, m*m + bdspac )
                    else if( wntqs ) then
                       ! path 5ts (n > m, jobz='s')
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqa ) then
                       ! path 5ta (n > m, jobz='a')
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = stdlib_${ri}$roundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = sqrt( stdlib_${ri}$lamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, dum )
           if( stdlib_${ri}$isnan( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n [tau] + n    [work]
                    ! workspace: prefer n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out below r
                    if (n>1) call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + n
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   n [e] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz = 'o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is ldwrkr by n
                    if( lwork >= lda*n + n*n + 3*n + bdspac ) then
                       ldwrkr = lda
                    else
                       ldwrkr = ( lwork - n*n - 3*n - bdspac ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_${ri}$laset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! work(iu) is n by n
                    iu = nwork
                    nwork = iu + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r
                    ! and vt by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), n, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    ! workspace: prefer m*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    do i = 1, m, ldwrkr
                       chunk = min( m - i + 1, ldwrkr )
                       call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu ), &
                                 n, zero, work( ir ),ldwrkr )
                       call stdlib_${ri}$lacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_${ri}$laset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagoal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! workspace: need   n*n [r]
                    call stdlib_${ri}$lacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda, work( ir ),ldwrkr, zero, u,&
                               ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! workspace: need   n*n [u] + n [tau] + n    [work]
                    ! workspace: prefer n*n [u] + n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! workspace: need   n*n [u] + n [tau] + m    [work]
                    ! workspace: prefer n*n [u] + n [tau] + m*nb [work]
                    call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce r in a, zeroing out other entries
                    if (n>1) call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! workspace: need   n*n [u]
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu, work( iu ),ldwrku, zero, a,&
                               lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr
                 ! path 5 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! workspace: need   3*n [e, tauq, taup] + m        [work]
                 ! workspace: prefer 3*n [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >= n, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5o (m >= n, jobz='o')
                    iu = nwork
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                       nwork = iu + ldwrku*n
                       call stdlib_${ri}$laset( 'F', m, n, zero, zero, work( iu ),ldwrku )
                       ! ir is unused; silence compile warnings
                       ir = -1
                    else
                       ! work( iu ) is n by n
                       ldwrku = n
                       nwork = iu + ldwrku*n
                       ! work(ir) is ldwrkr by n
                       ir = nwork
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), work( iu ),ldwrku, vt, ldvt, &
                              dum, idum, work( nwork ),iwork, info )
                    ! overwrite vt by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! path 5o-fast
                       ! overwrite work(iu) by left singular vectors of a
                       ! workspace: need   3*n [e, tauq, taup] + m*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + m*n [u] + n*nb [work]
                       call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy left singular vectors of a from work(iu) to a
                       call stdlib_${ri}$lacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 5o-slow
                       ! generate q in a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                       call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by left singular vectors of
                       ! bidiagonal matrix in work(iu), storing result in
                       ! work(ir) and copying to a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + nb*n [r]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + m*n  [r]
                       do i = 1, m, ldwrkr
                          chunk = min( m - i + 1, ldwrkr )
                          call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu )&
                                    , ldwrku, zero,work( ir ), ldwrkr )
                          call stdlib_${ri}$lacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, u, ldu )
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', m, m, zero, zero, u, ldu )
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of u to identity matrix
                    if( m>n ) then
                       call stdlib_${ri}$laset( 'F', m - n, m - n, zero, one, u(n+1,n+1),ldu )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m [tau] + m [work]
                    ! workspace: prefer m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out above l
                    if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + m
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   m [e] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ! work(il)  is m by m; it is later resized to m by chunk for gemm
                    il = ivt + m*m
                    if( lwork >= m*n + m*m + 3*m + bdspac ) then
                       ldwrkl = m
                       chunk = n
                    else
                       ldwrkl = m
                       chunk = ( lwork - m*m ) / m
                    end if
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_${ri}$laset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u, and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), m, dum, &
                              idum, work( nwork ),iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), m,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by q
                    ! in a, storing result in work(il) and copying to a
                    ! workspace: need   m*m [vt] + m*m [l]
                    ! workspace: prefer m*m [vt] + m*n [l]
                    ! at this point, l is resized as m by chunk.
                    do i = 1, n, chunk
                       blk = min( n - i + 1, chunk )
                       call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ivt ), m,a( 1, i ), lda,&
                                  zero, work( il ), ldwrkl )
                       call stdlib_${ri}$lacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_${ri}$laset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(iu).
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of l and vt
                    ! by right singular vectors of l
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(il) by
                    ! q in a, storing result in vt
                    ! workspace: need   m*m [l]
                    call stdlib_${ri}$lacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( il ), ldwrkl,a, lda, zero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! workspace: need   m*m [vt] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! workspace: need   m*m [vt] + m [tau] + n    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce l in a, zeroing out other entries
                    if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup]+ m    [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup]+ m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! workspace: need   m*m [vt]
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( ivt ), ldwkvt,vt, ldvt, zero,&
                               a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr
                 ! path 5t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! workspace: need   3*m [e, tauq, taup] + n        [work]
                 ! workspace: prefer 3*m [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n > m, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'L', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! work( ivt ) is m by n
                       call stdlib_${ri}$laset( 'F', m, n, zero, zero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                       ! il is unused; silence compile warnings
                       il = -1
                    else
                       ! work( ivt ) is m by m
                       nwork = ivt + ldwkvt*m
                       il = nwork
                       ! work(il) is m by chunk
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + bdspac
                    call stdlib_${ri}$bdsdc( 'L', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! path 5to-fast
                       ! overwrite work(ivt) by left singular vectors of a
                       ! workspace: need   3*m [e, tauq, taup] + m*n [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*n [vt] + m*nb [work]
                       call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy right singular vectors of a from work(ivt) to a
                       call stdlib_${ri}$lacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 5to-slow
                       ! generate p**t in a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                       call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by right singular vectors of
                       ! bidiagonal matrix in work(ivt), storing result in
                       ! work(il) and copying to a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m*nb [l]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*n  [l]
                       do i = 1, n, chunk
                          blk = min( n - i + 1, chunk )
                          call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ivt ),ldwkvt, a( 1, &
                                    i ), lda, zero,work( il ), m )
                          call stdlib_${ri}$lacpy( 'F', m, blk, work( il ), m, a( 1, i ),lda )
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, vt, ldvt )
                    call stdlib_${ri}$bdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', n, n, zero, zero, vt, ldvt )
                    call stdlib_${ri}$bdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of vt to identity matrix
                    if( n>m ) then
                       call stdlib_${ri}$laset( 'F', n-m, n-m, zero, one, vt(m+1,m+1),ldvt )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( anrm<smlnum )call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_${ri}$roundup_lwork( maxwrk )
           return
     end subroutine stdlib_${ri}$gesdd


     pure subroutine stdlib_${ri}$gesv( n, nrhs, a, lda, ipiv, b, ldb, info )
     !! DGESV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
     !! The LU decomposition with partial pivoting and row interchanges is
     !! used to factor A as
     !! A = P * L * U,
     !! where P is a permutation matrix, L is unit lower triangular, and U is
     !! upper triangular.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESV ', -info )
              return
           end if
           ! compute the lu factorization of a.
           call stdlib_${ri}$getrf( n, n, a, lda, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$getrs( 'NO TRANSPOSE', n, nrhs, a, lda, ipiv, b, ldb,info )
           end if
           return
     end subroutine stdlib_${ri}$gesv


     subroutine stdlib_${ri}$gesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, info )
     !! DGESVD: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**T, not V.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, ir, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_qgeqrf, lwork_qorgqr_n, lwork_qorgqr_m, lwork_qgebrd, &
                     lwork_qorgbr_p, lwork_qorgbr_q, lwork_qgelqf, lwork_qorglq_n, lwork_qorglq_m
           real(${rk}$) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsqr
                 mnthr = stdlib_ilaenv( 6, 'DGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*n
                 ! compute space needed for stdlib_${ri}$geqrf
                 call stdlib_${ri}$geqrf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qgeqrf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgqr
                 call stdlib_${ri}$orgqr( m, n, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_n = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgqr( m, m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$gebrd
                 call stdlib_${ri}$gebrd( n, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_qgebrd = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgbr p
                 call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgbr q
                 call stdlib_${ri}$orgbr( 'Q', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_q = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_qgeqrf
                       maxwrk = max( maxwrk, 3*n + lwork_qgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 3*n + lwork_qorgbr_p )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*n, bdspac )
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n + wrkbl, n*n + m*n + n )
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n + wrkbl, n*n + m*n + n )
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_${ri}$gebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_qgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*n + lwork_qgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_qorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n + lwork_qorgbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_${ri}$orgbr( 'Q', m, m, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_qorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n + lwork_qorgbr_q )
                    end if
                    if( .not.wntvn ) then
                      maxwrk = max( maxwrk, 3*n + lwork_qorgbr_p )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*n + m, bdspac )
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsqr
                 mnthr = stdlib_ilaenv( 6, 'DGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*m
                 ! compute space needed for stdlib_${ri}$gelqf
                 call stdlib_${ri}$gelqf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qgelqf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orglq
                 call stdlib_${ri}$orglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_n = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orglq( m, n, m, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$gebrd
                 call stdlib_${ri}$gebrd( m, m, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_qgebrd = int( dum(1),KIND=ilp)
                  ! compute space needed for stdlib_${ri}$orgbr p
                 call stdlib_${ri}$orgbr( 'P', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgbr q
                 call stdlib_${ri}$orgbr( 'Q', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_q = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_qgelqf
                       maxwrk = max( maxwrk, 3*m + lwork_qgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 3*m + lwork_qorgbr_q )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*m, bdspac )
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m + wrkbl, m*m + m*n + m )
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m + wrkbl, m*m + m*n + m )
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_${ri}$gebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_qgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*m + lwork_qgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_${ri}$orgbr p
                      call stdlib_${ri}$orgbr( 'P', m, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_qorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m + lwork_qorgbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_${ri}$orgbr( 'P', n, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_qorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m + lwork_qorgbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 3*m + lwork_qorgbr_q )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*m + n, bdspac )
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = sqrt( stdlib_${ri}$lamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (workspace: need 2*n, prefer n + n*nb)
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                    call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    iwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                              work( iwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_${ri}$lacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + n ) + lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + n ) + n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, work( ir+1 ),ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                       call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                       call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (workspace: need n*n + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, 0, n, 0, s, work( ie ), dum, 1,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n + 2*n, prefer n*n + m*n + n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (workspace: need 3*n + m, prefer 3*n + (m + n)*nb)
                       call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (workspace: need 4*n, prefer 3*n + n*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, 0, m, 0, s, work( ie ), dum, 1,a, lda, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + n ) + lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + n ) + n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                       call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_${ri}$lacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                       call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need n*n + 4*n-1, prefer n*n + 3*n + (n-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (workspace: need n*n + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ), vt, ldvt,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n + 2*n, prefer n*n + m*n + n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need 2*n, prefer n + n*nb)
                       call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need 2*n, prefer n + n*nb)
                       call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                       call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                       call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), vt, ldvt,a, lda, dum, &
                                 1, work( iwork ), info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda,work( ir ), ldwrkr, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n + 4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n + 4*n, prefer 2*n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n + 4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$lacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n + 4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (workspace: need n*n + n + m, prefer n*n + n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu,work( ir ), ldwrkr, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n*n + n + m, prefer 2*n*n + n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n + 4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n + 4*n, prefer 2*n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n + 4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_${ri}$lacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n*n + n + m, prefer n*n + n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n + 4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (workspace: need 3*n + m, prefer 3*n + (m + n)*nb)
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 3*n + ncu, prefer 3*n + ncu*nb)
                    call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_${ri}$orgbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n, prefer 3*n + n*nb)
                    call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                    call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (workspace: need 2*m, prefer m + m*nb)
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                    call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    iwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', m, 0, nru, 0, s, work( ie ), dum, 1, a,lda, dum, 1, &
                              work( iwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_${ri}$lacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + m ) + lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + m ) + m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                       call stdlib_${ri}$gebrd( m, m, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (workspace: need m*m + 4*m-1, prefer m*m + 3*m + (m-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, dum,&
                                  1, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m + 2*m, prefer m*m + m*n + m)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (workspace: need 3*m + n, prefer 3*m + (m + n)*nb)
                       call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'L', m, n, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + m ) + lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + m ) + m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                       call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_${ri}$lacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (workspace: need m*m + 4*m-1, prefer m*m + 3*m + (m-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( ir ), ldwrkr, u, &
                                 ldu, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m + 2*m, prefer m*m + m*n + m))
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need 2*m, prefer m + m*nb)
                       call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need 2*m, prefer m + m*nb)
                       call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                       call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                       call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), a, lda,u, ldu, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + (m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m + 4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m + 4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m + 4*m, prefer 2*m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$lacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, compute left
                          ! singular vectors of a in a and compute right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m + 4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in vt
                          ! (workspace: need m*m + m + n, prefer m*m + m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need m*m + 4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m*m + m + n, prefer 2*m*m + m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m + 4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m + 4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m + 4*m, prefer 2*m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_${ri}$lacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m*m + m + n, prefer m*m + m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + (m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (workspace: need 3*m + n, prefer 3*m + (m + n)*nb)
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 4*m-1, prefer 3*m + (m-1)*nb)
                    call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_${ri}$orgbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 3*m + nrvt, prefer 3*m + nrvt*nb)
                    call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_${ri}$orgbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m-1, prefer 3*m + (m-1)*nb)
                    call stdlib_${ri}$orgbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m, prefer 3*m + m*nb)
                    call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           end if
           ! if stdlib_${ri}$bdsqr failed to converge, copy unconverged superdiagonals
           ! to work( 2:minmn )
           if( info/=0 ) then
              if( ie>2 ) then
                 do i = 1, minmn - 1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
              if( ie<2 ) then
                 do i = minmn - 1, 1, -1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
              if( anrm<smlnum )call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gesvd


     subroutine stdlib_${ri}$gesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
     !! DGESVDQ: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lwork
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(${rk}$), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: ierr, iwoff, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_qgelqf, lwrk_qgesvd, lwrk_qgesvd2, lwrk_qgeqp3, &
           lwrk_qgeqrf, lwrk_qormlq, lwrk_qormqr, lwrk_qormqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lworq, lworq2, lworlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(${rk}$) :: big, epsln, rtmp, sconda, sfmin
           ! Local Arrays
           real(${rk}$) :: rdummy(1)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,sqrt
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              if ( conda ) then
                 iminwrk = max( 1, n + m - 1 + n )
              else
                 iminwrk = max( 1, n + m - 1 )
              end if
              rminwrk = max( 2, m )
           else
              if ( conda ) then
                 iminwrk = max( 1, n + n )
              else
                 iminwrk = max( 1, n )
              end if
              rminwrk = 2
           end if
           lquery = (liwork == -1 .or. lwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Dgeqp3 Of An M X N Matrix
              lwqp3 = 3 * n + 1
              ! Minimal Workspace Length For Stdlib_Dormqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lworq  = max( n  , 1 )
              else if ( wntua ) then
                  lworq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Dpocon Of An N X N Matrix
              lwcon = 3 * n
              ! Stdlib_Dgesvd Of An N X N Matrix
              lwsvd = max( 5 * n, 1 )
              if ( lquery ) then
                  call stdlib_${ri}$geqp3( m, n, a, lda, iwork, rdummy, rdummy, -1,ierr )
                  lwrk_qgeqp3 = int( rdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_${ri}$ormqr( 'L', 'N', m, n, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_qormqr = int( rdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_${ri}$ormqr( 'L', 'N', m, m, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_qormqr = int( rdummy(1),KIND=ilp)
                  else
                      lwrk_qormqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec )) then
                  ! Minimal And Optimal Sizes Of The Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_${ri}$gesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                ierr )
                      lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_qgeqp3, n+lwcon, lwrk_qgesvd )
                      else
                         optwrk = max( n+lwrk_qgeqp3, lwrk_qgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lworq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lworq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_${ri}$gesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     else
                        call stdlib_${ri}$gesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     end if
                     lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_qgeqp3, lwcon, lwrk_qgesvd,lwrk_qormqr )
                     else
                         optwrk = n + max( lwrk_qgeqp3, lwrk_qgesvd,lwrk_qormqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_${ri}$gesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      else
                          call stdlib_${ri}$gesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      end if
                      lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_qgeqp3, lwcon, lwrk_qgesvd )
                      else
                          optwrk = n + max( lwrk_qgeqp3, lwrk_qgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_${ri}$geqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_${ri}$gesvd
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lworq2, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_${ri}$gelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lworlq, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_${ri}$gesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_qgeqp3,lwrk_qgesvd,lwrk_qormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_${ri}$geqrf(n,n/2,u,ldu,rdummy,rdummy,-1,ierr)
                            lwrk_qgeqrf = int( rdummy(1),KIND=ilp)
                            call stdlib_${ri}$gesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, rdummy,&
                                       -1, ierr )
                            lwrk_qgesvd2 = int( rdummy(1),KIND=ilp)
                            call stdlib_${ri}$ormqr( 'R', 'C', n, n, n/2, u, ldu, rdummy,v, ldv, &
                                      rdummy, -1, ierr )
                            lwrk_qormqr2 = int( rdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_qgeqp3, n/2+lwrk_qgeqrf,n/2+lwrk_qgesvd2, n/2+&
                                      lwrk_qormqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_${ri}$gesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_qgeqp3,lwrk_qgesvd,lwrk_qormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_${ri}$gelqf(n/2,n,u,ldu,rdummy,rdummy,-1,ierr)
                           lwrk_qgelqf = int( rdummy(1),KIND=ilp)
                           call stdlib_${ri}$gesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, rdummy,&
                                      -1, ierr )
                           lwrk_qgesvd2 = int( rdummy(1),KIND=ilp)
                           call stdlib_${ri}$ormlq( 'R', 'N', n, n, n/2, u, ldu, rdummy,v, ldv, rdummy,&
                                     -1,ierr )
                           lwrk_qormlq = int( rdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_qgeqp3, n/2+lwrk_qgelqf,n/2+lwrk_qgesvd2, n/2+&
                                     lwrk_qormlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               work(1) = optwrk
               work(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_${ri}$lamch('O')
           ascaled = .false.
           iwoff = 1
           if ( rowprm ) then
                 iwoff = m
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_izamax(n,a(p,1),lda)) )
                     ! [[stdlib_${ri}$lange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_${ri}$lange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = -8
                         call stdlib_xerbla( 'DGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_i${ri}$amax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_${ri}$laset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_${ri}$laset('G', m, n, zero, one, u, ldu)
                    if ( wntua ) call stdlib_${ri}$laset('G', m, m, zero, one, u, ldu)
                    if ( wntva ) call stdlib_${ri}$laset('G', n, n, zero, one, v, ldv)
                    if ( wntuf ) then
                        call stdlib_${ri}$laset( 'G', n, 1, zero, zero, work, n )
                        call stdlib_${ri}$laset( 'G', m, n, zero,  one, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=${rk}$)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_${ri}$lascl('G',0,0,sqrt(real(m,KIND=${rk}$)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_${ri}$laswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_${ri}$lange( 'M', m, n, a, lda, rdummy )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = -8
                    call stdlib_xerbla( 'DGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=${rk}$)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_${ri}$lascl('G',0,0, sqrt(real(m,KIND=${rk}$)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_${ri}$geqp3( m, n, a, lda, iwork, work, work(n+1), lwork-n,ierr )
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_${ri}$lamch('E')
           sfmin = stdlib_${ri}$lamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=${rk}$))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_${ri}$lamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_${ri}$nrm2( p, v(1,p), 1 )
                       call stdlib_${ri}$scal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_${ri}$pocon( 'U', nr, v, ldv, one, rtmp,work, iwork(n+iwoff), ierr &
                                  )
                    else
                        call stdlib_${ri}$pocon( 'U', nr, v, ldv, one, rtmp,work(n+1), iwork(n+iwoff), &
                                  ierr )
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**t = [a](1:nr,1:n)**t
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**t and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    do q = p + 1, n
                       a(q,p) = a(p,q)
                       if ( q <= nr ) a(p,q) = zero
                    end do
                 end do
                 call stdlib_${ri}$gesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1,nr-1, zero,zero, a(2,1), lda )
                 call stdlib_${ri}$gesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_${ri}$gesvd to r**t
                  ! .. copy r**t into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, u(1,2), ldu )
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_${ri}$gesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Dgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1, nr-1, zero, zero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_${ri}$gesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_${ri}$laset('A', m-nr, nr, zero, zero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_${ri}$laset( 'A',nr,n1-nr,zero,zero,u(1,nr+1), ldu )
                     call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_${ri}$ormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_${ri}$gesvd to r**t
                  ! .. copy r**t into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = (a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_${ri}$gesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_${ri}$laset('G', n, n-nr, zero, zero, v(1,nr+1), ldv)
                     call stdlib_${ri}$gesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                               lwork-n, info )
                     do p = 1, n
                        do q = p + 1, n
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                     end do
                     call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Dgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1, nr-1, zero, zero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_${ri}$gesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_${ri}$laset('G', n-nr, n, zero,zero, v(nr+1,1), ldv)
                      call stdlib_${ri}$gesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                lwork-n, info )
                      call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the transposed matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_${ri}$gesvd to r**t [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite [v], the nr right
                 ! singular vectors of r**t stored in [u](1:nr,1:nr) as transposed
                    call stdlib_${ri}$gesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                              lwork-n, info )
                    ! Assemble V
                    do p = 1, nr
                       do q = p + 1, nr
                          rtmp   = v(q,p)
                          v(q,p) = v(p,q)
                          v(p,q) = rtmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_${ri}$laset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'dgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_${ri}$laset('U',nr-1,nr-1, zero,zero, v(1,2),ldv)
                                  
                        call stdlib_${ri}$laset('A',n,n-nr,zero,zero,v(1,nr+1),ldv)
                        call stdlib_${ri}$gesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                                  lwork-n, info )
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = v(q,p)
                              v(q,p) = v(p,q)
                              v(p,q) = rtmp
                           end do
                        end do
                        call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = u(q,p)
                              u(q,p) = u(p,q)
                              u(p,q) = rtmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_${ri}$laset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_${ri}$laset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_${ri}$laset('A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**t into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_${ri}$laset('U',nr-1,nr-1,zero,zero,u(1,nr+2),ldu)
                                  
                        call stdlib_${ri}$geqrf( n, nr, u(1,nr+1), ldu, work(n+1),work(n+nr+1), lwork-&
                                  n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = u(p,nr+q)
                            end do
                        end do
                       if (nr>1) call stdlib_${ri}$laset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_${ri}$gesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, work(n+nr+1)&
                                 ,lwork-n-nr, info )
                       call stdlib_${ri}$laset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_${ri}$laset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_${ri}$laset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_${ri}$ormqr('R','C', n, n, nr, u(1,nr+1), ldu,work(n+1),v,ldv,work(&
                                 n+nr+1),lwork-n-nr,ierr)
                       call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_${ri}$laset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_${ri}$gesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1,nr-1, zero,zero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_${ri}$gesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_${ri}$laset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'dgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_${ri}$laset('L', nr-1,nr-1, zero,zero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_${ri}$laset('A', n-nr,n, zero,zero, v(nr+1,1),ldv)
                       call stdlib_${ri}$gesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                 lwork-n, info )
                       call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the transposed matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_${ri}$laset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_${ri}$laset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_${ri}$laset( 'A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_${ri}$laset('L',nr-1,nr-1,zero,zero,u(nr+2,1),ldu)
                                 
                       call stdlib_${ri}$gelqf( nr, n, u(nr+1,1), ldu, work(n+1),work(n+nr+1), lwork-n-&
                                 nr, ierr )
                       call stdlib_${ri}$lacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_${ri}$laset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_${ri}$gesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, work(n+nr+&
                                 1), lwork-n-nr, info )
                       call stdlib_${ri}$laset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_${ri}$laset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_${ri}$laset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_${ri}$ormlq('R','N',n,n,nr,u(nr+1,1),ldu,work(n+1),v, ldv, work(n+&
                                 nr+1),lwork-n-nr,ierr)
                       call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_${ri}$laset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**t or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_${ri}$ormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_${ri}$laset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_${ri}$lascl( 'G',0,0, one,sqrt(real(m,KIND=${rk}$)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_${ri}$gesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_${ri}$gesvdq


     pure subroutine stdlib_${ri}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! DGESVJ: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! DGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(${rk}$), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(${rk}$) :: fastr(5)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,sign,sqrt
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=${rk}$) )
              else
                 ctol = real( m,KIND=${rk}$)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_${ri}$lamch() works properly on the target machine.)
           epsln = stdlib_${ri}$lamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_${ri}$lamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_${ri}$lamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=${rk}$) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=${rk}$)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_${ri}$laset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl= one / sqrt( real( m,KIND=${rk}$)*real( n,KIND=${rk}$) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl= one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_${ri}$laset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_${ri}$lascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=${rk}$) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=${rk}$) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=${rk}$) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl= temp1*skl
           if( skl/=one ) then
              call stdlib_${ri}$lascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl= one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_${ri}$gesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_${ri}$gesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_${ri}$gsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ri}$gsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ri}$gsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_${ri}$gsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ri}$gsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_${ri}$gsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_${ri}$gsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_${ri}$gsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_${ri}$gsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_${ri}$gsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_${ri}$nrm2(m,a(1,p),1)
              ! as sqrt(stdlib_${ri}$dot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_${ri}$nrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_${ri}$nrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_${ri}$nrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_${ri}$lassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_${ri}$axpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_${ri}$axpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_${ri}$axpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${ri}$nrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ri}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=${rk}$) )*tol ) .and. ( real( n,&
                        KIND=${rk}$)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_${ri}$scal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_${ri}$scal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_${ri}$nrm2( mvl, v( 1, p ), 1 )
                    call stdlib_${ri}$scal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl) ) ).or. ( ( skl<one ) .and. ( sva( max(&
                      n2, 1 ) ) >( sfmin / skl) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl= one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=${rk}$)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=${rk}$)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=${rk}$)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_${ri}$gesvj


     subroutine stdlib_${ri}$gesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,equed, r, c, b, ldb, &
     !! DGESVX: uses the LU factorization to compute the solution to a real
     !! system of linear equations
     !! A * X = B,
     !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               x, ldx, rcond, ferr, berr,work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), af(ldaf,*), b(ldb,*), c(*), r(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: colequ, equil, nofact, notran, rowequ
           character :: norm
           integer(ilp) :: i, infequ, j
           real(${rk}$) :: amax, anorm, bignum, colcnd, rcmax, rcmin, rowcnd, rpvgrw, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           notran = stdlib_lsame( trans, 'N' )
           if( nofact .or. equil ) then
              equed = 'N'
              rowequ = .false.
              colequ = .false.
           else
              rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
              colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rowequ .or. colequ .or. stdlib_lsame( &
                     equed, 'N' ) ) ) then
              info = -10
           else
              if( rowequ ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, r( j ) )
                    rcmax = max( rcmax, r( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -11
                 else if( n>0 ) then
                    rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    rowcnd = one
                 end if
              end if
              if( colequ .and. info==0 ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, c( j ) )
                    rcmax = max( rcmax, c( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -12
                 else if( n>0 ) then
                    colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    colcnd = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -14
                 else if( ldx<max( 1, n ) ) then
                    info = -16
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_${ri}$geequ( n, n, a, lda, r, c, rowcnd, colcnd, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_${ri}$laqge( n, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                 rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
                 colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              end if
           end if
           ! scale the right hand side.
           if( notran ) then
              if( rowequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       b( i, j ) = r( i )*b( i, j )
                    end do
                 end do
              end if
           else if( colequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = c( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the lu factorization of a.
              call stdlib_${ri}$lacpy( 'FULL', n, n, a, lda, af, ldaf )
              call stdlib_${ri}$getrf( n, n, af, ldaf, ipiv, info )
              ! return if info is non-zero.
              if( info>0 ) then
                 ! compute the reciprocal pivot growth factor of the
                 ! leading rank-deficient info columns of a.
                 rpvgrw = stdlib_${ri}$lantr( 'M', 'U', 'N', info, info, af, ldaf,work )
                 if( rpvgrw==zero ) then
                    rpvgrw = one
                 else
                    rpvgrw = stdlib_${ri}$lange( 'M', n, info, a, lda, work ) / rpvgrw
                 end if
                 work( 1 ) = rpvgrw
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a and the
           ! reciprocal pivot growth factor rpvgrw.
           if( notran ) then
              norm = '1'
           else
              norm = 'I'
           end if
           anorm = stdlib_${ri}$lange( norm, n, n, a, lda, work )
           rpvgrw = stdlib_${ri}$lantr( 'M', 'U', 'N', n, n, af, ldaf, work )
           if( rpvgrw==zero ) then
              rpvgrw = one
           else
              rpvgrw = stdlib_${ri}$lange( 'M', n, n, a, lda, work ) / rpvgrw
           end if
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$gecon( norm, n, af, ldaf, anorm, rcond, work, iwork, info )
           ! compute the solution matrix x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$getrs( trans, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_${ri}$gerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, iwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( notran ) then
              if( colequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       x( i, j ) = c( i )*x( i, j )
                    end do
                 end do
                 do j = 1, nrhs
                    ferr( j ) = ferr( j ) / colcnd
                 end do
              end if
           else if( rowequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = r( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / rowcnd
              end do
           end if
           work( 1 ) = rpvgrw
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$gesvx


     pure subroutine stdlib_${ri}$getc2( n, a, lda, ipiv, jpiv, info )
     !! DGETC2: computes an LU factorization with complete pivoting of the
     !! n-by-n matrix A. The factorization has the form A = P * L * U * Q,
     !! where P and Q are permutation matrices, L is lower triangular with
     !! unit diagonal elements and U is upper triangular.
     !! This is the Level 2 BLAS algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*), jpiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ip, ipv, j, jp, jpv
           real(${rk}$) :: bignum, eps, smin, smlnum, xmax
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! handle the case n=1 by itself
           if( n==1 ) then
              ipiv( 1 ) = 1
              jpiv( 1 ) = 1
              if( abs( a( 1, 1 ) )<smlnum ) then
                 info = 1
                 a( 1, 1 ) = smlnum
              end if
              return
           end if
           ! factorize a using complete pivoting.
           ! set pivots less than smin to smin.
           loop_40: do i = 1, n - 1
              ! find max element in matrix a
              xmax = zero
              do ip = i, n
                 do jp = i, n
                    if( abs( a( ip, jp ) )>=xmax ) then
                       xmax = abs( a( ip, jp ) )
                       ipv = ip
                       jpv = jp
                    end if
                 end do
              end do
              if( i==1 )smin = max( eps*xmax, smlnum )
              ! swap rows
              if( ipv/=i )call stdlib_${ri}$swap( n, a( ipv, 1 ), lda, a( i, 1 ), lda )
              ipiv( i ) = ipv
              ! swap columns
              if( jpv/=i )call stdlib_${ri}$swap( n, a( 1, jpv ), 1, a( 1, i ), 1 )
              jpiv( i ) = jpv
              ! check for singularity
              if( abs( a( i, i ) )<smin ) then
                 info = i
                 a( i, i ) = smin
              end if
              do j = i + 1, n
                 a( j, i ) = a( j, i ) / a( i, i )
              end do
              call stdlib_${ri}$ger( n-i, n-i, -one, a( i+1, i ), 1, a( i, i+1 ), lda,a( i+1, i+1 ), &
                        lda )
           end do loop_40
           if( abs( a( n, n ) )<smin ) then
              info = n
              a( n, n ) = smin
           end if
           ! set last pivots to n
           ipiv( n ) = n
           jpiv( n ) = n
           return
     end subroutine stdlib_${ri}$getc2


     pure subroutine stdlib_${ri}$getf2( m, n, a, lda, ipiv, info )
     !! DGETF2: computes an LU factorization of a general m-by-n matrix A
     !! using partial pivoting with row interchanges.
     !! The factorization has the form
     !! A = P * L * U
     !! where P is a permutation matrix, L is lower triangular with unit
     !! diagonal elements (lower trapezoidal if m > n), and U is upper
     !! triangular (upper trapezoidal if m < n).
     !! This is the right-looking Level 2 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: sfmin
           integer(ilp) :: i, j, jp
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGETF2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch('S')
           do j = 1, min( m, n )
              ! find pivot and test for singularity.
              jp = j - 1 + stdlib_i${ri}$amax( m-j+1, a( j, j ), 1 )
              ipiv( j ) = jp
              if( a( jp, j )/=zero ) then
                 ! apply the interchange to columns 1:n.
                 if( jp/=j )call stdlib_${ri}$swap( n, a( j, 1 ), lda, a( jp, 1 ), lda )
                 ! compute elements j+1:m of j-th column.
                 if( j<m ) then
                    if( abs(a( j, j )) >= sfmin ) then
                       call stdlib_${ri}$scal( m-j, one / a( j, j ), a( j+1, j ), 1 )
                    else
                      do i = 1, m-j
                         a( j+i, j ) = a( j+i, j ) / a( j, j )
                      end do
                    end if
                 end if
              else if( info==0 ) then
                 info = j
              end if
              if( j<min( m, n ) ) then
                 ! update trailing submatrix.
                 call stdlib_${ri}$ger( m-j, n-j, -one, a( j+1, j ), 1, a( j, j+1 ), lda,a( j+1, j+1 ),&
                            lda )
              end if
           end do
           return
     end subroutine stdlib_${ri}$getf2


     pure subroutine stdlib_${ri}$getrf( m, n, a, lda, ipiv, info )
     !! DGETRF: computes an LU factorization of a general M-by-N matrix A
     !! using partial pivoting with row interchanges.
     !! The factorization has the form
     !! A = P * L * U
     !! where P is a permutation matrix, L is lower triangular with unit
     !! diagonal elements (lower trapezoidal if m > n), and U is upper
     !! triangular (upper trapezoidal if m < n).
     !! This is the right-looking Level 3 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iinfo, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGETRF', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'DGETRF', ' ', m, n, -1, -1 )
           if( nb<=1 .or. nb>=min( m, n ) ) then
              ! use unblocked code.
              call stdlib_${ri}$getrf2( m, n, a, lda, ipiv, info )
           else
              ! use blocked code.
              do j = 1, min( m, n ), nb
                 jb = min( min( m, n )-j+1, nb )
                 ! factor diagonal and subdiagonal blocks and test for exact
                 ! singularity.
                 call stdlib_${ri}$getrf2( m-j+1, jb, a( j, j ), lda, ipiv( j ), iinfo )
                 ! adjust info and the pivot indices.
                 if( info==0 .and. iinfo>0 )info = iinfo + j - 1
                 do i = j, min( m, j+jb-1 )
                    ipiv( i ) = j - 1 + ipiv( i )
                 end do
                 ! apply interchanges to columns 1:j-1.
                 call stdlib_${ri}$laswp( j-1, a, lda, j, j+jb-1, ipiv, 1 )
                 if( j+jb<=n ) then
                    ! apply interchanges to columns j+jb:n.
                    call stdlib_${ri}$laswp( n-j-jb+1, a( 1, j+jb ), lda, j, j+jb-1,ipiv, 1 )
                    ! compute block row of u.
                    call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT', jb,n-j-jb+1, one, &
                              a( j, j ), lda, a( j, j+jb ),lda )
                    if( j+jb<=m ) then
                       ! update trailing submatrix.
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m-j-jb+1,n-j-jb+1, jb, -&
                       one, a( j+jb, j ), lda,a( j, j+jb ), lda, one, a( j+jb, j+jb ),lda )
                                 
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$getrf


     pure recursive subroutine stdlib_${ri}$getrf2( m, n, a, lda, ipiv, info )
     !! DGETRF2: computes an LU factorization of a general M-by-N matrix A
     !! using partial pivoting with row interchanges.
     !! The factorization has the form
     !! A = P * L * U
     !! where P is a permutation matrix, L is lower triangular with unit
     !! diagonal elements (lower trapezoidal if m > n), and U is upper
     !! triangular (upper trapezoidal if m < n).
     !! This is the recursive version of the algorithm. It divides
     !! the matrix into four submatrices:
     !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
     !! A = [ -----|----- ]  with n1 = min(m,n)/2
     !! [  A21 | A22  ]       n2 = n-n1
     !! [ A11 ]
     !! The subroutine calls itself to factor [ --- ],
     !! [ A12 ]
     !! [ A12 ]
     !! do the swaps on [ --- ], solve A12, update A22,
     !! [ A22 ]
     !! then calls itself to factor A22 and do the swaps on A21.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: sfmin, temp
           integer(ilp) :: i, iinfo, n1, n2
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGETRF2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if ( m==1 ) then
              ! use unblocked code for one row case
              ! just need to handle ipiv and info
              ipiv( 1 ) = 1
              if ( a(1,1)==zero )info = 1
           else if( n==1 ) then
              ! use unblocked code for one column case
              ! compute machine safe minimum
              sfmin = stdlib_${ri}$lamch('S')
              ! find pivot and test for singularity
              i = stdlib_i${ri}$amax( m, a( 1, 1 ), 1 )
              ipiv( 1 ) = i
              if( a( i, 1 )/=zero ) then
                 ! apply the interchange
                 if( i/=1 ) then
                    temp = a( 1, 1 )
                    a( 1, 1 ) = a( i, 1 )
                    a( i, 1 ) = temp
                 end if
                 ! compute elements 2:m of the column
                 if( abs(a( 1, 1 )) >= sfmin ) then
                    call stdlib_${ri}$scal( m-1, one / a( 1, 1 ), a( 2, 1 ), 1 )
                 else
                    do i = 1, m-1
                       a( 1+i, 1 ) = a( 1+i, 1 ) / a( 1, 1 )
                    end do
                 end if
              else
                 info = 1
              end if
           else
              ! use recursive code
              n1 = min( m, n ) / 2
              n2 = n-n1
                     ! [ a11 ]
              ! factor [ --- ]
                     ! [ a21 ]
              call stdlib_${ri}$getrf2( m, n1, a, lda, ipiv, iinfo )
              if ( info==0 .and. iinfo>0 )info = iinfo
                                    ! [ a12 ]
              ! apply interchanges to [ --- ]
                                    ! [ a22 ]
              call stdlib_${ri}$laswp( n2, a( 1, n1+1 ), lda, 1, n1, ipiv, 1 )
              ! solve a12
              call stdlib_${ri}$trsm( 'L', 'L', 'N', 'U', n1, n2, one, a, lda,a( 1, n1+1 ), lda )
                        
              ! update a22
              call stdlib_${ri}$gemm( 'N', 'N', m-n1, n2, n1, -one, a( n1+1, 1 ), lda,a( 1, n1+1 ), &
                        lda, one, a( n1+1, n1+1 ), lda )
              ! factor a22
              call stdlib_${ri}$getrf2( m-n1, n2, a( n1+1, n1+1 ), lda, ipiv( n1+1 ),iinfo )
              ! adjust info and the pivot indices
              if ( info==0 .and. iinfo>0 )info = iinfo + n1
              do i = n1+1, min( m, n )
                 ipiv( i ) = ipiv( i ) + n1
              end do
              ! apply interchanges to a21
              call stdlib_${ri}$laswp( n1, a( 1, 1 ), lda, n1+1, min( m, n), ipiv, 1 )
           end if
           return
     end subroutine stdlib_${ri}$getrf2


     pure subroutine stdlib_${ri}$getri( n, a, lda, ipiv, work, lwork, info )
     !! DGETRI: computes the inverse of a matrix using the LU factorization
     !! computed by DGETRF.
     !! This method inverts U and then computes inv(A) by solving the system
     !! inv(A)*L = inv(U) for inv(A).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iws, j, jb, jj, jp, ldwork, lwkopt, nb, nbmin, nn
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'DGETRI', ' ', n, -1, -1, -1 )
           lwkopt = n*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( lda<max( 1, n ) ) then
              info = -3
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGETRI', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form inv(u).  if info > 0 from stdlib_${ri}$trtri, then u is singular,
           ! and the inverse is not computed.
           call stdlib_${ri}$trtri( 'UPPER', 'NON-UNIT', n, a, lda, info )
           if( info>0 )return
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = max( ldwork*nb, 1 )
              if( lwork<iws ) then
                 nb = lwork / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DGETRI', ' ', n, -1, -1, -1 ) )
              end if
           else
              iws = n
           end if
           ! solve the equation inv(a)*l = inv(u) for inv(a).
           if( nb<nbmin .or. nb>=n ) then
              ! use unblocked code.
              do j = n, 1, -1
                 ! copy current column of l to work and replace with zeros.
                 do i = j + 1, n
                    work( i ) = a( i, j )
                    a( i, j ) = zero
                 end do
                 ! compute current column of inv(a).
                 if( j<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n, n-j, -one, a( 1, j+1 ),lda, work( &
                           j+1 ), 1, one, a( 1, j ), 1 )
              end do
           else
              ! use blocked code.
              nn = ( ( n-1 ) / nb )*nb + 1
              do j = nn, 1, -nb
                 jb = min( nb, n-j+1 )
                 ! copy current block column of l to work and replace with
                 ! zeros.
                 do jj = j, j + jb - 1
                    do i = jj + 1, n
                       work( i+( jj-j )*ldwork ) = a( i, jj )
                       a( i, jj ) = zero
                    end do
                 end do
                 ! compute current block column of inv(a).
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n, jb,n-j-jb+1, -&
                           one, a( 1, j+jb ), lda,work( j+jb ), ldwork, one, a( 1, j ), lda )
                 call stdlib_${ri}$trsm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n, jb,one, work( j )&
                           , ldwork, a( 1, j ), lda )
              end do
           end if
           ! apply column interchanges.
           do j = n - 1, 1, -1
              jp = ipiv( j )
              if( jp/=j )call stdlib_${ri}$swap( n, a( 1, j ), 1, a( 1, jp ), 1 )
           end do
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$getri


     pure subroutine stdlib_${ri}$getrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! DGETRS: solves a system of linear equations
     !! A * X = B  or  A**T * X = B
     !! with a general N-by-N matrix A using the LU factorization computed
     !! by DGETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGETRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( notran ) then
              ! solve a * x = b.
              ! apply row interchanges to the right hand sides.
              call stdlib_${ri}$laswp( nrhs, b, ldb, 1, n, ipiv, 1 )
              ! solve l*x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n, nrhs,one, a, lda, b, &
                        ldb )
              ! solve u*x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n,nrhs, one, a, lda,&
                         b, ldb )
           else
              ! solve a**t * x = b.
              ! solve u**t *x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, nrhs,one, a, lda, b,&
                         ldb )
              ! solve l**t *x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'TRANSPOSE', 'UNIT', n, nrhs, one,a, lda, b, &
                        ldb )
              ! apply row interchanges to the solution vectors.
              call stdlib_${ri}$laswp( nrhs, b, ldb, 1, n, ipiv, -1 )
           end if
           return
     end subroutine stdlib_${ri}$getrs


     subroutine stdlib_${ri}$getsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
     !! DGETSLS: solves overdetermined or underdetermined real linear systems
     !! involving an M-by-N matrix A, using a tall skinny QR or short wide LQ
     !! factorization of A.  It is assumed that A has full rank.
     !! The following options are provided:
     !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A*X ||.
     !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
     !! an underdetermined system A * X = B.
     !! 3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
     !! an undetermined system A**T * X = B.
     !! 4. If TRANS = 'T' and m < n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A**T * X ||.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, tran
           integer(ilp) :: i, iascl, ibscl, j, maxmn, brow, scllen, tszo, tszm, lwo, lwm, lw1, &
                     lw2, wsizeo, wsizem, info2
           real(${rk}$) :: anrm, bignum, bnrm, smlnum, tq(5), workq(1)
           ! Intrinsic Functions 
           intrinsic :: real,max,min,int
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           maxmn = max( m, n )
           tran  = stdlib_lsame( trans, 'T' )
           lquery = ( lwork==-1 .or. lwork==-2 )
           if( .not.( stdlib_lsame( trans, 'N' ) .or.stdlib_lsame( trans, 'T' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldb<max( 1, m, n ) ) then
              info = -8
           end if
           if( info==0 ) then
           ! determine the optimum and minimum lwork
            if( m>=n ) then
              call stdlib_${ri}$geqr( m, n, a, lda, tq, -1, workq, -1, info2 )
              tszo = int( tq( 1 ),KIND=ilp)
              lwo  = int( workq( 1 ),KIND=ilp)
              call stdlib_${ri}$gemqr( 'L', trans, m, nrhs, n, a, lda, tq,tszo, b, ldb, workq, -1, &
                        info2 )
              lwo  = max( lwo, int( workq( 1 ),KIND=ilp) )
              call stdlib_${ri}$geqr( m, n, a, lda, tq, -2, workq, -2, info2 )
              tszm = int( tq( 1 ),KIND=ilp)
              lwm  = int( workq( 1 ),KIND=ilp)
              call stdlib_${ri}$gemqr( 'L', trans, m, nrhs, n, a, lda, tq,tszm, b, ldb, workq, -1, &
                        info2 )
              lwm = max( lwm, int( workq( 1 ),KIND=ilp) )
              wsizeo = tszo + lwo
              wsizem = tszm + lwm
            else
              call stdlib_${ri}$gelq( m, n, a, lda, tq, -1, workq, -1, info2 )
              tszo = int( tq( 1 ),KIND=ilp)
              lwo  = int( workq( 1 ),KIND=ilp)
              call stdlib_${ri}$gemlq( 'L', trans, n, nrhs, m, a, lda, tq,tszo, b, ldb, workq, -1, &
                        info2 )
              lwo  = max( lwo, int( workq( 1 ),KIND=ilp) )
              call stdlib_${ri}$gelq( m, n, a, lda, tq, -2, workq, -2, info2 )
              tszm = int( tq( 1 ),KIND=ilp)
              lwm  = int( workq( 1 ),KIND=ilp)
              call stdlib_${ri}$gemlq( 'L', trans, n, nrhs, m, a, lda, tq,tszm, b, ldb, workq, -1, &
                        info2 )
              lwm  = max( lwm, int( workq( 1 ),KIND=ilp) )
              wsizeo = tszo + lwo
              wsizem = tszm + lwm
            end if
            if( ( lwork<wsizem ).and.( .not.lquery ) ) then
               info = -10
            end if
            work( 1 ) = real( wsizeo,KIND=${rk}$)
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DGETSLS', -info )
             return
           end if
           if( lquery ) then
             if( lwork==-2 ) work( 1 ) = real( wsizem,KIND=${rk}$)
             return
           end if
           if( lwork<wsizeo ) then
             lw1 = tszm
             lw2 = lwm
           else
             lw1 = tszo
             lw2 = lwo
           end if
           ! quick return if possible
           if( min( m, n, nrhs )==0 ) then
                call stdlib_${ri}$laset( 'FULL', max( m, n ), nrhs, zero, zero,b, ldb )
                return
           end if
           ! get machine parameters
            smlnum = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'P' )
            bignum = one / smlnum
            call stdlib_${ri}$labad( smlnum, bignum )
           ! scale a, b if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, work )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_${ri}$laset( 'F', maxmn, nrhs, zero, zero, b, ldb )
              go to 50
           end if
           brow = m
           if ( tran ) then
             brow = n
           end if
           bnrm = stdlib_${ri}$lange( 'M', brow, nrhs, b, ldb, work )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, smlnum, brow, nrhs, b, ldb,info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bignum, brow, nrhs, b, ldb,info )
              ibscl = 2
           end if
           if ( m>=n ) then
              ! compute qr factorization of a
             call stdlib_${ri}$geqr( m, n, a, lda, work( lw2+1 ), lw1,work( 1 ), lw2, info )
             if ( .not.tran ) then
                 ! least-squares problem min || a * x - b ||
                 ! b(1:m,1:nrhs) := q**t * b(1:m,1:nrhs)
               call stdlib_${ri}$gemqr( 'L' , 'T', m, nrhs, n, a, lda,work( lw2+1 ), lw1, b, ldb, work(&
                          1 ), lw2,info )
                 ! b(1:n,1:nrhs) := inv(r) * b(1:n,1:nrhs)
               call stdlib_${ri}$trtrs( 'U', 'N', 'N', n, nrhs,a, lda, b, ldb, info )
               if( info>0 ) then
                 return
               end if
               scllen = n
             else
                 ! overdetermined system of equations a**t * x = b
                 ! b(1:n,1:nrhs) := inv(r**t) * b(1:n,1:nrhs)
                 call stdlib_${ri}$trtrs( 'U', 'T', 'N', n, nrhs,a, lda, b, ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(n+1:m,1:nrhs) = zero
                 do j = 1, nrhs
                    do i = n + 1, m
                       b( i, j ) = zero
                    end do
                 end do
                 ! b(1:m,1:nrhs) := q(1:n,:) * b(1:n,1:nrhs)
                 call stdlib_${ri}$gemqr( 'L', 'N', m, nrhs, n, a, lda,work( lw2+1 ), lw1, b, ldb, &
                           work( 1 ), lw2,info )
                 scllen = m
              end if
           else
              ! compute lq factorization of a
              call stdlib_${ri}$gelq( m, n, a, lda, work( lw2+1 ), lw1,work( 1 ), lw2, info )
              ! workspace at least m, optimally m*nb.
              if( .not.tran ) then
                 ! underdetermined system of equations a * x = b
                 ! b(1:m,1:nrhs) := inv(l) * b(1:m,1:nrhs)
                 call stdlib_${ri}$trtrs( 'L', 'N', 'N', m, nrhs,a, lda, b, ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(m+1:n,1:nrhs) = 0
                 do j = 1, nrhs
                    do i = m + 1, n
                       b( i, j ) = zero
                    end do
                 end do
                 ! b(1:n,1:nrhs) := q(1:n,:)**t * b(1:m,1:nrhs)
                 call stdlib_${ri}$gemlq( 'L', 'T', n, nrhs, m, a, lda,work( lw2+1 ), lw1, b, ldb, &
                           work( 1 ), lw2,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 scllen = n
              else
                 ! overdetermined system min || a**t * x - b ||
                 ! b(1:n,1:nrhs) := q * b(1:n,1:nrhs)
                 call stdlib_${ri}$gemlq( 'L', 'N', n, nrhs, m, a, lda,work( lw2+1 ), lw1, b, ldb, &
                           work( 1 ), lw2,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 ! b(1:m,1:nrhs) := inv(l**t) * b(1:m,1:nrhs)
                 call stdlib_${ri}$trtrs( 'LOWER', 'TRANSPOSE', 'NON-UNIT', m, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 scllen = m
              end if
           end if
           ! undo scaling
           if( iascl==1 ) then
             call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, scllen, nrhs, b, ldb,info )
           else if( iascl==2 ) then
             call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, scllen, nrhs, b, ldb,info )
           end if
           if( ibscl==1 ) then
             call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, bnrm, scllen, nrhs, b, ldb,info )
           else if( ibscl==2 ) then
             call stdlib_${ri}$lascl( 'G', 0, 0, bignum, bnrm, scllen, nrhs, b, ldb,info )
           end if
           50 continue
           work( 1 ) = real( tszo + lwo,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$getsls


     pure subroutine stdlib_${ri}$getsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )
     !! DGETSQRHRT: computes a NB2-sized column blocked QR-factorization
     !! of a real M-by-N matrix A with M >= N,
     !! A = Q * R.
     !! The routine uses internally a NB1-sized column blocked and MB1-sized
     !! row blocked TSQR-factorization and perfors the reconstruction
     !! of the Householder vectors from the TSQR output. The routine also
     !! converts the R_tsqr factor from the TSQR-factorization output into
     !! the R factor that corresponds to the Householder QR-factorization,
     !! A = Q_tsqr * R_tsqr = Q * R.
     !! The output Q and R factors are stored in the same format as in DGEQRT
     !! (Q is in blocked compact WY-representation). See the documentation
     !! of DGEQRT for more details on the format.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, lwork, m, n, nb1, nb2, mb1
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lw1, lw2, lwt, ldwt, lworkopt, nb1local, nb2local, &
                     num_all_row_blocks
           ! Intrinsic Functions 
           intrinsic :: ceiling,real,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery  = lwork==-1
           if( m<0 ) then
              info = -1
           else if( n<0 .or. m<n ) then
              info = -2
           else if( mb1<=n ) then
              info = -3
           else if( nb1<1 ) then
              info = -4
           else if( nb2<1 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldt<max( 1,  min( nb2, n ) ) ) then
              info = -9
           else
              ! test the input lwork for the dimension of the array work.
              ! this workspace is used to store array:
              ! a) matrix t and work for stdlib_${ri}$latsqr;
              ! b) n-by-n upper-triangular factor r_tsqr;
              ! c) matrix t and array work for stdlib_${ri}$orgtsqr_row;
              ! d) diagonal d for stdlib_${ri}$orhr_col.
              if( lwork<n*n+1 .and. .not.lquery ) then
                 info = -11
              else
                 ! set block size for column blocks
                 nb1local = min( nb1, n )
                 num_all_row_blocks = max( 1,ceiling( real( m - n,KIND=${rk}$) / real( mb1 - n,&
                           KIND=${rk}$) ) )
                 ! length and leading dimension of work array to place
                 ! t array in tsqr.
                 lwt = num_all_row_blocks * n * nb1local
                 ldwt = nb1local
                 ! length of tsqr work array
                 lw1 = nb1local * n
                 ! length of stdlib_${ri}$orgtsqr_row work array.
                 lw2 = nb1local * max( nb1local, ( n - nb1local ) )
                 lworkopt = max( lwt + lw1, max( lwt+n*n+lw2, lwt+n*n+n ) )
                 if( ( lwork<max( 1, lworkopt ) ).and.(.not.lquery) ) then
                    info = -11
                 end if
              end if
           end if
           ! handle error in the input parameters and return workspace query.
           if( info/=0 ) then
              call stdlib_xerbla( 'DGETSQRHRT', -info )
              return
           else if ( lquery ) then
              work( 1 ) = real( lworkopt,KIND=${rk}$)
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              work( 1 ) = real( lworkopt,KIND=${rk}$)
              return
           end if
           nb2local = min( nb2, n )
           ! (1) perform tsqr-factorization of the m-by-n matrix a.
           call stdlib_${ri}$latsqr( m, n, mb1, nb1local, a, lda, work, ldwt,work(lwt+1), lw1, iinfo )
                     
           ! (2) copy the factor r_tsqr stored in the upper-triangular part
               ! of a into the square matrix in the work array
               ! work(lwt+1:lwt+n*n) column-by-column.
           do j = 1, n
              call stdlib_${ri}$copy( j, a( 1, j ), 1, work( lwt + n*(j-1)+1 ), 1 )
           end do
           ! (3) generate a m-by-n matrix q with orthonormal columns from
           ! the result stored below the diagonal in the array a in place.
           call stdlib_${ri}$orgtsqr_row( m, n, mb1, nb1local, a, lda, work, ldwt,work( lwt+n*n+1 ), &
                     lw2, iinfo )
           ! (4) perform the reconstruction of householder vectors from
           ! the matrix q (stored in a) in place.
           call stdlib_${ri}$orhr_col( m, n, nb2local, a, lda, t, ldt,work( lwt+n*n+1 ), iinfo )
                     
           ! (5) copy the factor r_tsqr stored in the square matrix in the
           ! work array work(lwt+1:lwt+n*n) into the upper-triangular
           ! part of a.
           ! (6) compute from r_tsqr the factor r_hr corresponding to
           ! the reconstructed householder vectors, i.e. r_hr = s * r_tsqr.
           ! this multiplication by the sign matrix s on the left means
           ! changing the sign of i-th row of the matrix r_tsqr according
           ! to sign of the i-th diagonal element diag(i) of the matrix s.
           ! diag is stored in work( lwt+n*n+1 ) from the stdlib_${ri}$orhr_col output.
           ! (5) and (6) can be combined in a single loop, so the rows in a
           ! are accessed only once.
           do i = 1, n
              if( work( lwt+n*n+i )==-one ) then
                 do j = i, n
                    a( i, j ) = -one * work( lwt+n*(j-1)+i )
                 end do
              else
                 call stdlib_${ri}$copy( n-i+1, work(lwt+n*(i-1)+i), n, a( i, i ), lda )
              end if
           end do
           work( 1 ) = real( lworkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$getsqrhrt


     pure subroutine stdlib_${ri}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! DGGBAK: forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! DGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: lscale(*), rscale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           intrinsic :: max,int
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_${ri}$scal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_${ri}$scal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_${ri}$ggbak


     pure subroutine stdlib_${ri}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! DGGBAL: balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sclfac = 1.0e+1_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(${rk}$) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,log10,max,min,sign
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_${ri}$swap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_${ri}$swap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_${ri}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ri}$swap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=${rk}$)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_${ri}$dot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_${ri}$dot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_${ri}$scal( nr, beta, work( ilo ), 1 )
           call stdlib_${ri}$scal( nr, beta, work( ilo+n ), 1 )
           call stdlib_${ri}$axpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_${ri}$axpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=${rk}$)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=${rk}$)*work( j ) + sum
           end do
           sum = stdlib_${ri}$dot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_${ri}$dot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_${ri}$axpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_${ri}$axpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_${ri}$lamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_i${ri}$amax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_i${ri}$amax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_i${ri}$amax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_i${ri}$amax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_${ri}$scal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_${ri}$scal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_${ri}$scal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_${ri}$scal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ri}$ggbal


     subroutine stdlib_${ri}$gges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
     !! DGGES: computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! DGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_${ri}$) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dif(2)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0 )then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
              else
                 minwrk = 1
                 maxwrk = 1
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n space for storing balancing factors)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_${ri}$gghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_${ri}$hgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: need 4*n+16 )
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_${ri}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gges


     subroutine stdlib_${ri}$gges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
     !! DGGES3: computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! DGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_${ri}$) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, lwkopt
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dif(2)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           else if( lwork<6*n+16 .and. .not.lquery ) then
              info = -19
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_${ri}$geqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 6*n+16, 3*n+int( work ( 1 ),KIND=ilp) )
              call stdlib_${ri}$ormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_${ri}$orgqr( n, n, n, vsl, ldvsl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              end if
              call stdlib_${ri}$gghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              call stdlib_${ri}$laqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                        beta, vsl, ldvsl, vsr, ldvsr,work, -1, 0, ierr )
              lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_${ri}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
                 beta, vsl, ldvsl, vsr, ldvsr,sdim, pvsl, pvsr, dif, work, -1, idum, 1,ierr )
                           
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_${ri}$gghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk,ierr )
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_${ri}$laqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta if desired
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_${ri}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$gges3


     subroutine stdlib_${ri}$ggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     !! DGGESX: computes for a pair of N-by-N real nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2), rcondv(2), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_${ri}$) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, wantsb, &
                     wantse, wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, ip, iright, &
                     irows, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           real(${rk}$) :: dif(2)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -16
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -18
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 6
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -22
              else if( liwork<liwmin  .and. .not.lquery ) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n for permutation parameters)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_${ri}$gghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_${ri}$hgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 60
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           ! (workspace: if ijob >= 1, need max( 8*(n+1), 2*sdim*(n-sdim) )
                       ! otherwise, need 8*(n+1) )
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              call stdlib_${ri}$tgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
              beta, vsl, ldvsl, vsr, ldvsr,sdim, pl, pr, dif, work( iwrk ), lwork-iwrk+1,iwork, &
                        liwork, ierr )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-22 ) then
                  ! not enough real workspace
                 info = -22
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           60 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$ggesx


     subroutine stdlib_${ri}$ggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
     !! DGGEV: computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
               ldvr, work, lwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, maxwrk, minwrk
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              minwrk = max( 1, 8*n )
              maxwrk = max( 1, n*( 7 +stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 ) ) )
              maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, 0 ) ) )
                        
              if( ilvl ) then
                 maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, -1 ) ) )
                           
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (workspace: need 6*n)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ri}$gghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_${ri}$gghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ri}$hgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           ! (workspace: need 6*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_${ri}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$ggev


     subroutine stdlib_${ri}$ggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
     !! DGGEV3: computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
                ldvr, work, lwork,info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, lwkopt
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           else if( lwork<max( 1, 8*n ) .and. .not.lquery ) then
              info = -16
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_${ri}$geqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max(1, 8*n, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_${ri}$ormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work, -1,ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_${ri}$orgqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_${ri}$gghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
                 call stdlib_${ri}$laqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              else
                 call stdlib_${ri}$gghd3( 'N', 'N', n, 1, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, work, -&
                           1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
                 call stdlib_${ri}$laqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ri}$gghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk, ierr )
           else
              call stdlib_${ri}$gghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ri}$laqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_${ri}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ggev3


     subroutine stdlib_${ri}$ggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     !! DGGEVX: computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${rk}$), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, pair, wantsb, wantse, &
                     wantsn, wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk, mm
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc,'S' ) .or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -14
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 if( noscl .and. .not.ilv ) then
                    minwrk = 2*n
                 else
                    minwrk = 6*n
                 end if
                 if( wantse .or. wantsb ) then
                    minwrk = 10*n
                 end if
                 if( wantsv .or. wantsb ) then
                    minwrk = max( minwrk, 2*n*( n + 4 ) + 16 )
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -26
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_${ri}$ggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,work, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_${ri}$lange( '1', n, n, a, lda, work( 1 ) )
           if( ilascl ) then
              work( 1 ) = abnrm
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, 1, 1, work( 1 ), 1,ierr )
              abnrm = work( 1 )
           end if
           bbnrm = stdlib_${ri}$lange( '1', n, n, b, ldb, work( 1 ) )
           if( ilbscl ) then
              work( 1 ) = bbnrm
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, work( 1 ), 1,ierr )
              bbnrm = work( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ri}$gghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_${ri}$gghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ri}$hgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr, work,lwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 130
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! (workspace: stdlib_${ri}$tgevc: need 6*n
                       ! stdlib_${ri}$tgsna: need 2*n*(n+2)+16 if sense = 'v' or 'b',
                               ! need n otherwise )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_${ri}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work, ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 130
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_${ri}$tgevc) and estimate condition
                 ! numbers (stdlib_${ri}$tgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to recalculate
                 ! eigenvectors and estimate one condition numbers at a time.
                 pair = .false.
                 loop_20: do i = 1, n
                    if( pair ) then
                       pair = .false.
                       cycle loop_20
                    end if
                    mm = 1
                    if( i<n ) then
                       if( a( i+1, i )/=zero ) then
                          pair = .true.
                          mm = 2
                       end if
                    end if
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    if( mm==1 ) then
                       bwork( i ) = .true.
                    else if( mm==2 ) then
                       bwork( i ) = .true.
                       bwork( i+1 ) = .true.
                    end if
                    iwrk = mm*n + 1
                    iwrk1 = iwrk + mm*n
                    ! compute a pair of left and right eigenvectors.
                    ! (compute workspace: need up to 4*n + 6*n)
                    if( wantse .or. wantsb ) then
                       call stdlib_${ri}$tgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, mm, m,work( iwrk1 ), ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 130
                       end if
                    end if
                    call stdlib_${ri}$tgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), mm, m, work( iwrk1 ),lwork-iwrk1+1, iwork,&
                               ierr )
                 end do loop_20
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_${ri}$ggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_70: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_70
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_70
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                       vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_70
           end if
           if( ilvr ) then
              call stdlib_${ri}$ggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_120: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_120
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_120
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                       vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_120
           end if
           ! undo scaling if necessary
           130 continue
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$ggevx


     pure subroutine stdlib_${ri}$ggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! DGGGLM: solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(${rk}$), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = zero
              end do
              do i = 1, p
                 y(i) = zero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**t*a = ( r11 ) m,    q**t*b*z**t = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_${ri}$ggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = work( m+np+1 )
           ! update left-hand-side vector d = q**t*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', n, 1, m, a, lda, work, d,max( 1, n ), work( m+&
                     np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_${ri}$copy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = zero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_${ri}$gemv( 'NO TRANSPOSE', m, n-m, -one, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1, &
                     one, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_${ri}$copy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**t *y
           call stdlib_${ri}$ormrq( 'LEFT', 'TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), ldb, work( &
                     m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ri}$ggglm


     pure subroutine stdlib_${ri}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHD3: reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of DGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(${rk}$) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           intrinsic :: real,max
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_${ri}$laset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_${ri}$laset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_${ri}$laset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'DGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'DGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_${ri}$laset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_${ri}$laset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_${ri}$lartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_${ri}$lartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_${ri}$rot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_${ri}$lasr.
                     ! call stdlib_${ri}$lasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_${ri}$rot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_${ri}$gemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_${ri}$gemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_${ri}$trmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_${ri}$gemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_${ri}$gemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_${ri}$lacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_${ri}$orm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_${ri}$lacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_${ri}$lacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_${ri}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_${ri}$laset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_${ri}$laset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_${ri}$laset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_${ri}$lacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_${ri}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_${ri}$lacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_${ri}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_${ri}$lacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_${ri}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_${ri}$gghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$gghd3


     pure subroutine stdlib_${ri}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHRD: reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(${rk}$) :: c, s, temp
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_${ri}$lartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_${ri}$rot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_${ri}$rot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_${ri}$rot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_${ri}$lartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_${ri}$rot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_${ri}$rot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_${ri}$rot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_${ri}$gghrd


     pure subroutine stdlib_${ri}$gglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! DGGLSE: solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(${rk}$), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**t = (  0  t12 ) p   z**t*a*q**t = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_${ri}$ggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = work( p+mn+1 )
           ! update c = z**t *c = ( c1 ) n-p
                                ! ( c2 ) m+p-n
           call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', m, 1, mn, a, lda, work( p+1 ),c, max( 1, m ), &
                     work( p+mn+1 ), lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
              call stdlib_${ri}$copy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-p, p, -one, a( 1, n-p+1 ), lda,d, 1, one, c, 1 &
                        )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_${ri}$copy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', nr, n-m, -one, a( n-p+1, m+1 ),lda, d( &
                        nr+1 ), 1, one, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_${ri}$axpy( nr, -one, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**t*x
           call stdlib_${ri}$ormrq( 'LEFT', 'TRANSPOSE', n, 1, p, b, ldb, work( 1 ), x,n, work( p+mn+1 &
                     ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ri}$gglse


     pure subroutine stdlib_${ri}$ggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )
     !! DGGQRF: computes a generalized QR factorization of an N-by-M matrix A
     !! and an N-by-P matrix B:
     !! A = Q*R,        B = Q*T*Z,
     !! where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
     !! matrix, and R and T assume one of the forms:
     !! if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
     !! (  0  ) N-M                         N   M-N
     !! M
     !! where R11 is upper triangular, and
     !! if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
     !! P-N  N                           ( T21 ) P
     !! P
     !! where T12 or T21 is upper triangular.
     !! In particular, if B is square and nonsingular, the GQR factorization
     !! of A and B implicitly gives the QR factorization of inv(B)*A:
     !! inv(B)*A = Z**T*(inv(T)*R)
     !! where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
     !! transpose of the matrix Z.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: taua(*), taub(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkopt, nb, nb1, nb2, nb3
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', n, m, -1, -1 )
           nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', n, p, -1, -1 )
           nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', n, m, p, -1 )
           nb = max( nb1, nb2, nb3 )
           lwkopt = max( n, m, p )*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( p<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, n, m, p ) .and. .not.lquery ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGQRF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! qr factorization of n-by-m matrix a: a = q*r
           call stdlib_${ri}$geqrf( n, m, a, lda, taua, work, lwork, info )
           lopt = work( 1 )
           ! update b := q**t*b.
           call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', n, p, min( n, m ), a, lda, taua,b, ldb, work, &
                     lwork, info )
           lopt = max( lopt, int( work( 1 ),KIND=ilp) )
           ! rq factorization of n-by-p matrix b: b = t*z.
           call stdlib_${ri}$gerqf( n, p, b, ldb, taub, work, lwork, info )
           work( 1 ) = max( lopt, int( work( 1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ri}$ggqrf


     pure subroutine stdlib_${ri}$ggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )
     !! DGGRQF: computes a generalized RQ factorization of an M-by-N matrix A
     !! and a P-by-N matrix B:
     !! A = R*Q,        B = Z*T*Q,
     !! where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
     !! matrix, and R and T assume one of the forms:
     !! if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
     !! N-M  M                           ( R21 ) N
     !! N
     !! where R12 or R21 is upper triangular, and
     !! if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
     !! (  0  ) P-N                         P   N-P
     !! N
     !! where T11 is upper triangular.
     !! In particular, if B is square and nonsingular, the GRQ factorization
     !! of A and B implicitly gives the RQ factorization of A*inv(B):
     !! A*inv(B) = (R*inv(T))*Z**T
     !! where inv(B) denotes the inverse of the matrix B, and Z**T denotes the
     !! transpose of the matrix Z.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: taua(*), taub(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkopt, nb, nb1, nb2, nb3
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           nb1 = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
           nb2 = stdlib_ilaenv( 1, 'DGEQRF', ' ', p, n, -1, -1 )
           nb3 = stdlib_ilaenv( 1, 'DORMRQ', ' ', m, n, p, -1 )
           nb = max( nb1, nb2, nb3 )
           lwkopt = max( n, m, p )*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( p<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -8
           else if( lwork<max( 1, m, p, n ) .and. .not.lquery ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGRQF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! rq factorization of m-by-n matrix a: a = r*q
           call stdlib_${ri}$gerqf( m, n, a, lda, taua, work, lwork, info )
           lopt = work( 1 )
           ! update b := b*q**t
           call stdlib_${ri}$ormrq( 'RIGHT', 'TRANSPOSE', p, n, min( m, n ),a( max( 1, m-n+1 ), 1 ), &
                     lda, taua, b, ldb, work,lwork, info )
           lopt = max( lopt, int( work( 1 ),KIND=ilp) )
           ! qr factorization of p-by-n matrix b: b = z*t
           call stdlib_${ri}$geqrf( p, n, b, ldb, taub, work, lwork, info )
           work( 1 ) = max( lopt, int( work( 1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ri}$ggrqf


     pure subroutine stdlib_${ri}$gsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
     !! DGSVJ0: is called from DGESVJ as a pre-processor and that is its main
     !! purpose. It applies Jacobi rotations in the same way as DGESVJ does, but
     !! it does not check convergence (stopping criterion). Few tuning
     !! parameters (marked by [TP]) are available for the implementer.
               nsweep, work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(${rk}$), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), sva(n), d(n), v(ldv,*)
           real(${rk}$), intent(out) :: work(lwork)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, mxaapq, mxsinj, &
                     rootbig, rooteps, rootsfmin, roottol, small, sn, t, temp1, theta, thsign
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, rotok, rsvec
           ! Local Arrays 
           real(${rk}$) :: fastr(5)
           ! Intrinsic Functions 
           intrinsic :: abs,max,real,min,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           applv = stdlib_lsame( jobv, 'A' )
           rsvec = stdlib_lsame( jobv, 'V' )
           if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -3
           else if( lda<m ) then
              info = -5
           else if( ( rsvec.or.applv ) .and. ( mv<0 ) ) then
              info = -8
           else if( ( rsvec.and.( ldv<n ) ).or.( applv.and.( ldv<mv ) ) ) then
              info = -10
           else if( tol<=eps ) then
              info = -13
           else if( nsweep<0 ) then
              info = -14
           else if( lwork<m ) then
              info = -16
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGSVJ0', -info )
              return
           end if
           if( rsvec ) then
              mvl = n
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           rooteps = sqrt( eps )
           rootsfmin = sqrt( sfmin )
           small = sfmin / eps
           big = one / sfmin
           rootbig = one / rootsfmin
           bigtheta = one / rooteps
           roottol = sqrt( tol )
           ! -#- row-cyclic jacobi svd algorithm with column pivoting -#-
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! -#- row-cyclic pivot strategy with de rijk's pivoting -#-
           swband = 0
      ! [tp] swband is a tuning parameter. it is meaningful and effective
           ! if stdlib_dgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_dgesvj. for sweeps i=1:swband the procedure
           ! ......
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = ( kbl**2 ) + 1
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           swband = 0
           pskipped = 0
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = d( p )
                          d( p ) = d( q )
                          d( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! some blas implementations compute stdlib_${ri}$nrm2(m,a(1,p),1)
              ! as sqrt(stdlib_${ri}$dot(m,a(1,p),1,a(1,p),1)), which may result in
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_${ri}$nrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_${ri}$nrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_${ri}$nrm2( m, a(1,p), 1 ) * d(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*d( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_${ri}$lassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*d( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*d( p )&
                                                *d( q ) / aaqq )/ aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, d( p ),m, 1, work, lda,&
                                                 ierr )
                                      aapq = stdlib_${ri}$dot( m, work, 1, a( 1, q ),1 )*d( q ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*d( p )&
                                                *d( q ) / aaqq )/ aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, d( q ),m, 1, work, lda,&
                                                 ierr )
                                      aapq = stdlib_${ri}$dot( m, work, 1, a( 1, p ),1 )*d( p ) / &
                                                aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
                 ! rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*d( p ) / d( q )
                                         fastr( 4 ) = -t*d( q ) / d( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = d( p ) / d( q )
                                         aqoap = d( q ) / d( p )
                                         if( d( p )>=one ) then
                                            if( d( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               d( p ) = d( p )*cs
                                               d( q ) = d( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               d( p ) = d( p )*cs
                                               d( q ) = d( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( d( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               d( p ) = d( p ) / cs
                                               d( q ) = d( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( d( p )>=d( q ) ) then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  d( p ) = d( p )*cs
                                                  d( q ) = d( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  d( p ) = d( p ) / cs
                                                  d( q ) = d( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one, m,1, work, lda, &
                                                ierr )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*d( p ) / d( q )
                                      call stdlib_${ri}$axpy( m, temp1, work, 1,a( 1, q ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*d( q )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*d( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*d( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*d( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
      ! ........................................................
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! -#- m x 2 jacobi svd -#-
              ! -#- safe gram matrix computation -#-
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*d( p )&
                                                *d( q ) / aaqq )/ aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, d( p ),m, 1, work, lda,&
                                                 ierr )
                                      aapq = stdlib_${ri}$dot( m, work, 1, a( 1, q ),1 )*d( q ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*d( p )&
                                                *d( q ) / aaqq )/ aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, d( q ),m, 1, work, lda,&
                                                 ierr )
                                      aapq = stdlib_${ri}$dot( m, work, 1, a( 1, p ),1 )*d( p ) / &
                                                aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
                 ! rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*d( p ) / d( q )
                                         fastr( 4 ) = -t*d( q ) / d( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = d( p ) / d( q )
                                         aqoap = d( q ) / d( p )
                                         if( d( p )>=one ) then
                                            if( d( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               d( p ) = d( p )*cs
                                               d( q ) = d( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               d( p ) = d( p )*cs
                                               d( q ) = d( q ) / cs
                                            end if
                                         else
                                            if( d( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               d( p ) = d( p ) / cs
                                               d( q ) = d( q )*cs
                                            else
                                               if( d( p )>=d( q ) ) then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  d( p ) = d( p )*cs
                                                  d( q ) = d( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  d( p ) = d( p ) / cs
                                                  d( q ) = d( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_${ri}$copy( m, a( 1, p ), 1, work,1 )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, work, lda,&
                                                    ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*d( p ) / d( q )
                                         call stdlib_${ri}$axpy( m, temp1, work, 1,a( 1, q ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_${ri}$copy( m, a( 1, q ), 1, work,1 )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, work, lda,&
                                                    ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*d( q ) / d( p )
                                         call stdlib_${ri}$axpy( m, temp1, work, 1,a( 1, p ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*d( q )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*d( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*d( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*d( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${ri}$nrm2( m, a( 1, n ), 1 )*d( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ri}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*d( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<real( n,KIND=${rk}$)*tol ) .and.( real( n,KIND=${rk}$)&
                        *mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:) reaching this point means that the procedure has completed the given
           ! number of iterations.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means that during the i-th sweep all pivots were
           ! below the given tolerance, causing early exit.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the vector d.
           do p = 1, n - 1
              q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = d( p )
                 d( p ) = d( q )
                 d( q ) = temp1
                 call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
           end do
           return
     end subroutine stdlib_${ri}$gsvj0


     pure subroutine stdlib_${ri}$gsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
     !! DGSVJ1: is called from DGESVJ as a pre-processor and that is its main
     !! purpose. It applies Jacobi rotations in the same way as DGESVJ does, but
     !! it targets only particular pivots and it does not check convergence
     !! (stopping criterion). Few tuning parameters (marked by [TP]) are
     !! available for the implementer.
     !! Further Details
     !! ~~~~~~~~~~~~~~~
     !! DGSVJ1 applies few sweeps of Jacobi rotations in the column space of
     !! the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
     !! off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
     !! block-entries (tiles) of the (1,2) off-diagonal block are marked by the
     !! [x]'s in the following scheme:
     !! | *  *  * [x] [x] [x]|
     !! | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
     !! | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
     !! |[x] [x] [x] *  *  * |
     !! |[x] [x] [x] *  *  * |
     !! |[x] [x] [x] *  *  * |
     !! In terms of the columns of A, the first N1 columns are rotated 'against'
     !! the remaining N-N1 columns, trying to increase the angle between the
     !! corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
     !! tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
     !! The number of sweeps is given in NSWEEP and the orthogonality threshold
     !! is given in TOL.
               nsweep, work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: eps, sfmin, tol
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), d(n), sva(n), v(ldv,*)
           real(${rk}$), intent(out) :: work(lwork)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, large, mxaapq, &
           mxsinj, rootbig, rooteps, rootsfmin, roottol, small, sn, t, temp1, theta, &
                     thsign
           integer(ilp) :: blskip, emptsw, i, ibr, igl, ierr, ijblsk, iswrot, jbc, jgl, kbl, mvl, &
                     notrot, nblc, nblr, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, rotok, rsvec
           ! Local Arrays 
           real(${rk}$) :: fastr(5)
           ! Intrinsic Functions 
           intrinsic :: abs,max,real,min,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           applv = stdlib_lsame( jobv, 'A' )
           rsvec = stdlib_lsame( jobv, 'V' )
           if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -3
           else if( n1<0 ) then
              info = -4
           else if( lda<m ) then
              info = -6
           else if( ( rsvec.or.applv ) .and. ( mv<0 ) ) then
              info = -9
           else if( ( rsvec.and.( ldv<n ) ).or.( applv.and.( ldv<mv ) )  ) then
              info = -11
           else if( tol<=eps ) then
              info = -14
           else if( nsweep<0 ) then
              info = -15
           else if( lwork<m ) then
              info = -17
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGSVJ1', -info )
              return
           end if
           if( rsvec ) then
              mvl = n
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           rooteps = sqrt( eps )
           rootsfmin = sqrt( sfmin )
           small = sfmin / eps
           big = one / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=${rk}$) )
           bigtheta = one / rooteps
           roottol = sqrt( tol )
           ! Initialize The Right Singular Vector Matrix 
           ! rsvec = stdlib_lsame( jobv, 'y' )
           emptsw = n1*( n-n1 )
           notrot = 0
           fastr( 1 ) = zero
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           kbl = min( 8, n )
           nblr = n1 / kbl
           if( ( nblr*kbl )/=n1 )nblr = nblr + 1
           ! .. the tiling is nblr-by-nblc [tiles]
           nblc = ( n-n1 ) / kbl
           if( ( nblc*kbl )/=( n-n1 ) )nblc = nblc + 1
           blskip = ( kbl**2 ) + 1
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           swband = 0
      ! [tp] swband is a tuning parameter. it is meaningful and effective
           ! if stdlib_dgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_dgesvj.
           ! | *   *   * [x] [x] [x]|
           ! | *   *   * [x] [x] [x]|    row-cycling in the nblr-by-nblc [x] blocks.
           ! | *   *   * [x] [x] [x]|    row-cyclic pivoting inside each [x] block.
           ! |[x] [x] [x] *   *   * |
           ! |[x] [x] [x] *   *   * |
           ! |[x] [x] [x] *   *   * |
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
              loop_2000: do ibr = 1, nblr
                 igl = ( ibr-1 )*kbl + 1
      ! ........................................................
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = 1, nblc
                    jgl = n1 + ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n1 )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! Safe Gram Matrix Computation 
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*d( p )&
                                                *d( q ) / aaqq )/ aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, d( p ),m, 1, work, lda,&
                                                 ierr )
                                      aapq = stdlib_${ri}$dot( m, work, 1, a( 1, q ),1 )*d( q ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*d( p )&
                                                *d( q ) / aaqq )/ aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1, work, 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, d( q ),m, 1, work, lda,&
                                                 ierr )
                                      aapq = stdlib_${ri}$dot( m, work, 1, a( 1, p ),1 )*d( p ) / &
                                                aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
                 ! rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq) / aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*d( p ) / d( q )
                                         fastr( 4 ) = -t*d( q ) / d( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = d( p ) / d( q )
                                         aqoap = d( q ) / d( p )
                                         if( d( p )>=one ) then
                                            if( d( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               d( p ) = d( p )*cs
                                               d( q ) = d( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               d( p ) = d( p )*cs
                                               d( q ) = d( q ) / cs
                                            end if
                                         else
                                            if( d( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               d( p ) = d( p ) / cs
                                               d( q ) = d( q )*cs
                                            else
                                               if( d( p )>=d( q ) ) then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  d( p ) = d( p )*cs
                                                  d( q ) = d( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  d( p ) = d( p ) / cs
                                                  d( q ) = d( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_${ri}$copy( m, a( 1, p ), 1, work,1 )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, work, lda,&
                                                    ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*d( p ) / d( q )
                                         call stdlib_${ri}$axpy( m, temp1, work, 1,a( 1, q ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_${ri}$copy( m, a( 1, q ), 1, work,1 )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, work, lda,&
                                                    ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*d( q ) / d( p )
                                         call stdlib_${ri}$axpy( m, temp1, work, 1,a( 1, p ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*d( q )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*d( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*d( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*d( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
                 ! skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
            ! if ( notrot >= emptsw )  go to 2011
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
      ! **      if ( notrot >= emptsw )  go to 2011
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **   if ( notrot >= emptsw ) go to 1994
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${ri}$nrm2( m, a( 1, n ), 1 )*d( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ri}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*d( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<real( n,KIND=${rk}$)*tol ) .and.( real( n,KIND=${rk}$)&
                        *mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:) reaching this point means that the procedure has completed the given
           ! number of sweeps.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means that during the i-th sweep all pivots were
           ! below the given threshold, causing early exit.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the vector d
           do p = 1, n - 1
              q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = d( p )
                 d( p ) = d( q )
                 d( q ) = temp1
                 call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
           end do
           return
     end subroutine stdlib_${ri}$gsvj1


     pure subroutine stdlib_${ri}$gtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, info &
     !! DGTCON: estimates the reciprocal of the condition number of a real
     !! tridiagonal matrix A using the LU factorization as computed by
     !! DGTTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), dl(*), du(*), du2(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: onenrm
           integer(ilp) :: i, kase, kase1
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGTCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           ! check that d(1:n) is non-zero.
           do i = 1, n
              if( d( i )==zero )return
           end do
           ainvnm = zero
           if( onenrm ) then
              kase1 = 1
           else
              kase1 = 2
           end if
           kase = 0
           20 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==kase1 ) then
                 ! multiply by inv(u)*inv(l).
                 call stdlib_${ri}$gttrs( 'NO TRANSPOSE', n, 1, dl, d, du, du2, ipiv,work, n, info )
                           
              else
                 ! multiply by inv(l**t)*inv(u**t).
                 call stdlib_${ri}$gttrs( 'TRANSPOSE', n, 1, dl, d, du, du2, ipiv, work,n, info )
                           
              end if
              go to 20
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$gtcon


     pure subroutine stdlib_${ri}$gtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, x, &
     !! DGTRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is tridiagonal, and provides
     !! error bounds and backward error estimates for the solution.
               ldx, ferr, berr, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: b(ldb,*), d(*), df(*), dl(*), dlf(*), du(*), du2(*), duf(*)
                     
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           ! Local Scalars 
           logical(lk) :: notran
           character :: transn, transt
           integer(ilp) :: count, i, j, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -13
           else if( ldx<max( 1, n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGTRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'T'
           else
              transn = 'T'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = 4
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_110: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$lagtm( trans, n, 1, -one, dl, d, du, x( 1, j ), ldx, one,work( n+1 ), &
                        n )
              ! compute abs(op(a))*abs(x) + abs(b) for use in the backward
              ! error bound.
              if( notran ) then
                 if( n==1 ) then
                    work( 1 ) = abs( b( 1, j ) ) + abs( d( 1 )*x( 1, j ) )
                 else
                    work( 1 ) = abs( b( 1, j ) ) + abs( d( 1 )*x( 1, j ) ) +abs( du( 1 )*x( 2, j )&
                               )
                    do i = 2, n - 1
                       work( i ) = abs( b( i, j ) ) +abs( dl( i-1 )*x( i-1, j ) ) +abs( d( i )*x( &
                                 i, j ) ) +abs( du( i )*x( i+1, j ) )
                    end do
                    work( n ) = abs( b( n, j ) ) +abs( dl( n-1 )*x( n-1, j ) ) +abs( d( n )*x( n, &
                              j ) )
                 end if
              else
                 if( n==1 ) then
                    work( 1 ) = abs( b( 1, j ) ) + abs( d( 1 )*x( 1, j ) )
                 else
                    work( 1 ) = abs( b( 1, j ) ) + abs( d( 1 )*x( 1, j ) ) +abs( dl( 1 )*x( 2, j )&
                               )
                    do i = 2, n - 1
                       work( i ) = abs( b( i, j ) ) +abs( du( i-1 )*x( i-1, j ) ) +abs( d( i )*x( &
                                 i, j ) ) +abs( dl( i )*x( i+1, j ) )
                    end do
                    work( n ) = abs( b( n, j ) ) +abs( du( n-1 )*x( n-1, j ) ) +abs( d( n )*x( n, &
                              j ) )
                 end if
              end if
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$gttrs( trans, n, 1, dlf, df, duf, du2, ipiv,work( n+1 ), n, info )
                           
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              70 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**t).
                    call stdlib_${ri}$gttrs( transt, n, 1, dlf, df, duf, du2, ipiv,work( n+1 ), n, &
                              info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$gttrs( transn, n, 1, dlf, df, duf, du2, ipiv,work( n+1 ), n, &
                              info )
                 end if
                 go to 70
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_110
           return
     end subroutine stdlib_${ri}$gtrfs


     pure subroutine stdlib_${ri}$gtsv( n, nrhs, dl, d, du, b, ldb, info )
     !! DGTSV:  solves the equation
     !! A*X = B,
     !! where A is an n by n tridiagonal matrix, by Gaussian elimination with
     !! partial pivoting.
     !! Note that the equation  A**T*X = B  may be solved by interchanging the
     !! order of the arguments DU and DL.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: b(ldb,*), d(*), dl(*), du(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: fact, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGTSV ', -info )
              return
           end if
           if( n==0 )return
           if( nrhs==1 ) then
              loop_10: do i = 1, n - 2
                 if( abs( d( i ) )>=abs( dl( i ) ) ) then
                    ! no row interchange required
                    if( d( i )/=zero ) then
                       fact = dl( i ) / d( i )
                       d( i+1 ) = d( i+1 ) - fact*du( i )
                       b( i+1, 1 ) = b( i+1, 1 ) - fact*b( i, 1 )
                    else
                       info = i
                       return
                    end if
                    dl( i ) = zero
                 else
                    ! interchange rows i and i+1
                    fact = d( i ) / dl( i )
                    d( i ) = dl( i )
                    temp = d( i+1 )
                    d( i+1 ) = du( i ) - fact*temp
                    dl( i ) = du( i+1 )
                    du( i+1 ) = -fact*dl( i )
                    du( i ) = temp
                    temp = b( i, 1 )
                    b( i, 1 ) = b( i+1, 1 )
                    b( i+1, 1 ) = temp - fact*b( i+1, 1 )
                 end if
              end do loop_10
              if( n>1 ) then
                 i = n - 1
                 if( abs( d( i ) )>=abs( dl( i ) ) ) then
                    if( d( i )/=zero ) then
                       fact = dl( i ) / d( i )
                       d( i+1 ) = d( i+1 ) - fact*du( i )
                       b( i+1, 1 ) = b( i+1, 1 ) - fact*b( i, 1 )
                    else
                       info = i
                       return
                    end if
                 else
                    fact = d( i ) / dl( i )
                    d( i ) = dl( i )
                    temp = d( i+1 )
                    d( i+1 ) = du( i ) - fact*temp
                    du( i ) = temp
                    temp = b( i, 1 )
                    b( i, 1 ) = b( i+1, 1 )
                    b( i+1, 1 ) = temp - fact*b( i+1, 1 )
                 end if
              end if
              if( d( n )==zero ) then
                 info = n
                 return
              end if
           else
              loop_40: do i = 1, n - 2
                 if( abs( d( i ) )>=abs( dl( i ) ) ) then
                    ! no row interchange required
                    if( d( i )/=zero ) then
                       fact = dl( i ) / d( i )
                       d( i+1 ) = d( i+1 ) - fact*du( i )
                       do j = 1, nrhs
                          b( i+1, j ) = b( i+1, j ) - fact*b( i, j )
                       end do
                    else
                       info = i
                       return
                    end if
                    dl( i ) = zero
                 else
                    ! interchange rows i and i+1
                    fact = d( i ) / dl( i )
                    d( i ) = dl( i )
                    temp = d( i+1 )
                    d( i+1 ) = du( i ) - fact*temp
                    dl( i ) = du( i+1 )
                    du( i+1 ) = -fact*dl( i )
                    du( i ) = temp
                    do j = 1, nrhs
                       temp = b( i, j )
                       b( i, j ) = b( i+1, j )
                       b( i+1, j ) = temp - fact*b( i+1, j )
                    end do
                 end if
              end do loop_40
              if( n>1 ) then
                 i = n - 1
                 if( abs( d( i ) )>=abs( dl( i ) ) ) then
                    if( d( i )/=zero ) then
                       fact = dl( i ) / d( i )
                       d( i+1 ) = d( i+1 ) - fact*du( i )
                       do j = 1, nrhs
                          b( i+1, j ) = b( i+1, j ) - fact*b( i, j )
                       end do
                    else
                       info = i
                       return
                    end if
                 else
                    fact = d( i ) / dl( i )
                    d( i ) = dl( i )
                    temp = d( i+1 )
                    d( i+1 ) = du( i ) - fact*temp
                    du( i ) = temp
                    do j = 1, nrhs
                       temp = b( i, j )
                       b( i, j ) = b( i+1, j )
                       b( i+1, j ) = temp - fact*b( i+1, j )
                    end do
                 end if
              end if
              if( d( n )==zero ) then
                 info = n
                 return
              end if
           end if
           ! back solve with the matrix u from the factorization.
           if( nrhs<=2 ) then
              j = 1
              70 continue
              b( n, j ) = b( n, j ) / d( n )
              if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) / d( n-1 )
              do i = n - 2, 1, -1
                 b( i, j ) = ( b( i, j )-du( i )*b( i+1, j )-dl( i )*b( i+2, j ) ) / d( i )
                           
              end do
              if( j<nrhs ) then
                 j = j + 1
                 go to 70
              end if
           else
              do j = 1, nrhs
                 b( n, j ) = b( n, j ) / d( n )
                 if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) /d( n-1 )
                 do i = n - 2, 1, -1
                    b( i, j ) = ( b( i, j )-du( i )*b( i+1, j )-dl( i )*b( i+2, j ) ) / d( i )
                              
                 end do
              end do
           end if
           return
     end subroutine stdlib_${ri}$gtsv


     pure subroutine stdlib_${ri}$gtsvx( fact, trans, n, nrhs, dl, d, du, dlf, df, duf,du2, ipiv, b, &
     !! DGTSVX: uses the LU factorization to compute the solution to a real
     !! system of linear equations A * X = B or A**T * X = B,
     !! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ldb, x, ldx, rcond, ferr, berr,work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: b(ldb,*), d(*), dl(*), du(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
           real(${rk}$), intent(inout) :: df(*), dlf(*), du2(*), duf(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact, notran
           character :: norm
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           notran = stdlib_lsame( trans, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -14
           else if( ldx<max( 1, n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the lu factorization of a.
              call stdlib_${ri}$copy( n, d, 1, df, 1 )
              if( n>1 ) then
                 call stdlib_${ri}$copy( n-1, dl, 1, dlf, 1 )
                 call stdlib_${ri}$copy( n-1, du, 1, duf, 1 )
              end if
              call stdlib_${ri}$gttrf( n, dlf, df, duf, du2, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           if( notran ) then
              norm = '1'
           else
              norm = 'I'
           end if
           anorm = stdlib_${ri}$langt( norm, n, dl, d, du )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$gtcon( norm, n, dlf, df, duf, du2, ipiv, anorm, rcond, work,iwork, info )
                     
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$gttrs( trans, n, nrhs, dlf, df, duf, du2, ipiv, x, ldx,info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$gtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv,b, ldb, x, ldx, &
                     ferr, berr, work, iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$gtsvx


     pure subroutine stdlib_${ri}$gttrf( n, dl, d, du, du2, ipiv, info )
     !! DGTTRF: computes an LU factorization of a real tridiagonal matrix A
     !! using elimination with partial pivoting and row interchanges.
     !! The factorization has the form
     !! A = L * U
     !! where L is a product of permutation and unit lower bidiagonal
     !! matrices and U is upper triangular with nonzeros in only the main
     !! diagonal and first two superdiagonals.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: d(*), dl(*), du(*)
           real(${rk}$), intent(out) :: du2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: fact, temp
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DGTTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize ipiv(i) = i and du2(i) = 0
           do i = 1, n
              ipiv( i ) = i
           end do
           do i = 1, n - 2
              du2( i ) = zero
           end do
           do i = 1, n - 2
              if( abs( d( i ) )>=abs( dl( i ) ) ) then
                 ! no row interchange required, eliminate dl(i)
                 if( d( i )/=zero ) then
                    fact = dl( i ) / d( i )
                    dl( i ) = fact
                    d( i+1 ) = d( i+1 ) - fact*du( i )
                 end if
              else
                 ! interchange rows i and i+1, eliminate dl(i)
                 fact = d( i ) / dl( i )
                 d( i ) = dl( i )
                 dl( i ) = fact
                 temp = du( i )
                 du( i ) = d( i+1 )
                 d( i+1 ) = temp - fact*d( i+1 )
                 du2( i ) = du( i+1 )
                 du( i+1 ) = -fact*du( i+1 )
                 ipiv( i ) = i + 1
              end if
           end do
           if( n>1 ) then
              i = n - 1
              if( abs( d( i ) )>=abs( dl( i ) ) ) then
                 if( d( i )/=zero ) then
                    fact = dl( i ) / d( i )
                    dl( i ) = fact
                    d( i+1 ) = d( i+1 ) - fact*du( i )
                 end if
              else
                 fact = d( i ) / dl( i )
                 d( i ) = dl( i )
                 dl( i ) = fact
                 temp = du( i )
                 du( i ) = d( i+1 )
                 d( i+1 ) = temp - fact*d( i+1 )
                 ipiv( i ) = i + 1
              end if
           end if
           ! check for a zero on the diagonal of u.
           do i = 1, n
              if( d( i )==zero ) then
                 info = i
                 go to 50
              end if
           end do
           50 continue
           return
     end subroutine stdlib_${ri}$gttrf


     pure subroutine stdlib_${ri}$gttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
     !! DGTTRS: solves one of the systems of equations
     !! A*X = B  or  A**T*X = B,
     !! with a tridiagonal matrix A using the LU factorization computed
     !! by DGTTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(in) :: d(*), dl(*), du(*), du2(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: itrans, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           notran = ( trans=='N' .or. trans=='N' )
           if( .not.notran .and. .not.( trans=='T' .or. trans=='T' ) .and. .not.( trans=='C' .or. &
                     trans=='C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( n, 1 ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGTTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! decode trans
           if( notran ) then
              itrans = 0
           else
              itrans = 1
           end if
           ! determine the number of right-hand sides to solve at a time.
           if( nrhs==1 ) then
              nb = 1
           else
              nb = max( 1, stdlib_ilaenv( 1, 'DGTTRS', trans, n, nrhs, -1, -1 ) )
           end if
           if( nb>=nrhs ) then
              call stdlib_${ri}$gtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
           else
              do j = 1, nrhs, nb
                 jb = min( nrhs-j+1, nb )
                 call stdlib_${ri}$gtts2( itrans, n, jb, dl, d, du, du2, ipiv, b( 1, j ),ldb )
              end do
           end if
     end subroutine stdlib_${ri}$gttrs


     pure subroutine stdlib_${ri}$gtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
     !! DGTTS2: solves one of the systems of equations
     !! A*X = B  or  A**T*X = B,
     !! with a tridiagonal matrix A using the LU factorization computed
     !! by DGTTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: itrans, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(in) :: d(*), dl(*), du(*), du2(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ip, j
           real(${rk}$) :: temp
           ! Executable Statements 
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( itrans==0 ) then
              ! solve a*x = b using the lu factorization of a,
              ! overwriting each right hand side vector with its solution.
              if( nrhs<=1 ) then
                 j = 1
                 10 continue
                 ! solve l*x = b.
                 do i = 1, n - 1
                    ip = ipiv( i )
                    temp = b( i+1-ip+i, j ) - dl( i )*b( ip, j )
                    b( i, j ) = b( ip, j )
                    b( i+1, j ) = temp
                 end do
                 ! solve u*x = b.
                 b( n, j ) = b( n, j ) / d( n )
                 if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) /d( n-1 )
                 do i = n - 2, 1, -1
                    b( i, j ) = ( b( i, j )-du( i )*b( i+1, j )-du2( i )*b( i+2, j ) ) / d( i )
                              
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 10
                 end if
              else
                 do j = 1, nrhs
                    ! solve l*x = b.
                    do i = 1, n - 1
                       if( ipiv( i )==i ) then
                          b( i+1, j ) = b( i+1, j ) - dl( i )*b( i, j )
                       else
                          temp = b( i, j )
                          b( i, j ) = b( i+1, j )
                          b( i+1, j ) = temp - dl( i )*b( i, j )
                       end if
                    end do
                    ! solve u*x = b.
                    b( n, j ) = b( n, j ) / d( n )
                    if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) /d( n-1 )
                    do i = n - 2, 1, -1
                       b( i, j ) = ( b( i, j )-du( i )*b( i+1, j )-du2( i )*b( i+2, j ) ) / d( i )
                                 
                    end do
                 end do
              end if
           else
              ! solve a**t * x = b.
              if( nrhs<=1 ) then
                 ! solve u**t*x = b.
                 j = 1
                 70 continue
                 b( 1, j ) = b( 1, j ) / d( 1 )
                 if( n>1 )b( 2, j ) = ( b( 2, j )-du( 1 )*b( 1, j ) ) / d( 2 )
                 do i = 3, n
                    b( i, j ) = ( b( i, j )-du( i-1 )*b( i-1, j )-du2( i-2 )*b( i-2, j ) ) / d( i &
                              )
                 end do
                 ! solve l**t*x = b.
                 do i = n - 1, 1, -1
                    ip = ipiv( i )
                    temp = b( i, j ) - dl( i )*b( i+1, j )
                    b( i, j ) = b( ip, j )
                    b( ip, j ) = temp
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 70
                 end if
              else
                 do j = 1, nrhs
                    ! solve u**t*x = b.
                    b( 1, j ) = b( 1, j ) / d( 1 )
                    if( n>1 )b( 2, j ) = ( b( 2, j )-du( 1 )*b( 1, j ) ) / d( 2 )
                    do i = 3, n
                       b( i, j ) = ( b( i, j )-du( i-1 )*b( i-1, j )-du2( i-2 )*b( i-2, j ) ) / d(&
                                  i )
                    end do
                    do i = n - 1, 1, -1
                       if( ipiv( i )==i ) then
                          b( i, j ) = b( i, j ) - dl( i )*b( i+1, j )
                       else
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - dl( i )*temp
                          b( i, j ) = temp
                       end if
                    end do
                 end do
              end if
           end if
     end subroutine stdlib_${ri}$gtts2


     subroutine stdlib_${ri}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! DHGEQZ: computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(${rk}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: safety = 1.0e+2_${rk}$
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(${rk}$) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(${rk}$) :: v(3)
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min,sqrt
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=${rk}$)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_${ri}$lamch( 'E' )*stdlib_${ri}$lamch( 'B' )
           anorm = stdlib_${ri}$lanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_${ri}$lanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_${ri}$lartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_${ri}$rot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_${ri}$rot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_${ri}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_${ri}$lartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_${ri}$rot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_${ri}$rot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_${ri}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_${ri}$lartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_${ri}$rot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_${ri}$rot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_${ri}$rot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_${ri}$lartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_${ri}$rot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_${ri}$rot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_${ri}$rot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=${rk}$)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=${rk}$) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_${ri}$lag2 is the wilkinson shift (aep p.512_${rk}$),
                 call stdlib_${ri}$lag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_${ri}$lartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_${ri}$lartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_${ri}$lartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_${ri}$lasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_${ri}$rot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_${ri}$rot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_${ri}$rot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_${ri}$rot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_${ri}$rot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_${ri}$rot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_${ri}$lag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_${ri}$lapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_${ri}$lapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_${ri}$lapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_${ri}$lapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_${ri}$lapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_${ri}$lapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_${ri}$lapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_${ri}$larfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_${ri}$larfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see dlagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_${ri}$lartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_${ri}$lartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$hgeqz


     subroutine stdlib_${ri}$hsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
     !! DHSEIN: uses inverse iteration to find specified right and/or left
     !! eigenvectors of a real upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               mm, m, work, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(${rk}$), intent(in) :: h(ldh,*), wi(*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, pair, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ksi, ksr, ldwork
           real(${rk}$) :: bignum, eps3, hnorm, smlnum, ulp, unfl, wki, wkr
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors, and standardize the array select.
           m = 0
           pair = .false.
           do k = 1, n
              if( pair ) then
                 pair = .false.
                 select( k ) = .false.
              else
                 if( wi( k )==zero ) then
                    if( select( k ) )m = m + 1
                 else
                    pair = .true.
                    if( select( k ) .or. select( k+1 ) ) then
                       select( k ) = .true.
                       m = m + 2
                    end if
                 end if
              end if
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -13
           else if( mm<m ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ldwork = n + 1
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ksr = 1
           loop_120: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are zero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==zero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==zero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_${ri}$lanhs( 'I', kr-kl+1, h( kl, kl ), ldh, work )
                    if( stdlib_${ri}$isnan( hnorm ) ) then
                       info = -6
                       return
                    else if( hnorm>zero ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wkr = wr( k )
                 wki = wi( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. abs( wr( i )-wkr )+abs( wi( i )-wki )<eps3 ) &
                              then
                       wkr = wkr + eps3
                       go to 60
                    end if
                 end do
                 wr( k ) = wkr
                 pair = wki/=zero
                 if( pair ) then
                    ksi = ksr + 1
                 else
                    ksi = ksr
                 end if
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_${ri}$laein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wkr, wki, vl( &
                    kl, ksr ), vl( kl, ksi ),work, ldwork, work( n*n+n+1 ), eps3, smlnum,bignum, &
                              iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifaill( ksr ) = k
                       ifaill( ksi ) = k
                    else
                       ifaill( ksr ) = 0
                       ifaill( ksi ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = 1, kl - 1
                          vl( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_${ri}$laein( .true., noinit, kr, h, ldh, wkr, wki,vr( 1, ksr ), vr( 1, &
                              ksi ), work, ldwork,work( n*n+n+1 ), eps3, smlnum, bignum,iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifailr( ksr ) = k
                       ifailr( ksi ) = k
                    else
                       ifailr( ksr ) = 0
                       ifailr( ksi ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = kr + 1, n
                          vr( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( pair ) then
                    ksr = ksr + 2
                 else
                    ksr = ksr + 1
                 end if
              end if
           end do loop_120
           return
     end subroutine stdlib_${ri}$hsein


     subroutine stdlib_${ri}$hseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
     !! DHSEQR: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ri}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_${ri}$lahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           ! Local Arrays 
           real(${rk}$) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: i, kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           intrinsic :: real,max,min
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = real( max( 1, n ),KIND=${rk}$)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -11
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -13
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'DHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                        work, lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=${rk}$), work( 1 ) )
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_${ri}$gebal ====
              do i = 1, ilo - 1
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              do i = ihi + 1, n
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_${ri}$laset( 'A', n, n, zero, one, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 wr( ilo ) = h( ilo, ilo )
                 wi( ilo ) = zero
                 return
              end if
              ! ==== stdlib_${ri}$lahqr/stdlib_${ri}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_${ri}$laqr0 for big matrices; stdlib_${ri}$lahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           work, lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           info )
                 if( info>0 ) then
                    ! ==== a rare stdlib_${ri}$lahqr failure!  stdlib_${ri}$laqr0 sometimes succeeds
                    ! .    when stdlib_${ri}$lahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_${ri}$laqr0 directly. ====
                       call stdlib_${ri}$laqr0( wantt, wantz, n, ilo, kbot, h, ldh, wr,wi, ilo, ihi, z,&
                                  ldz, work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_${ri}$laqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_${ri}$laqr0. ====
                       call stdlib_${ri}$lacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = zero
                       call stdlib_${ri}$laset( 'A', nl, nl-n, zero, zero, hl( 1, n+1 ),nl )
                       call stdlib_${ri}$laqr0( wantt, wantz, nl, ilo, kbot, hl, nl, wr,wi, ilo, ihi, &
                                 z, ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_${ri}$lacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_${ri}$laset( 'L', n-2, n-2, zero, zero,&
                         h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=${rk}$), work( 1 ) )
           end if
     end subroutine stdlib_${ri}$hseqr


     pure logical(lk) function stdlib_${ri}$isnan( din )
     !! DISNAN: returns .TRUE. if its argument is NaN, and .FALSE.
     !! otherwise.  To be replaced by the Fortran 2003 intrinsic in the
     !! future.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: din
        ! =====================================================================
        ! Executable Statements 
           stdlib_${ri}$isnan = stdlib_${ri}$laisnan(din,din)
           return
     end function stdlib_${ri}$isnan


     subroutine stdlib_${ri}$la_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )
     !! DLA_GBAMV:  performs one of the matrix-vector operations
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! m by n matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, ldab, m, n, kl, ku, trans
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_wero
           real(${rk}$) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky, lenx, leny, kd, ke
           ! Intrinsic Functions 
           intrinsic :: max,abs,sign
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( .not.( ( trans==stdlib_ilatrans( 'N' ) ).or. ( trans==stdlib_ilatrans( 'T' ) )&
                     .or. ( trans==stdlib_ilatrans( 'C' ) ) ) ) then
              info = 1
           else if( m<0 )then
              info = 2
           else if( n<0 )then
              info = 3
           else if( kl<0 .or. kl>m-1 ) then
              info = 4
           else if( ku<0 .or. ku>n-1 ) then
              info = 5
           else if( ldab<kl+ku+1 )then
              info = 6
           else if( incx==0 )then
              info = 8
           else if( incy==0 )then
              info = 11
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'DLA_GBAMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( m==0 ).or.( n==0 ).or.( ( alpha==zero ).and.( beta==one ) ) )return
           ! set  lenx  and  leny, the lengths of the vectors x and y, and set
           ! up the start points in  x  and  y.
           if( trans==stdlib_ilatrans( 'N' ) )then
              lenx = n
              leny = m
           else
              lenx = m
              leny = n
           end if
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( lenx - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( leny - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(m*n) symb_wero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           kd = ku + 1
           ke = kl + 1
           iy = ky
           if ( incx==1 ) then
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = abs( ab( kd+i-j, j ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = abs( ab( ke-i+j, i ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       jx = kx
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = abs( ab( kd+i-j, j ) )
                          symb_wero = symb_wero .and.( x( jx ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       jx = kx
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = abs( ab( ke-i+j, i ) )
                          symb_wero = symb_wero .and.( x( jx ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$la_gbamv


     real(${rk}$) function stdlib_${ri}$la_gbrcond( trans, n, kl, ku, ab, ldab,afb, ldafb, ipiv, cmode, c,&
     !! DLA_GBRCOND: Estimates the Skeel condition number of  op(A) * op2(C)
     !! where op2 is determined by CMODE as follows
     !! CMODE =  1    op2(C) = C
     !! CMODE =  0    op2(C) = I
     !! CMODE = -1    op2(C) = inv(C)
     !! The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
     !! is computed by computing scaling factors R such that
     !! diag(R)*A*op2(C) is row equilibrated and computing the standard
     !! infinity-norm condition number.
               info, work, iwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: n, ldab, ldafb, kl, ku, cmode
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: ab(ldab,*), afb(ldafb,*), c(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: notrans
           integer(ilp) :: kase, i, j, kd, ke
           real(${rk}$) :: ainvnm, tmp
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           stdlib_${ri}$la_gbrcond = zero
           info = 0
           notrans = stdlib_lsame( trans, 'N' )
           if ( .not. notrans .and. .not. stdlib_lsame(trans, 'T').and. .not. stdlib_lsame(trans, &
                     'C') ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 .or. kl>n-1 ) then
              info = -3
           else if( ku<0 .or. ku>n-1 ) then
              info = -4
           else if( ldab<kl+ku+1 ) then
              info = -6
           else if( ldafb<2*kl+ku+1 ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLA_GBRCOND', -info )
              return
           end if
           if( n==0 ) then
              stdlib_${ri}$la_gbrcond = one
              return
           end if
           ! compute the equilibration matrix r such that
           ! inv(r)*a*c has unit 1-norm.
           kd = ku + 1
           ke = kl + 1
           if ( notrans ) then
              do i = 1, n
                 tmp = zero
                    if ( cmode == 1 ) then
                       do j = max( i-kl, 1 ), min( i+ku, n )
                          tmp = tmp + abs( ab( kd+i-j, j ) * c( j ) )
                       end do
                    else if ( cmode == 0 ) then
                       do j = max( i-kl, 1 ), min( i+ku, n )
                          tmp = tmp + abs( ab( kd+i-j, j ) )
                       end do
                    else
                       do j = max( i-kl, 1 ), min( i+ku, n )
                          tmp = tmp + abs( ab( kd+i-j, j ) / c( j ) )
                       end do
                    end if
                 work( 2*n+i ) = tmp
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + abs( ab( ke-i+j, i ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + abs( ab( ke-i+j, i ) )
                    end do
                 else
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + abs( ab( ke-i+j, i ) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
                 if ( notrans ) then
                    call stdlib_${ri}$gbtrs( 'NO TRANSPOSE', n, kl, ku, 1, afb, ldafb,ipiv, work, n, &
                              info )
                 else
                    call stdlib_${ri}$gbtrs( 'TRANSPOSE', n, kl, ku, 1, afb, ldafb, ipiv,work, n, info &
                              )
                 end if
                 ! multiply by inv(c).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**t).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( notrans ) then
                    call stdlib_${ri}$gbtrs( 'TRANSPOSE', n, kl, ku, 1, afb, ldafb, ipiv,work, n, info &
                              )
                 else
                    call stdlib_${ri}$gbtrs( 'NO TRANSPOSE', n, kl, ku, 1, afb, ldafb,ipiv, work, n, &
                              info )
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_${ri}$la_gbrcond = ( one / ainvnm )
           return
     end function stdlib_${ri}$la_gbrcond


     pure real(${rk}$) function stdlib_${ri}$la_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )
     !! DLA_GBRPVGRW: computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, kl, ku, ncols, ldab, ldafb
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*), afb(ldafb,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j, kd
           real(${rk}$) :: amax, umax, rpvgrw
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           rpvgrw = one
           kd = ku + 1
           do j = 1, ncols
              amax = zero
              umax = zero
              do i = max( j-ku, 1 ), min( j+kl, n )
                 amax = max( abs( ab( kd+i-j, j)), amax )
              end do
              do i = max( j-ku, 1 ), j
                 umax = max( abs( afb( kd+i-j, j ) ), umax )
              end do
              if ( umax /= zero ) then
                 rpvgrw = min( amax / umax, rpvgrw )
              end if
           end do
           stdlib_${ri}$la_gbrpvgrw = rpvgrw
     end function stdlib_${ri}$la_gbrpvgrw


     subroutine stdlib_${ri}$la_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
     !! DLA_GEAMV:  performs one of the matrix-vector operations
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! m by n matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n, trans
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_wero
           real(${rk}$) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky, lenx, leny
           ! Intrinsic Functions 
           intrinsic :: max,abs,sign
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( .not.( ( trans==stdlib_ilatrans( 'N' ) ).or. ( trans==stdlib_ilatrans( 'T' ) )&
                     .or. ( trans==stdlib_ilatrans( 'C' )) ) ) then
              info = 1
           else if( m<0 )then
              info = 2
           else if( n<0 )then
              info = 3
           else if( lda<max( 1, m ) )then
              info = 6
           else if( incx==0 )then
              info = 8
           else if( incy==0 )then
              info = 11
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'DLA_GEAMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( m==0 ).or.( n==0 ).or.( ( alpha==zero ).and.( beta==one ) ) )return
           ! set  lenx  and  leny, the lengths of the vectors x and y, and set
           ! up the start points in  x  and  y.
           if( trans==stdlib_ilatrans( 'N' ) )then
              lenx = n
              leny = m
           else
              lenx = m
              leny = n
           end if
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( lenx - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( leny - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(m*n) symb_wero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           iy = ky
           if ( incx==1 ) then
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, lenx
                          temp = abs( a( i, j ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, lenx
                          temp = abs( a( j, i ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       jx = kx
                       do j = 1, lenx
                          temp = abs( a( i, j ) )
                          symb_wero = symb_wero .and.( x( jx ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if (.not.symb_wero)y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       jx = kx
                       do j = 1, lenx
                          temp = abs( a( j, i ) )
                          symb_wero = symb_wero .and.( x( jx ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if (.not.symb_wero)y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$la_geamv


     real(${rk}$) function stdlib_${ri}$la_gercond( trans, n, a, lda, af,ldaf, ipiv, cmode, c,info, work, &
     !! DLA_GERCOND: estimates the Skeel condition number of op(A) * op2(C)
     !! where op2 is determined by CMODE as follows
     !! CMODE =  1    op2(C) = C
     !! CMODE =  0    op2(C) = I
     !! CMODE = -1    op2(C) = inv(C)
     !! The Skeel condition number cond(A) = norminf( |inv(A)||A| )
     !! is computed by computing scaling factors R such that
     !! diag(R)*A*op2(C) is row equilibrated and computing the standard
     !! infinity-norm condition number.
               iwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: n, lda, ldaf, cmode
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), c(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: notrans
           integer(ilp) :: kase, i, j
           real(${rk}$) :: ainvnm, tmp
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           stdlib_${ri}$la_gercond = zero
           info = 0
           notrans = stdlib_lsame( trans, 'N' )
           if ( .not. notrans .and. .not. stdlib_lsame(trans, 'T').and. .not. stdlib_lsame(trans, &
                     'C') ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldaf<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLA_GERCOND', -info )
              return
           end if
           if( n==0 ) then
              stdlib_${ri}$la_gercond = one
              return
           end if
           ! compute the equilibration matrix r such that
           ! inv(r)*a*c has unit 1-norm.
           if (notrans) then
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = 1, n
                       tmp = tmp + abs( a( i, j ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = 1, n
                       tmp = tmp + abs( a( i, j ) )
                    end do
                 else
                    do j = 1, n
                       tmp = tmp + abs( a( i, j ) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = 1, n
                       tmp = tmp + abs( a( j, i ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = 1, n
                       tmp = tmp + abs( a( j, i ) )
                    end do
                 else
                    do j = 1, n
                       tmp = tmp + abs( a( j, i ) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work(i) = work(i) * work(2*n+i)
                 end do
                 if (notrans) then
                    call stdlib_${ri}$getrs( 'NO TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info )
                              
                 else
                    call stdlib_${ri}$getrs( 'TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info )
                 end if
                 ! multiply by inv(c).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**t).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if (notrans) then
                    call stdlib_${ri}$getrs( 'TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info )
                 else
                    call stdlib_${ri}$getrs( 'NO TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info )
                              
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_${ri}$la_gercond = ( one / ainvnm )
           return
     end function stdlib_${ri}$la_gercond


     pure real(${rk}$) function stdlib_${ri}$la_gerpvgrw( n, ncols, a, lda, af,ldaf )
     !! DLA_GERPVGRW: computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: amax, umax, rpvgrw
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           rpvgrw = one
           do j = 1, ncols
              amax = zero
              umax = zero
              do i = 1, n
                 amax = max( abs( a( i, j ) ), amax )
              end do
              do i = 1, j
                 umax = max( abs( af( i, j ) ), umax )
              end do
              if ( umax /= zero ) then
                 rpvgrw = min( amax / umax, rpvgrw )
              end if
           end do
           stdlib_${ri}$la_gerpvgrw = rpvgrw
     end function stdlib_${ri}$la_gerpvgrw


     pure subroutine stdlib_${ri}$la_lin_berr ( n, nz, nrhs, res, ayb, berr )
     !! DLA_LIN_BERR: computes component-wise relative backward error from
     !! the formula
     !! max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
     !! where abs(Z) is the component-wise absolute value of the matrix
     !! or vector Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, nz, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: ayb(n,nrhs)
           real(${rk}$), intent(out) :: berr(nrhs)
           real(${rk}$), intent(in) :: res(n,nrhs)
        ! =====================================================================
           ! Local Scalars 
           real(${rk}$) :: tmp,safe1
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! adding safe1 to the numerator guards against spuriously zero
           ! residuals.  a similar safeguard is in the sla_yyamv routine used
           ! to compute ayb.
           safe1 = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = (nz+1)*safe1
           do j = 1, nrhs
              berr(j) = zero
              do i = 1, n
                 if (ayb(i,j) /= zero) then
                    tmp = (safe1+abs(res(i,j)))/ayb(i,j)
                    berr(j) = max( berr(j), tmp )
                 end if
           ! if ayb is exactly 0.0_${rk}$ (and if computed by sla_yyamv), then we know
           ! the true residual also must be exactly zero.
              end do
           end do
     end subroutine stdlib_${ri}$la_lin_berr


     real(${rk}$) function stdlib_${ri}$la_porcond( uplo, n, a, lda, af, ldaf,cmode, c, info, work,iwork )
     !! DLA_PORCOND: Estimates the Skeel condition number of  op(A) * op2(C)
     !! where op2 is determined by CMODE as follows
     !! CMODE =  1    op2(C) = C
     !! CMODE =  0    op2(C) = I
     !! CMODE = -1    op2(C) = inv(C)
     !! The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
     !! is computed by computing scaling factors R such that
     !! diag(R)*A*op2(C) is row equilibrated and computing the standard
     !! infinity-norm condition number.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, ldaf, cmode
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), c(*)
           real(${rk}$), intent(out) :: work(*)
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: kase, i, j
           real(${rk}$) :: ainvnm, tmp
           logical(lk) :: up
           ! Array Arguments 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           stdlib_${ri}$la_porcond = zero
           info = 0
           if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLA_PORCOND', -info )
              return
           end if
           if( n==0 ) then
              stdlib_${ri}$la_porcond = one
              return
           end if
           up = .false.
           if ( stdlib_lsame( uplo, 'U' ) ) up = .true.
           ! compute the equilibration matrix r such that
           ! inv(r)*a*c has unit 1-norm.
           if ( up ) then
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( j, i ) * c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( i, j ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( j, i ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( i, j ) )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + abs( a( j ,i ) / c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( i, j ) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( i, j ) * c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( j, i ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( i, j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( j, i ) )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + abs( a( i, j ) / c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( j, i ) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           endif
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
                 if (up) then
                    call stdlib_${ri}$potrs( 'UPPER', n, 1, af, ldaf, work, n, info )
                 else
                    call stdlib_${ri}$potrs( 'LOWER', n, 1, af, ldaf, work, n, info )
                 endif
                 ! multiply by inv(c).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**t).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( up ) then
                    call stdlib_${ri}$potrs( 'UPPER', n, 1, af, ldaf, work, n, info )
                 else
                    call stdlib_${ri}$potrs( 'LOWER', n, 1, af, ldaf, work, n, info )
                 endif
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_${ri}$la_porcond = ( one / ainvnm )
           return
     end function stdlib_${ri}$la_porcond


     real(${rk}$) function stdlib_${ri}$la_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
     !! DLA_PORPVGRW: computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: ncols, lda, ldaf
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: amax, umax, rpvgrw
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           ! stdlib_${ri}$potrf will have factored only the ncolsxncols leading minor, so
           ! we restrict the growth search to that minor and use only the first
           ! 2*ncols workspace entries.
           rpvgrw = one
           do i = 1, 2*ncols
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column.
           if ( upper ) then
              do j = 1, ncols
                 do i = 1, j
                    work( ncols+j ) =max( abs( a( i, j ) ), work( ncols+j ) )
                 end do
              end do
           else
              do j = 1, ncols
                 do i = j, ncols
                    work( ncols+j ) =max( abs( a( i, j ) ), work( ncols+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of the factor in
           ! af.  no pivoting, so no permutations.
           if ( stdlib_lsame( 'UPPER', uplo ) ) then
              do j = 1, ncols
                 do i = 1, j
                    work( j ) = max( abs( af( i, j ) ), work( j ) )
                 end do
              end do
           else
              do j = 1, ncols
                 do i = j, ncols
                    work( j ) = max( abs( af( i, j ) ), work( j ) )
                 end do
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( stdlib_lsame( 'UPPER', uplo ) ) then
              do i = 1, ncols
                 umax = work( i )
                 amax = work( ncols+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( ncols+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_${ri}$la_porpvgrw = rpvgrw
     end function stdlib_${ri}$la_porpvgrw


     subroutine stdlib_${ri}$la_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
     !! DLA_SYAMV:  performs the matrix-vector operation
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! n by n symmetric matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n, uplo
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_wero
           real(${rk}$) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky
           ! Intrinsic Functions 
           intrinsic :: max,abs,sign
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( uplo/=stdlib_ilauplo( 'U' ) .and.uplo/=stdlib_ilauplo( 'L' ) ) then
              info = 1
           else if( n<0 )then
              info = 2
           else if( lda<max( 1, n ) )then
              info = 5
           else if( incx==0 )then
              info = 7
           else if( incy==0 )then
              info = 10
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'DLA_SYAMV', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ).or.( ( alpha==zero ).and.( beta==one ) ) )return
           ! set up the start points in  x  and  y.
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( n - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( n - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(n^2) symb_wero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           iy = ky
           if ( incx==1 ) then
              if ( uplo == stdlib_ilauplo( 'U' ) ) then
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = abs( a( j, i ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                       do j = i+1, n
                          temp = abs( a( i, j ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = abs( a( i, j ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                       do j = i+1, n
                          temp = abs( a( j, i ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if ( uplo == stdlib_ilauplo( 'U' ) ) then
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    jx = kx
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = abs( a( j, i ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                       do j = i+1, n
                          temp = abs( a( i, j ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_wero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_wero = .true.
                    else
                       symb_wero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    jx = kx
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = abs( a( i, j ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                       do j = i+1, n
                          temp = abs( a( j, i ) )
                          symb_wero = symb_wero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*abs( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_wero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$la_syamv


     real(${rk}$) function stdlib_${ri}$la_syrcond( uplo, n, a, lda, af, ldaf,ipiv, cmode, c, info, work,&
     !! DLA_SYRCOND: estimates the Skeel condition number of  op(A) * op2(C)
     !! where op2 is determined by CMODE as follows
     !! CMODE =  1    op2(C) = C
     !! CMODE =  0    op2(C) = I
     !! CMODE = -1    op2(C) = inv(C)
     !! The Skeel condition number cond(A) = norminf( |inv(A)||A| )
     !! is computed by computing scaling factors R such that
     !! diag(R)*A*op2(C) is row equilibrated and computing the standard
     !! infinity-norm condition number.
               iwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, ldaf, cmode
           integer(ilp), intent(out) :: info
           ! Array Arguments
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), c(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           character :: normin
           integer(ilp) :: kase, i, j
           real(${rk}$) :: ainvnm, smlnum, tmp
           logical(lk) :: up
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           stdlib_${ri}$la_syrcond = zero
           info = 0
           if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldaf<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLA_SYRCOND', -info )
              return
           end if
           if( n==0 ) then
              stdlib_${ri}$la_syrcond = one
              return
           end if
           up = .false.
           if ( stdlib_lsame( uplo, 'U' ) ) up = .true.
           ! compute the equilibration matrix r such that
           ! inv(r)*a*c has unit 1-norm.
           if ( up ) then
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( j, i ) * c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( i, j ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( j, i ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( i, j ) )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + abs( a( j, i ) / c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( i, j ) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( cmode == 1 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( i, j ) * c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( j, i ) * c( j ) )
                    end do
                 else if ( cmode == 0 ) then
                    do j = 1, i
                       tmp = tmp + abs( a( i, j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( j, i ) )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + abs( a( i, j) / c( j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + abs( a( j, i) / c( j ) )
                    end do
                 end if
                 work( 2*n+i ) = tmp
              end do
           endif
           ! estimate the norm of inv(op(a)).
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ainvnm = zero
           normin = 'N'
           kase = 0
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
                 if ( up ) then
                    call stdlib_${ri}$sytrs( 'U', n, 1, af, ldaf, ipiv, work, n, info )
                 else
                    call stdlib_${ri}$sytrs( 'L', n, 1, af, ldaf, ipiv, work, n, info )
                 endif
                 ! multiply by inv(c).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**t).
                 if ( cmode == 1 ) then
                    do i = 1, n
                       work( i ) = work( i ) / c( i )
                    end do
                 else if ( cmode == -1 ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( up ) then
                    call stdlib_${ri}$sytrs( 'U', n, 1, af, ldaf, ipiv, work, n, info )
                 else
                    call stdlib_${ri}$sytrs( 'L', n, 1, af, ldaf, ipiv, work, n, info )
                 endif
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * work( 2*n+i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_${ri}$la_syrcond = ( one / ainvnm )
           return
     end function stdlib_${ri}$la_syrcond


     real(${rk}$) function stdlib_${ri}$la_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
     !! DLA_SYRPVGRW: computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: ncols, i, j, k, kp
           real(${rk}$) :: amax, umax, rpvgrw, tmp
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           if ( info==0 ) then
              if ( upper ) then
                 ncols = 1
              else
                 ncols = n
              end if
           else
              ncols = info
           end if
           rpvgrw = one
           do i = 1, 2*n
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column of a.  compute the max
           ! for all n columns so we can apply the pivot permutation while
           ! looping below.  assume a full factorization is the common case.
           if ( upper ) then
              do j = 1, n
                 do i = 1, j
                    work( n+i ) = max( abs( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( abs( a( i, j ) ), work( n+j ) )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    work( n+i ) = max( abs( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( abs( a( i, j ) ), work( n+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of u or l.  also
           ! permute the magnitudes of a above so they're in the same order as
           ! the factor.
           ! the iteration orders and permutations were copied from stdlib_${ri}$sytrs.
           ! calls to stdlib_dswap would be severe overkill.
           if ( upper ) then
              k = n
              do while ( k < ncols .and. k>0 )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = 1, k
                       work( k ) = max( abs( af( i, k ) ), work( k ) )
                    end do
                    k = k - 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k-1 )
                    work( n+k-1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = 1, k-1
                       work( k ) = max( abs( af( i, k ) ), work( k ) )
                       work( k-1 ) = max( abs( af( i, k-1 ) ), work( k-1 ) )
                    end do
                    work( k ) = max( abs( af( k, k ) ), work( k ) )
                    k = k - 2
                 end if
              end do
              k = ncols
              do while ( k <= n )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k + 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k + 2
                 end if
              end do
           else
              k = 1
              do while ( k <= ncols )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = k, n
                       work( k ) = max( abs( af( i, k ) ), work( k ) )
                    end do
                    k = k + 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k+1 )
                    work( n+k+1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = k+1, n
                       work( k ) = max( abs( af( i, k ) ), work( k ) )
                       work( k+1 ) = max( abs( af(i, k+1 ) ), work( k+1 ) )
                    end do
                    work( k ) = max( abs( af( k, k ) ), work( k ) )
                    k = k + 2
                 end if
              end do
              k = ncols
              do while ( k >= 1 )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k - 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k - 2
                 endif
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( upper ) then
              do i = ncols, n
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_${ri}$la_syrpvgrw = rpvgrw
     end function stdlib_${ri}$la_syrpvgrw


     pure subroutine stdlib_${ri}$la_wwaddw( n, x, y, w )
     !! DLA_WWADDW: adds a vector W into a doubled-single vector (X, Y).
     !! This works for all extant IBM's hex and binary floating point
     !! arithmetic, but not for decimal.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: x(*), y(*)
           real(${rk}$), intent(in) :: w(*)
        ! =====================================================================
           ! Local Scalars 
           real(${rk}$) :: s
           integer(ilp) :: i
           ! Executable Statements 
           do 10 i = 1, n
             s = x(i) + w(i)
             s = (s + s) - s
             y(i) = ((x(i) - s) + w(i)) + y(i)
             x(i) = s
             10 continue
           return
     end subroutine stdlib_${ri}$la_wwaddw


     pure subroutine stdlib_${ri}$labad( small, large )
     !! DLABAD: takes as input the values computed by DLAMCH for underflow and
     !! overflow, and returns the square root of each of these values if the
     !! log of LARGE is sufficiently large.  This subroutine is intended to
     !! identify machines with a large exponent range, such as the Crays, and
     !! redefine the underflow and overflow limits to be the square roots of
     !! the values computed by DLAMCH.  This subroutine is needed because
     !! DLAMCH does not compensate for poor arithmetic in the upper half of
     !! the exponent range, as is found on a Cray.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(inout) :: large, small
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: log10,sqrt
           ! Executable Statements 
           ! if it looks like we're on a cray, take the square root of
           ! small and large to avoid overflow and underflow problems.
           if( log10( large )>2000._${rk}$ ) then
              small = sqrt( small )
              large = sqrt( large )
           end if
           return
     end subroutine stdlib_${ri}$labad


     pure subroutine stdlib_${ri}$labrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
     !! DLABRD: reduces the first NB rows and columns of a real general
     !! m by n matrix A to upper or lower bidiagonal form by an orthogonal
     !! transformation Q**T * A * P, and returns the matrices X and Y which
     !! are needed to apply the transformation to the unreduced part of A.
     !! If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
     !! bidiagonal form.
     !! This is an auxiliary routine called by DGEBRD
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldx, ldy, m, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), taup(*), tauq(*), x(ldx,*), y(ldy,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 )return
           if( m>=n ) then
              ! reduce to upper bidiagonal form
              loop_10: do i = 1, nb
                 ! update a(i:m,i)
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i+1, i-1, -one, a( i, 1 ),lda, y( i, 1 ), &
                           ldy, one, a( i, i ), 1 )
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i+1, i-1, -one, x( i, 1 ),ldx, a( 1, i ), 1,&
                            one, a( i, i ), 1 )
                 ! generate reflection q(i) to annihilate a(i+1:m,i)
                 call stdlib_${ri}$larfg( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,tauq( i ) )
                           
                 d( i ) = a( i, i )
                 if( i<n ) then
                    a( i, i ) = one
                    ! compute y(i+1:n,i)
                    call stdlib_${ri}$gemv( 'TRANSPOSE', m-i+1, n-i, one, a( i, i+1 ),lda, a( i, i ), &
                              1, zero, y( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', m-i+1, i-1, one, a( i, 1 ), lda,a( i, i ), 1, &
                              zero, y( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i-1, -one, y( i+1, 1 ),ldy, y( 1, i ),&
                               1, one, y( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', m-i+1, i-1, one, x( i, 1 ), ldx,a( i, i ), 1, &
                              zero, y( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i, -one, a( 1, i+1 ),lda, y( 1, i ), 1,&
                               one, y( i+1, i ), 1 )
                    call stdlib_${ri}$scal( n-i, tauq( i ), y( i+1, i ), 1 )
                    ! update a(i,i+1:n)
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i, -one, y( i+1, 1 ),ldy, a( i, 1 ), &
                              lda, one, a( i, i+1 ), lda )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i, -one, a( 1, i+1 ),lda, x( i, 1 ), &
                              ldx, one, a( i, i+1 ), lda )
                    ! generate reflection p(i) to annihilate a(i,i+2:n)
                    call stdlib_${ri}$larfg( n-i, a( i, i+1 ), a( i, min( i+2, n ) ),lda, taup( i ) )
                              
                    e( i ) = a( i, i+1 )
                    a( i, i+1 ) = one
                    ! compute x(i+1:m,i)
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, n-i, one, a( i+1, i+1 ),lda, a( i, i+&
                              1 ), lda, zero, x( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i, i, one, y( i+1, 1 ), ldy,a( i, i+1 ), &
                              lda, zero, x( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, i, -one, a( i+1, 1 ),lda, x( 1, i ), &
                              1, one, x( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i, one, a( 1, i+1 ),lda, a( i, i+1 )&
                              , lda, zero, x( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, i-1, -one, x( i+1, 1 ),ldx, x( 1, i ),&
                               1, one, x( i+1, i ), 1 )
                    call stdlib_${ri}$scal( m-i, taup( i ), x( i+1, i ), 1 )
                 end if
              end do loop_10
           else
              ! reduce to lower bidiagonal form
              loop_20: do i = 1, nb
                 ! update a(i,i:n)
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -one, y( i, 1 ),ldy, a( i, 1 ), &
                           lda, one, a( i, i ), lda )
                 call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i+1, -one, a( 1, i ), lda,x( i, 1 ), ldx, &
                           one, a( i, i ), lda )
                 ! generate reflection p(i) to annihilate a(i,i+1:n)
                 call stdlib_${ri}$larfg( n-i+1, a( i, i ), a( i, min( i+1, n ) ), lda,taup( i ) )
                           
                 d( i ) = a( i, i )
                 if( i<m ) then
                    a( i, i ) = one
                    ! compute x(i+1:m,i)
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, n-i+1, one, a( i+1, i ),lda, a( i, i )&
                              , lda, zero, x( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i+1, i-1, one, y( i, 1 ), ldy,a( i, i ), &
                              lda, zero, x( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, i-1, -one, a( i+1, 1 ),lda, x( 1, i ),&
                               1, one, x( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i+1, one, a( 1, i ),lda, a( i, i ), &
                              lda, zero, x( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, i-1, -one, x( i+1, 1 ),ldx, x( 1, i ),&
                               1, one, x( i+1, i ), 1 )
                    call stdlib_${ri}$scal( m-i, taup( i ), x( i+1, i ), 1 )
                    ! update a(i+1:m,i)
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, i-1, -one, a( i+1, 1 ),lda, y( i, 1 ),&
                               ldy, one, a( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-i, i, -one, x( i+1, 1 ),ldx, a( 1, i ), &
                              1, one, a( i+1, i ), 1 )
                    ! generate reflection q(i) to annihilate a(i+2:m,i)
                    call stdlib_${ri}$larfg( m-i, a( i+1, i ), a( min( i+2, m ), i ), 1,tauq( i ) )
                              
                    e( i ) = a( i+1, i )
                    a( i+1, i ) = one
                    ! compute y(i+1:n,i)
                    call stdlib_${ri}$gemv( 'TRANSPOSE', m-i, n-i, one, a( i+1, i+1 ),lda, a( i+1, i ),&
                               1, zero, y( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', m-i, i-1, one, a( i+1, 1 ), lda,a( i+1, i ), &
                              1, zero, y( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i-1, -one, y( i+1, 1 ),ldy, y( 1, i ),&
                               1, one, y( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', m-i, i, one, x( i+1, 1 ), ldx,a( i+1, i ), 1, &
                              zero, y( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', i, n-i, -one, a( 1, i+1 ), lda,y( 1, i ), 1, &
                              one, y( i+1, i ), 1 )
                    call stdlib_${ri}$scal( n-i, tauq( i ), y( i+1, i ), 1 )
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_${ri}$labrd


     pure subroutine stdlib_${ri}$lacn2( n, v, x, isgn, est, kase, isave )
     !! DLACN2: estimates the 1-norm of a square, real matrix A.
     !! Reverse communication is used for evaluating matrix-vector products.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(inout) :: kase
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(inout) :: est
           ! Array Arguments 
           integer(ilp), intent(out) :: isgn(*)
           integer(ilp), intent(inout) :: isave(3)
           real(${rk}$), intent(out) :: v(*)
           real(${rk}$), intent(inout) :: x(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           ! Local Scalars 
           integer(ilp) :: i, jlast
           real(${rk}$) :: altsgn, estold, temp, xs
           ! Intrinsic Functions 
           intrinsic :: abs,real,nint
           ! Executable Statements 
           if( kase==0 ) then
              do i = 1, n
                 x( i ) = one / real( n,KIND=${rk}$)
              end do
              kase = 1
              isave( 1 ) = 1
              return
           end if
           go to ( 20, 40, 70, 110, 140 )isave( 1 )
           ! ................ entry   (isave( 1 ) = 1)
           ! first iteration.  x has been overwritten by a*x.
           20 continue
           if( n==1 ) then
              v( 1 ) = x( 1 )
              est = abs( v( 1 ) )
              ! ... quit
              go to 150
           end if
           est = stdlib_${ri}$asum( n, x, 1 )
           do i = 1, n
              if( x(i)>=zero ) then
                 x(i) = one
              else
                 x(i) = -one
              end if
              isgn( i ) = nint( x( i ),KIND=ilp)
           end do
           kase = 2
           isave( 1 ) = 2
           return
           ! ................ entry   (isave( 1 ) = 2)
           ! first iteration.  x has been overwritten by transpose(a)*x.
           40 continue
           isave( 2 ) = stdlib_i${ri}$amax( n, x, 1 )
           isave( 3 ) = 2
           ! main loop - iterations 2,3,...,itmax.
           50 continue
           do i = 1, n
              x( i ) = zero
           end do
           x( isave( 2 ) ) = one
           kase = 1
           isave( 1 ) = 3
           return
           ! ................ entry   (isave( 1 ) = 3)
           ! x has been overwritten by a*x.
           70 continue
           call stdlib_${ri}$copy( n, x, 1, v, 1 )
           estold = est
           est = stdlib_${ri}$asum( n, v, 1 )
           do i = 1, n
              if( x(i)>=zero ) then
                 xs = one
              else
                 xs = -one
              end if
              if( nint( xs,KIND=ilp)/=isgn( i ) )go to 90
           end do
           ! repeated sign vector detected, hence algorithm has converged.
           go to 120
           90 continue
           ! test for cycling.
           if( est<=estold )go to 120
           do i = 1, n
              if( x(i)>=zero ) then
                 x(i) = one
              else
                 x(i) = -one
              end if
              isgn( i ) = nint( x( i ),KIND=ilp)
           end do
           kase = 2
           isave( 1 ) = 4
           return
           ! ................ entry   (isave( 1 ) = 4)
           ! x has been overwritten by transpose(a)*x.
           110 continue
           jlast = isave( 2 )
           isave( 2 ) = stdlib_i${ri}$amax( n, x, 1 )
           if( ( x( jlast )/=abs( x( isave( 2 ) ) ) ) .and.( isave( 3 )<itmax ) ) then
              isave( 3 ) = isave( 3 ) + 1
              go to 50
           end if
           ! iteration complete.  final stage.
           120 continue
           altsgn = one
           do i = 1, n
              x( i ) = altsgn*( one+real( i-1,KIND=${rk}$) / real( n-1,KIND=${rk}$) )
              altsgn = -altsgn
           end do
           kase = 1
           isave( 1 ) = 5
           return
           ! ................ entry   (isave( 1 ) = 5)
           ! x has been overwritten by a*x.
           140 continue
           temp = two*( stdlib_${ri}$asum( n, x, 1 ) / real( 3*n,KIND=${rk}$) )
           if( temp>est ) then
              call stdlib_${ri}$copy( n, x, 1, v, 1 )
              est = temp
           end if
           150 continue
           kase = 0
           return
     end subroutine stdlib_${ri}$lacn2


     subroutine stdlib_${ri}$lacon( n, v, x, isgn, est, kase )
     !! DLACON: estimates the 1-norm of a square, real matrix A.
     !! Reverse communication is used for evaluating matrix-vector products.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(inout) :: kase
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(inout) :: est
           ! Array Arguments 
           integer(ilp), intent(out) :: isgn(*)
           real(${rk}$), intent(out) :: v(*)
           real(${rk}$), intent(inout) :: x(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           ! Local Scalars 
           integer(ilp) :: i, iter, j, jlast, jump
           real(${rk}$) :: altsgn, estold, temp
           ! Intrinsic Functions 
           intrinsic :: abs,real,nint,sign
           ! Save Statement 
           save
           ! Executable Statements 
           if( kase==0 ) then
              do i = 1, n
                 x( i ) = one / real( n,KIND=${rk}$)
              end do
              kase = 1
              jump = 1
              return
           end if
           go to ( 20, 40, 70, 110, 140 )jump
           ! ................ entry   (jump = 1)
           ! first iteration.  x has been overwritten by a*x.
           20 continue
           if( n==1 ) then
              v( 1 ) = x( 1 )
              est = abs( v( 1 ) )
              ! ... quit
              go to 150
           end if
           est = stdlib_${ri}$asum( n, x, 1 )
           do i = 1, n
              x( i ) = sign( one, x( i ) )
              isgn( i ) = nint( x( i ),KIND=ilp)
           end do
           kase = 2
           jump = 2
           return
           ! ................ entry   (jump = 2)
           ! first iteration.  x has been overwritten by transpose(a)*x.
           40 continue
           j = stdlib_i${ri}$amax( n, x, 1 )
           iter = 2
           ! main loop - iterations 2,3,...,itmax.
           50 continue
           do i = 1, n
              x( i ) = zero
           end do
           x( j ) = one
           kase = 1
           jump = 3
           return
           ! ................ entry   (jump = 3)
           ! x has been overwritten by a*x.
           70 continue
           call stdlib_${ri}$copy( n, x, 1, v, 1 )
           estold = est
           est = stdlib_${ri}$asum( n, v, 1 )
           do i = 1, n
              if( nint( sign( one, x( i ) ),KIND=ilp)/=isgn( i ) )go to 90
           end do
           ! repeated sign vector detected, hence algorithm has converged.
           go to 120
           90 continue
           ! test for cycling.
           if( est<=estold )go to 120
           do i = 1, n
              x( i ) = sign( one, x( i ) )
              isgn( i ) = nint( x( i ),KIND=ilp)
           end do
           kase = 2
           jump = 4
           return
           ! ................ entry   (jump = 4)
           ! x has been overwritten by transpose(a)*x.
           110 continue
           jlast = j
           j = stdlib_i${ri}$amax( n, x, 1 )
           if( ( x( jlast )/=abs( x( j ) ) ) .and. ( iter<itmax ) ) then
              iter = iter + 1
              go to 50
           end if
           ! iteration complete.  final stage.
           120 continue
           altsgn = one
           do i = 1, n
              x( i ) = altsgn*( one+real( i-1,KIND=${rk}$) / real( n-1,KIND=${rk}$) )
              altsgn = -altsgn
           end do
           kase = 1
           jump = 5
           return
           ! ................ entry   (jump = 5)
           ! x has been overwritten by a*x.
           140 continue
           temp = two*( stdlib_${ri}$asum( n, x, 1 ) / real( 3*n,KIND=${rk}$) )
           if( temp>est ) then
              call stdlib_${ri}$copy( n, x, 1, v, 1 )
              est = temp
           end if
           150 continue
           kase = 0
           return
     end subroutine stdlib_${ri}$lacon


     pure subroutine stdlib_${ri}$lacpy( uplo, m, n, a, lda, b, ldb )
     !! DLACPY: copies all or part of a two-dimensional matrix A to another
     !! matrix B.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldb, m, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( stdlib_lsame( uplo, 'U' ) ) then
              do j = 1, n
                 do i = 1, min( j, m )
                    b( i, j ) = a( i, j )
                 end do
              end do
           else if( stdlib_lsame( uplo, 'L' ) ) then
              do j = 1, n
                 do i = j, m
                    b( i, j ) = a( i, j )
                 end do
              end do
           else
              do j = 1, n
                 do i = 1, m
                    b( i, j ) = a( i, j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_${ri}$lacpy


     pure subroutine stdlib_${ri}$ladiv( a, b, c, d, p, q )
     !! DLADIV: performs complex division in  real arithmetic
     !! a + i*b
     !! p + i*q = ---------
     !! c + i*d
     !! The algorithm is due to Michael Baudin and Robert L. Smith
     !! and can be found in the paper
     !! "A Robust Complex Division in Scilab"
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b, c, d
           real(${rk}$), intent(out) :: p, q
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: bs = 2.0_${rk}$
           
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, cc, dd, ab, cd, s, ov, un, be, eps
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           aa = a
           bb = b
           cc = c
           dd = d
           ab = max( abs(a), abs(b) )
           cd = max( abs(c), abs(d) )
           s = one
           ov = stdlib_${ri}$lamch( 'OVERFLOW THRESHOLD' )
           un = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           be = bs / (eps*eps)
           if( ab >= half*ov ) then
              aa = half * aa
              bb = half * bb
              s  = two * s
           end if
           if( cd >= half*ov ) then
              cc = half * cc
              dd = half * dd
              s  = half * s
           end if
           if( ab <= un*bs/eps ) then
              aa = aa * be
              bb = bb * be
              s  = s / be
           end if
           if( cd <= un*bs/eps ) then
              cc = cc * be
              dd = dd * be
              s  = s * be
           end if
           if( abs( d )<=abs( c ) ) then
              call stdlib_${ri}$ladiv1(aa, bb, cc, dd, p, q)
           else
              call stdlib_${ri}$ladiv1(bb, aa, dd, cc, p, q)
              q = -q
           end if
           p = p * s
           q = q * s
           return
     end subroutine stdlib_${ri}$ladiv


     pure subroutine stdlib_${ri}$ladiv1( a, b, c, d, p, q )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(inout) :: a
           real(${rk}$), intent(in) :: b, c, d
           real(${rk}$), intent(out) :: p, q
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: r, t
           ! Executable Statements 
           r = d / c
           t = one / (c + d * r)
           p = stdlib_${ri}$ladiv2(a, b, c, d, r, t)
           a = -a
           q = stdlib_${ri}$ladiv2(b, a, c, d, r, t)
           return
     end subroutine stdlib_${ri}$ladiv1


     pure real(${rk}$) function stdlib_${ri}$ladiv2( a, b, c, d, r, t )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b, c, d, r, t
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: br
           ! Executable Statements 
           if( r/=zero ) then
              br = b * r
              if( br/=zero ) then
                 stdlib_${ri}$ladiv2 = (a + br) * t
              else
                 stdlib_${ri}$ladiv2 = a * t + (b * t) * r
              end if
           else
              stdlib_${ri}$ladiv2 = (a + d * (b / c)) * t
           end if
           return
     end function stdlib_${ri}$ladiv2


     pure subroutine stdlib_${ri}$lae2( a, b, c, rt1, rt2 )
     !! DLAE2:  computes the eigenvalues of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, and RT2
     !! is the eigenvalue of smaller absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b, c
           real(${rk}$), intent(out) :: rt1, rt2
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           real(${rk}$) :: ab, acmn, acmx, adf, df, rt, sm, tb
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
           end if
           return
     end subroutine stdlib_${ri}$lae2


     pure subroutine stdlib_${ri}$laebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
     !! DLAEBZ: contains the iteration loops which compute and use the
     !! function N(w), which is the count of eigenvalues of a symmetric
     !! tridiagonal matrix T less than or equal to its argument  w.  It
     !! performs a choice of two types of loops:
     !! IJOB=1, followed by
     !! IJOB=2: It takes as input a list of intervals and returns a list of
     !! sufficiently small intervals whose union contains the same
     !! eigenvalues as the union of the original intervals.
     !! The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
     !! The output interval (AB(j,1),AB(j,2)] will contain
     !! eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
     !! IJOB=3: It performs a binary search in each input interval
     !! (AB(j,1),AB(j,2)] for a point  w(j)  such that
     !! N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
     !! the search.  If such a w(j) is found, then on output
     !! AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
     !! (AB(j,1),AB(j,2)] will be a small interval containing the
     !! point where N(w) jumps through NVAL(j), unless that point
     !! lies outside the initial interval.
     !! Note that the intervals are in all cases half-open intervals,
     !! i.e., of the form  (a,b] , which includes  b  but not  a .
     !! To avoid underflow, the matrix should be scaled so that its largest
     !! element is no greater than  overflow**(1/2) * underflow**(1/4)
     !! in absolute value.  To assure the most accurate computation
     !! of small eigenvalues, the matrix should be scaled to be
     !! not much smaller than that, either.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966
     !! Note: the arguments are, in general, *not* checked for unreasonable
     !! values.
               e, e2, nval, ab, c, mout,nab, work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(ilp), intent(out) :: info, mout
           real(${rk}$), intent(in) :: abstol, pivmin, reltol
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(inout) :: nab(mmax,*), nval(*)
           real(${rk}$), intent(inout) :: ab(mmax,*), c(*)
           real(${rk}$), intent(in) :: d(*), e(*), e2(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: itmp1, itmp2, j, ji, jit, jp, kf, kfnew, kl, klnew
           real(${rk}$) :: tmp1, tmp2
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! check for errors
           info = 0
           if( ijob<1 .or. ijob>3 ) then
              info = -1
              return
           end if
           ! initialize nab
           if( ijob==1 ) then
              ! compute the number of eigenvalues in the initial intervals.
              mout = 0
              do ji = 1, minp
                 do jp = 1, 2
                    tmp1 = d( 1 ) - ab( ji, jp )
                    if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                    nab( ji, jp ) = 0
                    if( tmp1<=zero )nab( ji, jp ) = 1
                    do j = 2, n
                       tmp1 = d( j ) - e2( j-1 ) / tmp1 - ab( ji, jp )
                       if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                       if( tmp1<=zero )nab( ji, jp ) = nab( ji, jp ) + 1
                    end do
                 end do
                 mout = mout + nab( ji, 2 ) - nab( ji, 1 )
              end do
              return
           end if
           ! initialize for loop
           ! kf and kl have the following meaning:
              ! intervals 1,...,kf-1 have converged.
              ! intervals kf,...,kl  still need to be refined.
           kf = 1
           kl = minp
           ! if ijob=2, initialize c.
           ! if ijob=3, use the user-supplied starting point.
           if( ijob==2 ) then
              do ji = 1, minp
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
           end if
           ! iteration loop
           loop_130: do jit = 1, nitmax
              ! loop over intervals
              if( kl-kf+1>=nbmin .and. nbmin>0 ) then
                 ! begin of parallel version of the loop
                 do ji = kf, kl
                    ! compute n(c), the number of eigenvalues less than c
                    work( ji ) = d( 1 ) - c( ji )
                    iwork( ji ) = 0
                    if( work( ji )<=pivmin ) then
                       iwork( ji ) = 1
                       work( ji ) = min( work( ji ), -pivmin )
                    end if
                    do j = 2, n
                       work( ji ) = d( j ) - e2( j-1 ) / work( ji ) - c( ji )
                       if( work( ji )<=pivmin ) then
                          iwork( ji ) = iwork( ji ) + 1
                          work( ji ) = min( work( ji ), -pivmin )
                       end if
                    end do
                 end do
                 if( ijob<=2 ) then
                    ! ijob=2: choose all intervals containing eigenvalues.
                    klnew = kl
                    loop_70: do ji = kf, kl
                       ! insure that n(w) is monotone
                       iwork( ji ) = min( nab( ji, 2 ),max( nab( ji, 1 ), iwork( ji ) ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( iwork( ji )==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = c( ji )
                       else if( iwork( ji )==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = c( ji )
                       else
                          klnew = klnew + 1
                          if( klnew<=mmax ) then
                             ! eigenvalue in both intervals -- add upper to
                             ! queue.
                             ab( klnew, 2 ) = ab( ji, 2 )
                             nab( klnew, 2 ) = nab( ji, 2 )
                             ab( klnew, 1 ) = c( ji )
                             nab( klnew, 1 ) = iwork( ji )
                             ab( ji, 2 ) = c( ji )
                             nab( ji, 2 ) = iwork( ji )
                          else
                             info = mmax + 1
                          end if
                       end if
                    end do loop_70
                    if( info/=0 )return
                    kl = klnew
                 else
                    ! ijob=3: binary search.  keep only the interval containing
                            ! w   s.t. n(w) = nval
                    do ji = kf, kl
                       if( iwork( ji )<=nval( ji ) ) then
                          ab( ji, 1 ) = c( ji )
                          nab( ji, 1 ) = iwork( ji )
                       end if
                       if( iwork( ji )>=nval( ji ) ) then
                          ab( ji, 2 ) = c( ji )
                          nab( ji, 2 ) = iwork( ji )
                       end if
                    end do
                 end if
              else
                 ! end of parallel version of the loop
                 ! begin of serial version of the loop
                 klnew = kl
                 loop_100: do ji = kf, kl
                    ! compute n(w), the number of eigenvalues less than w
                    tmp1 = c( ji )
                    tmp2 = d( 1 ) - tmp1
                    itmp1 = 0
                    if( tmp2<=pivmin ) then
                       itmp1 = 1
                       tmp2 = min( tmp2, -pivmin )
                    end if
                    do j = 2, n
                       tmp2 = d( j ) - e2( j-1 ) / tmp2 - tmp1
                       if( tmp2<=pivmin ) then
                          itmp1 = itmp1 + 1
                          tmp2 = min( tmp2, -pivmin )
                       end if
                    end do
                    if( ijob<=2 ) then
                       ! ijob=2: choose all intervals containing eigenvalues.
                       ! insure that n(w) is monotone
                       itmp1 = min( nab( ji, 2 ),max( nab( ji, 1 ), itmp1 ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( itmp1==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = tmp1
                       else if( itmp1==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = tmp1
                       else if( klnew<mmax ) then
                          ! eigenvalue in both intervals -- add upper to queue.
                          klnew = klnew + 1
                          ab( klnew, 2 ) = ab( ji, 2 )
                          nab( klnew, 2 ) = nab( ji, 2 )
                          ab( klnew, 1 ) = tmp1
                          nab( klnew, 1 ) = itmp1
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       else
                          info = mmax + 1
                          return
                       end if
                    else
                       ! ijob=3: binary search.  keep only the interval
                               ! containing  w  s.t. n(w) = nval
                       if( itmp1<=nval( ji ) ) then
                          ab( ji, 1 ) = tmp1
                          nab( ji, 1 ) = itmp1
                       end if
                       if( itmp1>=nval( ji ) ) then
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       end if
                    end if
                 end do loop_100
                 kl = klnew
              end if
              ! check for convergence
              kfnew = kf
              loop_110: do ji = kf, kl
                 tmp1 = abs( ab( ji, 2 )-ab( ji, 1 ) )
                 tmp2 = max( abs( ab( ji, 2 ) ), abs( ab( ji, 1 ) ) )
                 if( tmp1<max( abstol, pivmin, reltol*tmp2 ) .or.nab( ji, 1 )>=nab( ji, 2 ) ) &
                           then
                    ! converged -- swap with position kfnew,
                                 ! then increment kfnew
                    if( ji>kfnew ) then
                       tmp1 = ab( ji, 1 )
                       tmp2 = ab( ji, 2 )
                       itmp1 = nab( ji, 1 )
                       itmp2 = nab( ji, 2 )
                       ab( ji, 1 ) = ab( kfnew, 1 )
                       ab( ji, 2 ) = ab( kfnew, 2 )
                       nab( ji, 1 ) = nab( kfnew, 1 )
                       nab( ji, 2 ) = nab( kfnew, 2 )
                       ab( kfnew, 1 ) = tmp1
                       ab( kfnew, 2 ) = tmp2
                       nab( kfnew, 1 ) = itmp1
                       nab( kfnew, 2 ) = itmp2
                       if( ijob==3 ) then
                          itmp1 = nval( ji )
                          nval( ji ) = nval( kfnew )
                          nval( kfnew ) = itmp1
                       end if
                    end if
                    kfnew = kfnew + 1
                 end if
              end do loop_110
              kf = kfnew
              ! choose midpoints
              do ji = kf, kl
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
              ! if no more intervals to refine, quit.
              if( kf>kl )go to 140
           end do loop_130
           ! converged
           140 continue
           info = max( kl+1-kf, 0 )
           mout = kl
           return
     end subroutine stdlib_${ri}$laebz


     pure subroutine stdlib_${ri}$laed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
     !! DLAED0: computes all eigenvalues and corresponding eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
               )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*), q(ldq,*)
           real(${rk}$), intent(out) :: qstore(ldqs,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, subpbs, &
                     tlvls
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,log,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>2 ) then
              info = -1
           else if( ( icompq==1 ) .and. ( qsiz<max( 0, n ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( ldqs<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           if( icompq/=2 ) then
              ! set up workspaces for eigenvalues only/accumulate new vectors
              ! routine
              temp = log( real( n,KIND=${rk}$) ) / log( two )
              lgn = int( temp,KIND=ilp)
              if( 2**lgn<n )lgn = lgn + 1
              if( 2**lgn<n )lgn = lgn + 1
              iprmpt = indxq + n + 1
              iperm = iprmpt + n*lgn
              iqptr = iperm + n*lgn
              igivpt = iqptr + n + 2
              igivcl = igivpt + n*lgn
              igivnm = 1
              iq = igivnm + 2*n*lgn
              iwrem = iq + n**2 + 1
              ! initialize pointers
              do i = 0, subpbs
                 iwork( iprmpt+i ) = 1
                 iwork( igivpt+i ) = 1
              end do
              iwork( iqptr ) = 1
           end if
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           loop_70: do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              if( icompq==2 ) then
                 call stdlib_${ri}$steqr( 'I', matsiz, d( submat ), e( submat ),q( submat, submat ), &
                           ldq, work, info )
                 if( info/=0 )go to 130
              else
                 call stdlib_${ri}$steqr( 'I', matsiz, d( submat ), e( submat ),work( iq-1+iwork( &
                           iqptr+curr ) ), matsiz, work,info )
                 if( info/=0 )go to 130
                 if( icompq==1 ) then
                    call stdlib_${ri}$gemm( 'N', 'N', qsiz, matsiz, matsiz, one,q( 1, submat ), ldq, &
                    work( iq-1+iwork( iqptr+curr ) ), matsiz, zero, qstore( 1, submat ),ldqs )
                              
                 end if
                 iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
                 curr = curr + 1
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do loop_70
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              loop_90: do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.
           ! stdlib_${ri}$laed1 is used only for the full eigensystem of a tridiagonal
           ! matrix.
           ! stdlib_${ri}$laed7 handles the cases in which eigenvalues only or eigenvalues
           ! and eigenvectors of a full symmetric matrix (which was reduced to
           ! tridiagonal form) are desired.
                 if( icompq==2 ) then
                    call stdlib_${ri}$laed1( matsiz, d( submat ), q( submat, submat ),ldq, iwork( &
                    indxq+submat ),e( submat+msd2-1 ), msd2, work,iwork( subpbs+1 ), info )
                              
                 else
                    call stdlib_${ri}$laed7( icompq, matsiz, qsiz, tlvls, curlvl, curprb,d( submat ), &
                    qstore( 1, submat ), ldqs,iwork( indxq+submat ), e( submat+msd2-1 ),msd2, &
                    work( iq ), iwork( iqptr ),iwork( iprmpt ), iwork( iperm ),iwork( igivpt ), &
                    iwork( igivcl ),work( igivnm ), work( iwrem ),iwork( subpbs+1 ), info )
                              
                 end if
                 if( info/=0 )go to 130
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do loop_90
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           if( icompq==1 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_${ri}$copy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
              end do
              call stdlib_${ri}$copy( n, work, 1, d, 1 )
           else if( icompq==2 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_${ri}$copy( n, q( 1, j ), 1, work( n*i+1 ), 1 )
              end do
              call stdlib_${ri}$copy( n, work, 1, d, 1 )
              call stdlib_${ri}$lacpy( 'A', n, n, work( n+1 ), n, q, ldq )
           else
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
              end do
              call stdlib_${ri}$copy( n, work, 1, d, 1 )
           end if
           go to 140
           130 continue
           info = submat*( n+1 ) + submat + matsiz - 1
           140 continue
           return
     end subroutine stdlib_${ri}$laed0


     pure subroutine stdlib_${ri}$laed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
     !! DLAED1: computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix.  This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
     !! the case in which eigenvalues only or eigenvalues and eigenvectors
     !! of a full symmetric matrix (which was reduced to tridiagonal form)
     !! are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**T*u, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by DLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: indxq(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, n1, n2, &
                     zpp1
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( ldq<max( 1, n ) ) then
              info = -4
           else if( min( 1, n / 2 )>cutpnt .or. ( n / 2 )<cutpnt ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED1', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are integer pointers which indicate
           ! the portion of the workspace
           ! used by a particular array in stdlib_${ri}$laed2 and stdlib_${ri}$laed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           call stdlib_${ri}$copy( cutpnt, q( cutpnt, 1 ), ldq, work( iz ), 1 )
           zpp1 = cutpnt + 1
           call stdlib_${ri}$copy( n-cutpnt, q( zpp1, zpp1 ), ldq, work( iz+cutpnt ), 1 )
           ! deflate eigenvalues.
           call stdlib_${ri}$laed2( k, n, cutpnt, d, q, ldq, indxq, rho, work( iz ),work( idlmda ), &
           work( iw ), work( iq2 ),iwork( indx ), iwork( indxc ), iwork( indxp ),iwork( coltyp ), &
                     info )
           if( info/=0 )go to 20
           ! solve secular equation.
           if( k/=0 ) then
              is = ( iwork( coltyp )+iwork( coltyp+1 ) )*cutpnt +( iwork( coltyp+1 )+iwork( &
                        coltyp+2 ) )*( n-cutpnt ) + iq2
              call stdlib_${ri}$laed3( k, n, cutpnt, d, q, ldq, rho, work( idlmda ),work( iq2 ), iwork(&
                         indxc ), iwork( coltyp ),work( iw ), work( is ), info )
              if( info/=0 )go to 20
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_${ri}$lamrg( n1, n2, d, 1, -1, indxq )
           else
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           20 continue
           return
     end subroutine stdlib_${ri}$laed1


     pure subroutine stdlib_${ri}$laed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
     !! DLAED2: merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny entry in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
                indxp, coltyp, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, k
           integer(ilp), intent(in) :: ldq, n, n1
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*), z(*)
           real(${rk}$), intent(out) :: dlamda(*), q2(*), w(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: mone = -1.0_${rk}$
           
           ! Local Arrays 
           integer(ilp) :: ctot(4), psm(4)
           ! Local Scalars 
           integer(ilp) :: ct, i, imax, iq1, iq2, j, jmax, js, k2, n1p1, n2, nj, pj
           real(${rk}$) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( min( 1, ( n / 2 ) )>n1 .or. ( n / 2 )<n1 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_${ri}$scal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1.  since z is the concatenation of
           ! two normalized vectors, norm2(z) = sqrt(2).
           t = one / sqrt( two )
           call stdlib_${ri}$scal( n, t, z, 1 )
           ! rho = abs( norm(z)**2 * rho )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = n1p1, n
              indxq( i ) = indxq( i ) + n1
           end do
           ! re-integrate the deflated parts from the last pass
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
           end do
           call stdlib_${ri}$lamrg( n1, n2, dlamda, 1, 1, indxc )
           do i = 1, n
              indx( i ) = indxq( indxc( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_i${ri}$amax( n, z, 1 )
           jmax = stdlib_i${ri}$amax( n, d, 1 )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tol = eight*eps*max( abs( d( jmax ) ), abs( z( imax ) ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              iq2 = 1
              do j = 1, n
                 i = indx( j )
                 call stdlib_${ri}$copy( n, q( 1, i ), 1, q2( iq2 ), 1 )
                 dlamda( j ) = d( i )
                 iq2 = iq2 + n
              end do
              call stdlib_${ri}$lacpy( 'A', n, n, q2, n, q, ldq )
              call stdlib_${ri}$copy( n, dlamda, 1, d, 1 )
              go to 190
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           do i = 1, n1
              coltyp( i ) = 1
           end do
           do i = n1p1, n
              coltyp( i ) = 3
           end do
           k = 0
           k2 = n + 1
           do j = 1, n
              nj = indx( j )
              if( rho*abs( z( nj ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 coltyp( nj ) = 4
                 indxp( k2 ) = nj
                 if( j==n )go to 100
              else
                 pj = nj
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           nj = indx( j )
           if( j>n )go to 100
           if( rho*abs( z( nj ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              coltyp( nj ) = 4
              indxp( k2 ) = nj
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( pj )
              c = z( nj )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_${ri}$lapy2( c, s )
              t = d( nj ) - d( pj )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( nj ) = tau
                 z( pj ) = zero
                 if( coltyp( nj )/=coltyp( pj ) )coltyp( nj ) = 2
                 coltyp( pj ) = 4
                 call stdlib_${ri}$rot( n, q( 1, pj ), 1, q( 1, nj ), 1, c, s )
                 t = d( pj )*c**2 + d( nj )*s**2
                 d( nj ) = d( pj )*s**2 + d( nj )*c**2
                 d( pj ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( pj )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = pj
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = pj
                    end if
                 else
                    indxp( k2+i-1 ) = pj
                 end if
                 pj = nj
              else
                 k = k + 1
                 dlamda( k ) = d( pj )
                 w( k ) = z( pj )
                 indxp( k ) = pj
                 pj = nj
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           dlamda( k ) = d( pj )
           w( k ) = z( pj )
           indxp( k ) = pj
           ! count up the total number of the various types of columns, then
           ! form a permutation which positions the four column types into
           ! four uniform groups (although one or more of these groups may be
           ! empty).
           do j = 1, 4
              ctot( j ) = 0
           end do
           do j = 1, n
              ct = coltyp( j )
              ctot( ct ) = ctot( ct ) + 1
           end do
           ! psm(*) = position in submatrix (of types 1 through 4)
           psm( 1 ) = 1
           psm( 2 ) = 1 + ctot( 1 )
           psm( 3 ) = psm( 2 ) + ctot( 2 )
           psm( 4 ) = psm( 3 ) + ctot( 3 )
           k = n - ctot( 4 )
           ! fill out the indxc array so that the permutation which it induces
           ! will place all type-1 columns first, all type-2 columns next,
           ! then all type-3's, and finally all type-4's.
           do j = 1, n
              js = indxp( j )
              ct = coltyp( js )
              indx( psm( ct ) ) = js
              indxc( psm( ct ) ) = j
              psm( ct ) = psm( ct ) + 1
           end do
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           i = 1
           iq1 = 1
           iq2 = 1 + ( ctot( 1 )+ctot( 2 ) )*n1
           do j = 1, ctot( 1 )
              js = indx( i )
              call stdlib_${ri}$copy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
           end do
           do j = 1, ctot( 2 )
              js = indx( i )
              call stdlib_${ri}$copy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              call stdlib_${ri}$copy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
              iq2 = iq2 + n2
           end do
           do j = 1, ctot( 3 )
              js = indx( i )
              call stdlib_${ri}$copy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq2 = iq2 + n2
           end do
           iq1 = iq2
           do j = 1, ctot( 4 )
              js = indx( i )
              call stdlib_${ri}$copy( n, q( 1, js ), 1, q2( iq2 ), 1 )
              iq2 = iq2 + n
              z( i ) = d( js )
              i = i + 1
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_${ri}$lacpy( 'A', n, ctot( 4 ), q2( iq1 ), n,q( 1, k+1 ), ldq )
              call stdlib_${ri}$copy( n-k, z( k+1 ), 1, d( k+1 ), 1 )
           end if
           ! copy ctot into coltyp for referencing in stdlib_${ri}$laed3.
           do j = 1, 4
              coltyp( j ) = ctot( j )
           end do
           190 continue
           return
     end subroutine stdlib_${ri}$laed2


     pure subroutine stdlib_${ri}$laed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
     !! DLAED3: finds the roots of the secular equation, as defined by the
     !! values in D, W, and RHO, between 1 and K.  It makes the
     !! appropriate calls to DLAED4 and then updates the eigenvectors by
     !! multiplying the matrix of eigenvectors of the pair of eigensystems
     !! being combined by the matrix of eigenvectors of the K-by-K system
     !! which is solved here.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldq, n, n1
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           integer(ilp), intent(in) :: ctot(*), indx(*)
           real(${rk}$), intent(out) :: d(*), q(ldq,*), s(*)
           real(${rk}$), intent(inout) :: dlamda(*), w(*)
           real(${rk}$), intent(in) :: q2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, iq2, j, n12, n2, n23
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           intrinsic :: max,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( n<k ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED3', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, k
              dlamda( i ) = stdlib_${ri}$lamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = 1, k
              call stdlib_${ri}$laed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 )go to 110
           if( k==2 ) then
              do j = 1, k
                 w( 1 ) = q( 1, j )
                 w( 2 ) = q( 2, j )
                 ii = indx( 1 )
                 q( 1, j ) = w( ii )
                 ii = indx( 2 )
                 q( 2, j ) = w( ii )
              end do
              go to 110
           end if
           ! compute updated w.
           call stdlib_${ri}$copy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_${ri}$copy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 s( i ) = w( i ) / q( i, j )
              end do
              temp = stdlib_${ri}$nrm2( k, s, 1 )
              do i = 1, k
                 ii = indx( i )
                 q( i, j ) = s( ii ) / temp
              end do
           end do
           ! compute the updated eigenvectors.
           110 continue
           n2 = n - n1
           n12 = ctot( 1 ) + ctot( 2 )
           n23 = ctot( 2 ) + ctot( 3 )
           call stdlib_${ri}$lacpy( 'A', n23, k, q( ctot( 1 )+1, 1 ), ldq, s, n23 )
           iq2 = n1*n12 + 1
           if( n23/=0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', n2, k, n23, one, q2( iq2 ), n2, s, n23,zero, q( n1+1, &
                        1 ), ldq )
           else
              call stdlib_${ri}$laset( 'A', n2, k, zero, zero, q( n1+1, 1 ), ldq )
           end if
           call stdlib_${ri}$lacpy( 'A', n12, k, q, ldq, s, n12 )
           if( n12/=0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', n1, k, n12, one, q2, n1, s, n12, zero, q,ldq )
           else
              call stdlib_${ri}$laset( 'A', n1, k, zero, zero, q( 1, 1 ), ldq )
           end if
           120 continue
           return
     end subroutine stdlib_${ri}$laed3


     pure subroutine stdlib_${ri}$laed4( n, i, d, z, delta, rho, dlam, info )
     !! This subroutine computes the I-th updated eigenvalue of a symmetric
     !! rank-one modification to a diagonal matrix whose elements are
     !! given in the array d, and that
     !! D(i) < D(j)  for  i < j
     !! and that RHO > 0.  This is arranged by the calling routine, and is
     !! no loss in generality.  The rank-one modified system is thus
     !! diag( D )  +  RHO * Z * Z_transpose.
     !! where we assume the Euclidean norm of Z is 1.
     !! The method consists of approximating the rational functions in the
     !! secular equation by simpler interpolating rational functions.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(out) :: dlam
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), z(*)
           real(${rk}$), intent(out) :: delta(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           logical(lk) :: orgati, swtch, swtch3
           integer(ilp) :: ii, iim1, iip1, ip1, iter, j, niter
           real(${rk}$) :: a, b, c, del, dltlb, dltub, dphi, dpsi, dw, eps, erretm, eta, midpt, phi, &
                     prew, psi, rhoinv, tau, temp, temp1, w
           ! Local Arrays 
           real(${rk}$) :: zz(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           ! since this routine is called in an inner loop, we do no argument
           ! checking.
           ! quick return for n=1 and 2.
           info = 0
           if( n==1 ) then
               ! presumably, i=1 upon entry
              dlam = d( 1 ) + rho*z( 1 )*z( 1 )
              delta( 1 ) = one
              return
           end if
           if( n==2 ) then
              call stdlib_${ri}$laed5( i, d, z, delta, rho, dlam )
              return
           end if
           ! compute machine epsilon
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           rhoinv = one / rho
           ! the case i = n
           if( i==n ) then
              ! initialize some basic variables
              ii = n - 1
              niter = 1
              ! calculate initial guess
              midpt = rho / two
              ! if ||z||_2 is not one, then temp should be set to
              ! rho * ||z||_2^2 / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, n - 2
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi
              w = c + z( ii )*z( ii ) / delta( ii ) +z( n )*z( n ) / delta( n )
              if( w<=zero ) then
                 temp = z( n-1 )*z( n-1 ) / ( d( n )-d( n-1 )+rho ) +z( n )*z( n ) / rho
                 if( c<=temp ) then
                    tau = rho
                 else
                    del = d( n ) - d( n-1 )
                    a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                    b = z( n )*z( n )*del
                    if( a<zero ) then
                       tau = two*b / ( sqrt( a*a+four*b*c )-a )
                    else
                       tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                    end if
                 end if
                 ! it can be proved that
                     ! d(n)+rho/2 <= lambda(n) < d(n)+tau <= d(n)+rho
                 dltlb = midpt
                 dltub = rho
              else
                 del = d( n ) - d( n-1 )
                 a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                 b = z( n )*z( n )*del
                 if( a<zero ) then
                    tau = two*b / ( sqrt( a*a+four*b*c )-a )
                 else
                    tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                 end if
                 ! it can be proved that
                     ! d(n) < d(n)+tau < lambda(n) < d(n)+rho/2
                 dltlb = zero
                 dltub = midpt
              end if
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - tau
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 dlam = d( i ) + tau
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              c = w - delta( n-1 )*dpsi - delta( n )*dphi
              a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
              b = delta( n-1 )*delta( n )*w
              if( c<zero )c = abs( c )
              if( c==zero ) then
                ! eta = b/a
                 ! eta = rho - tau
                 eta = dltub - tau
              else if( a>=zero ) then
                 eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>zero )eta = -w / ( dpsi+dphi )
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              tau = tau + eta
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_90: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    dlam = d( i ) + tau
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 c = w - delta( n-1 )*dpsi - delta( n )*dphi
                 a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
                 b = delta( n-1 )*delta( n )*w
                 if( a>=zero ) then
                    eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>zero )eta = -w / ( dpsi+dphi )
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, ii
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 temp = z( n ) / delta( n )
                 phi = z( n )*temp
                 dphi = temp*temp
                 erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                           
                 w = rhoinv + phi + psi
              end do loop_90
              ! return with info = 1, niter = maxit and not converged
              info = 1
              dlam = d( i ) + tau
              go to 250
              ! end for the case i = n
           else
              ! the case for i < n
              niter = 1
              ip1 = i + 1
              ! calculate initial guess
              del = d( ip1 ) - d( i )
              midpt = del / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, i - 1
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              phi = zero
              do j = n, i + 2, -1
                 phi = phi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi + phi
              w = c + z( i )*z( i ) / delta( i ) +z( ip1 )*z( ip1 ) / delta( ip1 )
              if( w>zero ) then
                 ! d(i)< the ith eigenvalue < (d(i)+d(i+1))/2
                 ! we choose d(i) as origin.
                 orgati = .true.
                 a = c*del + z( i )*z( i ) + z( ip1 )*z( ip1 )
                 b = z( i )*z( i )*del
                 if( a>zero ) then
                    tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 else
                    tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = zero
                 dltub = midpt
              else
                 ! (d(i)+d(i+1))/2 <= the ith eigenvalue < d(i+1)
                 ! we choose d(i+1) as origin.
                 orgati = .false.
                 a = c*del - z( i )*z( i ) - z( ip1 )*z( ip1 )
                 b = z( ip1 )*z( ip1 )*del
                 if( a<zero ) then
                    tau = two*b / ( a-sqrt( abs( a*a+four*b*c ) ) )
                 else
                    tau = -( a+sqrt( abs( a*a+four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = -midpt
                 dltub = zero
              end if
              if( orgati ) then
                 do j = 1, n
                    delta( j ) = ( d( j )-d( i ) ) - tau
                 end do
              else
                 do j = 1, n
                    delta( j ) = ( d( j )-d( ip1 ) ) - tau
                 end do
              end if
              if( orgati ) then
                 ii = i
              else
                 ii = i + 1
              end if
              iim1 = ii - 1
              iip1 = ii + 1
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              w = rhoinv + phi + psi
              ! w is the value of the secular function with
              ! its ii-th element removed.
              swtch3 = .false.
              if( orgati ) then
                 if( w<zero )swtch3 = .true.
              else
                 if( w>zero )swtch3 = .true.
              end if
              if( ii==1 .or. ii==n )swtch3 = .false.
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = w + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                        *dw
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 if( orgati ) then
                    dlam = d( i ) + tau
                 else
                    dlam = d( ip1 ) + tau
                 end if
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              if( .not.swtch3 ) then
                 if( orgati ) then
                    c = w - delta( ip1 )*dw - ( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                              **2
                 else
                    c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                              **2
                 end if
                 a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                 b = delta( i )*delta( ip1 )*w
                 if( c==zero ) then
                    if( a==zero ) then
                       if( orgati ) then
                          a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                       else
                          a = z( ip1 )*z( ip1 ) + delta( i )*delta( i )*( dpsi+dphi )
                       end if
                    end if
                    eta = b / a
                 else if( a<=zero ) then
                    eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 end if
              else
                 ! interpolation using three most relevant poles
                 temp = rhoinv + psi + phi
                 if( orgati ) then
                    temp1 = z( iim1 ) / delta( iim1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )*temp1
                    zz( 1 ) = z( iim1 )*z( iim1 )
                    zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                 else
                    temp1 = z( iip1 ) / delta( iip1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )*temp1
                    zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                    zz( 3 ) = z( iip1 )*z( iip1 )
                 end if
                 zz( 2 ) = z( ii )*z( ii )
                 call stdlib_${ri}$laed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                 if( info/=0 )go to 250
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>=zero )eta = -w / dw
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              prew = w
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = rhoinv + phi + psi + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau+eta )&
                        *dw
              swtch = .false.
              if( orgati ) then
                 if( -w>abs( prew ) / ten )swtch = .true.
              else
                 if( w>abs( prew ) / ten )swtch = .true.
              end if
              tau = tau + eta
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_240: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    if( orgati ) then
                       dlam = d( i ) + tau
                    else
                       dlam = d( ip1 ) + tau
                    end if
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 if( .not.swtch3 ) then
                    if( .not.swtch ) then
                       if( orgati ) then
                          c = w - delta( ip1 )*dw -( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                                    **2
                       else
                          c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                                    **2
                       end if
                    else
                       temp = z( ii ) / delta( ii )
                       if( orgati ) then
                          dpsi = dpsi + temp*temp
                       else
                          dphi = dphi + temp*temp
                       end if
                       c = w - delta( i )*dpsi - delta( ip1 )*dphi
                    end if
                    a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                    b = delta( i )*delta( ip1 )*w
                    if( c==zero ) then
                       if( a==zero ) then
                          if( .not.swtch ) then
                             if( orgati ) then
                                a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                                          
                             else
                                a = z( ip1 )*z( ip1 ) +delta( i )*delta( i )*( dpsi+dphi )
                             end if
                          else
                             a = delta( i )*delta( i )*dpsi +delta( ip1 )*delta( ip1 )&
                                       *dphi
                          end if
                       end if
                       eta = b / a
                    else if( a<=zero ) then
                       eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                    else
                       eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                    end if
                 else
                    ! interpolation using three most relevant poles
                    temp = rhoinv + psi + phi
                    if( swtch ) then
                       c = temp - delta( iim1 )*dpsi - delta( iip1 )*dphi
                       zz( 1 ) = delta( iim1 )*delta( iim1 )*dpsi
                       zz( 3 ) = delta( iip1 )*delta( iip1 )*dphi
                    else
                       if( orgati ) then
                          temp1 = z( iim1 ) / delta( iim1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )&
                                    *temp1
                          zz( 1 ) = z( iim1 )*z( iim1 )
                          zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                       else
                          temp1 = z( iip1 ) / delta( iip1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )&
                                    *temp1
                          zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                          zz( 3 ) = z( iip1 )*z( iip1 )
                       end if
                    end if
                    call stdlib_${ri}$laed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                    if( info/=0 )go to 250
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>=zero )eta = -w / dw
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 prew = w
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, iim1
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 dphi = zero
                 phi = zero
                 do j = n, iip1, -1
                    temp = z( j ) / delta( j )
                    phi = phi + z( j )*temp
                    dphi = dphi + temp*temp
                    erretm = erretm + phi
                 end do
                 temp = z( ii ) / delta( ii )
                 dw = dpsi + dphi + temp*temp
                 temp = z( ii )*temp
                 w = rhoinv + phi + psi + temp
                 erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                           *dw
                 if( w*prew>zero .and. abs( w )>abs( prew ) / ten )swtch = .not.swtch
              end do loop_240
              ! return with info = 1, niter = maxit and not converged
              info = 1
              if( orgati ) then
                 dlam = d( i ) + tau
              else
                 dlam = d( ip1 ) + tau
              end if
           end if
           250 continue
           return
     end subroutine stdlib_${ri}$laed4


     pure subroutine stdlib_${ri}$laed5( i, d, z, delta, rho, dlam )
     !! This subroutine computes the I-th eigenvalue of a symmetric rank-one
     !! modification of a 2-by-2 diagonal matrix
     !! diag( D )  +  RHO * Z * transpose(Z) .
     !! The diagonal elements in the array D are assumed to satisfy
     !! D(i) < D(j)  for  i < j .
     !! We also assume RHO > 0 and that the Euclidean norm of the vector
     !! Z is one.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i
           real(${rk}$), intent(out) :: dlam
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(2), z(2)
           real(${rk}$), intent(out) :: delta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: b, c, del, tau, temp, w
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           del = d( 2 ) - d( 1 )
           if( i==1 ) then
              w = one + two*rho*( z( 2 )*z( 2 )-z( 1 )*z( 1 ) ) / del
              if( w>zero ) then
                 b = del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 1 )*z( 1 )*del
                 ! b > zero, always
                 tau = two*c / ( b+sqrt( abs( b*b-four*c ) ) )
                 dlam = d( 1 ) + tau
                 delta( 1 ) = -z( 1 ) / tau
                 delta( 2 ) = z( 2 ) / ( del-tau )
              else
                 b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 2 )*z( 2 )*del
                 if( b>zero ) then
                    tau = -two*c / ( b+sqrt( b*b+four*c ) )
                 else
                    tau = ( b-sqrt( b*b+four*c ) ) / two
                 end if
                 dlam = d( 2 ) + tau
                 delta( 1 ) = -z( 1 ) / ( del+tau )
                 delta( 2 ) = -z( 2 ) / tau
              end if
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           else
           ! now i=2
              b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
              c = rho*z( 2 )*z( 2 )*del
              if( b>zero ) then
                 tau = ( b+sqrt( b*b+four*c ) ) / two
              else
                 tau = two*c / ( -b+sqrt( b*b+four*c ) )
              end if
              dlam = d( 2 ) + tau
              delta( 1 ) = -z( 1 ) / ( del+tau )
              delta( 2 ) = -z( 2 ) / tau
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           end if
           return
     end subroutine stdlib_${ri}$laed5


     pure subroutine stdlib_${ri}$laed6( kniter, orgati, rho, d, z, finit, tau, info )
     !! DLAED6: computes the positive or negative root (closest to the origin)
     !! of
     !! z(1)        z(2)        z(3)
     !! f(x) =   rho + --------- + ---------- + ---------
     !! d(1)-x      d(2)-x      d(3)-x
     !! It is assumed that
     !! if ORGATI = .true. the root is between d(2) and d(3);
     !! otherwise it is between d(1) and d(2)
     !! This routine will be called by DLAED4 when necessary. In most cases,
     !! the root sought is the smallest in magnitude, though it might not be
     !! in some extremely rare situations.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: orgati
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kniter
           real(${rk}$), intent(in) :: finit, rho
           real(${rk}$), intent(out) :: tau
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(3), z(3)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 40
           
           
           ! Local Arrays 
           real(${rk}$) :: dscale(3), zscale(3)
           ! Local Scalars 
           logical(lk) :: scale
           integer(ilp) :: i, iter, niter
           real(${rk}$) :: a, b, base, c, ddf, df, eps, erretm, eta, f, fc, sclfac, sclinv, small1, &
                     small2, sminv1, sminv2, temp, temp1, temp2, temp3, temp4, lbd, ubd
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,min,sqrt
           ! Executable Statements 
           info = 0
           if( orgati ) then
              lbd = d(2)
              ubd = d(3)
           else
              lbd = d(1)
              ubd = d(2)
           end if
           if( finit < zero )then
              lbd = zero
           else
              ubd = zero
           end if
           niter = 1
           tau = zero
           if( kniter==2 ) then
              if( orgati ) then
                 temp = ( d( 3 )-d( 2 ) ) / two
                 c = rho + z( 1 ) / ( ( d( 1 )-d( 2 ) )-temp )
                 a = c*( d( 2 )+d( 3 ) ) + z( 2 ) + z( 3 )
                 b = c*d( 2 )*d( 3 ) + z( 2 )*d( 3 ) + z( 3 )*d( 2 )
              else
                 temp = ( d( 1 )-d( 2 ) ) / two
                 c = rho + z( 3 ) / ( ( d( 3 )-d( 2 ) )-temp )
                 a = c*( d( 1 )+d( 2 ) ) + z( 1 ) + z( 2 )
                 b = c*d( 1 )*d( 2 ) + z( 1 )*d( 2 ) + z( 2 )*d( 1 )
              end if
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 tau = b / a
              else if( a<=zero ) then
                 tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( tau < lbd .or. tau > ubd )tau = ( lbd+ubd )/two
              if( d(1)==tau .or. d(2)==tau .or. d(3)==tau ) then
                 tau = zero
              else
                 temp = finit + tau*z(1)/( d(1)*( d( 1 )-tau ) ) +tau*z(2)/( d(2)*( d( 2 )-tau ) )&
                            +tau*z(3)/( d(3)*( d( 3 )-tau ) )
                 if( temp <= zero )then
                    lbd = tau
                 else
                    ubd = tau
                 end if
                 if( abs( finit )<=abs( temp ) )tau = zero
              end if
           end if
           ! get machine parameters for possible scaling to avoid overflow
           ! modified by sven: parameters small1, sminv1, small2,
           ! sminv2, eps are not saved anymore between one call to the
           ! others but recomputed at each call
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           base = stdlib_${ri}$lamch( 'BASE' )
           small1 = base**( int( log( stdlib_${ri}$lamch( 'SAFMIN' ) ) / log( base ) /three,KIND=ilp) )
                     
           sminv1 = one / small1
           small2 = small1*small1
           sminv2 = sminv1*sminv1
           ! determine if scaling of inputs necessary to avoid overflow
           ! when computing 1/temp**3
           if( orgati ) then
              temp = min( abs( d( 2 )-tau ), abs( d( 3 )-tau ) )
           else
              temp = min( abs( d( 1 )-tau ), abs( d( 2 )-tau ) )
           end if
           scale = .false.
           if( temp<=small1 ) then
              scale = .true.
              if( temp<=small2 ) then
              ! scale up by power of radix nearest 1/safmin**(2/3)
                 sclfac = sminv2
                 sclinv = small2
              else
              ! scale up by power of radix nearest 1/safmin**(1/3)
                 sclfac = sminv1
                 sclinv = small1
              end if
              ! scaling up safe because d, z, tau scaled elsewhere to be o(1)
              do i = 1, 3
                 dscale( i ) = d( i )*sclfac
                 zscale( i ) = z( i )*sclfac
              end do
              tau = tau*sclfac
              lbd = lbd*sclfac
              ubd = ubd*sclfac
           else
              ! copy d and z to dscale and zscale
              do i = 1, 3
                 dscale( i ) = d( i )
                 zscale( i ) = z( i )
              end do
           end if
           fc = zero
           df = zero
           ddf = zero
           do i = 1, 3
              temp = one / ( dscale( i )-tau )
              temp1 = zscale( i )*temp
              temp2 = temp1*temp
              temp3 = temp2*temp
              fc = fc + temp1 / dscale( i )
              df = df + temp2
              ddf = ddf + temp3
           end do
           f = finit + tau*fc
           if( abs( f )<=zero )go to 60
           if( f <= zero )then
              lbd = tau
           else
              ubd = tau
           end if
              ! iteration begins -- use gragg-thornton-warner cubic convergent
                                  ! scheme
           ! it is not hard to see that
                 ! 1) iterations will go up monotonically
                    ! if finit < 0;
                 ! 2) iterations will go down monotonically
                    ! if finit > 0.
           iter = niter + 1
           loop_50: do niter = iter, maxit
              if( orgati ) then
                 temp1 = dscale( 2 ) - tau
                 temp2 = dscale( 3 ) - tau
              else
                 temp1 = dscale( 1 ) - tau
                 temp2 = dscale( 2 ) - tau
              end if
              a = ( temp1+temp2 )*f - temp1*temp2*df
              b = temp1*temp2*f
              c = f - ( temp1+temp2 )*df + temp1*temp2*ddf
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 eta = b / a
              else if( a<=zero ) then
                 eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( f*eta>=zero ) then
                 eta = -f / df
              end if
              tau = tau + eta
              if( tau < lbd .or. tau > ubd )tau = ( lbd + ubd )/two
              fc = zero
              erretm = zero
              df = zero
              ddf = zero
              do i = 1, 3
                 if ( ( dscale( i )-tau )/=zero ) then
                    temp = one / ( dscale( i )-tau )
                    temp1 = zscale( i )*temp
                    temp2 = temp1*temp
                    temp3 = temp2*temp
                    temp4 = temp1 / dscale( i )
                    fc = fc + temp4
                    erretm = erretm + abs( temp4 )
                    df = df + temp2
                    ddf = ddf + temp3
                 else
                    go to 60
                 end if
              end do
              f = finit + tau*fc
              erretm = eight*( abs( finit )+abs( tau )*erretm ) +abs( tau )*df
              if( ( abs( f )<=four*eps*erretm ) .or.( (ubd-lbd)<=four*eps*abs(tau) )  )go to &
                        60
              if( f <= zero )then
                 lbd = tau
              else
                 ubd = tau
              end if
           end do loop_50
           info = 1
           60 continue
           ! undo scaling
           if( scale )tau = tau*sclinv
           return
     end subroutine stdlib_${ri}$laed6


     pure subroutine stdlib_${ri}$laed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
     !! DLAED7: computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense symmetric matrix
     !! that has been reduced to tridiagonal form.  DLAED1 handles
     !! the case in which all eigenvalues and eigenvectors of a symmetric
     !! tridiagonal matrix are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**Tu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED8.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by DLAED9).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), givnum(2,*), q(ldq,*), qstore(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, ldq2, &
                     n1, n2, ptr
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( icompq==1 .and. qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_${ri}$laed8 and stdlib_${ri}$laed9.
           if( icompq==1 ) then
              ldq2 = qsiz
           else
              ldq2 = n
           end if
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           is = iq2 + n*ldq2
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_${ri}$laeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, work( iz ),work( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_${ri}$laed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt,work( iz ), work(&
            idlmda ), work( iq2 ), ldq2,work( iw ), perm( prmptr( curr ) ), givptr( curr+1 ),&
            givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), iwork( indxp ),iwork( indx ),&
                       info )
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_${ri}$laed9( k, 1, k, n, d, work( is ), k, rho, work( idlmda ),work( iw ), &
                        qstore( qptr( curr ) ), k, info )
              if( info/=0 )go to 30
              if( icompq==1 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', qsiz, k, k, one, work( iq2 ), ldq2,qstore( qptr( &
                           curr ) ), k, zero, q, ldq )
              end if
              qptr( curr+1 ) = qptr( curr ) + k**2
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_${ri}$lamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           30 continue
           return
     end subroutine stdlib_${ri}$laed7


     pure subroutine stdlib_${ri}$laed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
     !! DLAED8: merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*), z(*)
           real(${rk}$), intent(out) :: dlamda(*), givnum(2,*), q2(ldq2,*), w(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: mone = -1.0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(${rk}$) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -3
           else if( icompq==1 .and. qsiz<n ) then
              info = -4
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -10
           else if( ldq2<max( 1, n ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_${ri}$scal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_${ri}$scal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_${ri}$lamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_i${ri}$amax( n, z, 1 )
           jmax = stdlib_i${ri}$amax( n, d, 1 )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              if( icompq==0 ) then
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                 end do
              else
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                    call stdlib_${ri}$copy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
                 end do
                 call stdlib_${ri}$lacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ),ldq )
              end if
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 110
              else
                 jlam = j
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           if( j>n )go to 100
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_${ri}$lapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 if( icompq==1 ) then
                    call stdlib_${ri}$rot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j &
                              ) ) ), 1, c, s )
                 end if
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           110 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           if( icompq==0 ) then
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
              end do
           else
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
                 call stdlib_${ri}$copy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
           end if
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              if( icompq==0 ) then
                 call stdlib_${ri}$copy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              else
                 call stdlib_${ri}$copy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
                 call stdlib_${ri}$lacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2,q( 1, k+1 ), ldq )
              end if
           end if
           return
     end subroutine stdlib_${ri}$laed8


     pure subroutine stdlib_${ri}$laed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
     !! DLAED9: finds the roots of the secular equation, as defined by the
     !! values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
     !! appropriate calls to DLAED4 and then stores the new matrix of
     !! eigenvectors for use in calculating the next level of Z vectors.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(${rk}$), intent(inout) :: dlamda(*), w(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           intrinsic :: max,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( kstart<1 .or. kstart>max( 1, k ) ) then
              info = -2
           else if( max( 1, kstop )<kstart .or. kstop>max( 1, k ) )then
              info = -3
           else if( n<k ) then
              info = -4
           else if( ldq<max( 1, k ) ) then
              info = -7
           else if( lds<max( 1, k ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED9', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, n
              dlamda( i ) = stdlib_${ri}$lamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = kstart, kstop
              call stdlib_${ri}$laed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 .or. k==2 ) then
              do i = 1, k
                 do j = 1, k
                    s( j, i ) = q( j, i )
                 end do
              end do
              go to 120
           end if
           ! compute updated w.
           call stdlib_${ri}$copy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_${ri}$copy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i, 1 ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 q( i, j ) = w( i ) / q( i, j )
              end do
              temp = stdlib_${ri}$nrm2( k, q( 1, j ), 1 )
              do i = 1, k
                 s( i, j ) = q( i, j ) / temp
              end do
           end do
           120 continue
           return
     end subroutine stdlib_${ri}$laed9


     pure subroutine stdlib_${ri}$laeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
     !! DLAEDA: computes the Z vector corresponding to the merge step in the
     !! CURLVLth step of the merge process with TLVLS steps for the CURPBMth
     !! problem.
                q, qptr, z, ztemp, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, n, tlvls
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(${rk}$), intent(in) :: givnum(2,*), q(*)
           real(${rk}$), intent(out) :: z(*), ztemp(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: bsiz1, bsiz2, curr, i, k, mid, psiz1, psiz2, ptr, zptr1
           ! Intrinsic Functions 
           intrinsic :: real,int,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAEDA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine location of first number in second half.
           mid = n / 2 + 1
           ! gather last/first rows of appropriate eigenblocks into center of z
           ptr = 1
           ! determine location of lowest level subproblem in the full storage
           ! scheme
           curr = ptr + curpbm*2**curlvl + 2**( curlvl-1 ) - 1
           ! determine size of these matrices.  we add half to the value of
           ! the sqrt in case the machine underestimates one of these square
           ! roots.
           bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=${rk}$) ),KIND=ilp)
           bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=${rk}$) ),KIND=ilp)
                     
           do k = 1, mid - bsiz1 - 1
              z( k ) = zero
           end do
           call stdlib_${ri}$copy( bsiz1, q( qptr( curr )+bsiz1-1 ), bsiz1,z( mid-bsiz1 ), 1 )
           call stdlib_${ri}$copy( bsiz2, q( qptr( curr+1 ) ), bsiz2, z( mid ), 1 )
           do k = mid + bsiz2, n
              z( k ) = zero
           end do
           ! loop through remaining levels 1 -> curlvl applying the givens
           ! rotations and permutation and then multiplying the center matrices
           ! against the current z.
           ptr = 2**tlvls + 1
           loop_70: do k = 1, curlvl - 1
              curr = ptr + curpbm*2**( curlvl-k ) + 2**( curlvl-k-1 ) - 1
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              zptr1 = mid - psiz1
             ! apply givens at curr and curr+1
              do i = givptr( curr ), givptr( curr+1 ) - 1
                 call stdlib_${ri}$rot( 1, z( zptr1+givcol( 1, i )-1 ), 1,z( zptr1+givcol( 2, i )-1 ), &
                           1, givnum( 1, i ),givnum( 2, i ) )
              end do
              do i = givptr( curr+1 ), givptr( curr+2 ) - 1
                 call stdlib_${ri}$rot( 1, z( mid-1+givcol( 1, i ) ), 1,z( mid-1+givcol( 2, i ) ), 1, &
                           givnum( 1, i ),givnum( 2, i ) )
              end do
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              do i = 0, psiz1 - 1
                 ztemp( i+1 ) = z( zptr1+perm( prmptr( curr )+i )-1 )
              end do
              do i = 0, psiz2 - 1
                 ztemp( psiz1+i+1 ) = z( mid+perm( prmptr( curr+1 )+i )-1 )
              end do
              ! multiply blocks at curr and curr+1
              ! determine size of these matrices.  we add half to the value of
              ! the sqrt in case the machine underestimates one of these
              ! square roots.
              bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=${rk}$) ),KIND=ilp)
                        
              bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=${rk}$) ),KIND=ilp)
                        
              if( bsiz1>0 ) then
                 call stdlib_${ri}$gemv( 'T', bsiz1, bsiz1, one, q( qptr( curr ) ),bsiz1, ztemp( 1 ), &
                           1, zero, z( zptr1 ), 1 )
              end if
              call stdlib_${ri}$copy( psiz1-bsiz1, ztemp( bsiz1+1 ), 1, z( zptr1+bsiz1 ),1 )
              if( bsiz2>0 ) then
                 call stdlib_${ri}$gemv( 'T', bsiz2, bsiz2, one, q( qptr( curr+1 ) ),bsiz2, ztemp( &
                           psiz1+1 ), 1, zero, z( mid ), 1 )
              end if
              call stdlib_${ri}$copy( psiz2-bsiz2, ztemp( psiz1+bsiz2+1 ), 1,z( mid+bsiz2 ), 1 )
                        
              ptr = ptr + 2**( tlvls-k )
           end do loop_70
           return
     end subroutine stdlib_${ri}$laeda


     pure subroutine stdlib_${ri}$laein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! DLAEIN: uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(${rk}$), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(${rk}$), intent(out) :: b(ldb,*), work(*)
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: tenth = 1.0e-1_${rk}$
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(${rk}$) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,sqrt
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=${rk}$) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_${ri}$nrm2( n, vr, 1 )
                 call stdlib_${ri}$scal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_${ri}$latrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_${ri}$asum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_i${ri}$amax( n, vr, 1 )
              call stdlib_${ri}$scal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr, 1 ), stdlib_${ri}$nrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_${ri}$scal( n, rec, vr, 1 )
                 call stdlib_${ri}$scal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_${ri}$lapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_${ri}$asum( n-i, b( i, i+1 ), ldb ) +stdlib_${ri}$asum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_${ri}$lapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_${ri}$asum( j-1, b( 1, j ), 1 ) +stdlib_${ri}$asum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_${ri}$scal( n, rec, vr, 1 )
                       call stdlib_${ri}$scal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_${ri}$scal( n, rec, vr, 1 )
                             call stdlib_${ri}$scal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_${ri}$ladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_${ri}$asum( n, vr, 1 ) + stdlib_${ri}$asum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_${ri}$scal( n, one / vnorm, vr, 1 )
              call stdlib_${ri}$scal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_${ri}$laein


     pure subroutine stdlib_${ri}$laev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! DLAEV2: computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
     !! [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b, c
           real(${rk}$), intent(out) :: cs1, rt1, rt2, sn1
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: sgn1, sgn2
           real(${rk}$) :: ab, acmn, acmx, acs, adf, cs, ct, df, rt, sm, tb, tn
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              sgn1 = -1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              sgn1 = 1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
              sgn1 = 1
           end if
           ! compute the eigenvector
           if( df>=zero ) then
              cs = df + rt
              sgn2 = 1
           else
              cs = df - rt
              sgn2 = -1
           end if
           acs = abs( cs )
           if( acs>ab ) then
              ct = -tb / cs
              sn1 = one / sqrt( one+ct*ct )
              cs1 = ct*sn1
           else
              if( ab==zero ) then
                 cs1 = one
                 sn1 = zero
              else
                 tn = -cs / tb
                 cs1 = one / sqrt( one+tn*tn )
                 sn1 = tn*cs1
              end if
           end if
           if( sgn1==sgn2 ) then
              tn = cs1
              cs1 = -sn1
              sn1 = tn
           end if
           return
     end subroutine stdlib_${ri}$laev2


     subroutine stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
     !! DLAEXC: swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
     !! an upper quasi-triangular matrix T by an orthogonal similarity
     !! transformation.
     !! T must be in Schur canonical form, that is, block upper triangular
     !! with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
     !! has its diagonal elements equal and its off-diagonal elements of
     !! opposite sign.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, ldq, ldt, n, n1, n2
           ! Array Arguments 
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldd = 4
           integer(ilp), parameter :: ldx = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, j2, j3, j4, k, nd
           real(${rk}$) :: cs, dnorm, eps, scale, smlnum, sn, t11, t22, t33, tau, tau1, tau2, temp, &
                     thresh, wi1, wi2, wr1, wr2, xnorm
           ! Local Arrays 
           real(${rk}$) :: d(ldd,4), u(3), u1(3), u2(3), x(ldx,2)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 .or. n1==0 .or. n2==0 )return
           if( j1+n1>n )return
           j2 = j1 + 1
           j3 = j1 + 2
           j4 = j1 + 3
           if( n1==1 .and. n2==1 ) then
              ! swap two 1-by-1 blocks.
              t11 = t( j1, j1 )
              t22 = t( j2, j2 )
              ! determine the transformation to perform the interchange.
              call stdlib_${ri}$lartg( t( j1, j2 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( j3<=n )call stdlib_${ri}$rot( n-j1-1, t( j1, j3 ), ldt, t( j2, j3 ), ldt, cs,sn )
                        
              call stdlib_${ri}$rot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
              t( j1, j1 ) = t22
              t( j2, j2 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
           else
              ! swapping involves at least one 2-by-2 block.
              ! copy the diagonal block of order n1+n2 to the local array d
              ! and compute its norm.
              nd = n1 + n2
              call stdlib_${ri}$lacpy( 'FULL', nd, nd, t( j1, j1 ), ldt, d, ldd )
              dnorm = stdlib_${ri}$lange( 'MAX', nd, nd, d, ldd, work )
              ! compute machine-dependent threshold for test for accepting
              ! swap.
              eps = stdlib_${ri}$lamch( 'P' )
              smlnum = stdlib_${ri}$lamch( 'S' ) / eps
              thresh = max( ten*eps*dnorm, smlnum )
              ! solve t11*x - x*t22 = scale*t12 for x.
              call stdlib_${ri}$lasy2( .false., .false., -1, n1, n2, d, ldd,d( n1+1, n1+1 ), ldd, d( 1,&
                         n1+1 ), ldd, scale, x,ldx, xnorm, ierr )
              ! swap the adjacent diagonal blocks.
              k = n1 + n1 + n2 - 3
              go to ( 10, 20, 30 )k
              10 continue
              ! n1 = 1, n2 = 2: generate elementary reflector h so that:
              ! ( scale, x11, x12 ) h = ( 0, 0, * )
              u( 1 ) = scale
              u( 2 ) = x( 1, 1 )
              u( 3 ) = x( 1, 2 )
              call stdlib_${ri}$larfg( 3, u( 3 ), u, 1, tau )
              u( 3 ) = one
              t11 = t( j1, j1 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_${ri}$larfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_${ri}$larfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 3,3 )-t11 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_${ri}$larfx( 'L', 3, n-j1+1, u, tau, t( j1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'R', j2, 3, u, tau, t( 1, j1 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j3, j3 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$larfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              20 continue
              ! n1 = 2, n2 = 1: generate elementary reflector h so that:
              ! h (  -x11 ) = ( * )
                ! (  -x21 ) = ( 0 )
                ! ( scale ) = ( 0 )
              u( 1 ) = -x( 1, 1 )
              u( 2 ) = -x( 2, 1 )
              u( 3 ) = scale
              call stdlib_${ri}$larfg( 3, u( 1 ), u( 2 ), 1, tau )
              u( 1 ) = one
              t33 = t( j3, j3 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_${ri}$larfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_${ri}$larfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 2, 1 ) ), abs( d( 3, 1 ) ), abs( d( 1,1 )-t33 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_${ri}$larfx( 'R', j3, 3, u, tau, t( 1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'L', 3, n-j1, u, tau, t( j1, j2 ), ldt, work )
              t( j1, j1 ) = t33
              t( j2, j1 ) = zero
              t( j3, j1 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$larfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              30 continue
              ! n1 = 2, n2 = 2: generate elementary reflectors h(1) and h(2) so
              ! that:
              ! h(2) h(1) (  -x11  -x12 ) = (  *  * )
                        ! (  -x21  -x22 )   (  0  * )
                        ! ( scale    0  )   (  0  0 )
                        ! (    0  scale )   (  0  0 )
              u1( 1 ) = -x( 1, 1 )
              u1( 2 ) = -x( 2, 1 )
              u1( 3 ) = scale
              call stdlib_${ri}$larfg( 3, u1( 1 ), u1( 2 ), 1, tau1 )
              u1( 1 ) = one
              temp = -tau1*( x( 1, 2 )+u1( 2 )*x( 2, 2 ) )
              u2( 1 ) = -temp*u1( 2 ) - x( 2, 2 )
              u2( 2 ) = -temp*u1( 3 )
              u2( 3 ) = scale
              call stdlib_${ri}$larfg( 3, u2( 1 ), u2( 2 ), 1, tau2 )
              u2( 1 ) = one
              ! perform swap provisionally on diagonal block in d.
              call stdlib_${ri}$larfx( 'L', 3, 4, u1, tau1, d, ldd, work )
              call stdlib_${ri}$larfx( 'R', 4, 3, u1, tau1, d, ldd, work )
              call stdlib_${ri}$larfx( 'L', 3, 4, u2, tau2, d( 2, 1 ), ldd, work )
              call stdlib_${ri}$larfx( 'R', 4, 3, u2, tau2, d( 1, 2 ), ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 4, 1 ) ),abs( d( 4, 2 ) ) )&
                        >thresh )go to 50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_${ri}$larfx( 'L', 3, n-j1+1, u1, tau1, t( j1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'R', j4, 3, u1, tau1, t( 1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'L', 3, n-j1+1, u2, tau2, t( j2, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'R', j4, 3, u2, tau2, t( 1, j2 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j4, j1 ) = zero
              t( j4, j2 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$larfx( 'R', n, 3, u1, tau1, q( 1, j1 ), ldq, work )
                 call stdlib_${ri}$larfx( 'R', n, 3, u2, tau2, q( 1, j2 ), ldq, work )
              end if
              40 continue
              if( n2==2 ) then
                 ! standardize new 2-by-2 block t11
                 call stdlib_${ri}$lanv2( t( j1, j1 ), t( j1, j2 ), t( j2, j1 ),t( j2, j2 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 call stdlib_${ri}$rot( n-j1-1, t( j1, j1+2 ), ldt, t( j2, j1+2 ), ldt,cs, sn )
                 call stdlib_${ri}$rot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
                 if( wantq )call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
              if( n1==2 ) then
                 ! standardize new 2-by-2 block t22
                 j3 = j1 + n2
                 j4 = j3 + 1
                 call stdlib_${ri}$lanv2( t( j3, j3 ), t( j3, j4 ), t( j4, j3 ),t( j4, j4 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 if( j3+2<=n )call stdlib_${ri}$rot( n-j3-1, t( j3, j3+2 ), ldt, t( j4, j3+2 ),ldt, cs,&
                            sn )
                 call stdlib_${ri}$rot( j3-1, t( 1, j3 ), 1, t( 1, j4 ), 1, cs, sn )
                 if( wantq )call stdlib_${ri}$rot( n, q( 1, j3 ), 1, q( 1, j4 ), 1, cs, sn )
              end if
           end if
           return
           ! exit with info = 1 if swap was rejected.
           50 continue
           info = 1
           return
     end subroutine stdlib_${ri}$laexc


     pure subroutine stdlib_${ri}$lag2( a, lda, b, ldb, safmin, scale1, scale2, wr1,wr2, wi )
     !! DLAG2: computes the eigenvalues of a 2 x 2 generalized eigenvalue
     !! problem  A - w B, with scaling as necessary to avoid over-/underflow.
     !! The scaling factor "s" results in a modified eigenvalue equation
     !! s A - w B
     !! where  s  is a non-negative scaling factor chosen so that  w,  w B,
     !! and  s A  do not overflow and, if possible, do not underflow, either.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(${rk}$), intent(in) :: safmin
           real(${rk}$), intent(out) :: scale1, scale2, wi, wr1, wr2
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fuzzy1 = one+1.0e-5_${rk}$
           
           
           
           ! Local Scalars 
           real(${rk}$) :: a11, a12, a21, a22, abi22, anorm, as11, as12, as22, ascale, b11, b12, b22, &
           binv11, binv22, bmin, bnorm, bscale, bsize, c1, c2, c3, c4, c5, diff, discr, pp, qq, r,&
            rtmax, rtmin, s1, s2, safmax, shift, ss, sum, wabs, wbig, wdet, wscale, wsize, &
                      wsmall
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sign,sqrt
           ! Executable Statements 
           rtmin = sqrt( safmin )
           rtmax = one / rtmin
           safmax = one / safmin
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a11 = ascale*a( 1, 1 )
           a21 = ascale*a( 2, 1 )
           a12 = ascale*a( 1, 2 )
           a22 = ascale*a( 2, 2 )
           ! perturb b if necessary to insure non-singularity
           b11 = b( 1, 1 )
           b12 = b( 1, 2 )
           b22 = b( 2, 2 )
           bmin = rtmin*max( abs( b11 ), abs( b12 ), abs( b22 ), rtmin )
           if( abs( b11 )<bmin )b11 = sign( bmin, b11 )
           if( abs( b22 )<bmin )b22 = sign( bmin, b22 )
           ! scale b
           bnorm = max( abs( b11 ), abs( b12 )+abs( b22 ), safmin )
           bsize = max( abs( b11 ), abs( b22 ) )
           bscale = one / bsize
           b11 = b11*bscale
           b12 = b12*bscale
           b22 = b22*bscale
           ! compute larger eigenvalue by method described by c. van loan
           ! ( as is a shifted by -shift*b )
           binv11 = one / b11
           binv22 = one / b22
           s1 = a11*binv11
           s2 = a22*binv22
           if( abs( s1 )<=abs( s2 ) ) then
              as12 = a12 - s1*b12
              as22 = a22 - s1*b22
              ss = a21*( binv11*binv22 )
              abi22 = as22*binv22 - ss*b12
              pp = half*abi22
              shift = s1
           else
              as12 = a12 - s2*b12
              as11 = a11 - s2*b11
              ss = a21*( binv11*binv22 )
              abi22 = -ss*b12
              pp = half*( as11*binv11+abi22 )
              shift = s2
           end if
           qq = ss*as12
           if( abs( pp*rtmin )>=one ) then
              discr = ( rtmin*pp )**2 + qq*safmin
              r = sqrt( abs( discr ) )*rtmax
           else
              if( pp**2+abs( qq )<=safmin ) then
                 discr = ( rtmax*pp )**2 + qq*safmax
                 r = sqrt( abs( discr ) )*rtmin
              else
                 discr = pp**2 + qq
                 r = sqrt( abs( discr ) )
              end if
           end if
           ! note: the test of r in the following if is to cover the case when
                 ! discr is small and negative and is flushed to zero during
                 ! the calculation of r.  on machines which have a consistent
                 ! flush-to-zero threshold and handle numbers above that
                 ! threshold correctly, it would not be necessary.
           if( discr>=zero .or. r==zero ) then
              sum = pp + sign( r, pp )
              diff = pp - sign( r, pp )
              wbig = shift + sum
              ! compute smaller eigenvalue
              wsmall = shift + diff
              if( half*abs( wbig )>max( abs( wsmall ), safmin ) ) then
                 wdet = ( a11*a22-a12*a21 )*( binv11*binv22 )
                 wsmall = wdet / wbig
              end if
              ! choose (real) eigenvalue closest to 2,2 element of a*b**(-1)
              ! for wr1.
              if( pp>abi22 ) then
                 wr1 = min( wbig, wsmall )
                 wr2 = max( wbig, wsmall )
              else
                 wr1 = max( wbig, wsmall )
                 wr2 = min( wbig, wsmall )
              end if
              wi = zero
           else
              ! complex eigenvalues
              wr1 = shift + pp
              wr2 = wr1
              wi = r
           end if
           ! further scaling to avoid underflow and overflow in computing
           ! scale1 and overflow in computing w*b.
           ! this scale factor (wscale) is bounded from above using c1 and c2,
           ! and from below using c3 and c4.
              ! c1 implements the condition  s a  must never overflow.
              ! c2 implements the condition  w b  must never overflow.
              ! c3, with c2,
                 ! implement the condition that s a - w b must never overflow.
              ! c4 implements the condition  s    should not underflow.
              ! c5 implements the condition  max(s,|w|) should be at least 2.
           c1 = bsize*( safmin*max( one, ascale ) )
           c2 = safmin*max( one, bnorm )
           c3 = bsize*safmin
           if( ascale<=one .and. bsize<=one ) then
              c4 = min( one, ( ascale / safmin )*bsize )
           else
              c4 = one
           end if
           if( ascale<=one .or. bsize<=one ) then
              c5 = min( one, ascale*bsize )
           else
              c5 = one
           end if
           ! scale first eigenvalue
           wabs = abs( wr1 ) + abs( wi )
           wsize = max( safmin, c1, fuzzy1*( wabs*c2+c3 ),min( c4, half*max( wabs, c5 ) ) )
                     
           if( wsize/=one ) then
              wscale = one / wsize
              if( wsize>one ) then
                 scale1 = ( max( ascale, bsize )*wscale )*min( ascale, bsize )
              else
                 scale1 = ( min( ascale, bsize )*wscale )*max( ascale, bsize )
              end if
              wr1 = wr1*wscale
              if( wi/=zero ) then
                 wi = wi*wscale
                 wr2 = wr1
                 scale2 = scale1
              end if
           else
              scale1 = ascale*bsize
              scale2 = scale1
           end if
           ! scale second eigenvalue (if real)
           if( wi==zero ) then
              wsize = max( safmin, c1, fuzzy1*( abs( wr2 )*c2+c3 ),min( c4, half*max( abs( wr2 ), &
                        c5 ) ) )
              if( wsize/=one ) then
                 wscale = one / wsize
                 if( wsize>one ) then
                    scale2 = ( max( ascale, bsize )*wscale )*min( ascale, bsize )
                 else
                    scale2 = ( min( ascale, bsize )*wscale )*max( ascale, bsize )
                 end if
                 wr2 = wr2*wscale
              else
                 scale2 = ascale*bsize
              end if
           end if
           return
     end subroutine stdlib_${ri}$lag2


     pure subroutine stdlib_${ri}$lag2s( m, n, a, lda, sa, ldsa, info )
     !! DLAG2S: converts a DOUBLE PRECISION matrix, SA, to a SINGLE
     !! PRECISION matrix, A.
     !! RMAX is the overflow for the SINGLE PRECISION arithmetic
     !! DLAG2S checks that all the entries of A are between -RMAX and
     !! RMAX. If not the conversion is aborted and a flag is raised.
     !! This is an auxiliary routine so there is no argument checking.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldsa, m, n
           ! Array Arguments 
           real(dp), intent(out) :: sa(ldsa,*)
           real(${rk}$), intent(in) :: a(lda,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: rmax
           ! Executable Statements 
           rmax = stdlib_dlamch( 'O' )
           do j = 1, n
              do i = 1, m
                 if( ( a( i, j )<-rmax ) .or. ( a( i, j )>rmax ) ) then
                    info = 1
                    go to 30
                 end if
                 sa( i, j ) = a( i, j )
              end do
           end do
           info = 0
           30 continue
           return
     end subroutine stdlib_${ri}$lag2s


     pure subroutine stdlib_${ri}$lags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
     !! DLAGS2: computes 2-by-2 orthogonal matrices U, V and Q, such
     !! that if ( UPPER ) then
     !! U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )
     !! ( 0  A3 )     ( x  x  )
     !! and
     !! V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )
     !! ( 0  B3 )     ( x  x  )
     !! or if ( .NOT.UPPER ) then
     !! U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )
     !! ( A2 A3 )     ( 0  x  )
     !! and
     !! V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )
     !! ( B2 B3 )     ( 0  x  )
     !! The rows of the transformed A and B are parallel, where
     !! U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
     !! ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
     !! Z**T denotes the transpose of Z.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: upper
           real(${rk}$), intent(in) :: a1, a2, a3, b1, b2, b3
           real(${rk}$), intent(out) :: csq, csu, csv, snq, snu, snv
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: a, aua11, aua12, aua21, aua22, avb11, avb12, avb21, avb22, b, c, csl, csr, &
           d, r, s1, s2, snl, snr, ua11, ua11r, ua12, ua21, ua22, ua22r, vb11, vb11r, vb12, vb21, &
                     vb22, vb22r
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           if( upper ) then
              ! input matrices a and b are upper triangular matrices
              ! form matrix c = a*adj(b) = ( a b )
                                         ! ( 0 d )
              a = a1*b3
              d = a3*b1
              b = a2*b1 - a1*b2
              ! the svd of real 2-by-2 triangular c
               ! ( csl -snl )*( a b )*(  csr  snr ) = ( r 0 )
               ! ( snl  csl ) ( 0 d ) ( -snr  csr )   ( 0 t )
              call stdlib_${ri}$lasv2( a, b, d, s1, s2, snr, csr, snl, csl )
              if( abs( csl )>=abs( snl ) .or. abs( csr )>=abs( snr ) )then
                 ! compute the (1,1) and (1,2) elements of u**t *a and v**t *b,
                 ! and (1,2) element of |u|**t *|a| and |v|**t *|b|.
                 ua11r = csl*a1
                 ua12 = csl*a2 + snl*a3
                 vb11r = csr*b1
                 vb12 = csr*b2 + snr*b3
                 aua12 = abs( csl )*abs( a2 ) + abs( snl )*abs( a3 )
                 avb12 = abs( csr )*abs( b2 ) + abs( snr )*abs( b3 )
                 ! zero (1,2) elements of u**t *a and v**t *b
                 if( ( abs( ua11r )+abs( ua12 ) )/=zero ) then
                    if( aua12 / ( abs( ua11r )+abs( ua12 ) )<=avb12 /( abs( vb11r )+abs( vb12 ) ) &
                              ) then
                       call stdlib_${ri}$lartg( -ua11r, ua12, csq, snq, r )
                    else
                       call stdlib_${ri}$lartg( -vb11r, vb12, csq, snq, r )
                    end if
                 else
                    call stdlib_${ri}$lartg( -vb11r, vb12, csq, snq, r )
                 end if
                 csu = csl
                 snu = -snl
                 csv = csr
                 snv = -snr
              else
                 ! compute the (2,1) and (2,2) elements of u**t *a and v**t *b,
                 ! and (2,2) element of |u|**t *|a| and |v|**t *|b|.
                 ua21 = -snl*a1
                 ua22 = -snl*a2 + csl*a3
                 vb21 = -snr*b1
                 vb22 = -snr*b2 + csr*b3
                 aua22 = abs( snl )*abs( a2 ) + abs( csl )*abs( a3 )
                 avb22 = abs( snr )*abs( b2 ) + abs( csr )*abs( b3 )
                 ! zero (2,2) elements of u**t*a and v**t*b, and then swap.
                 if( ( abs( ua21 )+abs( ua22 ) )/=zero ) then
                    if( aua22 / ( abs( ua21 )+abs( ua22 ) )<=avb22 /( abs( vb21 )+abs( vb22 ) ) ) &
                              then
                       call stdlib_${ri}$lartg( -ua21, ua22, csq, snq, r )
                    else
                       call stdlib_${ri}$lartg( -vb21, vb22, csq, snq, r )
                    end if
                 else
                    call stdlib_${ri}$lartg( -vb21, vb22, csq, snq, r )
                 end if
                 csu = snl
                 snu = csl
                 csv = snr
                 snv = csr
              end if
           else
              ! input matrices a and b are lower triangular matrices
              ! form matrix c = a*adj(b) = ( a 0 )
                                         ! ( c d )
              a = a1*b3
              d = a3*b1
              c = a2*b3 - a3*b2
              ! the svd of real 2-by-2 triangular c
               ! ( csl -snl )*( a 0 )*(  csr  snr ) = ( r 0 )
               ! ( snl  csl ) ( c d ) ( -snr  csr )   ( 0 t )
              call stdlib_${ri}$lasv2( a, c, d, s1, s2, snr, csr, snl, csl )
              if( abs( csr )>=abs( snr ) .or. abs( csl )>=abs( snl ) )then
                 ! compute the (2,1) and (2,2) elements of u**t *a and v**t *b,
                 ! and (2,1) element of |u|**t *|a| and |v|**t *|b|.
                 ua21 = -snr*a1 + csr*a2
                 ua22r = csr*a3
                 vb21 = -snl*b1 + csl*b2
                 vb22r = csl*b3
                 aua21 = abs( snr )*abs( a1 ) + abs( csr )*abs( a2 )
                 avb21 = abs( snl )*abs( b1 ) + abs( csl )*abs( b2 )
                 ! zero (2,1) elements of u**t *a and v**t *b.
                 if( ( abs( ua21 )+abs( ua22r ) )/=zero ) then
                    if( aua21 / ( abs( ua21 )+abs( ua22r ) )<=avb21 /( abs( vb21 )+abs( vb22r ) ) &
                              ) then
                       call stdlib_${ri}$lartg( ua22r, ua21, csq, snq, r )
                    else
                       call stdlib_${ri}$lartg( vb22r, vb21, csq, snq, r )
                    end if
                 else
                    call stdlib_${ri}$lartg( vb22r, vb21, csq, snq, r )
                 end if
                 csu = csr
                 snu = -snr
                 csv = csl
                 snv = -snl
              else
                 ! compute the (1,1) and (1,2) elements of u**t *a and v**t *b,
                 ! and (1,1) element of |u|**t *|a| and |v|**t *|b|.
                 ua11 = csr*a1 + snr*a2
                 ua12 = snr*a3
                 vb11 = csl*b1 + snl*b2
                 vb12 = snl*b3
                 aua11 = abs( csr )*abs( a1 ) + abs( snr )*abs( a2 )
                 avb11 = abs( csl )*abs( b1 ) + abs( snl )*abs( b2 )
                 ! zero (1,1) elements of u**t*a and v**t*b, and then swap.
                 if( ( abs( ua11 )+abs( ua12 ) )/=zero ) then
                    if( aua11 / ( abs( ua11 )+abs( ua12 ) )<=avb11 /( abs( vb11 )+abs( vb12 ) ) ) &
                              then
                       call stdlib_${ri}$lartg( ua12, ua11, csq, snq, r )
                    else
                       call stdlib_${ri}$lartg( vb12, vb11, csq, snq, r )
                    end if
                 else
                    call stdlib_${ri}$lartg( vb12, vb11, csq, snq, r )
                 end if
                 csu = snr
                 snu = csr
                 csv = snl
                 snv = csl
              end if
           end if
           return
     end subroutine stdlib_${ri}$lags2


     pure subroutine stdlib_${ri}$lagtf( n, a, lambda, b, c, tol, d, in, info )
     !! DLAGTF: factorizes the matrix (T - lambda*I), where T is an n by n
     !! tridiagonal matrix and lambda is a scalar, as
     !! T - lambda*I = PLU,
     !! where P is a permutation matrix, L is a unit lower tridiagonal matrix
     !! with at most one non-zero sub-diagonal elements per column and U is
     !! an upper triangular matrix with at most two non-zero super-diagonal
     !! elements per column.
     !! The factorization is obtained by Gaussian elimination with partial
     !! pivoting and implicit row scaling.
     !! The parameter LAMBDA is included in the routine so that DLAGTF may
     !! be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
     !! inverse iteration.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: lambda, tol
           ! Array Arguments 
           integer(ilp), intent(out) :: in(*)
           real(${rk}$), intent(inout) :: a(*), b(*), c(*)
           real(${rk}$), intent(out) :: d(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(${rk}$) :: eps, mult, piv1, piv2, scale1, scale2, temp, tl
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DLAGTF', -info )
              return
           end if
           if( n==0 )return
           a( 1 ) = a( 1 ) - lambda
           in( n ) = 0
           if( n==1 ) then
              if( a( 1 )==zero )in( 1 ) = 1
              return
           end if
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tl = max( tol, eps )
           scale1 = abs( a( 1 ) ) + abs( b( 1 ) )
           loop_10: do k = 1, n - 1
              a( k+1 ) = a( k+1 ) - lambda
              scale2 = abs( c( k ) ) + abs( a( k+1 ) )
              if( k<( n-1 ) )scale2 = scale2 + abs( b( k+1 ) )
              if( a( k )==zero ) then
                 piv1 = zero
              else
                 piv1 = abs( a( k ) ) / scale1
              end if
              if( c( k )==zero ) then
                 in( k ) = 0
                 piv2 = zero
                 scale1 = scale2
                 if( k<( n-1 ) )d( k ) = zero
              else
                 piv2 = abs( c( k ) ) / scale2
                 if( piv2<=piv1 ) then
                    in( k ) = 0
                    scale1 = scale2
                    c( k ) = c( k ) / a( k )
                    a( k+1 ) = a( k+1 ) - c( k )*b( k )
                    if( k<( n-1 ) )d( k ) = zero
                 else
                    in( k ) = 1
                    mult = a( k ) / c( k )
                    a( k ) = c( k )
                    temp = a( k+1 )
                    a( k+1 ) = b( k ) - mult*temp
                    if( k<( n-1 ) ) then
                       d( k ) = b( k+1 )
                       b( k+1 ) = -mult*d( k )
                    end if
                    b( k ) = temp
                    c( k ) = mult
                 end if
              end if
              if( ( max( piv1, piv2 )<=tl ) .and. ( in( n )==0 ) )in( n ) = k
           end do loop_10
           if( ( abs( a( n ) )<=scale1*tl ) .and. ( in( n )==0 ) )in( n ) = n
           return
     end subroutine stdlib_${ri}$lagtf


     pure subroutine stdlib_${ri}$lagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )
     !! DLAGTM: performs a matrix-vector product of the form
     !! B := alpha * A * X + beta * B
     !! where A is a tridiagonal matrix of order N, B and X are N by NRHS
     !! matrices, and alpha and beta are real scalars, each of which may be
     !! 0., 1., or -1.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(in) :: alpha, beta
           ! Array Arguments 
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(in) :: d(*), dl(*), du(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Executable Statements 
           if( n==0 )return
           ! multiply b by beta if beta/=1.
           if( beta==zero ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = zero
                 end do
              end do
           else if( beta==-one ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = -b( i, j )
                 end do
              end do
           end if
           if( alpha==one ) then
              if( stdlib_lsame( trans, 'N' ) ) then
                 ! compute b := b + a*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j ) +du( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) + dl( n-1 )*x( n-1, j ) +d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) + dl( i-1 )*x( i-1, j ) +d( i )*x( i, j ) + du( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              else
                 ! compute b := b + a**t*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j ) +dl( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) + du( n-1 )*x( n-1, j ) +d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) + du( i-1 )*x( i-1, j ) +d( i )*x( i, j ) + dl( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              end if
           else if( alpha==-one ) then
              if( stdlib_lsame( trans, 'N' ) ) then
                 ! compute b := b - a*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j ) -du( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) - dl( n-1 )*x( n-1, j ) -d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) - dl( i-1 )*x( i-1, j ) -d( i )*x( i, j ) - du( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              else
                 ! compute b := b - a**t*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j ) -dl( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) - du( n-1 )*x( n-1, j ) -d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) - du( i-1 )*x( i-1, j ) -d( i )*x( i, j ) - dl( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$lagtm


     pure subroutine stdlib_${ri}$lagts( job, n, a, b, c, d, in, y, tol, info )
     !! DLAGTS: may be used to solve one of the systems of equations
     !! (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
     !! where T is an n by n tridiagonal matrix, for x, following the
     !! factorization of (T - lambda*I) as
     !! (T - lambda*I) = P*L*U ,
     !! by routine DLAGTF. The choice of equation to be solved is
     !! controlled by the argument JOB, and in each case there is an option
     !! to perturb zero or very small diagonal elements of U, this option
     !! being intended for use in applications such as inverse iteration.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: job, n
           real(${rk}$), intent(inout) :: tol
           ! Array Arguments 
           integer(ilp), intent(in) :: in(*)
           real(${rk}$), intent(in) :: a(*), b(*), c(*), d(*)
           real(${rk}$), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(${rk}$) :: absak, ak, bignum, eps, pert, sfmin, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max,sign
           ! Executable Statements 
           info = 0
           if( ( abs( job )>2 ) .or. ( job==0 ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAGTS', -info )
              return
           end if
           if( n==0 )return
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           sfmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           bignum = one / sfmin
           if( job<0 ) then
              if( tol<=zero ) then
                 tol = abs( a( 1 ) )
                 if( n>1 )tol = max( tol, abs( a( 2 ) ), abs( b( 1 ) ) )
                 do k = 3, n
                    tol = max( tol, abs( a( k ) ), abs( b( k-1 ) ),abs( d( k-2 ) ) )
                 end do
                 tol = tol*eps
                 if( tol==zero )tol = eps
              end if
           end if
           if( abs( job )==1 ) then
              do k = 2, n
                 if( in( k-1 )==0 ) then
                    y( k ) = y( k ) - c( k-1 )*y( k-1 )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
              if( job==1 ) then
                 loop_30: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_30
              else
                 loop_50: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    40 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 40
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 40
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_50
              end if
           else
              ! come to here if  job = 2 or -2
              if( job==2 ) then
                 loop_60: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_60
              else
                 loop_80: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    70 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 70
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 70
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_80
              end if
              do k = n, 2, -1
                 if( in( k-1 )==0 ) then
                    y( k-1 ) = y( k-1 ) - c( k-1 )*y( k )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
           end if
     end subroutine stdlib_${ri}$lagts


     pure subroutine stdlib_${ri}$lagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! DLAGV2: computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(${rk}$), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           safmin = stdlib_${ri}$lamch( 'S' )
           ulp = stdlib_${ri}$lamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_${ri}$lartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_${ri}$lartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_${ri}$lag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_${ri}$lapy2( h1, h2 )
                 qq = stdlib_${ri}$lapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_${ri}$lartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_${ri}$lartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_${ri}$lartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_${ri}$lartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_${ri}$lasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_${ri}$lasv2
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_${ri}$lagv2


     pure subroutine stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! DLAHQR: is an auxiliary routine called by DHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by DHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(${rk}$), parameter :: dat1 = 3.0_${rk}$/4.0_${rk}$
           real(${rk}$), parameter :: dat2 = -0.4375_${rk}$
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(${rk}$) :: v(3)
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min,sqrt
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=${rk}$) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=${rk}$)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_${ri}$copy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_${ri}$larfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_${ri}$lanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_${ri}$rot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_${ri}$rot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_${ri}$rot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_${ri}$lahqr


     pure subroutine stdlib_${ri}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! DLAHR2: reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by DGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_${ri}$copy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_${ri}$gemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_${ri}$trmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_${ri}$trmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_${ri}$axpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_${ri}$larfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_${ri}$gemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_${ri}$scal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_${ri}$scal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_${ri}$lacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_${ri}$lahr2


     pure subroutine stdlib_${ri}$laic1( job, j, x, sest, w, gamma, sestpr, s, c )
     !! DLAIC1: applies one step of incremental condition estimation in
     !! its simplest version:
     !! Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
     !! lower triangular matrix L, such that
     !! twonorm(L*x) = sest
     !! Then DLAIC1 computes sestpr, s, c such that
     !! the vector
     !! [ s*x ]
     !! xhat = [  c  ]
     !! is an approximate singular vector of
     !! [ L       0  ]
     !! Lhat = [ w**T gamma ]
     !! in the sense that
     !! twonorm(Lhat*xhat) = sestpr.
     !! Depending on JOB, an estimate for the largest or smallest singular
     !! value is computed.
     !! Note that [s c]**T and sestpr**2 is an eigenpair of the system
     !! diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
     !! [ gamma ]
     !! where  alpha =  x**T*w.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: j, job
           real(${rk}$), intent(out) :: c, s, sestpr
           real(${rk}$), intent(in) :: gamma, sest
           ! Array Arguments 
           real(${rk}$), intent(in) :: w(j), x(j)
        ! =====================================================================
           
           
           ! Local Scalars 
           real(${rk}$) :: absalp, absest, absgam, alpha, b, cosine, eps, norma, s1, s2, sine, t, &
                     test, tmp, zeta1, zeta2
           ! Intrinsic Functions 
           intrinsic :: abs,max,sign,sqrt
           ! Executable Statements 
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           alpha = stdlib_${ri}$dot( j, x, 1, w, 1 )
           absalp = abs( alpha )
           absgam = abs( gamma )
           absest = abs( sest )
           if( job==1 ) then
              ! estimating largest singular value
              ! special cases
              if( sest==zero ) then
                 s1 = max( absgam, absalp )
                 if( s1==zero ) then
                    s = zero
                    c = one
                    sestpr = zero
                 else
                    s = alpha / s1
                    c = gamma / s1
                    tmp = sqrt( s*s+c*c )
                    s = s / tmp
                    c = c / tmp
                    sestpr = s1*tmp
                 end if
                 return
              else if( absgam<=eps*absest ) then
                 s = one
                 c = zero
                 tmp = max( absest, absalp )
                 s1 = absest / tmp
                 s2 = absalp / tmp
                 sestpr = tmp*sqrt( s1*s1+s2*s2 )
                 return
              else if( absalp<=eps*absest ) then
                 s1 = absgam
                 s2 = absest
                 if( s1<=s2 ) then
                    s = one
                    c = zero
                    sestpr = s2
                 else
                    s = zero
                    c = one
                    sestpr = s1
                 end if
                 return
              else if( absest<=eps*absalp .or. absest<=eps*absgam ) then
                 s1 = absgam
                 s2 = absalp
                 if( s1<=s2 ) then
                    tmp = s1 / s2
                    s = sqrt( one+tmp*tmp )
                    sestpr = s2*s
                    c = ( gamma / s2 ) / s
                    s = sign( one, alpha ) / s
                 else
                    tmp = s2 / s1
                    c = sqrt( one+tmp*tmp )
                    sestpr = s1*c
                    s = ( alpha / s1 ) / c
                    c = sign( one, gamma ) / c
                 end if
                 return
              else
                 ! normal case
                 zeta1 = alpha / absest
                 zeta2 = gamma / absest
                 b = ( one-zeta1*zeta1-zeta2*zeta2 )*half
                 c = zeta1*zeta1
                 if( b>zero ) then
                    t = c / ( b+sqrt( b*b+c ) )
                 else
                    t = sqrt( b*b+c ) - b
                 end if
                 sine = -zeta1 / t
                 cosine = -zeta2 / ( one+t )
                 tmp = sqrt( sine*sine+cosine*cosine )
                 s = sine / tmp
                 c = cosine / tmp
                 sestpr = sqrt( t+one )*absest
                 return
              end if
           else if( job==2 ) then
              ! estimating smallest singular value
              ! special cases
              if( sest==zero ) then
                 sestpr = zero
                 if( max( absgam, absalp )==zero ) then
                    sine = one
                    cosine = zero
                 else
                    sine = -gamma
                    cosine = alpha
                 end if
                 s1 = max( abs( sine ), abs( cosine ) )
                 s = sine / s1
                 c = cosine / s1
                 tmp = sqrt( s*s+c*c )
                 s = s / tmp
                 c = c / tmp
                 return
              else if( absgam<=eps*absest ) then
                 s = zero
                 c = one
                 sestpr = absgam
                 return
              else if( absalp<=eps*absest ) then
                 s1 = absgam
                 s2 = absest
                 if( s1<=s2 ) then
                    s = zero
                    c = one
                    sestpr = s1
                 else
                    s = one
                    c = zero
                    sestpr = s2
                 end if
                 return
              else if( absest<=eps*absalp .or. absest<=eps*absgam ) then
                 s1 = absgam
                 s2 = absalp
                 if( s1<=s2 ) then
                    tmp = s1 / s2
                    c = sqrt( one+tmp*tmp )
                    sestpr = absest*( tmp / c )
                    s = -( gamma / s2 ) / c
                    c = sign( one, alpha ) / c
                 else
                    tmp = s2 / s1
                    s = sqrt( one+tmp*tmp )
                    sestpr = absest / s
                    c = ( alpha / s1 ) / s
                    s = -sign( one, gamma ) / s
                 end if
                 return
              else
                 ! normal case
                 zeta1 = alpha / absest
                 zeta2 = gamma / absest
                 norma = max( one+zeta1*zeta1+abs( zeta1*zeta2 ),abs( zeta1*zeta2 )+zeta2*zeta2 )
                           
                 ! see if root is closer to zero or to one
                 test = one + two*( zeta1-zeta2 )*( zeta1+zeta2 )
                 if( test>=zero ) then
                    ! root is close to zero, compute directly
                    b = ( zeta1*zeta1+zeta2*zeta2+one )*half
                    c = zeta2*zeta2
                    t = c / ( b+sqrt( abs( b*b-c ) ) )
                    sine = zeta1 / ( one-t )
                    cosine = -zeta2 / t
                    sestpr = sqrt( t+four*eps*eps*norma )*absest
                 else
                    ! root is closer to one, shift by that amount
                    b = ( zeta2*zeta2+zeta1*zeta1-one )*half
                    c = zeta1*zeta1
                    if( b>=zero ) then
                       t = -c / ( b+sqrt( b*b+c ) )
                    else
                       t = b - sqrt( b*b+c )
                    end if
                    sine = -zeta1 / t
                    cosine = -zeta2 / ( one+t )
                    sestpr = sqrt( one+t+four*eps*eps*norma )*absest
                 end if
                 tmp = sqrt( sine*sine+cosine*cosine )
                 s = sine / tmp
                 c = cosine / tmp
                 return
              end if
           end if
           return
     end subroutine stdlib_${ri}$laic1


     pure logical(lk) function stdlib_${ri}$laisnan( din1, din2 )
     !! This routine is not for general use.  It exists solely to avoid
     !! over-optimization in DISNAN.
     !! DLAISNAN: checks for NaNs by comparing its two arguments for
     !! inequality.  NaN is the only floating-point value where NaN != NaN
     !! returns .TRUE.  To check for NaNs, pass the same variable as both
     !! arguments.
     !! A compiler must assume that the two arguments are
     !! not the same variable, and the test will not be optimized away.
     !! Interprocedural or whole-program optimization may delete this
     !! test.  The ISNAN functions will be replaced by the correct
     !! Fortran 03 intrinsic once the intrinsic is widely available.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: din1, din2
        ! =====================================================================
        ! Executable Statements 
           stdlib_${ri}$laisnan = (din1/=din2)
           return
     end function stdlib_${ri}$laisnan


     pure subroutine stdlib_${ri}$laln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! DLALN2: solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by DLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(${rk}$), intent(in) :: ca, d1, d2, smin, wi, wr
           real(${rk}$), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(${rk}$) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: rswap(4), zswap(4)
           integer(ilp) :: ipivot(4,4)
           real(${rk}$) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           zswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_${ri}$ladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=${rk}$)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=${rk}$)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_${ri}$ladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$laln2


     pure subroutine stdlib_${ri}$lals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
     !! DLALS0: applies back the multiplying factors of either the left or the
     !! right singular vector matrix of a diagonal matrix appended by a row
     !! to the right hand side matrix B in solving the least squares problem
     !! using the divide-and-conquer SVD approach.
     !! For the left singular vector matrix, three types of orthogonal
     !! matrices are involved:
     !! (1L) Givens rotations: the number of such rotations is GIVPTR; the
     !! pairs of columns/rows they were applied to are stored in GIVCOL;
     !! and the C- and S-values of these rotations are stored in GIVNUM.
     !! (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
     !! row, and for J=2:N, PERM(J)-th row of B is to be moved to the
     !! J-th row.
     !! (3L) The left singular vector matrix of the remaining matrix.
     !! For the right singular vector matrix, four types of orthogonal
     !! matrices are involved:
     !! (1R) The right singular vector matrix of the remaining matrix.
     !! (2R) If SQRE = 1, one extra Givens rotation to generate the right
     !! null space.
     !! (3R) The inverse transformation of (2L).
     !! (4R) The inverse transformation of (1L).
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: c, s
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(ldgcol,*), perm(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(out) :: bx(ldbx,*), work(*)
           real(${rk}$), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, m, n, nlp1
           real(${rk}$) :: diflj, difrj, dj, dsigj, dsigjp, temp
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           n = nl + nr + 1
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( nl<1 ) then
              info = -2
           else if( nr<1 ) then
              info = -3
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -4
           else if( nrhs<1 ) then
              info = -5
           else if( ldb<n ) then
              info = -7
           else if( ldbx<n ) then
              info = -9
           else if( givptr<0 ) then
              info = -11
           else if( ldgcol<n ) then
              info = -13
           else if( ldgnum<n ) then
              info = -15
           else if( k<1 ) then
              info = -20
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLALS0', -info )
              return
           end if
           m = n + sqre
           nlp1 = nl + 1
           if( icompq==0 ) then
              ! apply back orthogonal transformations from the left.
              ! step (1l): apply back the givens rotations performed.
              do i = 1, givptr
                 call stdlib_${ri}$rot( nrhs, b( givcol( i, 2 ), 1 ), ldb,b( givcol( i, 1 ), 1 ), ldb, &
                           givnum( i, 2 ),givnum( i, 1 ) )
              end do
              ! step (2l): permute rows of b.
              call stdlib_${ri}$copy( nrhs, b( nlp1, 1 ), ldb, bx( 1, 1 ), ldbx )
              do i = 2, n
                 call stdlib_${ri}$copy( nrhs, b( perm( i ), 1 ), ldb, bx( i, 1 ), ldbx )
              end do
              ! step (3l): apply the inverse of the left singular vector
              ! matrix to bx.
              if( k==1 ) then
                 call stdlib_${ri}$copy( nrhs, bx, ldbx, b, ldb )
                 if( z( 1 )<zero ) then
                    call stdlib_${ri}$scal( nrhs, negone, b, ldb )
                 end if
              else
                 loop_50: do j = 1, k
                    diflj = difl( j )
                    dj = poles( j, 1 )
                    dsigj = -poles( j, 2 )
                    if( j<k ) then
                       difrj = -difr( j, 1 )
                       dsigjp = -poles( j+1, 2 )
                    end if
                    if( ( z( j )==zero ) .or. ( poles( j, 2 )==zero ) )then
                       work( j ) = zero
                    else
                       work( j ) = -poles( j, 2 )*z( j ) / diflj /( poles( j, 2 )+dj )
                    end if
                    do i = 1, j - 1
                       if( ( z( i )==zero ) .or.( poles( i, 2 )==zero ) ) then
                          work( i ) = zero
                       else
                          work( i ) = poles( i, 2 )*z( i ) /( stdlib_${ri}$lamc3( poles( i, 2 ), dsigj &
                                    )-diflj ) / ( poles( i, 2 )+dj )
                       end if
                    end do
                    do i = j + 1, k
                       if( ( z( i )==zero ) .or.( poles( i, 2 )==zero ) ) then
                          work( i ) = zero
                       else
                          work( i ) = poles( i, 2 )*z( i ) /( stdlib_${ri}$lamc3( poles( i, 2 ), &
                                    dsigjp )+difrj ) / ( poles( i, 2 )+dj )
                       end if
                    end do
                    work( 1 ) = negone
                    temp = stdlib_${ri}$nrm2( k, work, 1 )
                    call stdlib_${ri}$gemv( 'T', k, nrhs, one, bx, ldbx, work, 1, zero,b( j, 1 ), ldb )
                              
                    call stdlib_${ri}$lascl( 'G', 0, 0, temp, one, 1, nrhs, b( j, 1 ),ldb, info )
                              
                 end do loop_50
              end if
              ! move the deflated rows of bx to b also.
              if( k<max( m, n ) )call stdlib_${ri}$lacpy( 'A', n-k, nrhs, bx( k+1, 1 ), ldbx,b( k+1, 1 &
                        ), ldb )
           else
              ! apply back the right orthogonal transformations.
              ! step (1r): apply back the new right singular vector matrix
              ! to b.
              if( k==1 ) then
                 call stdlib_${ri}$copy( nrhs, b, ldb, bx, ldbx )
              else
                 do j = 1, k
                    dsigj = poles( j, 2 )
                    if( z( j )==zero ) then
                       work( j ) = zero
                    else
                       work( j ) = -z( j ) / difl( j ) /( dsigj+poles( j, 1 ) ) / difr( j, 2 )
                                 
                    end if
                    do i = 1, j - 1
                       if( z( j )==zero ) then
                          work( i ) = zero
                       else
                          work( i ) = z( j ) / ( stdlib_${ri}$lamc3( dsigj, -poles( i+1,2 ) )-difr( i, &
                                    1 ) ) /( dsigj+poles( i, 1 ) ) / difr( i, 2 )
                       end if
                    end do
                    do i = j + 1, k
                       if( z( j )==zero ) then
                          work( i ) = zero
                       else
                          work( i ) = z( j ) / ( stdlib_${ri}$lamc3( dsigj, -poles( i,2 ) )-difl( i ) )&
                                     /( dsigj+poles( i, 1 ) ) / difr( i, 2 )
                       end if
                    end do
                    call stdlib_${ri}$gemv( 'T', k, nrhs, one, b, ldb, work, 1, zero,bx( j, 1 ), ldbx )
                              
                 end do
              end if
              ! step (2r): if sqre = 1, apply back the rotation that is
              ! related to the right null space of the subproblem.
              if( sqre==1 ) then
                 call stdlib_${ri}$copy( nrhs, b( m, 1 ), ldb, bx( m, 1 ), ldbx )
                 call stdlib_${ri}$rot( nrhs, bx( 1, 1 ), ldbx, bx( m, 1 ), ldbx, c, s )
              end if
              if( k<max( m, n ) )call stdlib_${ri}$lacpy( 'A', n-k, nrhs, b( k+1, 1 ), ldb, bx( k+1, 1 &
                        ),ldbx )
              ! step (3r): permute rows of b.
              call stdlib_${ri}$copy( nrhs, bx( 1, 1 ), ldbx, b( nlp1, 1 ), ldb )
              if( sqre==1 ) then
                 call stdlib_${ri}$copy( nrhs, bx( m, 1 ), ldbx, b( m, 1 ), ldb )
              end if
              do i = 2, n
                 call stdlib_${ri}$copy( nrhs, bx( i, 1 ), ldbx, b( perm( i ), 1 ), ldb )
              end do
              ! step (4r): apply back the givens rotations performed.
              do i = givptr, 1, -1
                 call stdlib_${ri}$rot( nrhs, b( givcol( i, 2 ), 1 ), ldb,b( givcol( i, 1 ), 1 ), ldb, &
                           givnum( i, 2 ),-givnum( i, 1 ) )
              end do
           end if
           return
     end subroutine stdlib_${ri}$lals0


     pure subroutine stdlib_${ri}$lalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
     !! DLALSA: is an itermediate step in solving the least squares problem
     !! by computing the SVD of the coefficient matrix in compact form (The
     !! singular vectors are computed as products of simple orthorgonal
     !! matrices.).
     !! If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector
     !! matrix of an upper bidiagonal matrix to the right hand side; and if
     !! ICOMPQ = 1, DLALSA applies the right singular vector matrix to the
     !! right hand side. The singular vector matrices were generated in
     !! compact form by DLALSA.
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(out) :: bx(ldbx,*), work(*)
           real(${rk}$), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, ic, im1, inode, j, lf, ll, lvl, lvl2, nd, ndb1, ndiml, ndimr, &
                     nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqre
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( smlsiz<3 ) then
              info = -2
           else if( n<smlsiz ) then
              info = -3
           else if( nrhs<1 ) then
              info = -4
           else if( ldb<n ) then
              info = -6
           else if( ldbx<n ) then
              info = -8
           else if( ldu<n ) then
              info = -10
           else if( ldgcol<n ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLALSA', -info )
              return
           end if
           ! book-keeping and  setting up the computation tree.
           inode = 1
           ndiml = inode + n
           ndimr = ndiml + n
           call stdlib_${ri}$lasdt( n, nlvl, nd, iwork( inode ), iwork( ndiml ),iwork( ndimr ), smlsiz &
                     )
           ! the following code applies back the left singular vector factors.
           ! for applying back the right singular vector factors, go to 50.
           if( icompq==1 ) then
              go to 50
           end if
           ! the nodes on the bottom level of the tree were solved
           ! by stdlib_${ri}$lasdq. the corresponding left and right singular vector
           ! matrices are in explicit form. first apply back the left
           ! singular vector matrices.
           ndb1 = ( nd+1 ) / 2
           do i = ndb1, nd
              ! ic : center row of each node
              ! nl : number of rows of left  subproblem
              ! nr : number of rows of right subproblem
              ! nlf: starting row of the left   subproblem
              ! nrf: starting row of the right  subproblem
              i1 = i - 1
              ic = iwork( inode+i1 )
              nl = iwork( ndiml+i1 )
              nr = iwork( ndimr+i1 )
              nlf = ic - nl
              nrf = ic + 1
              call stdlib_${ri}$gemm( 'T', 'N', nl, nrhs, nl, one, u( nlf, 1 ), ldu,b( nlf, 1 ), ldb, &
                        zero, bx( nlf, 1 ), ldbx )
              call stdlib_${ri}$gemm( 'T', 'N', nr, nrhs, nr, one, u( nrf, 1 ), ldu,b( nrf, 1 ), ldb, &
                        zero, bx( nrf, 1 ), ldbx )
           end do
           ! next copy the rows of b that correspond to unchanged rows
           ! in the bidiagonal matrix to bx.
           do i = 1, nd
              ic = iwork( inode+i-1 )
              call stdlib_${ri}$copy( nrhs, b( ic, 1 ), ldb, bx( ic, 1 ), ldbx )
           end do
           ! finally go through the left singular vector matrices of all
           ! the other subproblems bottom-up on the tree.
           j = 2**nlvl
           sqre = 0
           do lvl = nlvl, 1, -1
              lvl2 = 2*lvl - 1
              ! find the first node lf and last node ll on
              ! the current level lvl
              if( lvl==1 ) then
                 lf = 1
                 ll = 1
              else
                 lf = 2**( lvl-1 )
                 ll = 2*lf - 1
              end if
              do i = lf, ll
                 im1 = i - 1
                 ic = iwork( inode+im1 )
                 nl = iwork( ndiml+im1 )
                 nr = iwork( ndimr+im1 )
                 nlf = ic - nl
                 nrf = ic + 1
                 j = j - 1
                 call stdlib_${ri}$lals0( icompq, nl, nr, sqre, nrhs, bx( nlf, 1 ), ldbx,b( nlf, 1 ), &
                 ldb, perm( nlf, lvl ),givptr( j ), givcol( nlf, lvl2 ), ldgcol,givnum( nlf, lvl2 &
                 ), ldu, poles( nlf, lvl2 ),difl( nlf, lvl ), difr( nlf, lvl2 ),z( nlf, lvl ), k( &
                           j ), c( j ), s( j ), work,info )
              end do
           end do
           go to 90
           ! icompq = 1: applying back the right singular vector factors.
           50 continue
           ! first now go through the right singular vector matrices of all
           ! the tree nodes top-down.
           j = 0
           loop_70: do lvl = 1, nlvl
              lvl2 = 2*lvl - 1
              ! find the first node lf and last node ll on
              ! the current level lvl.
              if( lvl==1 ) then
                 lf = 1
                 ll = 1
              else
                 lf = 2**( lvl-1 )
                 ll = 2*lf - 1
              end if
              do i = ll, lf, -1
                 im1 = i - 1
                 ic = iwork( inode+im1 )
                 nl = iwork( ndiml+im1 )
                 nr = iwork( ndimr+im1 )
                 nlf = ic - nl
                 nrf = ic + 1
                 if( i==ll ) then
                    sqre = 0
                 else
                    sqre = 1
                 end if
                 j = j + 1
                 call stdlib_${ri}$lals0( icompq, nl, nr, sqre, nrhs, b( nlf, 1 ), ldb,bx( nlf, 1 ), &
                 ldbx, perm( nlf, lvl ),givptr( j ), givcol( nlf, lvl2 ), ldgcol,givnum( nlf, &
                 lvl2 ), ldu, poles( nlf, lvl2 ),difl( nlf, lvl ), difr( nlf, lvl2 ),z( nlf, lvl )&
                           , k( j ), c( j ), s( j ), work,info )
              end do
           end do loop_70
           ! the nodes on the bottom level of the tree were solved
           ! by stdlib_${ri}$lasdq. the corresponding right singular vector
           ! matrices are in explicit form. apply them back.
           ndb1 = ( nd+1 ) / 2
           do i = ndb1, nd
              i1 = i - 1
              ic = iwork( inode+i1 )
              nl = iwork( ndiml+i1 )
              nr = iwork( ndimr+i1 )
              nlp1 = nl + 1
              if( i==nd ) then
                 nrp1 = nr
              else
                 nrp1 = nr + 1
              end if
              nlf = ic - nl
              nrf = ic + 1
              call stdlib_${ri}$gemm( 'T', 'N', nlp1, nrhs, nlp1, one, vt( nlf, 1 ), ldu,b( nlf, 1 ), &
                        ldb, zero, bx( nlf, 1 ), ldbx )
              call stdlib_${ri}$gemm( 'T', 'N', nrp1, nrhs, nrp1, one, vt( nrf, 1 ), ldu,b( nrf, 1 ), &
                        ldb, zero, bx( nrf, 1 ), ldbx )
           end do
           90 continue
           return
     end subroutine stdlib_${ri}$lalsa


     pure subroutine stdlib_${ri}$lalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, iwork, &
     !! DLALSD: uses the singular value decomposition of A to solve the least
     !! squares problem of finding X to minimize the Euclidean norm of each
     !! column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
     !! are N-by-NRHS. The solution X overwrites B.
     !! The singular values of A smaller than RCOND times the largest
     !! singular value are treated as zero in solving the least squares
     !! problem; in this case a minimum norm solution is returned.
     !! The actual singular values are returned in D in ascending order.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: ldb, n, nrhs, smlsiz
           real(${rk}$), intent(in) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: b(ldb,*), d(*), e(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: bx, bxst, c, difl, difr, givcol, givnum, givptr, i, icmpq1, icmpq2, &
           iwk, j, k, nlvl, nm1, nsize, nsub, nwork, perm, poles, s, sizei, smlszp, sqre, st, st1,&
                      u, vt, z
           real(${rk}$) :: cs, eps, orgnrm, r, rcnd, sn, tol
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,log,sign
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -3
           else if( nrhs<1 ) then
              info = -4
           else if( ( ldb<1 ) .or. ( ldb<n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLALSD', -info )
              return
           end if
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           ! set up the tolerance.
           if( ( rcond<=zero ) .or. ( rcond>=one ) ) then
              rcnd = eps
           else
              rcnd = rcond
           end if
           rank = 0
           ! quick return if possible.
           if( n==0 ) then
              return
           else if( n==1 ) then
              if( d( 1 )==zero ) then
                 call stdlib_${ri}$laset( 'A', 1, nrhs, zero, zero, b, ldb )
              else
                 rank = 1
                 call stdlib_${ri}$lascl( 'G', 0, 0, d( 1 ), one, 1, nrhs, b, ldb, info )
                 d( 1 ) = abs( d( 1 ) )
              end if
              return
           end if
           ! rotate the matrix if it is lower bidiagonal.
           if( uplo=='L' ) then
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( nrhs==1 ) then
                    call stdlib_${ri}$rot( 1, b( i, 1 ), 1, b( i+1, 1 ), 1, cs, sn )
                 else
                    work( i*2-1 ) = cs
                    work( i*2 ) = sn
                 end if
              end do
              if( nrhs>1 ) then
                 do i = 1, nrhs
                    do j = 1, n - 1
                       cs = work( j*2-1 )
                       sn = work( j*2 )
                       call stdlib_${ri}$rot( 1, b( j, i ), 1, b( j+1, i ), 1, cs, sn )
                    end do
                 end do
              end if
           end if
           ! scale.
           nm1 = n - 1
           orgnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( orgnrm==zero ) then
              call stdlib_${ri}$laset( 'A', n, nrhs, zero, zero, b, ldb )
              return
           end if
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, info )
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, info )
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              nwork = 1 + n*n
              call stdlib_${ri}$laset( 'A', n, n, zero, one, work, n )
              call stdlib_${ri}$lasdq( 'U', 0, n, n, 0, nrhs, d, e, work, n, work, n, b,ldb, work( &
                        nwork ), info )
              if( info/=0 ) then
                 return
              end if
              tol = rcnd*abs( d( stdlib_i${ri}$amax( n, d, 1 ) ) )
              do i = 1, n
                 if( d( i )<=tol ) then
                    call stdlib_${ri}$laset( 'A', 1, nrhs, zero, zero, b( i, 1 ), ldb )
                 else
                    call stdlib_${ri}$lascl( 'G', 0, 0, d( i ), one, 1, nrhs, b( i, 1 ),ldb, info )
                              
                    rank = rank + 1
                 end if
              end do
              call stdlib_${ri}$gemm( 'T', 'N', n, nrhs, n, one, work, n, b, ldb, zero,work( nwork ), &
                        n )
              call stdlib_${ri}$lacpy( 'A', n, nrhs, work( nwork ), n, b, ldb )
              ! unscale.
              call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, info )
              call stdlib_${ri}$lasrt( 'D', n, d, info )
              call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, nrhs, b, ldb, info )
              return
           end if
           ! book-keeping and setting up some constants.
           nlvl = int( log( real( n,KIND=${rk}$) / real( smlsiz+1,KIND=${rk}$) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           u = 1
           vt = 1 + smlsiz*n
           difl = vt + smlszp*n
           difr = difl + nlvl*n
           z = difr + nlvl*n*2
           c = z + nlvl*n
           s = c + n
           poles = s + n
           givnum = poles + 2*nlvl*n
           bx = givnum + 2*nlvl*n
           nwork = bx + n*nrhs
           sizei = 1 + n
           k = sizei + n
           givptr = k + n
           perm = givptr + n
           givcol = perm + nlvl*n
           iwk = givcol + nlvl*n*2
           st = 1
           sqre = 0
           icmpq1 = 1
           icmpq2 = 0
           nsub = 0
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           loop_60: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 nsub = nsub + 1
                 iwork( nsub ) = st
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - st + 1
                    iwork( sizei+nsub-1 ) = nsize
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - st + 1
                    iwork( sizei+nsub-1 ) = nsize
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n), which is not solved
                    ! explicitly.
                    nsize = i - st + 1
                    iwork( sizei+nsub-1 ) = nsize
                    nsub = nsub + 1
                    iwork( nsub ) = n
                    iwork( sizei+nsub-1 ) = 1
                    call stdlib_${ri}$copy( nrhs, b( n, 1 ), ldb, work( bx+nm1 ), n )
                 end if
                 st1 = st - 1
                 if( nsize==1 ) then
                    ! this is a 1-by-1 subproblem and is not solved
                    ! explicitly.
                    call stdlib_${ri}$copy( nrhs, b( st, 1 ), ldb, work( bx+st1 ), n )
                 else if( nsize<=smlsiz ) then
                    ! this is a small subproblem and is solved by stdlib_${ri}$lasdq.
                    call stdlib_${ri}$laset( 'A', nsize, nsize, zero, one,work( vt+st1 ), n )
                    call stdlib_${ri}$lasdq( 'U', 0, nsize, nsize, 0, nrhs, d( st ),e( st ), work( vt+&
                              st1 ), n, work( nwork ),n, b( st, 1 ), ldb, work( nwork ), info )
                    if( info/=0 ) then
                       return
                    end if
                    call stdlib_${ri}$lacpy( 'A', nsize, nrhs, b( st, 1 ), ldb,work( bx+st1 ), n )
                              
                 else
                    ! a large problem. solve it using divide and conquer.
                    call stdlib_${ri}$lasda( icmpq1, smlsiz, nsize, sqre, d( st ),e( st ), work( u+st1 &
                    ), n, work( vt+st1 ),iwork( k+st1 ), work( difl+st1 ),work( difr+st1 ), work( &
                    z+st1 ),work( poles+st1 ), iwork( givptr+st1 ),iwork( givcol+st1 ), n, iwork( &
                    perm+st1 ),work( givnum+st1 ), work( c+st1 ),work( s+st1 ), work( nwork ), &
                              iwork( iwk ),info )
                    if( info/=0 ) then
                       return
                    end if
                    bxst = bx + st1
                    call stdlib_${ri}$lalsa( icmpq2, smlsiz, nsize, nrhs, b( st, 1 ),ldb, work( bxst ),&
                     n, work( u+st1 ), n,work( vt+st1 ), iwork( k+st1 ),work( difl+st1 ), work( &
                     difr+st1 ),work( z+st1 ), work( poles+st1 ),iwork( givptr+st1 ), iwork( &
                     givcol+st1 ), n,iwork( perm+st1 ), work( givnum+st1 ),work( c+st1 ), work( s+&
                               st1 ), work( nwork ),iwork( iwk ), info )
                    if( info/=0 ) then
                       return
                    end if
                 end if
                 st = i + 1
              end if
           end do loop_60
           ! apply the singular values and treat the tiny ones as zero.
           tol = rcnd*abs( d( stdlib_i${ri}$amax( n, d, 1 ) ) )
           do i = 1, n
              ! some of the elements in d can be negative because 1-by-1
              ! subproblems were not solved explicitly.
              if( abs( d( i ) )<=tol ) then
                 call stdlib_${ri}$laset( 'A', 1, nrhs, zero, zero, work( bx+i-1 ), n )
              else
                 rank = rank + 1
                 call stdlib_${ri}$lascl( 'G', 0, 0, d( i ), one, 1, nrhs,work( bx+i-1 ), n, info )
                           
              end if
              d( i ) = abs( d( i ) )
           end do
           ! now apply back the right singular vectors.
           icmpq2 = 1
           do i = 1, nsub
              st = iwork( i )
              st1 = st - 1
              nsize = iwork( sizei+i-1 )
              bxst = bx + st1
              if( nsize==1 ) then
                 call stdlib_${ri}$copy( nrhs, work( bxst ), n, b( st, 1 ), ldb )
              else if( nsize<=smlsiz ) then
                 call stdlib_${ri}$gemm( 'T', 'N', nsize, nrhs, nsize, one,work( vt+st1 ), n, work( &
                           bxst ), n, zero,b( st, 1 ), ldb )
              else
                 call stdlib_${ri}$lalsa( icmpq2, smlsiz, nsize, nrhs, work( bxst ), n,b( st, 1 ), ldb,&
                  work( u+st1 ), n,work( vt+st1 ), iwork( k+st1 ),work( difl+st1 ), work( difr+&
                  st1 ),work( z+st1 ), work( poles+st1 ),iwork( givptr+st1 ), iwork( givcol+st1 ),&
                   n,iwork( perm+st1 ), work( givnum+st1 ),work( c+st1 ), work( s+st1 ), work( &
                             nwork ),iwork( iwk ), info )
                 if( info/=0 ) then
                    return
                 end if
              end if
           end do
           ! unscale and sort the singular values.
           call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, info )
           call stdlib_${ri}$lasrt( 'D', n, d, info )
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, nrhs, b, ldb, info )
           return
     end subroutine stdlib_${ri}$lalsd


     pure real(${rk}$) function stdlib_${ri}$lamch( cmach )
     !! DLAMCH: determines quad precision machine parameters.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: cmach
       ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: rnd, eps, sfmin, small, rmach
           ! Intrinsic Functions 
           intrinsic :: digits,epsilon,huge,maxexponent,minexponent,radix,tiny
           ! Executable Statements 
           ! assume rounding, not chopping. always.
           rnd = one
           if( one==rnd ) then
              eps = epsilon(zero) * 0.5
           else
              eps = epsilon(zero)
           end if
           if( stdlib_lsame( cmach, 'E' ) ) then
              rmach = eps
           else if( stdlib_lsame( cmach, 'S' ) ) then
              sfmin = tiny(zero)
              small = one / huge(zero)
              if( small>=sfmin ) then
                 ! use small plus a bit, to avoid the possibility of rounding
                 ! causing overflow when computing  1/sfmin.
                 sfmin = small*( one+eps )
              end if
              rmach = sfmin
           else if( stdlib_lsame( cmach, 'B' ) ) then
              rmach = radix(zero)
           else if( stdlib_lsame( cmach, 'P' ) ) then
              rmach = eps * radix(zero)
           else if( stdlib_lsame( cmach, 'N' ) ) then
              rmach = digits(zero)
           else if( stdlib_lsame( cmach, 'R' ) ) then
              rmach = rnd
           else if( stdlib_lsame( cmach, 'M' ) ) then
              rmach = minexponent(zero)
           else if( stdlib_lsame( cmach, 'U' ) ) then
              rmach = tiny(zero)
           else if( stdlib_lsame( cmach, 'L' ) ) then
              rmach = maxexponent(zero)
           else if( stdlib_lsame( cmach, 'O' ) ) then
              rmach = huge(zero)
           else
              rmach = zero
           end if
           stdlib_${ri}$lamch = rmach
           return
     end function stdlib_${ri}$lamch


     pure real(${rk}$) function stdlib_${ri}$lamc3( a, b )
        ! -- lapack auxiliary routine --
           ! univ. of tennessee, univ. of california berkeley and nag ltd..
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b
       ! =====================================================================
           ! Executable Statements 
           stdlib_${ri}$lamc3 = a + b
           return
     end function stdlib_${ri}$lamc3


     pure subroutine stdlib_${ri}$lamrg( n1, n2, a, dtrd1, dtrd2, index )
     !! DLAMRG: will create a permutation list which will merge the elements
     !! of A (which is composed of two independently sorted sets) into a
     !! single set which is sorted in ascending order.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dtrd1, dtrd2, n1, n2
           ! Array Arguments 
           integer(ilp), intent(out) :: index(*)
           real(${rk}$), intent(in) :: a(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ind1, ind2, n1sv, n2sv
           ! Executable Statements 
           n1sv = n1
           n2sv = n2
           if( dtrd1>0 ) then
              ind1 = 1
           else
              ind1 = n1
           end if
           if( dtrd2>0 ) then
              ind2 = 1 + n1
           else
              ind2 = n1 + n2
           end if
           i = 1
           ! while ( (n1sv > 0)
           10 continue
           if( n1sv>0 .and. n2sv>0 ) then
              if( a( ind1 )<=a( ind2 ) ) then
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + dtrd1
                 n1sv = n1sv - 1
              else
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + dtrd2
                 n2sv = n2sv - 1
              end if
              go to 10
           end if
           ! end while
           if( n1sv==0 ) then
              do n1sv = 1, n2sv
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + dtrd2
              end do
           else
           ! n2sv == 0
              do n2sv = 1, n1sv
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + dtrd1
              end do
           end if
           return
     end subroutine stdlib_${ri}$lamrg


     pure subroutine stdlib_${ri}$lamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, work, &
     !! DLAMSWLQ: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product of blocked
     !! elementary reflectors computed by short wide LQ
     !! factorization (DLASWLQ)
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, mb, nb, ldt, lwork, ldc
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: c(ldc,*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: i, ii, kk, ctr, lw
           ! External Subroutines 
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork<0
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'T' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           if (left) then
             lw = n * mb
           else
             lw = m * mb
           end if
           info = 0
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( k<0 ) then
             info = -5
           else if( m<k ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<mb .or. mb<1) then
             info = -6
           else if( lda<max( 1, k ) ) then
             info = -9
           else if( ldt<max( 1, mb) ) then
             info = -11
           else if( ldc<max( 1, m ) ) then
              info = -13
           else if(( lwork<max(1,lw)).and.(.not.lquery)) then
             info = -15
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DLAMSWLQ', -info )
             work(1) = lw
             return
           else if (lquery) then
             work(1) = lw
             return
           end if
           ! quick return if possible
           if( min(m,n,k)==0 ) then
             return
           end if
           if((nb<=k).or.(nb>=max(m,n,k))) then
             call stdlib_${ri}$gemlqt( side, trans, m, n, k, mb, a, lda,t, ldt, c, ldc, work, info)
                       
             return
           end if
           if(left.and.tran) then
               ! multiply q to the last block of c
               kk = mod((m-k),(nb-k))
               ctr = (m-k)/(nb-k)
               if (kk>0) then
                 ii=m-kk+1
                 call stdlib_${ri}$tpmlqt('L','T',kk , n, k, 0, mb, a(1,ii), lda,t(1,ctr*k+1), ldt, c(&
                           1,1), ldc,c(ii,1), ldc, work, info )
               else
                 ii=m+1
               end if
               do i=ii-(nb-k),nb+1,-(nb-k)
               ! multiply q to the current block of c (1:m,i:i+nb)
                 ctr = ctr - 1
                 call stdlib_${ri}$tpmlqt('L','T',nb-k , n, k, 0,mb, a(1,i), lda,t(1, ctr*k+1),ldt, c(&
                           1,1), ldc,c(i,1), ldc, work, info )
               end do
               ! multiply q to the first block of c (1:m,1:nb)
               call stdlib_${ri}$gemlqt('L','T',nb , n, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                         info )
           else if (left.and.notran) then
               ! multiply q to the first block of c
              kk = mod((m-k),(nb-k))
              ii=m-kk+1
              ctr = 1
              call stdlib_${ri}$gemlqt('L','N',nb , n, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=nb+1,ii-nb+k,(nb-k)
               ! multiply q to the current block of c (i:i+nb,1:n)
               call stdlib_${ri}$tpmlqt('L','N',nb-k , n, k, 0,mb, a(1,i), lda,t(1,ctr*k+1), ldt, c(1,&
                         1), ldc,c(i,1), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=m) then
               ! multiply q to the last block of c
               call stdlib_${ri}$tpmlqt('L','N',kk , n, k, 0, mb, a(1,ii), lda,t(1,ctr*k+1), ldt, c(1,&
                         1), ldc,c(ii,1), ldc, work, info )
              end if
           else if(right.and.notran) then
               ! multiply q to the last block of c
               kk = mod((n-k),(nb-k))
               ctr = (n-k)/(nb-k)
               if (kk>0) then
                 ii=n-kk+1
                 call stdlib_${ri}$tpmlqt('R','N',m , kk, k, 0, mb, a(1, ii), lda,t(1,ctr *k+1), ldt, &
                           c(1,1), ldc,c(1,ii), ldc, work, info )
               else
                 ii=n+1
               end if
               do i=ii-(nb-k),nb+1,-(nb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
                  ctr = ctr - 1
                  call stdlib_${ri}$tpmlqt('R','N', m, nb-k, k, 0, mb, a(1, i), lda,t(1,ctr*k+1), ldt, &
                            c(1,1), ldc,c(1,i), ldc, work, info )
               end do
               ! multiply q to the first block of c (1:m,1:mb)
               call stdlib_${ri}$gemlqt('R','N',m , nb, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                         info )
           else if (right.and.tran) then
             ! multiply q to the first block of c
              kk = mod((n-k),(nb-k))
              ctr = 1
              ii=n-kk+1
              call stdlib_${ri}$gemlqt('R','T',m , nb, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=nb+1,ii-nb+k,(nb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
               call stdlib_${ri}$tpmlqt('R','T',m , nb-k, k, 0,mb, a(1,i), lda,t(1,ctr*k+1), ldt, c(1,&
                         1), ldc,c(1,i), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=n) then
             ! multiply q to the last block of c
               call stdlib_${ri}$tpmlqt('R','T',m , kk, k, 0,mb, a(1,ii), lda,t(1,ctr*k+1),ldt, c(1,1),&
                          ldc,c(1,ii), ldc, work, info )
              end if
           end if
           work(1) = lw
           return
     end subroutine stdlib_${ri}$lamswlq


     pure subroutine stdlib_${ri}$lamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, work, &
     !! DLAMTSQR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product
     !! of blocked elementary reflectors computed by tall skinny
     !! QR factorization (DLATSQR)
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, mb, nb, ldt, lwork, ldc
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: c(ldc,*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: i, ii, kk, lw, ctr, q
           ! External Subroutines 
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork<0
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'T' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           if (left) then
             lw = n * nb
             q = m
           else
             lw = mb * nb
             q = n
           end if
           info = 0
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<k ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<0 ) then
             info = -5
           else if( k<nb .or. nb<1 ) then
             info = -7
           else if( lda<max( 1, q ) ) then
             info = -9
           else if( ldt<max( 1, nb) ) then
             info = -11
           else if( ldc<max( 1, m ) ) then
              info = -13
           else if(( lwork<max(1,lw)).and.(.not.lquery)) then
             info = -15
           end if
           ! determine the block size if it is tall skinny or short and wide
           if( info==0)  then
               work(1) = lw
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DLAMTSQR', -info )
             return
           else if (lquery) then
            return
           end if
           ! quick return if possible
           if( min(m,n,k)==0 ) then
             return
           end if
           if((mb<=k).or.(mb>=max(m,n,k))) then
             call stdlib_${ri}$gemqrt( side, trans, m, n, k, nb, a, lda,t, ldt, c, ldc, work, info)
                       
             return
            end if
           if(left.and.notran) then
               ! multiply q to the last block of c
              kk = mod((m-k),(mb-k))
              ctr = (m-k)/(mb-k)
              if (kk>0) then
                ii=m-kk+1
                call stdlib_${ri}$tpmqrt('L','N',kk , n, k, 0, nb, a(ii,1), lda,t(1,ctr*k+1),ldt , c(1,&
                          1), ldc,c(ii,1), ldc, work, info )
              else
                ii=m+1
              end if
              do i=ii-(mb-k),mb+1,-(mb-k)
               ! multiply q to the current block of c (i:i+mb,1:n)
                ctr = ctr - 1
                call stdlib_${ri}$tpmqrt('L','N',mb-k , n, k, 0,nb, a(i,1), lda,t(1,ctr*k+1),ldt, c(1,&
                          1), ldc,c(i,1), ldc, work, info )
              end do
               ! multiply q to the first block of c (1:mb,1:n)
              call stdlib_${ri}$gemqrt('L','N',mb , n, k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
           else if (left.and.tran) then
               ! multiply q to the first block of c
              kk = mod((m-k),(mb-k))
              ii=m-kk+1
              ctr = 1
              call stdlib_${ri}$gemqrt('L','T',mb , n, k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=mb+1,ii-mb+k,(mb-k)
               ! multiply q to the current block of c (i:i+mb,1:n)
               call stdlib_${ri}$tpmqrt('L','T',mb-k , n, k, 0,nb, a(i,1), lda,t(1,ctr * k + 1),ldt, c(&
                         1,1), ldc,c(i,1), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=m) then
               ! multiply q to the last block of c
               call stdlib_${ri}$tpmqrt('L','T',kk , n, k, 0,nb, a(ii,1), lda,t(1,ctr * k + 1), ldt, c(&
                         1,1), ldc,c(ii,1), ldc, work, info )
              end if
           else if(right.and.tran) then
               ! multiply q to the last block of c
               kk = mod((n-k),(mb-k))
               ctr = (n-k)/(mb-k)
               if (kk>0) then
                 ii=n-kk+1
                 call stdlib_${ri}$tpmqrt('R','T',m , kk, k, 0, nb, a(ii,1), lda,t(1,ctr*k+1), ldt, c(&
                           1,1), ldc,c(1,ii), ldc, work, info )
               else
                 ii=n+1
               end if
               do i=ii-(mb-k),mb+1,-(mb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
                 ctr = ctr - 1
                 call stdlib_${ri}$tpmqrt('R','T',m , mb-k, k, 0,nb, a(i,1), lda,t(1,ctr*k+1), ldt, c(&
                           1,1), ldc,c(1,i), ldc, work, info )
               end do
               ! multiply q to the first block of c (1:m,1:mb)
               call stdlib_${ri}$gemqrt('R','T',m , mb, k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                         info )
           else if (right.and.notran) then
               ! multiply q to the first block of c
              kk = mod((n-k),(mb-k))
              ii=n-kk+1
              ctr = 1
              call stdlib_${ri}$gemqrt('R','N', m, mb , k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=mb+1,ii-mb+k,(mb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
               call stdlib_${ri}$tpmqrt('R','N', m, mb-k, k, 0,nb, a(i,1), lda,t(1, ctr * k + 1),ldt, &
                         c(1,1), ldc,c(1,i), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=n) then
               ! multiply q to the last block of c
               call stdlib_${ri}$tpmqrt('R','N', m, kk , k, 0,nb, a(ii,1), lda,t(1, ctr * k + 1),ldt, &
                         c(1,1), ldc,c(1,ii), ldc, work, info )
              end if
           end if
           work(1) = lw
           return
     end subroutine stdlib_${ri}$lamtsqr


     pure integer(ilp) function stdlib_${ri}$laneg( n, d, lld, sigma, pivmin, r )
     !! DLANEG: computes the Sturm count, the number of negative pivots
     !! encountered while factoring tridiagonal T - sigma I = L D L^T.
     !! This implementation works directly on the factors without forming
     !! the tridiagonal matrix T.  The Sturm count is also the number of
     !! eigenvalues of T less than sigma.
     !! This routine is called from DLARRB.
     !! The current routine does not use the PIVMIN parameter but rather
     !! requires IEEE-754 propagation of Infinities and NaNs.  This
     !! routine also has no input range restrictions but does require
     !! default exception handling such that x/0 produces Inf when x is
     !! non-zero, and Inf/Inf produces NaN.  For more information, see:
     !! Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
     !! Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
     !! Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
     !! (Tech report version in LAWN 172 with the same title.)
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, r
           real(${rk}$), intent(in) :: pivmin, sigma
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), lld(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: blklen = 128
           
           ! some architectures propagate infinities and nans very slowly, so
           ! the code computes counts in blklen chunks.  then a nan can
           ! propagate at most blklen columns before being detected.  this is
           ! not a general tuning parameter; it needs only to be just large
           ! enough that the overhead is tiny in common cases.
           
           ! Local Scalars 
           integer(ilp) :: bj, j, neg1, neg2, negcnt
           real(${rk}$) :: bsav, dminus, dplus, gamma, p, t, tmp
           logical(lk) :: sawnan
           ! Intrinsic Functions 
           intrinsic :: min,max
           ! Executable Statements 
           negcnt = 0
           ! i) upper part: l d l^t - sigma i = l+ d+ l+^t
           t = -sigma
           loop_210: do bj = 1, r-1, blklen
              neg1 = 0
              bsav = t
              do j = bj, min(bj+blklen-1, r-1)
                 dplus = d( j ) + t
                 if( dplus<zero ) neg1 = neg1 + 1
                 tmp = t / dplus
                 t = tmp * lld( j ) - sigma
              end do
              sawnan = stdlib_${ri}$isnan( t )
           ! run a slower version of the above loop if a nan is detected.
           ! a nan should occur only with a zero pivot after an infinite
           ! pivot.  in that case, substituting 1 for t/dplus is the
           ! correct limit.
              if( sawnan ) then
                 neg1 = 0
                 t = bsav
                 do j = bj, min(bj+blklen-1, r-1)
                    dplus = d( j ) + t
                    if( dplus<zero ) neg1 = neg1 + 1
                    tmp = t / dplus
                    if (stdlib_${ri}$isnan(tmp)) tmp = one
                    t = tmp * lld(j) - sigma
                 end do
              end if
              negcnt = negcnt + neg1
           end do loop_210
           ! ii) lower part: l d l^t - sigma i = u- d- u-^t
           p = d( n ) - sigma
           do bj = n-1, r, -blklen
              neg2 = 0
              bsav = p
              do j = bj, max(bj-blklen+1, r), -1
                 dminus = lld( j ) + p
                 if( dminus<zero ) neg2 = neg2 + 1
                 tmp = p / dminus
                 p = tmp * d( j ) - sigma
              end do
              sawnan = stdlib_${ri}$isnan( p )
           ! as above, run a slower version that substitutes 1 for inf/inf.
              if( sawnan ) then
                 neg2 = 0
                 p = bsav
                 do j = bj, max(bj-blklen+1, r), -1
                    dminus = lld( j ) + p
                    if( dminus<zero ) neg2 = neg2 + 1
                    tmp = p / dminus
                    if (stdlib_${ri}$isnan(tmp)) tmp = one
                    p = tmp * d(j) - sigma
                 end do
              end if
              negcnt = negcnt + neg2
           end do
           ! iii) twist index
             ! t was shifted by sigma initially.
           gamma = (t + sigma) + p
           if( gamma<zero ) negcnt = negcnt+1
           stdlib_${ri}$laneg = negcnt
     end function stdlib_${ri}$laneg


     real(${rk}$) function stdlib_${ri}$langb( norm, n, kl, ku, ab, ldab,work )
     !! DLANGB:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: kl, ku, ldab, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, k, l
           real(${rk}$) :: scale, sum, value, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              do j = 1, n
                 do i = max( ku+2-j, 1 ), min( n+ku+1-j, kl+ku+1 )
                    temp = abs( ab( i, j ) )
                    if( value<temp .or. stdlib_${ri}$isnan( temp ) ) value = temp
                 end do
              end do
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              do j = 1, n
                 sum = zero
                 do i = max( ku+2-j, 1 ), min( n+ku+1-j, kl+ku+1 )
                    sum = sum + abs( ab( i, j ) )
                 end do
                 if( value<sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              do i = 1, n
                 work( i ) = zero
              end do
              do j = 1, n
                 k = ku + 1 - j
                 do i = max( 1, j-ku ), min( n, j+kl )
                    work( i ) = work( i ) + abs( ab( k+i, j ) )
                 end do
              end do
              value = zero
              do i = 1, n
                 temp = work( i )
                 if( value<temp .or. stdlib_${ri}$isnan( temp ) ) value = temp
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              do j = 1, n
                 l = max( 1, j-ku )
                 k = ku + 1 - j + l
                 call stdlib_${ri}$lassq( min( n, j+kl )-l+1, ab( k, j ), 1, scale, sum )
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$langb = value
           return
     end function stdlib_${ri}$langb


     real(${rk}$) function stdlib_${ri}$lange( norm, m, n, a, lda, work )
     !! DLANGE:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! real matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: scale, sum, value, temp
           ! Intrinsic Functions 
           intrinsic :: abs,min,sqrt
           ! Executable Statements 
           if( min( m, n )==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              do j = 1, n
                 do i = 1, m
                    temp = abs( a( i, j ) )
                    if( value<temp .or. stdlib_${ri}$isnan( temp ) ) value = temp
                 end do
              end do
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              do j = 1, n
                 sum = zero
                 do i = 1, m
                    sum = sum + abs( a( i, j ) )
                 end do
                 if( value<sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              do i = 1, m
                 work( i ) = zero
              end do
              do j = 1, n
                 do i = 1, m
                    work( i ) = work( i ) + abs( a( i, j ) )
                 end do
              end do
              value = zero
              do i = 1, m
                 temp = work( i )
                 if( value<temp .or. stdlib_${ri}$isnan( temp ) ) value = temp
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              do j = 1, n
                 call stdlib_${ri}$lassq( m, a( 1, j ), 1, scale, sum )
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lange = value
           return
     end function stdlib_${ri}$lange


     pure real(${rk}$) function stdlib_${ri}$langt( norm, n, dl, d, du )
     !! DLANGT:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! real tridiagonal matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), dl(*), du(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: anorm, scale, sum, temp
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n<=0 ) then
              anorm = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              anorm = abs( d( n ) )
              do i = 1, n - 1
                 if( anorm<abs( dl( i ) ) .or. stdlib_${ri}$isnan( abs( dl( i ) ) ) )anorm = abs(dl(i))
                           
                 if( anorm<abs( d( i ) ) .or. stdlib_${ri}$isnan( abs( d( i ) ) ) )anorm = abs(d(i))
                           
                 if( anorm<abs( du( i ) ) .or. stdlib_${ri}$isnan (abs( du( i ) ) ) )anorm = abs(du(i))
                           
              end do
           else if( stdlib_lsame( norm, 'O' ) .or. norm=='1' ) then
              ! find norm1(a).
              if( n==1 ) then
                 anorm = abs( d( 1 ) )
              else
                 anorm = abs( d( 1 ) )+abs( dl( 1 ) )
                 temp = abs( d( n ) )+abs( du( n-1 ) )
                 if( anorm < temp .or. stdlib_${ri}$isnan( temp ) ) anorm = temp
                 do i = 2, n - 1
                    temp = abs( d( i ) )+abs( dl( i ) )+abs( du( i-1 ) )
                    if( anorm < temp .or. stdlib_${ri}$isnan( temp ) ) anorm = temp
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              if( n==1 ) then
                 anorm = abs( d( 1 ) )
              else
                 anorm = abs( d( 1 ) )+abs( du( 1 ) )
                 temp = abs( d( n ) )+abs( dl( n-1 ) )
                 if( anorm < temp .or. stdlib_${ri}$isnan( temp ) ) anorm = temp
                 do i = 2, n - 1
                    temp = abs( d( i ) )+abs( du( i ) )+abs( dl( i-1 ) )
                    if( anorm < temp .or. stdlib_${ri}$isnan( temp ) ) anorm = temp
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              call stdlib_${ri}$lassq( n, d, 1, scale, sum )
              if( n>1 ) then
                 call stdlib_${ri}$lassq( n-1, dl, 1, scale, sum )
                 call stdlib_${ri}$lassq( n-1, du, 1, scale, sum )
              end if
              anorm = scale*sqrt( sum )
           end if
           stdlib_${ri}$langt = anorm
           return
     end function stdlib_${ri}$langt


     real(${rk}$) function stdlib_${ri}$lanhs( norm, n, a, lda, work )
     !! DLANHS:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! Hessenberg matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              do j = 1, n
                 do i = 1, min( n, j+1 )
                    sum = abs( a( i, j ) )
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end do
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              do j = 1, n
                 sum = zero
                 do i = 1, min( n, j+1 )
                    sum = sum + abs( a( i, j ) )
                 end do
                 if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              do i = 1, n
                 work( i ) = zero
              end do
              do j = 1, n
                 do i = 1, min( n, j+1 )
                    work( i ) = work( i ) + abs( a( i, j ) )
                 end do
              end do
              value = zero
              do i = 1, n
                 sum = work( i )
                 if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              do j = 1, n
                 call stdlib_${ri}$lassq( min( n, j+1 ), a( 1, j ), 1, scale, sum )
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lanhs = value
           return
     end function stdlib_${ri}$lanhs


     real(${rk}$) function stdlib_${ri}$lansb( norm, uplo, n, k, ab, ldab,work )
     !! DLANSB:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n symmetric band matrix A,  with k super-diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: k, ldab, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           real(${rk}$) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    do i = max( k+2-j, 1 ), k + 1
                       sum = abs( ab( i, j ) )
                       if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                    end do
                 end do
              else
                 do j = 1, n
                    do i = 1, min( n+1-j, k+1 )
                       sum = abs( ab( i, j ) )
                       if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                    end do
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    l = k + 1 - j
                    do i = max( 1, j-k ), j - 1
                       absa = abs( ab( l+i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    work( j ) = sum + abs( ab( k+1, j ) )
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( ab( 1, j ) )
                    l = 1 - j
                    do i = j + 1, min( n, j+k )
                       absa = abs( ab( l+i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( k>0 ) then
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 2, n
                       call stdlib_${ri}$lassq( min( j-1, k ), ab( max( k+2-j, 1 ), j ),1, scale, sum )
                                 
                    end do
                    l = k + 1
                 else
                    do j = 1, n - 1
                       call stdlib_${ri}$lassq( min( n-j, k ), ab( 2, j ), 1, scale,sum )
                    end do
                    l = 1
                 end if
                 sum = 2*sum
              else
                 l = 1
              end if
              call stdlib_${ri}$lassq( n, ab( l, 1 ), ldab, scale, sum )
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lansb = value
           return
     end function stdlib_${ri}$lansb


     real(${rk}$) function stdlib_${ri}$lansf( norm, transr, uplo, n, a, work )
     !! DLANSF: returns the value of the one norm, or the Frobenius norm, or
     !! the infinity norm, or the element of largest absolute value of a
     !! real symmetric matrix A in RFP format.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, transr, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(0:*)
           real(${rk}$), intent(out) :: work(0:*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, ifm, ilu, noe, n1, k, l, lda
           real(${rk}$) :: scale, s, value, aa, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           if( n==0 ) then
              stdlib_${ri}$lansf = zero
              return
           else if( n==1 ) then
              stdlib_${ri}$lansf = abs( a(0) )
              return
           end if
           ! set noe = 1 if n is odd. if n is even set noe=0
           noe = 1
           if( mod( n, 2 )==0 )noe = 0
           ! set ifm = 0 when form='t or 't' and 1 otherwise
           ifm = 1
           if( stdlib_lsame( transr, 'T' ) )ifm = 0
           ! set ilu = 0 when uplo='u or 'u' and 1 otherwise
           ilu = 1
           if( stdlib_lsame( uplo, 'U' ) )ilu = 0
           ! set lda = (n+1)/2 when ifm = 0
           ! set lda = n when ifm = 1 and noe = 1
           ! set lda = n+1 when ifm = 1 and noe = 0
           if( ifm==1 ) then
              if( noe==1 ) then
                 lda = n
              else
                 ! noe=0
                 lda = n + 1
              end if
           else
              ! ifm=0
              lda = ( n+1 ) / 2
           end if
           if( stdlib_lsame( norm, 'M' ) ) then
             ! find max(abs(a(i,j))).
              k = ( n+1 ) / 2
              value = zero
              if( noe==1 ) then
                 ! n is odd
                 if( ifm==1 ) then
                 ! a is n by k
                    do j = 0, k - 1
                       do i = 0, n - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end do
                 else
                    ! xpose case; a is k by n
                    do j = 0, n - 1
                       do i = 0, k - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end do
                 end if
              else
                 ! n is even
                 if( ifm==1 ) then
                    ! a is n+1 by k
                    do j = 0, k - 1
                       do i = 0, n
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end do
                 else
                    ! xpose case; a is k by n+1
                    do j = 0, n
                       do i = 0, k - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              if( ifm==1 ) then
                 k = n / 2
                 if( noe==1 ) then
                    ! n is odd
                    if( ilu==0 ) then
                       do i = 0, k - 1
                          work( i ) = zero
                       end do
                       do j = 0, k
                          s = zero
                          do i = 0, k + j - 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(i,j+k)
                             s = s + aa
                             work( i ) = work( i ) + aa
                          end do
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j+k,j+k)
                          work( j+k ) = s + aa
                          if( i==k+k )go to 10
                          i = i + 1
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j,j)
                          work( j ) = work( j ) + aa
                          s = zero
                          do l = j + 1, k - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       10 continue
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    else
                       ! ilu = 1
                       k = k + 1
                       ! k=(n+1)/2 for n odd and ilu=1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = k - 1, 0, -1
                          s = zero
                          do i = 0, j - 2
                             aa = abs( a( i+j*lda ) )
                             ! -> a(j+k,i+k)
                             s = s + aa
                             work( i+k ) = work( i+k ) + aa
                          end do
                          if( j>0 ) then
                             aa = abs( a( i+j*lda ) )
                             ! -> a(j+k,j+k)
                             s = s + aa
                             work( i+k ) = work( i+k ) + s
                             ! i=j
                             i = i + 1
                          end if
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j,j)
                          work( j ) = aa
                          s = zero
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end if
                 else
                    ! n is even
                    if( ilu==0 ) then
                       do i = 0, k - 1
                          work( i ) = zero
                       end do
                       do j = 0, k - 1
                          s = zero
                          do i = 0, k + j - 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(i,j+k)
                             s = s + aa
                             work( i ) = work( i ) + aa
                          end do
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j+k,j+k)
                          work( j+k ) = s + aa
                          i = i + 1
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j,j)
                          work( j ) = work( j ) + aa
                          s = zero
                          do l = j + 1, k - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    else
                       ! ilu = 1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = k - 1, 0, -1
                          s = zero
                          do i = 0, j - 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(j+k,i+k)
                             s = s + aa
                             work( i+k ) = work( i+k ) + aa
                          end do
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j+k,j+k)
                          s = s + aa
                          work( i+k ) = work( i+k ) + s
                          ! i=j
                          i = i + 1
                          aa = abs( a( i+j*lda ) )
                          ! -> a(j,j)
                          work( j ) = aa
                          s = zero
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end if
                 end if
              else
                 ! ifm=0
                 k = n / 2
                 if( noe==1 ) then
                    ! n is odd
                    if( ilu==0 ) then
                       n1 = k
                       ! n/2
                       k = k + 1
                       ! k is the row size and lda
                       do i = n1, n - 1
                          work( i ) = zero
                       end do
                       do j = 0, n1 - 1
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,n1+i)
                             work( i+n1 ) = work( i+n1 ) + aa
                             s = s + aa
                          end do
                          work( j ) = s
                       end do
                       ! j=n1=k-1 is special
                       s = abs( a( 0+j*lda ) )
                       ! a(k-1,k-1)
                       do i = 1, k - 1
                          aa = abs( a( i+j*lda ) )
                          ! a(k-1,i+n1)
                          work( i+n1 ) = work( i+n1 ) + aa
                          s = s + aa
                       end do
                       work( j ) = work( j ) + s
                       do j = k, n - 1
                          s = zero
                          do i = 0, j - k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(i,j-k)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          ! i=j-k
                          aa = abs( a( i+j*lda ) )
                          ! a(j-k,j-k)
                          s = s + aa
                          work( j-k ) = work( j-k ) + s
                          i = i + 1
                          s = abs( a( i+j*lda ) )
                          ! a(j,j)
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,l)
                             work( l ) = work( l ) + aa
                             s = s + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    else
                       ! ilu=1
                       k = k + 1
                       ! k=(n+1)/2 for n odd and ilu=1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = 0, k - 2
                          ! process
                          s = zero
                          do i = 0, j - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          aa = abs( a( i+j*lda ) )
                          ! i=j so process of a(j,j)
                          s = s + aa
                          work( j ) = s
                          ! is initialised here
                          i = i + 1
                          ! i=j process a(j+k,j+k)
                          aa = abs( a( i+j*lda ) )
                          s = aa
                          do l = k + j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(l,k+j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( k+j ) = work( k+j ) + s
                       end do
                       ! j=k-1 is special :process col a(k-1,0:k-1)
                       s = zero
                       do i = 0, k - 2
                          aa = abs( a( i+j*lda ) )
                          ! a(k,i)
                          work( i ) = work( i ) + aa
                          s = s + aa
                       end do
                       ! i=k-1
                       aa = abs( a( i+j*lda ) )
                       ! a(k-1,k-1)
                       s = s + aa
                       work( i ) = s
                       ! done with col j=k+1
                       do j = k, n - 1
                          ! process col j of a = a(j,0:k-1)
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end if
                 else
                    ! n is even
                    if( ilu==0 ) then
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = 0, k - 1
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,i+k)
                             work( i+k ) = work( i+k ) + aa
                             s = s + aa
                          end do
                          work( j ) = s
                       end do
                       ! j=k
                       aa = abs( a( 0+j*lda ) )
                       ! a(k,k)
                       s = aa
                       do i = 1, k - 1
                          aa = abs( a( i+j*lda ) )
                          ! a(k,k+i)
                          work( i+k ) = work( i+k ) + aa
                          s = s + aa
                       end do
                       work( j ) = work( j ) + s
                       do j = k + 1, n - 1
                          s = zero
                          do i = 0, j - 2 - k
                             aa = abs( a( i+j*lda ) )
                             ! a(i,j-k-1)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                           ! i=j-1-k
                          aa = abs( a( i+j*lda ) )
                          ! a(j-k-1,j-k-1)
                          s = s + aa
                          work( j-k-1 ) = work( j-k-1 ) + s
                          i = i + 1
                          aa = abs( a( i+j*lda ) )
                          ! a(j,j)
                          s = aa
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,l)
                             work( l ) = work( l ) + aa
                             s = s + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       ! j=n
                       s = zero
                       do i = 0, k - 2
                          aa = abs( a( i+j*lda ) )
                          ! a(i,k-1)
                          work( i ) = work( i ) + aa
                          s = s + aa
                       end do
                       ! i=k-1
                       aa = abs( a( i+j*lda ) )
                       ! a(k-1,k-1)
                       s = s + aa
                       work( i ) = work( i ) + s
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    else
                       ! ilu=1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       ! j=0 is special :process col a(k:n-1,k)
                       s = abs( a( 0 ) )
                       ! a(k,k)
                       do i = 1, k - 1
                          aa = abs( a( i ) )
                          ! a(k+i,k)
                          work( i+k ) = work( i+k ) + aa
                          s = s + aa
                       end do
                       work( k ) = work( k ) + s
                       do j = 1, k - 1
                          ! process
                          s = zero
                          do i = 0, j - 2
                             aa = abs( a( i+j*lda ) )
                             ! a(j-1,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          aa = abs( a( i+j*lda ) )
                          ! i=j-1 so process of a(j-1,j-1)
                          s = s + aa
                          work( j-1 ) = s
                          ! is initialised here
                          i = i + 1
                          ! i=j process a(j+k,j+k)
                          aa = abs( a( i+j*lda ) )
                          s = aa
                          do l = k + j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(l,k+j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( k+j ) = work( k+j ) + s
                       end do
                       ! j=k is special :process col a(k,0:k-1)
                       s = zero
                       do i = 0, k - 2
                          aa = abs( a( i+j*lda ) )
                          ! a(k,i)
                          work( i ) = work( i ) + aa
                          s = s + aa
                       end do
                       ! i=k-1
                       aa = abs( a( i+j*lda ) )
                       ! a(k-1,k-1)
                       s = s + aa
                       work( i ) = s
                       ! done with col j=k+1
                       do j = k + 1, n
                          ! process col j-1 of a = a(j-1,0:k-1)
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j-1,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          work( j-1 ) = work( j-1 ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_${ri}$isnan( temp ) )value = temp
                       end do
                    end if
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
             ! find normf(a).
              k = ( n+1 ) / 2
              scale = zero
              s = one
              if( noe==1 ) then
                 ! n is odd
                 if( ifm==1 ) then
                    ! a is normal
                    if( ilu==0 ) then
                       ! a is upper
                       do j = 0, k - 3
                          call stdlib_${ri}$lassq( k-j-2, a( k+j+1+j*lda ), 1, scale, s )
                          ! l at a(k,0)
                       end do
                       do j = 0, k - 1
                          call stdlib_${ri}$lassq( k+j-1, a( 0+j*lda ), 1, scale, s )
                          ! trap u at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k-1, a( k ), lda+1, scale, s )
                       ! tri l at a(k,0)
                       call stdlib_${ri}$lassq( k, a( k-1 ), lda+1, scale, s )
                       ! tri u at a(k-1,0)
                    else
                       ! ilu=1
                       do j = 0, k - 1
                          call stdlib_${ri}$lassq( n-j-1, a( j+1+j*lda ), 1, scale, s )
                          ! trap l at a(0,0)
                       end do
                       do j = 0, k - 2
                          call stdlib_${ri}$lassq( j, a( 0+( 1+j )*lda ), 1, scale, s )
                          ! u at a(0,1)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k, a( 0 ), lda+1, scale, s )
                       ! tri l at a(0,0)
                       call stdlib_${ri}$lassq( k-1, a( 0+lda ), lda+1, scale, s )
                       ! tri u at a(0,1)
                    end if
                 else
                    ! a is xpose
                    if( ilu==0 ) then
                       ! a**t is upper
                       do j = 1, k - 2
                          call stdlib_${ri}$lassq( j, a( 0+( k+j )*lda ), 1, scale, s )
                          ! u at a(0,k)
                       end do
                       do j = 0, k - 2
                          call stdlib_${ri}$lassq( k, a( 0+j*lda ), 1, scale, s )
                          ! k by k-1 rect. at a(0,0)
                       end do
                       do j = 0, k - 2
                          call stdlib_${ri}$lassq( k-j-1, a( j+1+( j+k-1 )*lda ), 1,scale, s )
                          ! l at a(0,k-1)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k-1, a( 0+k*lda ), lda+1, scale, s )
                       ! tri u at a(0,k)
                       call stdlib_${ri}$lassq( k, a( 0+( k-1 )*lda ), lda+1, scale, s )
                       ! tri l at a(0,k-1)
                    else
                       ! a**t is lower
                       do j = 1, k - 1
                          call stdlib_${ri}$lassq( j, a( 0+j*lda ), 1, scale, s )
                          ! u at a(0,0)
                       end do
                       do j = k, n - 1
                          call stdlib_${ri}$lassq( k, a( 0+j*lda ), 1, scale, s )
                          ! k by k-1 rect. at a(0,k)
                       end do
                       do j = 0, k - 3
                          call stdlib_${ri}$lassq( k-j-2, a( j+2+j*lda ), 1, scale, s )
                          ! l at a(1,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k, a( 0 ), lda+1, scale, s )
                       ! tri u at a(0,0)
                       call stdlib_${ri}$lassq( k-1, a( 1 ), lda+1, scale, s )
                       ! tri l at a(1,0)
                    end if
                 end if
              else
                 ! n is even
                 if( ifm==1 ) then
                    ! a is normal
                    if( ilu==0 ) then
                       ! a is upper
                       do j = 0, k - 2
                          call stdlib_${ri}$lassq( k-j-1, a( k+j+2+j*lda ), 1, scale, s )
                          ! l at a(k+1,0)
                       end do
                       do j = 0, k - 1
                          call stdlib_${ri}$lassq( k+j, a( 0+j*lda ), 1, scale, s )
                          ! trap u at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k, a( k+1 ), lda+1, scale, s )
                       ! tri l at a(k+1,0)
                       call stdlib_${ri}$lassq( k, a( k ), lda+1, scale, s )
                       ! tri u at a(k,0)
                    else
                       ! ilu=1
                       do j = 0, k - 1
                          call stdlib_${ri}$lassq( n-j-1, a( j+2+j*lda ), 1, scale, s )
                          ! trap l at a(1,0)
                       end do
                       do j = 1, k - 1
                          call stdlib_${ri}$lassq( j, a( 0+j*lda ), 1, scale, s )
                          ! u at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k, a( 1 ), lda+1, scale, s )
                       ! tri l at a(1,0)
                       call stdlib_${ri}$lassq( k, a( 0 ), lda+1, scale, s )
                       ! tri u at a(0,0)
                    end if
                 else
                    ! a is xpose
                    if( ilu==0 ) then
                       ! a**t is upper
                       do j = 1, k - 1
                          call stdlib_${ri}$lassq( j, a( 0+( k+1+j )*lda ), 1, scale, s )
                          ! u at a(0,k+1)
                       end do
                       do j = 0, k - 1
                          call stdlib_${ri}$lassq( k, a( 0+j*lda ), 1, scale, s )
                          ! k by k rect. at a(0,0)
                       end do
                       do j = 0, k - 2
                          call stdlib_${ri}$lassq( k-j-1, a( j+1+( j+k )*lda ), 1, scale,s )
                          ! l at a(0,k)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k, a( 0+( k+1 )*lda ), lda+1, scale, s )
                       ! tri u at a(0,k+1)
                       call stdlib_${ri}$lassq( k, a( 0+k*lda ), lda+1, scale, s )
                       ! tri l at a(0,k)
                    else
                       ! a**t is lower
                       do j = 1, k - 1
                          call stdlib_${ri}$lassq( j, a( 0+( j+1 )*lda ), 1, scale, s )
                          ! u at a(0,1)
                       end do
                       do j = k + 1, n
                          call stdlib_${ri}$lassq( k, a( 0+j*lda ), 1, scale, s )
                          ! k by k rect. at a(0,k+1)
                       end do
                       do j = 0, k - 2
                          call stdlib_${ri}$lassq( k-j-1, a( j+1+j*lda ), 1, scale, s )
                          ! l at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       call stdlib_${ri}$lassq( k, a( lda ), lda+1, scale, s )
                       ! tri l at a(0,1)
                       call stdlib_${ri}$lassq( k, a( 0 ), lda+1, scale, s )
                       ! tri u at a(0,0)
                    end if
                 end if
              end if
              value = scale*sqrt( s )
           end if
           stdlib_${ri}$lansf = value
           return
     end function stdlib_${ri}$lansf


     real(${rk}$) function stdlib_${ri}$lansp( norm, uplo, n, ap, work )
     !! DLANSP:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! real symmetric matrix A,  supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, k
           real(${rk}$) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 k = 1
                 do j = 1, n
                    do i = k, k + j - 1
                       sum = abs( ap( i ) )
                       if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                    end do
                    k = k + j
                 end do
              else
                 k = 1
                 do j = 1, n
                    do i = k, k + n - j
                       sum = abs( ap( i ) )
                       if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                    end do
                    k = k + n - j + 1
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              value = zero
              k = 1
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    do i = 1, j - 1
                       absa = abs( ap( k ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                       k = k + 1
                    end do
                    work( j ) = sum + abs( ap( k ) )
                    k = k + 1
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( ap( k ) )
                    k = k + 1
                    do i = j + 1, n
                       absa = abs( ap( k ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                       k = k + 1
                    end do
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              k = 2
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 2, n
                    call stdlib_${ri}$lassq( j-1, ap( k ), 1, scale, sum )
                    k = k + j
                 end do
              else
                 do j = 1, n - 1
                    call stdlib_${ri}$lassq( n-j, ap( k ), 1, scale, sum )
                    k = k + n - j + 1
                 end do
              end if
              sum = 2*sum
              k = 1
              do i = 1, n
                 if( ap( k )/=zero ) then
                    absa = abs( ap( k ) )
                    if( scale<absa ) then
                       sum = one + sum*( scale / absa )**2
                       scale = absa
                    else
                       sum = sum + ( absa / scale )**2
                    end if
                 end if
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    k = k + i + 1
                 else
                    k = k + n - i + 1
                 end if
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lansp = value
           return
     end function stdlib_${ri}$lansp


     pure real(${rk}$) function stdlib_${ri}$lanst( norm, n, d, e )
     !! DLANST:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! real symmetric tridiagonal matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: anorm, scale, sum
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n<=0 ) then
              anorm = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              anorm = abs( d( n ) )
              do i = 1, n - 1
                 sum = abs( d( i ) )
                 if( anorm < sum .or. stdlib_${ri}$isnan( sum ) ) anorm = sum
                 sum = abs( e( i ) )
                 if( anorm < sum .or. stdlib_${ri}$isnan( sum ) ) anorm = sum
              end do
           else if( stdlib_lsame( norm, 'O' ) .or. norm=='1' .or.stdlib_lsame( norm, 'I' ) ) &
                     then
              ! find norm1(a).
              if( n==1 ) then
                 anorm = abs( d( 1 ) )
              else
                 anorm = abs( d( 1 ) )+abs( e( 1 ) )
                 sum = abs( e( n-1 ) )+abs( d( n ) )
                 if( anorm < sum .or. stdlib_${ri}$isnan( sum ) ) anorm = sum
                 do i = 2, n - 1
                    sum = abs( d( i ) )+abs( e( i ) )+abs( e( i-1 ) )
                    if( anorm < sum .or. stdlib_${ri}$isnan( sum ) ) anorm = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( n>1 ) then
                 call stdlib_${ri}$lassq( n-1, e, 1, scale, sum )
                 sum = 2*sum
              end if
              call stdlib_${ri}$lassq( n, d, 1, scale, sum )
              anorm = scale*sqrt( sum )
           end if
           stdlib_${ri}$lanst = anorm
           return
     end function stdlib_${ri}$lanst


     real(${rk}$) function stdlib_${ri}$lansy( norm, uplo, n, a, lda, work )
     !! DLANSY:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! real symmetric matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    do i = 1, j
                       sum = abs( a( i, j ) )
                       if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                    end do
                 end do
              else
                 do j = 1, n
                    do i = j, n
                       sum = abs( a( i, j ) )
                       if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                    end do
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    do i = 1, j - 1
                       absa = abs( a( i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    work( j ) = sum + abs( a( j, j ) )
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( a( j, j ) )
                    do i = j + 1, n
                       absa = abs( a( i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 2, n
                    call stdlib_${ri}$lassq( j-1, a( 1, j ), 1, scale, sum )
                 end do
              else
                 do j = 1, n - 1
                    call stdlib_${ri}$lassq( n-j, a( j+1, j ), 1, scale, sum )
                 end do
              end if
              sum = 2*sum
              call stdlib_${ri}$lassq( n, a, lda+1, scale, sum )
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lansy = value
           return
     end function stdlib_${ri}$lansy


     real(${rk}$) function stdlib_${ri}$lantb( norm, uplo, diag, n, k, ab,ldab, work )
     !! DLANTB:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n triangular band matrix A,  with ( k + 1 ) diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(in) :: k, ldab, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: udiag
           integer(ilp) :: i, j, l
           real(${rk}$) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              if( stdlib_lsame( diag, 'U' ) ) then
                 value = one
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = max( k+2-j, 1 ), k
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = 2, min( n+1-j, k+1 )
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              else
                 value = zero
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = max( k+2-j, 1 ), k + 1
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = 1, min( n+1-j, k+1 )
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              udiag = stdlib_lsame( diag, 'U' )
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = max( k+2-j, 1 ), k
                          sum = sum + abs( ab( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = max( k+2-j, 1 ), k + 1
                          sum = sum + abs( ab( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = 2, min( n+1-j, k+1 )
                          sum = sum + abs( ab( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = 1, min( n+1-j, k+1 )
                          sum = sum + abs( ab( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       l = k + 1 - j
                       do i = max( 1, j-k ), j - 1
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       l = k + 1 - j
                       do i = max( 1, j-k ), j
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       l = 1 - j
                       do i = j + 1, min( n, j+k )
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       l = 1 - j
                       do i = j, min( n, j+k )
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 end if
              end if
              do i = 1, n
                 sum = work( i )
                 if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    if( k>0 ) then
                       do j = 2, n
                          call stdlib_${ri}$lassq( min( j-1, k ),ab( max( k+2-j, 1 ), j ), 1, scale,&
                                    sum )
                       end do
                    end if
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_${ri}$lassq( min( j, k+1 ), ab( max( k+2-j, 1 ), j ),1, scale, sum )
                                 
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    if( k>0 ) then
                       do j = 1, n - 1
                          call stdlib_${ri}$lassq( min( n-j, k ), ab( 2, j ), 1, scale,sum )
                       end do
                    end if
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_${ri}$lassq( min( n-j+1, k+1 ), ab( 1, j ), 1, scale,sum )
                    end do
                 end if
              end if
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lantb = value
           return
     end function stdlib_${ri}$lantb


     real(${rk}$) function stdlib_${ri}$lantp( norm, uplo, diag, n, ap, work )
     !! DLANTP:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! triangular matrix A, supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: udiag
           integer(ilp) :: i, j, k
           real(${rk}$) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              k = 1
              if( stdlib_lsame( diag, 'U' ) ) then
                 value = one
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = k, k + j - 2
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                       k = k + j
                    end do
                 else
                    do j = 1, n
                       do i = k + 1, k + n - j
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                       k = k + n - j + 1
                    end do
                 end if
              else
                 value = zero
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = k, k + j - 1
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                       k = k + j
                    end do
                 else
                    do j = 1, n
                       do i = k, k + n - j
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                       k = k + n - j + 1
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              k = 1
              udiag = stdlib_lsame( diag, 'U' )
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = k, k + j - 2
                          sum = sum + abs( ap( i ) )
                       end do
                    else
                       sum = zero
                       do i = k, k + j - 1
                          sum = sum + abs( ap( i ) )
                       end do
                    end if
                    k = k + j
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = k + 1, k + n - j
                          sum = sum + abs( ap( i ) )
                       end do
                    else
                       sum = zero
                       do i = k, k + n - j
                          sum = sum + abs( ap( i ) )
                       end do
                    end if
                    k = k + n - j + 1
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              k = 1
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       do i = 1, j - 1
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                       k = k + 1
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = 1, j
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       k = k + 1
                       do i = j + 1, n
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = j, n
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                    end do
                 end if
              end if
              value = zero
              do i = 1, n
                 sum = work( i )
                 if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    k = 2
                    do j = 2, n
                       call stdlib_${ri}$lassq( j-1, ap( k ), 1, scale, sum )
                       k = k + j
                    end do
                 else
                    scale = zero
                    sum = one
                    k = 1
                    do j = 1, n
                       call stdlib_${ri}$lassq( j, ap( k ), 1, scale, sum )
                       k = k + j
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    k = 2
                    do j = 1, n - 1
                       call stdlib_${ri}$lassq( n-j, ap( k ), 1, scale, sum )
                       k = k + n - j + 1
                    end do
                 else
                    scale = zero
                    sum = one
                    k = 1
                    do j = 1, n
                       call stdlib_${ri}$lassq( n-j+1, ap( k ), 1, scale, sum )
                       k = k + n - j + 1
                    end do
                 end if
              end if
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lantp = value
           return
     end function stdlib_${ri}$lantp


     real(${rk}$) function stdlib_${ri}$lantr( norm, uplo, diag, m, n, a, lda,work )
     !! DLANTR:  returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! trapezoidal or triangular matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: udiag
           integer(ilp) :: i, j
           real(${rk}$) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,min,sqrt
           ! Executable Statements 
           if( min( m, n )==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              if( stdlib_lsame( diag, 'U' ) ) then
                 value = one
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = 1, min( m, j-1 )
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = j + 1, m
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              else
                 value = zero
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = 1, min( m, j )
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = j, m
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              udiag = stdlib_lsame( diag, 'U' )
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    if( ( udiag ) .and. ( j<=m ) ) then
                       sum = one
                       do i = 1, j - 1
                          sum = sum + abs( a( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = 1, min( m, j )
                          sum = sum + abs( a( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = j + 1, m
                          sum = sum + abs( a( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = j, m
                          sum = sum + abs( a( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, m
                       work( i ) = one
                    end do
                    do j = 1, n
                       do i = 1, min( m, j-1 )
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 else
                    do i = 1, m
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = 1, min( m, j )
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, min( m, n )
                       work( i ) = one
                    end do
                    do i = n + 1, m
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = j + 1, m
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 else
                    do i = 1, m
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = j, m
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 end if
              end if
              value = zero
              do i = 1, m
                 sum = work( i )
                 if( value < sum .or. stdlib_${ri}$isnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = min( m, n )
                    do j = 2, n
                       call stdlib_${ri}$lassq( min( m, j-1 ), a( 1, j ), 1, scale, sum )
                    end do
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_${ri}$lassq( min( m, j ), a( 1, j ), 1, scale, sum )
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = min( m, n )
                    do j = 1, n
                       call stdlib_${ri}$lassq( m-j, a( min( m, j+1 ), j ), 1, scale,sum )
                    end do
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_${ri}$lassq( m-j+1, a( j, j ), 1, scale, sum )
                    end do
                 end if
              end if
              value = scale*sqrt( sum )
           end if
           stdlib_${ri}$lantr = value
           return
     end function stdlib_${ri}$lantr


     pure subroutine stdlib_${ri}$lanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! DLANV2: computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(inout) :: a, b, c, d
           real(${rk}$), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: multpl = 4.0e+0_${rk}$
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sign,sqrt
           ! Executable Statements 
           safmin = stdlib_${ri}$lamch( 'S' )
           eps = stdlib_${ri}$lamch( 'P' )
           safmn2 = stdlib_${ri}$lamch( 'B' )**int( log( safmin / eps ) /log( stdlib_${ri}$lamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( ( a-d )==zero .and. sign( one, b )/=sign( one, c ) )then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_${ri}$lapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=${rk}$) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_${ri}$lapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_${ri}$lanv2


     pure subroutine stdlib_${ri}$laorhr_col_getrfnp( m, n, a, lda, d, info )
     !! DLAORHR_COL_GETRFNP: computes the modified LU factorization without
     !! pivoting of a real general M-by-N matrix A. The factorization has
     !! the form:
     !! A - S = L * U,
     !! where:
     !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
     !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
     !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
     !! i-1 steps of Gaussian elimination. This means that the diagonal
     !! element at each step of "modified" Gaussian elimination is
     !! at least one in absolute value (so that division-by-zero not
     !! not possible during the division by the diagonal element);
     !! L is a M-by-N lower triangular matrix with unit diagonal elements
     !! (lower trapezoidal if M > N);
     !! and U is a M-by-N upper triangular matrix
     !! (upper trapezoidal if M < N).
     !! This routine is an auxiliary routine used in the Householder
     !! reconstruction routine DORHR_COL. In DORHR_COL, this routine is
     !! applied to an M-by-N matrix A with orthonormal columns, where each
     !! element is bounded by one in absolute value. With the choice of
     !! the matrix S above, one can show that the diagonal element at each
     !! step of Gaussian elimination is the largest (in absolute value) in
     !! the column on or below the diagonal, so that no pivoting is required
     !! for numerical stability [1].
     !! For more details on the Householder reconstruction algorithm,
     !! including the modified LU factorization, see [1].
     !! This is the blocked right-looking version of the algorithm,
     !! calling Level 3 BLAS to update the submatrix. To factorize a block,
     !! this routine calls the recursive routine DLAORHR_COL_GETRFNP2.
     !! [1] "Reconstructing Householder vectors from tall-skinny QR",
     !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
     !! E. Solomonik, J. Parallel Distrib. Comput.,
     !! vol. 85, pp. 3-31, 2015.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: iinfo, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAORHR_COL_GETRFNP', -info )
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'DLAORHR_COL_GETRFNP', ' ', m, n, -1, -1 )
           if( nb<=1 .or. nb>=min( m, n ) ) then
              ! use unblocked code.
              call stdlib_${ri}$laorhr_col_getrfnp2( m, n, a, lda, d, info )
           else
              ! use blocked code.
              do j = 1, min( m, n ), nb
                 jb = min( min( m, n )-j+1, nb )
                 ! factor diagonal and subdiagonal blocks.
                 call stdlib_${ri}$laorhr_col_getrfnp2( m-j+1, jb, a( j, j ), lda,d( j ), iinfo )
                           
                 if( j+jb<=n ) then
                    ! compute block row of u.
                    call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT', jb,n-j-jb+1, one, &
                              a( j, j ), lda, a( j, j+jb ),lda )
                    if( j+jb<=m ) then
                       ! update trailing submatrix.
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m-j-jb+1,n-j-jb+1, jb, -&
                       one, a( j+jb, j ), lda,a( j, j+jb ), lda, one, a( j+jb, j+jb ),lda )
                                 
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$laorhr_col_getrfnp


     pure recursive subroutine stdlib_${ri}$laorhr_col_getrfnp2( m, n, a, lda, d, info )
     !! DLAORHR_COL_GETRFNP2: computes the modified LU factorization without
     !! pivoting of a real general M-by-N matrix A. The factorization has
     !! the form:
     !! A - S = L * U,
     !! where:
     !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
     !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
     !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
     !! i-1 steps of Gaussian elimination. This means that the diagonal
     !! element at each step of "modified" Gaussian elimination is at
     !! least one in absolute value (so that division-by-zero not
     !! possible during the division by the diagonal element);
     !! L is a M-by-N lower triangular matrix with unit diagonal elements
     !! (lower trapezoidal if M > N);
     !! and U is a M-by-N upper triangular matrix
     !! (upper trapezoidal if M < N).
     !! This routine is an auxiliary routine used in the Householder
     !! reconstruction routine DORHR_COL. In DORHR_COL, this routine is
     !! applied to an M-by-N matrix A with orthonormal columns, where each
     !! element is bounded by one in absolute value. With the choice of
     !! the matrix S above, one can show that the diagonal element at each
     !! step of Gaussian elimination is the largest (in absolute value) in
     !! the column on or below the diagonal, so that no pivoting is required
     !! for numerical stability [1].
     !! For more details on the Householder reconstruction algorithm,
     !! including the modified LU factorization, see [1].
     !! This is the recursive version of the LU factorization algorithm.
     !! Denote A - S by B. The algorithm divides the matrix B into four
     !! submatrices:
     !! [  B11 | B12  ]  where B11 is n1 by n1,
     !! B = [ -----|----- ]        B21 is (m-n1) by n1,
     !! [  B21 | B22  ]        B12 is n1 by n2,
     !! B22 is (m-n1) by n2,
     !! with n1 = min(m,n)/2, n2 = n-n1.
     !! The subroutine calls itself to factor B11, solves for B21,
     !! solves for B12, updates B22, then calls itself to factor B22.
     !! For more details on the recursive LU algorithm, see [2].
     !! DLAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
     !! routine DLAORHR_COL_GETRFNP, which uses blocked code calling
     !! Level 3 BLAS to update the submatrix. However, DLAORHR_COL_GETRFNP2
     !! is self-sufficient and can be used without DLAORHR_COL_GETRFNP.
     !! [1] "Reconstructing Householder vectors from tall-skinny QR",
     !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
     !! E. Solomonik, J. Parallel Distrib. Comput.,
     !! vol. 85, pp. 3-31, 2015.
     !! [2] "Recursion leads to automatic variable blocking for dense linear
     !! algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
     !! vol. 41, no. 6, pp. 737-755, 1997.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: sfmin
           integer(ilp) :: i, iinfo, n1, n2
           ! Intrinsic Functions 
           intrinsic :: abs,sign,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAORHR_COL_GETRFNP2', -info )
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 )return
           if ( m==1 ) then
              ! one row case, (also recursion termination case),
              ! use unblocked code
              ! transfer the sign
              d( 1 ) = -sign( one, a( 1, 1 ) )
              ! construct the row of u
              a( 1, 1 ) = a( 1, 1 ) - d( 1 )
           else if( n==1 ) then
              ! one column case, (also recursion termination case),
              ! use unblocked code
              ! transfer the sign
              d( 1 ) = -sign( one, a( 1, 1 ) )
              ! construct the row of u
              a( 1, 1 ) = a( 1, 1 ) - d( 1 )
              ! scale the elements 2:m of the column
              ! determine machine safe minimum
              sfmin = stdlib_${ri}$lamch('S')
              ! construct the subdiagonal elements of l
              if( abs( a( 1, 1 ) ) >= sfmin ) then
                 call stdlib_${ri}$scal( m-1, one / a( 1, 1 ), a( 2, 1 ), 1 )
              else
                 do i = 2, m
                    a( i, 1 ) = a( i, 1 ) / a( 1, 1 )
                 end do
              end if
           else
              ! divide the matrix b into four submatrices
              n1 = min( m, n ) / 2
              n2 = n-n1
              ! factor b11, recursive call
              call stdlib_${ri}$laorhr_col_getrfnp2( n1, n1, a, lda, d, iinfo )
              ! solve for b21
              call stdlib_${ri}$trsm( 'R', 'U', 'N', 'N', m-n1, n1, one, a, lda,a( n1+1, 1 ), lda )
                        
              ! solve for b12
              call stdlib_${ri}$trsm( 'L', 'L', 'N', 'U', n1, n2, one, a, lda,a( 1, n1+1 ), lda )
                        
              ! update b22, i.e. compute the schur complement
              ! b22 := b22 - b21*b12
              call stdlib_${ri}$gemm( 'N', 'N', m-n1, n2, n1, -one, a( n1+1, 1 ), lda,a( 1, n1+1 ), &
                        lda, one, a( n1+1, n1+1 ), lda )
              ! factor b22, recursive call
              call stdlib_${ri}$laorhr_col_getrfnp2( m-n1, n2, a( n1+1, n1+1 ), lda,d( n1+1 ), iinfo )
                        
           end if
           return
     end subroutine stdlib_${ri}$laorhr_col_getrfnp2


     pure subroutine stdlib_${ri}$lapll( n, x, incx, y, incy, ssmin )
     !! Given two column vectors X and Y, let
     !! A = ( X Y ).
     !! The subroutine first computes the QR factorization of A = Q*R,
     !! and then computes the SVD of the 2-by-2 upper triangular matrix R.
     !! The smaller singular value of R is returned in SSMIN, which is used
     !! as the measurement of the linear dependency of the vectors X and Y.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(out) :: ssmin
           ! Array Arguments 
           real(${rk}$), intent(inout) :: x(*), y(*)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: a11, a12, a22, c, ssmax, tau
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 ) then
              ssmin = zero
              return
           end if
           ! compute the qr factorization of the n-by-2 matrix ( x y )
           call stdlib_${ri}$larfg( n, x( 1 ), x( 1+incx ), incx, tau )
           a11 = x( 1 )
           x( 1 ) = one
           c = -tau*stdlib_${ri}$dot( n, x, incx, y, incy )
           call stdlib_${ri}$axpy( n, c, x, incx, y, incy )
           call stdlib_${ri}$larfg( n-1, y( 1+incy ), y( 1+2*incy ), incy, tau )
           a12 = y( 1 )
           a22 = y( 1+incy )
           ! compute the svd of 2-by-2 upper triangular matrix.
           call stdlib_${ri}$las2( a11, a12, a22, ssmin, ssmax )
           return
     end subroutine stdlib_${ri}$lapll


     pure subroutine stdlib_${ri}$lapmr( forwrd, m, n, x, ldx, k )
     !! DLAPMR: rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           real(${rk}$) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_${ri}$lapmr


     pure subroutine stdlib_${ri}$lapmt( forwrd, m, n, x, ldx, k )
     !! DLAPMT: rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, in, j
           real(${rk}$) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_${ri}$lapmt


     pure real(${rk}$) function stdlib_${ri}$lapy2( x, y )
     !! DLAPY2: returns sqrt(x**2+y**2), taking care not to cause unnecessary
     !! overflow and unnecessary underflow.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: x, y
        ! =====================================================================
           
           
           ! Local Scalars 
           real(${rk}$) :: w, xabs, yabs, z, hugeval
           logical(lk) :: x_is_nan, y_is_nan
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           x_is_nan = stdlib_${ri}$isnan( x )
           y_is_nan = stdlib_${ri}$isnan( y )
           if ( x_is_nan ) stdlib_${ri}$lapy2 = x
           if ( y_is_nan ) stdlib_${ri}$lapy2 = y
           hugeval = stdlib_${ri}$lamch( 'OVERFLOW' )
           if ( .not.( x_is_nan.or.y_is_nan ) ) then
              xabs = abs( x )
              yabs = abs( y )
              w = max( xabs, yabs )
              z = min( xabs, yabs )
              if( z==zero .or. w>hugeval ) then
                 stdlib_${ri}$lapy2 = w
              else
                 stdlib_${ri}$lapy2 = w*sqrt( one+( z / w )**2 )
              end if
           end if
           return
     end function stdlib_${ri}$lapy2


     pure real(${rk}$) function stdlib_${ri}$lapy3( x, y, z )
     !! DLAPY3: returns sqrt(x**2+y**2+z**2), taking care not to cause
     !! unnecessary overflow and unnecessary underflow.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: x, y, z
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: w, xabs, yabs, zabs, hugeval
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           hugeval = stdlib_${ri}$lamch( 'OVERFLOW' )
           xabs = abs( x )
           yabs = abs( y )
           zabs = abs( z )
           w = max( xabs, yabs, zabs )
           if( w==zero .or. w>hugeval ) then
           ! w can be zero for max(0,nan,0)
           ! adding all three entries together will make sure
           ! nan will not disappear.
              stdlib_${ri}$lapy3 =  xabs + yabs + zabs
           else
              stdlib_${ri}$lapy3 = w*sqrt( ( xabs / w )**2+( yabs / w )**2+( zabs / w )**2 )
           end if
           return
     end function stdlib_${ri}$lapy3


     pure subroutine stdlib_${ri}$laqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
     !! DLAQGB: equilibrates a general M by N band matrix A with KL
     !! subdiagonals and KU superdiagonals using the row and scaling factors
     !! in the vectors R and C.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           real(${rk}$), intent(in) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(in) :: c(*), r(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( rowcnd>=thresh .and. amax>=small .and. amax<=large )then
              ! no row scaling
              if( colcnd>=thresh ) then
                 ! no column scaling
                 equed = 'N'
              else
                 ! column scaling
                 do j = 1, n
                    cj = c( j )
                    do i = max( 1, j-ku ), min( m, j+kl )
                       ab( ku+1+i-j, j ) = cj*ab( ku+1+i-j, j )
                    end do
                 end do
                 equed = 'C'
              end if
           else if( colcnd>=thresh ) then
              ! row scaling, no column scaling
              do j = 1, n
                 do i = max( 1, j-ku ), min( m, j+kl )
                    ab( ku+1+i-j, j ) = r( i )*ab( ku+1+i-j, j )
                 end do
              end do
              equed = 'R'
           else
              ! row and column scaling
              do j = 1, n
                 cj = c( j )
                 do i = max( 1, j-ku ), min( m, j+kl )
                    ab( ku+1+i-j, j ) = cj*r( i )*ab( ku+1+i-j, j )
                 end do
              end do
              equed = 'B'
           end if
           return
     end subroutine stdlib_${ri}$laqgb


     pure subroutine stdlib_${ri}$laqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
     !! DLAQGE: equilibrates a general M by N matrix A using the row and
     !! column scaling factors in the vectors R and C.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           integer(ilp), intent(in) :: lda, m, n
           real(${rk}$), intent(in) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: c(*), r(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( rowcnd>=thresh .and. amax>=small .and. amax<=large )then
              ! no row scaling
              if( colcnd>=thresh ) then
                 ! no column scaling
                 equed = 'N'
              else
                 ! column scaling
                 do j = 1, n
                    cj = c( j )
                    do i = 1, m
                       a( i, j ) = cj*a( i, j )
                    end do
                 end do
                 equed = 'C'
              end if
           else if( colcnd>=thresh ) then
              ! row scaling, no column scaling
              do j = 1, n
                 do i = 1, m
                    a( i, j ) = r( i )*a( i, j )
                 end do
              end do
              equed = 'R'
           else
              ! row and column scaling
              do j = 1, n
                 cj = c( j )
                 do i = 1, m
                    a( i, j ) = cj*r( i )*a( i, j )
                 end do
              end do
              equed = 'B'
           end if
           return
     end subroutine stdlib_${ri}$laqge


     pure subroutine stdlib_${ri}$laqp2( m, n, offset, a, lda, jpvt, tau, vn1, vn2,work )
     !! DLAQP2: computes a QR factorization with column pivoting of
     !! the block A(OFFSET+1:M,1:N).
     !! The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, m, n, offset
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(${rk}$), intent(inout) :: a(lda,*), vn1(*), vn2(*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, itemp, j, mn, offpi, pvt
           real(${rk}$) :: aii, temp, temp2, tol3z
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           mn = min( m-offset, n )
           tol3z = sqrt(stdlib_${ri}$lamch('EPSILON'))
           ! compute factorization.
           loop_20: do i = 1, mn
              offpi = offset + i
              ! determine ith pivot column and swap if necessary.
              pvt = ( i-1 ) + stdlib_i${ri}$amax( n-i+1, vn1( i ), 1 )
              if( pvt/=i ) then
                 call stdlib_${ri}$swap( m, a( 1, pvt ), 1, a( 1, i ), 1 )
                 itemp = jpvt( pvt )
                 jpvt( pvt ) = jpvt( i )
                 jpvt( i ) = itemp
                 vn1( pvt ) = vn1( i )
                 vn2( pvt ) = vn2( i )
              end if
              ! generate elementary reflector h(i).
              if( offpi<m ) then
                 call stdlib_${ri}$larfg( m-offpi+1, a( offpi, i ), a( offpi+1, i ), 1,tau( i ) )
                           
              else
                 call stdlib_${ri}$larfg( 1, a( m, i ), a( m, i ), 1, tau( i ) )
              end if
              if( i<n ) then
                 ! apply h(i)**t to a(offset+i:m,i+1:n) from the left.
                 aii = a( offpi, i )
                 a( offpi, i ) = one
                 call stdlib_${ri}$larf( 'LEFT', m-offpi+1, n-i, a( offpi, i ), 1,tau( i ), a( offpi, &
                           i+1 ), lda, work( 1 ) )
                 a( offpi, i ) = aii
              end if
              ! update partial column norms.
              do j = i + 1, n
                 if( vn1( j )/=zero ) then
                    ! note: the following 4 lines follow from the analysis in
                    ! lapack working note 176.
                    temp = one - ( abs( a( offpi, j ) ) / vn1( j ) )**2
                    temp = max( temp, zero )
                    temp2 = temp*( vn1( j ) / vn2( j ) )**2
                    if( temp2 <= tol3z ) then
                       if( offpi<m ) then
                          vn1( j ) = stdlib_${ri}$nrm2( m-offpi, a( offpi+1, j ), 1 )
                          vn2( j ) = vn1( j )
                       else
                          vn1( j ) = zero
                          vn2( j ) = zero
                       end if
                    else
                       vn1( j ) = vn1( j )*sqrt( temp )
                    end if
                 end if
              end do
           end do loop_20
           return
     end subroutine stdlib_${ri}$laqp2


     pure subroutine stdlib_${ri}$laqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
     !! DLAQPS: computes a step of QR factorization with column pivoting
     !! of a real M-by-N matrix A by using Blas-3.  It tries to factorize
     !! NB columns from A starting from the row OFFSET+1, and updates all
     !! of the matrix with Blas-3 xGEMM.
     !! In some cases, due to catastrophic cancellations, it cannot
     !! factorize NB columns.  Hence, the actual number of factorized
     !! columns is returned in KB.
     !! Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
               ldf )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: kb
           integer(ilp), intent(in) :: lda, ldf, m, n, nb, offset
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(${rk}$), intent(inout) :: a(lda,*), auxv(*), f(ldf,*), vn1(*), vn2(*)
           real(${rk}$), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: itemp, j, k, lastrk, lsticc, pvt, rk
           real(${rk}$) :: akk, temp, temp2, tol3z
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min,nint,sqrt
           ! Executable Statements 
           lastrk = min( m, n+offset )
           lsticc = 0
           k = 0
           tol3z = sqrt(stdlib_${ri}$lamch('EPSILON'))
           ! beginning of while loop.
           10 continue
           if( ( k<nb ) .and. ( lsticc==0 ) ) then
              k = k + 1
              rk = offset + k
              ! determine ith pivot column and swap if necessary
              pvt = ( k-1 ) + stdlib_i${ri}$amax( n-k+1, vn1( k ), 1 )
              if( pvt/=k ) then
                 call stdlib_${ri}$swap( m, a( 1, pvt ), 1, a( 1, k ), 1 )
                 call stdlib_${ri}$swap( k-1, f( pvt, 1 ), ldf, f( k, 1 ), ldf )
                 itemp = jpvt( pvt )
                 jpvt( pvt ) = jpvt( k )
                 jpvt( k ) = itemp
                 vn1( pvt ) = vn1( k )
                 vn2( pvt ) = vn2( k )
              end if
              ! apply previous householder reflectors to column k:
              ! a(rk:m,k) := a(rk:m,k) - a(rk:m,1:k-1)*f(k,1:k-1)**t.
              if( k>1 ) then
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', m-rk+1, k-1, -one, a( rk, 1 ),lda, f( k, 1 ), &
                           ldf, one, a( rk, k ), 1 )
              end if
              ! generate elementary reflector h(k).
              if( rk<m ) then
                 call stdlib_${ri}$larfg( m-rk+1, a( rk, k ), a( rk+1, k ), 1, tau( k ) )
              else
                 call stdlib_${ri}$larfg( 1, a( rk, k ), a( rk, k ), 1, tau( k ) )
              end if
              akk = a( rk, k )
              a( rk, k ) = one
              ! compute kth column of f:
              ! compute  f(k+1:n,k) := tau(k)*a(rk:m,k+1:n)**t*a(rk:m,k).
              if( k<n ) then
                 call stdlib_${ri}$gemv( 'TRANSPOSE', m-rk+1, n-k, tau( k ),a( rk, k+1 ), lda, a( rk, &
                           k ), 1, zero,f( k+1, k ), 1 )
              end if
              ! padding f(1:k,k) with zeros.
              do j = 1, k
                 f( j, k ) = zero
              end do
              ! incremental updating of f:
              ! f(1:n,k) := f(1:n,k) - tau(k)*f(1:n,1:k-1)*a(rk:m,1:k-1)**t
                          ! *a(rk:m,k).
              if( k>1 ) then
                 call stdlib_${ri}$gemv( 'TRANSPOSE', m-rk+1, k-1, -tau( k ), a( rk, 1 ),lda, a( rk, k &
                           ), 1, zero, auxv( 1 ), 1 )
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n, k-1, one, f( 1, 1 ), ldf,auxv( 1 ), 1, one,&
                            f( 1, k ), 1 )
              end if
              ! update the current row of a:
              ! a(rk,k+1:n) := a(rk,k+1:n) - a(rk,1:k)*f(k+1:n,1:k)**t.
              if( k<n ) then
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, k, -one, f( k+1, 1 ), ldf,a( rk, 1 ), &
                           lda, one, a( rk, k+1 ), lda )
              end if
              ! update partial column norms.
              if( rk<lastrk ) then
                 do j = k + 1, n
                    if( vn1( j )/=zero ) then
                       ! note: the following 4 lines follow from the analysis in
                       ! lapack working note 176.
                       temp = abs( a( rk, j ) ) / vn1( j )
                       temp = max( zero, ( one+temp )*( one-temp ) )
                       temp2 = temp*( vn1( j ) / vn2( j ) )**2
                       if( temp2 <= tol3z ) then
                          vn2( j ) = real( lsticc,KIND=${rk}$)
                          lsticc = j
                       else
                          vn1( j ) = vn1( j )*sqrt( temp )
                       end if
                    end if
                 end do
              end if
              a( rk, k ) = akk
              ! end of while loop.
              go to 10
           end if
           kb = k
           rk = offset + kb
           ! apply the block reflector to the rest of the matrix:
           ! a(offset+kb+1:m,kb+1:n) := a(offset+kb+1:m,kb+1:n) -
                               ! a(offset+kb+1:m,1:kb)*f(kb+1:n,1:kb)**t.
           if( kb<min( n, m-offset ) ) then
              call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m-rk, n-kb, kb, -one,a( rk+1, 1 ), &
                        lda, f( kb+1, 1 ), ldf, one,a( rk+1, kb+1 ), lda )
           end if
           ! recomputation of difficult columns.
           40 continue
           if( lsticc>0 ) then
              itemp = nint( vn2( lsticc ),KIND=ilp)
              vn1( lsticc ) = stdlib_${ri}$nrm2( m-rk, a( rk+1, lsticc ), 1 )
              ! note: the computation of vn1( lsticc ) relies on the fact that
              ! stdlib_dnrm2 does not fail on vectors with norm below the value of
              ! sqrt(stdlib_${ri}$lamch('s'))
              vn2( lsticc ) = vn1( lsticc )
              lsticc = itemp
              go to 40
           end if
           return
     end subroutine stdlib_${ri}$laqps


     subroutine stdlib_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
     !! DLAQR0: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${rk}$), parameter :: wilk1 = 0.75_${rk}$
           real(${rk}$), parameter :: wilk2 = -0.4375_${rk}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ri}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(${rk}$) :: zdum(1,1)
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,max,min,mod
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ri}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ri}$laqr3 ====
              call stdlib_${ri}$laqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ri}$laqr5, stdlib_${ri}$laqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=${rk}$)
                 return
              end if
              ! ==== stdlib_${ri}$lahqr/stdlib_${ri}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ri}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ri}$laqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ri}$laqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ri}$laqr4 or
                       ! .    stdlib_${ri}$lahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ri}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_${ri}$laqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, work,lwork, inf )
                          else
                             call stdlib_${ri}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr0


     pure subroutine stdlib_${ri}$laqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, DLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: h21s, h31s, s
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_${ri}$laqr1


     subroutine stdlib_${ri}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! DLAQR2: is identical to DLAQR3 except that it avoids
     !! recursion by calling DLAHQR instead of DLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwkopt
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,max,min,sqrt
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ri}$gehrd ====
              call stdlib_${ri}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ri}$ormhr ====
              call stdlib_${ri}$ormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=${rk}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ri}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ri}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ri}$laset( 'A', jw, jw, zero, one, v, ldv )
           call stdlib_${ri}$lahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, jw, &
                     v, ldv, infqr )
           ! ==== stdlib_${ri}$trexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not.bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_${ri}$trexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_${ri}$trexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_${ri}$lanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ri}$copy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_${ri}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_${ri}$laset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_${ri}$larf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ri}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_${ri}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ri}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_${ri}$ormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_${ri}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr2


     subroutine stdlib_${ri}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! Aggressive early deflation:
     !! DLAQR3: accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwk3, lwkopt, nmin
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,max,min,sqrt
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ri}$gehrd ====
              call stdlib_${ri}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ri}$ormhr ====
              call stdlib_${ri}$ormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ri}$laqr4 ====
              call stdlib_${ri}$laqr4( .true., .true., jw, 1, jw, t, ldt, sr, si, 1, jw,v, ldv, work, -&
                        1, infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=${rk}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ri}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ri}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ri}$laset( 'A', jw, jw, zero, one, v, ldv )
           nmin = stdlib_ilaenv( 12, 'DLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_${ri}$laqr4( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, work, lwork, infqr )
           else
              call stdlib_${ri}$lahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, infqr )
           end if
           ! ==== stdlib_${ri}$trexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not. bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_${ri}$trexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_${ri}$trexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_${ri}$lanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ri}$copy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_${ri}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_${ri}$laset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_${ri}$larf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ri}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_${ri}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ri}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_${ri}$ormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_${ri}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr3


     subroutine stdlib_${ri}$laqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
     !! DLAQR4: implements one level of recursion for DLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by DLAQR0 and, for large enough
     !! deflation window size, it may be called by DLAQR3.  This
     !! subroutine is identical to DLAQR0 except that it calls DLAQR2
     !! instead of DLAQR3.
     !! DLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${rk}$), parameter :: wilk1 = 0.75_${rk}$
           real(${rk}$), parameter :: wilk2 = -0.4375_${rk}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ri}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(${rk}$) :: zdum(1,1)
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,max,min,mod
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ri}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ri}$laqr2 ====
              call stdlib_${ri}$laqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ri}$laqr5, stdlib_${ri}$laqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=${rk}$)
                 return
              end if
              ! ==== stdlib_${ri}$lahqr/stdlib_${ri}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ri}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ri}$laqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ri}$laqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ri}$lahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ri}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_${ri}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( ks &
                                    ), wi( ks ),1, 1, zdum, 1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr4


     pure subroutine stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! DLAQR5:, called by DLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min,mod
           ! Local Arrays 
           real(${rk}$) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_${ri}$laset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ri}$laqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_${ri}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_${ri}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ri}$laqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_${ri}$larfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_${ri}$larfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_${ri}$laqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_${ri}$larfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_${ri}$lacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_${ri}$gemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_${ri}$gemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_${ri}$lacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_${ri}$laqr5


     pure subroutine stdlib_${ri}$laqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! DLAQSB: equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(${rk}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ri}$laqsb


     pure subroutine stdlib_${ri}$laqsp( uplo, n, ap, s, scond, amax, equed )
     !! DLAQSP: equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j, jc
           real(${rk}$) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 jc = 1
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       ap( jc+i-1 ) = cj*s( i )*ap( jc+i-1 )
                    end do
                    jc = jc + j
                 end do
              else
                 ! lower triangle of a is stored.
                 jc = 1
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       ap( jc+i-j ) = cj*s( i )*ap( jc+i-j )
                    end do
                    jc = jc + n - j + 1
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ri}$laqsp


     pure subroutine stdlib_${ri}$laqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! DLAQSY: equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ri}$laqsy


     subroutine stdlib_${ri}$laqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
     !! DLAQTR: solves the real quasi-triangular system
     !! op(T)*p = scale*c,               if LREAL = .TRUE.
     !! or the complex quasi-triangular systems
     !! op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
     !! in real arithmetic, where T is upper quasi-triangular.
     !! If LREAL = .FALSE., then the first diagonal block of T must be
     !! 1 by 1, B is the specially structured matrix
     !! B = [ b(1) b(2) ... b(n) ]
     !! [       w            ]
     !! [           w        ]
     !! [              .     ]
     !! [                 w  ]
     !! op(A) = A or A**T, A**T denotes the transpose of
     !! matrix A.
     !! On input, X = [ c ].  On output, X = [ p ].
     !! [ d ]                  [ q ]
     !! This subroutine is designed for the condition number estimation
     !! in routine DTRSNA.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: lreal, ltran
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldt, n
           real(${rk}$), intent(out) :: scale
           real(${rk}$), intent(in) :: w
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, j1, j2, jnext, k, n1, n2
           real(${rk}$) :: bignum, eps, rec, scaloc, si, smin, sminw, smlnum, sr, tjj, tmp, xj, xmax, &
                     xnorm, z
           ! Local Arrays 
           real(${rk}$) :: d(2,2), v(2,2)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! do not test the input parameters for errors
           notran = .not.ltran
           info = 0
           ! quick return if possible
           if( n==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           bignum = one / smlnum
           xnorm = stdlib_${ri}$lange( 'M', n, n, t, ldt, d )
           if( .not.lreal )xnorm = max( xnorm, abs( w ), stdlib_${ri}$lange( 'M', n, 1, b, n, d ) )
                     
           smin = max( smlnum, eps*xnorm )
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = stdlib_${ri}$asum( j-1, t( 1, j ), 1 )
           end do
           if( .not.lreal ) then
              do i = 2, n
                 work( i ) = work( i ) + abs( b( i ) )
              end do
           end if
           n2 = 2*n
           n1 = n
           if( .not.lreal )n1 = n2
           k = stdlib_i${ri}$amax( n1, x, 1 )
           xmax = abs( x( k ) )
           scale = one
           if( xmax>bignum ) then
              scale = bignum / xmax
              call stdlib_${ri}$scal( n1, scale, x, 1 )
              xmax = bignum
           end if
           if( lreal ) then
              if( notran ) then
                 ! solve t*p = scale*c
                 jnext = n
                 loop_30: do j = n, 1, -1
                    if( j>jnext )cycle loop_30
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! meet 1 by 1 diagonal block
                       ! scale to avoid overflow when computing
                           ! x(j) = b(j)/t(j,j)
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( xj==zero )cycle loop_30
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xj = abs( x( j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          k = stdlib_i${ri}$amax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       ! call 2 by 2 linear system solve, to take
                       ! care of possible overflow by scaling factor.
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       ! scale v(1,1) (= x(j1)) and/or v(2,1) (=x(j2))
                       ! to avoid overflow in updating right-hand side.
                       xj = max( abs( v( 1, 1 ) ), abs( v( 2, 1 ) ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update right-hand side
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          k = stdlib_i${ri}$amax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    end if
                 end do loop_30
              else
                 ! solve t**t*p = scale*c
                 jnext = 1
                 loop_40: do j = 1, n
                    if( j<jnext )cycle loop_40
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x, 1 )
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xmax = max( xmax, abs( x( j1 ) ) )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side elements by inner product.
                       xj = max( abs( x( j1 ) ), abs( x( j2 ) ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j2 ), work( j1 ) )>( bignum-xj )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_${ri}$dot( j1-1, t( 1, j2 ), 1, x,1 )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d, &
                                 2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       xmax = max( abs( x( j1 ) ), abs( x( j2 ) ), xmax )
                    end if
                 end do loop_40
              end if
           else
              sminw = max( eps*abs( w ), smin )
              if( notran ) then
                 ! solve (t + ib)*(p+iq) = c+id
                 jnext = n
                 loop_70: do j = n, 1, -1
                    if( j>jnext )cycle loop_70
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in division
                       z = w
                       if( j1==1 )z = b( 1 )
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( xj==zero )cycle loop_70
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_${ri}$ladiv( x( j1 ), x( n+j1 ), tmp, z, sr, si )
                       x( j1 ) = sr
                       x( n+j1 ) = si
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( xmax, abs( x( k ) )+abs( x( k+n ) ) )
                          end do
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       d( 1, 2 ) = x( n+j1 )
                       d( 2, 2 ) = x( n+j2 )
                       call stdlib_${ri}$laln2( .false., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, &
                                 d, 2, zero, -w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( 2*n, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       ! scale x(j1), .... to avoid overflow in
                       ! updating right hand side.
                       xj = max( abs( v( 1, 1 ) )+abs( v( 1, 2 ) ),abs( v( 2, 1 ) )+abs( v( 2, 2 )&
                                  ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update the right-hand side.
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( n+j2 ), t( 1, j2 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 ) +b( j2 )*x( n+j2 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 ) -b( j2 )*x( j2 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( abs( x( k ) )+abs( x( k+n ) ),xmax )
                          end do
                       end if
                    end if
                 end do loop_70
              else
                 ! solve (t + ib)**t*(p+iq) = c+id
                 jnext = 1
                 loop_80: do j = 1, n
                    if( j<jnext )cycle loop_80
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x, 1 )
                       x( n+j1 ) = x( n+j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       if( j1>1 ) then
                          x( j1 ) = x( j1 ) - b( j1 )*x( n+1 )
                          x( n+j1 ) = x( n+j1 ) + b( j1 )*x( 1 )
                       end if
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       z = w
                       if( j1==1 )z = b( 1 )
                       ! scale if necessary to avoid overflow in
                       ! complex division
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_${ri}$ladiv( x( j1 ), x( n+j1 ), tmp, -z, sr, si )
                       x( j1 ) = sr
                       x( j1+n ) = si
                       xmax = max( abs( x( j1 ) )+abs( x( j1+n ) ), xmax )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) ) )
                                 
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j1 ), work( j2 ) )>( bignum-xj ) / xmax ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_${ri}$dot( j1-1, t( 1, j2 ), 1, x,1 )
                       d( 1, 2 ) = x( n+j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       d( 2, 2 ) = x( n+j2 ) - stdlib_${ri}$dot( j1-1, t( 1, j2 ), 1,x( n+1 ), 1 )
                                 
                       d( 1, 1 ) = d( 1, 1 ) - b( j1 )*x( n+1 )
                       d( 2, 1 ) = d( 2, 1 ) - b( j2 )*x( n+1 )
                       d( 1, 2 ) = d( 1, 2 ) + b( j1 )*x( 1 )
                       d( 2, 2 ) = d( 2, 2 ) + b( j2 )*x( 1 )
                       call stdlib_${ri}$laln2( .true., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( n2, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       xmax = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) )&
                                 , xmax )
                    end if
                 end do loop_80
              end if
           end if
           return
     end subroutine stdlib_${ri}$laqtr


     recursive subroutine stdlib_${ri}$laqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
     !! DLAQZ0: computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * ), work( * )
           
           ! local scalars
           real(${rk}$) :: smlnum, ulp, eshift, safmin, safmax, c1, s1, temp, swap
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_qeflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost, i
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=${rk}$)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=${rk}$)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_${ri}$hgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai,&
                         beta, q, ldq, z, ldz, work,lwork, info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_${ri}$laqz3
           nw = max( nwr, nmin )
           call stdlib_${ri}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_qeflated, alphar,alphai, beta, work, nw, work, nw, work, -1, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_${ri}$laqz4
           call stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alphar,alphai, beta, a, &
                     lda, b, ldb, q, ldq, z, ldz, work,nbr, work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=${rk}$)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( iwantz==3 ) call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! get machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$)/ulp )
           istart = ilo
           istop = ihi
           maxit = 3*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop-1, istop-2 ) ) <= max( smlnum,ulp*( abs( a( istop-1, istop-1 ) )+&
                        abs( a( istop-2,istop-2 ) ) ) ) ) then
                 a( istop-1, istop-2 ) = zero
                 istop = istop-2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+&
                        abs( a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = zero
                 istop = istop-1
                 ld = 0
                 eshift = zero
              end if
              ! check deflations at the start
              if ( abs( a( istart+2, istart+1 ) ) <= max( smlnum,ulp*( abs( a( istart+1, istart+1 &
                        ) )+abs( a( istart+2,istart+2 ) ) ) ) ) then
                 a( istart+2, istart+1 ) = zero
                 istart = istart+2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart )&
                         )+abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = zero
                 istart = istart+1
                 ld = 0
                 eshift = zero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = zero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 temp = zero
                 if( k < istop ) then
                    temp = temp+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    temp = temp+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*temp ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_${ri}$lartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = zero
                       call stdlib_${ri}$rot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_${ri}$rot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_${ri}$rot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_${ri}$lartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = zero
                          call stdlib_${ri}$rot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_${ri}$rot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_${ri}$rot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, s1 )
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_${ri}$lartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = zero
                       call stdlib_${ri}$rot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_${ri}$rot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_${ri}$rot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, s1 )
                                    
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = zero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using stdlib_${ri}$hgeqz because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_${ri}$laqz3( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_qeflated,alphar, alphai, beta, work, nw, work( nw**2+1 ),&
                         nw, work( 2*nw**2+1 ), lwork-2*nw**2, rec,aed_info )
              if ( n_qeflated > 0 ) then
                 istop = istop-n_qeflated
                 ld = 0
                 eshift = zero
              end if
              if ( 100*n_qeflated > nibble*( n_qeflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_qeflated-n_undeflated+1
              ! shuffle shifts to put double shifts in front
              ! this ensures that we don't split up a double shift
              do i = shiftpos, shiftpos+n_undeflated-1, 2
                 if( alphai( i )/=-alphai( i+1 ) ) then
                    swap = alphar( i )
                    alphar( i ) = alphar( i+1 )
                    alphar( i+1 ) = alphar( i+2 )
                    alphar( i+2 ) = swap
                    swap = alphai( i )
                    alphai( i ) = alphai( i+1 )
                    alphai( i+1 ) = alphai( i+2 )
                    alphai( i+2 ) = swap
                    swap = beta( i )
                    beta( i ) = beta( i+1 )
                    beta( i+1 ) = beta( i+2 )
                    beta( i+2 ) = swap
                 end if
              end do
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=${rk}$)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+one/( safmin*real( maxit,KIND=${rk}$) )
                 end if
                 alphar( shiftpos ) = one
                 alphar( shiftpos+1 ) = zero
                 alphai( shiftpos ) = zero
                 alphai( shiftpos+1 ) = zero
                 beta( shiftpos ) = eshift
                 beta( shiftpos+1 ) = eshift
                 ns = 2
              end if
              ! time for a qz sweep
              call stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alphar( &
              shiftpos ), alphai( shiftpos ),beta( shiftpos ), a, lda, b, ldb, q, ldq, z, ldz,&
              work, nblock, work( nblock**2+1 ), nblock,work( 2*nblock**2+1 ), lwork-2*nblock**2,&
                        sweep_info )
           end do
           ! call stdlib_${ri}$hgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_${ri}$hgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_${ri}$hgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                  beta, q, ldq, z, ldz, work, lwork,norm_info )
           info = norm_info
     end subroutine stdlib_${ri}$laqz0


     pure subroutine stdlib_${ri}$laqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), DLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(${rk}$), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(${rk}$), intent( out ) :: v( * )
           
           ! local scalars
           real(${rk}$) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_${ri}$isnan( v( 1 ) ) .or.stdlib_${ri}$isnan( v( 2 ) ) .or. stdlib_${ri}$isnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_${ri}$laqz1


     pure subroutine stdlib_${ri}$laqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! DLAQZ2: chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! local variables
           real(${rk}$) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_${ri}$lartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_${ri}$rot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_${ri}$lartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_${ri}$rot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_${ri}$lartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_${ri}$rot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_${ri}$rot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_${ri}$rot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_${ri}$lartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_${ri}$rot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_${ri}$rot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_${ri}$rot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_${ri}$lartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_${ri}$rot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_${ri}$lartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_${ri}$rot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_${ri}$lartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_${ri}$rot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_${ri}$lartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_${ri}$rot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_${ri}$rot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_${ri}$rot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_${ri}$lartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_${ri}$lartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
              ! apply transformations from the left
              call stdlib_${ri}$rot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_${ri}$rot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_${ri}$rot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_${ri}$rot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_${ri}$rot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_${ri}$rot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_${ri}$laqz2


     recursive subroutine stdlib_${ri}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! DLAQZ3: performs AED
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           real(${rk}$), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(${rk}$), intent(out) :: work(*)
           
           ! local scalars
           logical(lk) :: bulge
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, dtgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(${rk}$) :: s, smlnum, ulp, safmin, safmax, c1, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = zero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_${ri}$tgexc( .true., .true., jw, a, lda, b, ldb, qc, ldqc, zc,ldzc, ifst, ilst, &
                     work, -1, dtgexc_info )
           lworkreq = int( work( 1 ),KIND=ilp)
           call stdlib_${ri}$laqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work, -1, rec+1, qz_small_info )
           lworkreq = max( lworkreq, int( work( 1 ),KIND=ilp)+2*jw**2 )
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ3', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alphar( kwtop ) = a( kwtop, kwtop )
              alphai( kwtop ) = zero
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = zero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_${ri}$lacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_${ri}$lacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_${ri}$laset( 'FULL', jw, jw, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', jw, jw, zero, one, zc, ldzc )
           call stdlib_${ri}$laqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work( 2*jw**2+1 ), lwork-2*jw**2,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_${ri}$lacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_${ri}$lacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == zero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                 bulge = .false.
                 if ( kwbot-kwtop+1 >= 2 ) then
                    bulge = a( kwbot, kwbot-1 ) /= zero
                 end if
                 if ( bulge ) then
                    ! try to deflate complex conjugate eigenvalue pair
                    temp = abs( a( kwbot, kwbot ) )+sqrt( abs( a( kwbot,kwbot-1 ) ) )*sqrt( abs( &
                              a( kwbot-1, kwbot ) ) )
                    if( temp == zero )then
                       temp = abs( s )
                    end if
                    if ( max( abs( s*qc( 1, kwbot-kwtop ) ), abs( s*qc( 1,kwbot-kwtop+1 ) ) ) <= &
                              max( smlnum,ulp*temp ) ) then
                       ! deflatable
                       kwbot = kwbot-2
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_${ri}$tgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,dtgexc_info )
                                 
                       k2 = k2+2
                    end if
                    k = k+2
                 else
                    ! try to deflate real eigenvalue
                    temp = abs( a( kwbot, kwbot ) )
                    if( temp == zero ) then
                       temp = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*temp, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_${ri}$tgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,dtgexc_info )
                                 
                       k2 = k2+1
                    end if
                    k = k+1
                 end if
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              bulge = .false.
              if ( k < ihi ) then
                 if ( a( k+1, k ) /= zero ) then
                    bulge = .true.
                 end if
              end if
              if ( bulge ) then
                 ! 2x2 eigenvalue block
                 call stdlib_${ri}$lag2( a( k, k ), lda, b( k, k ), ldb, safmin,beta( k ), beta( k+1 ),&
                            alphar( k ),alphar( k+1 ), alphai( k ) )
                 alphai( k+1 ) = -alphai( k )
                 k = k+2
              else
                 ! 1x1 eigenvalue block
                 alphar( k ) = a( k, k )
                 alphai( k ) = zero
                 beta( k ) = b( k, k )
                 k = k+1
              end if
           end do
           if ( kwtop /= ilo .and. s /= zero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 )*qc( 1,1:jw-nd )
              do k = kwbot-1, kwtop, -1
                 call stdlib_${ri}$lartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = zero
                 k2 = max( kwtop, k-1 )
                 call stdlib_${ri}$rot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_${ri}$rot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_${ri}$rot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, s1 )
                           
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 if ( ( k >= kwtop+1 ) .and. a( k+1, k-1 ) /= zero ) then
                    ! move double pole block down and remove it
                    do k2 = k-1, kwbot-2
                       call stdlib_${ri}$laqz2( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b,&
                                  ldb, jw, kwtop, qc,ldqc, jw, kwtop, zc, ldzc )
                    end do
                    k = k-2
                 else
                    ! k points to single shift
                    do k2 = k, kwbot-2
                       ! move shift down
                       call stdlib_${ri}$lartg( b( k2+1, k2+1 ), b( k2+1, k2 ), c1, s1,temp )
                       b( k2+1, k2+1 ) = temp
                       b( k2+1, k2 ) = zero
                       call stdlib_${ri}$rot( k2+2-istartm+1, a( istartm, k2+1 ), 1,a( istartm, k2 ), &
                                 1, c1, s1 )
                       call stdlib_${ri}$rot( k2-istartm+1, b( istartm, k2+1 ), 1,b( istartm, k2 ), 1, &
                                 c1, s1 )
                       call stdlib_${ri}$rot( jw, zc( 1, k2+1-kwtop+1 ), 1, zc( 1,k2-kwtop+1 ), 1, c1, &
                                 s1 )
                       call stdlib_${ri}$lartg( a( k2+1, k2 ), a( k2+2, k2 ), c1, s1,temp )
                       a( k2+1, k2 ) = temp
                       a( k2+2, k2 ) = zero
                       call stdlib_${ri}$rot( istopm-k2, a( k2+1, k2+1 ), lda, a( k2+2,k2+1 ), lda, c1,&
                                  s1 )
                       call stdlib_${ri}$rot( istopm-k2, b( k2+1, k2+1 ), ldb, b( k2+2,k2+1 ), ldb, c1,&
                                  s1 )
                       call stdlib_${ri}$rot( jw, qc( 1, k2+1-kwtop+1 ), 1, qc( 1,k2+2-kwtop+1 ), 1, &
                                 c1, s1 )
                    end do
                    ! remove the shift
                    call stdlib_${ri}$lartg( b( kwbot, kwbot ), b( kwbot, kwbot-1 ), c1,s1, temp )
                              
                    b( kwbot, kwbot ) = temp
                    b( kwbot, kwbot-1 ) = zero
                    call stdlib_${ri}$rot( kwbot-istartm, b( istartm, kwbot ), 1,b( istartm, kwbot-1 ),&
                               1, c1, s1 )
                    call stdlib_${ri}$rot( kwbot-istartm+1, a( istartm, kwbot ), 1,a( istartm, kwbot-1 &
                              ), 1, c1, s1 )
                    call stdlib_${ri}$rot( jw, zc( 1, kwbot-kwtop+1 ), 1, zc( 1,kwbot-1-kwtop+1 ), 1, &
                              c1, s1 )
                    k = k-1
                 end if
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, zero, work, jw )
              call stdlib_${ri}$lacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_${ri}$gemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, zero, work, jw )
              call stdlib_${ri}$lacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, jw, jw, one, q( 1, kwtop ), ldq, qc,ldqc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', kwtop-istartm, jw, jw, one, a( istartm,kwtop ), lda, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_${ri}$lacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop &
                        ), lda )
              call stdlib_${ri}$gemm( 'N', 'N', kwtop-istartm, jw, jw, one, b( istartm,kwtop ), ldb, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_${ri}$lacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop &
                        ), ldb )
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, jw, jw, one, z( 1, kwtop ), ldz, zc,ldzc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_${ri}$laqz3


     pure subroutine stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, sr, &
     !! DLAQZ4: Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(ilp), intent( out ) :: info
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(${rk}$) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_qesired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_qesired
              return
           else if ( lwork < n*nblock_qesired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_qesired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_${ri}$laset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_${ri}$laqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_${ri}$lartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_${ri}$lartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_${ri}$rot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_${ri}$rot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_${ri}$rot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_${ri}$rot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_${ri}$rot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_${ri}$rot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_${ri}$laqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_${ri}$laset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_${ri}$laset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_${ri}$laqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_${ri}$lacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_${ri}$lacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_${ri}$laset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_${ri}$laqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz,zc, ldzc, zero,&
                         work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_${ri}$laqz4


     pure subroutine stdlib_${ri}$lar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! DLAR1V: computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(${rk}$), intent(in) :: gaptol, lambda, pivmin
           real(${rk}$), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(${rk}$), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: z(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(${rk}$) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_${ri}$isnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_${ri}$isnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_${ri}$isnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = one
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + z( i )*z( i )
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + z( i )*z( i )
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_${ri}$lar1v


     pure subroutine stdlib_${ri}$lar2v( n, x, y, z, incx, c, s, incc )
     !! DLAR2V: applies a vector of real plane rotations from both sides to
     !! a sequence of 2-by-2 real symmetric matrices, defined by the elements
     !! of the vectors x, y and z. For i = 1,2,...,n
     !! ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
     !! ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incc, incx, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: c(*), s(*)
           real(${rk}$), intent(inout) :: x(*), y(*), z(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ic, ix
           real(${rk}$) :: ci, si, t1, t2, t3, t4, t5, t6, xi, yi, zi
           ! Executable Statements 
           ix = 1
           ic = 1
           do i = 1, n
              xi = x( ix )
              yi = y( ix )
              zi = z( ix )
              ci = c( ic )
              si = s( ic )
              t1 = si*zi
              t2 = ci*zi
              t3 = t2 - si*xi
              t4 = t2 + si*yi
              t5 = ci*xi + t1
              t6 = ci*yi - t1
              x( ix ) = ci*t5 + si*t4
              y( ix ) = ci*t6 - si*t3
              z( ix ) = ci*t4 - si*t5
              ix = ix + incx
              ic = ic + incc
           end do
           return
     end subroutine stdlib_${ri}$lar2v


     pure subroutine stdlib_${ri}$larf( side, m, n, v, incv, tau, c, ldc, work )
     !! DLARF: applies a real elementary reflector H to a real m by n matrix
     !! C, from either the left or the right. H is represented in the form
     !! H = I - tau * v * v**T
     !! where tau is a real scalar and v is a real vector.
     !! If tau = 0, then H is taken to be the unit matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side
           integer(ilp), intent(in) :: incv, ldc, m, n
           real(${rk}$), intent(in) :: tau
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(in) :: v(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: applyleft
           integer(ilp) :: i, lastv, lastc
           ! Executable Statements 
           applyleft = stdlib_lsame( side, 'L' )
           lastv = 0
           lastc = 0
           if( tau/=zero ) then
           ! set up variables for scanning v.  lastv begins pointing to the end
           ! of v.
              if( applyleft ) then
                 lastv = m
              else
                 lastv = n
              end if
              if( incv>0 ) then
                 i = 1 + (lastv-1) * incv
              else
                 i = 1
              end if
           ! look for the last non-zero row in v.
              do while( lastv>0 .and. v( i )==zero )
                 lastv = lastv - 1
                 i = i - incv
              end do
              if( applyleft ) then
           ! scan for the last non-zero column in c(1:lastv,:).
                 lastc = stdlib_ila${ri}$lc(lastv, n, c, ldc)
              else
           ! scan for the last non-zero row in c(:,1:lastv).
                 lastc = stdlib_ila${ri}$lr(m, lastv, c, ldc)
              end if
           end if
           ! note that lastc.eq.0_${rk}$ renders the blas operations null; no special
           ! case is needed at this level.
           if( applyleft ) then
              ! form  h * c
              if( lastv>0 ) then
                 ! w(1:lastc,1) := c(1:lastv,1:lastc)**t * v(1:lastv,1)
                 call stdlib_${ri}$gemv( 'TRANSPOSE', lastv, lastc, one, c, ldc, v, incv,zero, work, 1 &
                           )
                 ! c(1:lastv,1:lastc) := c(...) - v(1:lastv,1) * w(1:lastc,1)**t
                 call stdlib_${ri}$ger( lastv, lastc, -tau, v, incv, work, 1, c, ldc )
              end if
           else
              ! form  c * h
              if( lastv>0 ) then
                 ! w(1:lastc,1) := c(1:lastc,1:lastv) * v(1:lastv,1)
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', lastc, lastv, one, c, ldc,v, incv, zero, work,&
                            1 )
                 ! c(1:lastc,1:lastv) := c(...) - w(1:lastc,1) * v(1:lastv,1)**t
                 call stdlib_${ri}$ger( lastc, lastv, -tau, work, 1, v, incv, c, ldc )
              end if
           end if
           return
     end subroutine stdlib_${ri}$larf


     pure subroutine stdlib_${ri}$larfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, ldc, &
     !! DLARFB: applies a real block reflector H or its transpose H**T to a
     !! real m by n matrix C, from either the left or the right.
               work, ldwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, side, storev, trans
           integer(ilp), intent(in) :: k, ldc, ldt, ldv, ldwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(in) :: t(ldt,*), v(ldv,*)
           real(${rk}$), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           character :: transt
           integer(ilp) :: i, j
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 )return
           if( stdlib_lsame( trans, 'N' ) ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           if( stdlib_lsame( storev, 'C' ) ) then
              if( stdlib_lsame( direct, 'F' ) ) then
                 ! let  v =  ( v1 )    (first k rows)
                           ! ( v2 )
                 ! where  v1  is unit lower triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**t * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**t * v  =  (c1**t * v1 + c2**t * v2)  (stored in work)
                    ! w := c1**t
                    do j = 1, k
                       call stdlib_${ri}$copy( n, c( j, 1 ), ldc, work( 1, j ), 1 )
                    end do
                    ! w := w * v1
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n,k, one, v, ldv,&
                               work, ldwork )
                    if( m>k ) then
                       ! w := w + c2**t * v2
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', n, k, m-k,one, c( k+1, 1 ),&
                                  ldc, v( k+1, 1 ), ldv,one, work, ldwork )
                    end if
                    ! w := w * t**t  or  w * t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', transt, 'NON-UNIT', n, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - v * w**t
                    if( m>k ) then
                       ! c2 := c2 - v2 * w**t
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m-k, n, k,-one, v( k+1, 1 )&
                                 , ldv, work, ldwork, one,c( k+1, 1 ), ldc )
                    end if
                    ! w := w * v1**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE', 'UNIT', n, k,one, v, ldv, &
                              work, ldwork )
                    ! c1 := c1 - w**t
                    do j = 1, k
                       do i = 1, n
                          c( j, i ) = c( j, i ) - work( i, j )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**t  where  c = ( c1  c2 )
                    ! w := c * v  =  (c1*v1 + c2*v2)  (stored in work)
                    ! w := c1
                    do j = 1, k
                       call stdlib_${ri}$copy( m, c( 1, j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v1
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', m,k, one, v, ldv,&
                               work, ldwork )
                    if( n>k ) then
                       ! w := w + c2 * v2
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, k, n-k,one, c( 1, k+&
                                 1 ), ldc, v( k+1, 1 ), ldv,one, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', trans, 'NON-UNIT', m, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v**t
                    if( n>k ) then
                       ! c2 := c2 - w * v2**t
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m, n-k, k,-one, work, &
                                 ldwork, v( k+1, 1 ), ldv, one,c( 1, k+1 ), ldc )
                    end if
                    ! w := w * v1**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE', 'UNIT', m, k,one, v, ldv, &
                              work, ldwork )
                    ! c1 := c1 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, j ) = c( i, j ) - work( i, j )
                       end do
                    end do
                 end if
              else
                 ! let  v =  ( v1 )
                           ! ( v2 )    (last k rows)
                 ! where  v2  is unit upper triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**t * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**t * v  =  (c1**t * v1 + c2**t * v2)  (stored in work)
                    ! w := c2**t
                    do j = 1, k
                       call stdlib_${ri}$copy( n, c( m-k+j, 1 ), ldc, work( 1, j ), 1 )
                    end do
                    ! w := w * v2
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', n,k, one, v( m-k+&
                              1, 1 ), ldv, work, ldwork )
                    if( m>k ) then
                       ! w := w + c1**t * v1
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', n, k, m-k,one, c, ldc, v, &
                                 ldv, one, work, ldwork )
                    end if
                    ! w := w * t**t  or  w * t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', transt, 'NON-UNIT', n, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - v * w**t
                    if( m>k ) then
                       ! c1 := c1 - v1 * w**t
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m-k, n, k,-one, v, ldv, &
                                 work, ldwork, one, c, ldc )
                    end if
                    ! w := w * v2**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'TRANSPOSE', 'UNIT', n, k,one, v( m-k+1, &
                              1 ), ldv, work, ldwork )
                    ! c2 := c2 - w**t
                    do j = 1, k
                       do i = 1, n
                          c( m-k+j, i ) = c( m-k+j, i ) - work( i, j )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**t  where  c = ( c1  c2 )
                    ! w := c * v  =  (c1*v1 + c2*v2)  (stored in work)
                    ! w := c2
                    do j = 1, k
                       call stdlib_${ri}$copy( m, c( 1, n-k+j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v2
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', m,k, one, v( n-k+&
                              1, 1 ), ldv, work, ldwork )
                    if( n>k ) then
                       ! w := w + c1 * v1
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, k, n-k,one, c, ldc, &
                                 v, ldv, one, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', trans, 'NON-UNIT', m, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v**t
                    if( n>k ) then
                       ! c1 := c1 - w * v1**t
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m, n-k, k,-one, work, &
                                 ldwork, v, ldv, one, c, ldc )
                    end if
                    ! w := w * v2**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'TRANSPOSE', 'UNIT', m, k,one, v( n-k+1, &
                              1 ), ldv, work, ldwork )
                    ! c2 := c2 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, n-k+j ) = c( i, n-k+j ) - work( i, j )
                       end do
                    end do
                 end if
              end if
           else if( stdlib_lsame( storev, 'R' ) ) then
              if( stdlib_lsame( direct, 'F' ) ) then
                 ! let  v =  ( v1  v2 )    (v1: first k columns)
                 ! where  v1  is unit upper triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**t * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**t * v**t  =  (c1**t * v1**t + c2**t * v2**t) (stored in work)
                    ! w := c1**t
                    do j = 1, k
                       call stdlib_${ri}$copy( n, c( j, 1 ), ldc, work( 1, j ), 1 )
                    end do
                    ! w := w * v1**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'TRANSPOSE', 'UNIT', n, k,one, v, ldv, &
                              work, ldwork )
                    if( m>k ) then
                       ! w := w + c2**t * v2**t
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE', n, k, m-k, one,c( k+1, 1 ), &
                                 ldc, v( 1, k+1 ), ldv, one,work, ldwork )
                    end if
                    ! w := w * t**t  or  w * t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', transt, 'NON-UNIT', n, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - v**t * w**t
                    if( m>k ) then
                       ! c2 := c2 - v2**t * w**t
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE', m-k, n, k, -one,v( 1, k+1 ), &
                                 ldv, work, ldwork, one,c( k+1, 1 ), ldc )
                    end if
                    ! w := w * v1
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', n,k, one, v, ldv,&
                               work, ldwork )
                    ! c1 := c1 - w**t
                    do j = 1, k
                       do i = 1, n
                          c( j, i ) = c( j, i ) - work( i, j )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**t  where  c = ( c1  c2 )
                    ! w := c * v**t  =  (c1*v1**t + c2*v2**t)  (stored in work)
                    ! w := c1
                    do j = 1, k
                       call stdlib_${ri}$copy( m, c( 1, j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v1**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'TRANSPOSE', 'UNIT', m, k,one, v, ldv, &
                              work, ldwork )
                    if( n>k ) then
                       ! w := w + c2 * v2**t
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m, k, n-k,one, c( 1, k+1 ),&
                                  ldc, v( 1, k+1 ), ldv,one, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', trans, 'NON-UNIT', m, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v
                    if( n>k ) then
                       ! c2 := c2 - w * v2
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, n-k, k,-one, work, &
                                 ldwork, v( 1, k+1 ), ldv, one,c( 1, k+1 ), ldc )
                    end if
                    ! w := w * v1
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', m,k, one, v, ldv,&
                               work, ldwork )
                    ! c1 := c1 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, j ) = c( i, j ) - work( i, j )
                       end do
                    end do
                 end if
              else
                 ! let  v =  ( v1  v2 )    (v2: last k columns)
                 ! where  v2  is unit lower triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**t * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**t * v**t  =  (c1**t * v1**t + c2**t * v2**t) (stored in work)
                    ! w := c2**t
                    do j = 1, k
                       call stdlib_${ri}$copy( n, c( m-k+j, 1 ), ldc, work( 1, j ), 1 )
                    end do
                    ! w := w * v2**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE', 'UNIT', n, k,one, v( 1, m-k+&
                              1 ), ldv, work, ldwork )
                    if( m>k ) then
                       ! w := w + c1**t * v1**t
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE', n, k, m-k, one,c, ldc, v, ldv,&
                                  one, work, ldwork )
                    end if
                    ! w := w * t**t  or  w * t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', transt, 'NON-UNIT', n, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - v**t * w**t
                    if( m>k ) then
                       ! c1 := c1 - v1**t * w**t
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE', m-k, n, k, -one,v, ldv, work, &
                                 ldwork, one, c, ldc )
                    end if
                    ! w := w * v2
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n,k, one, v( 1, &
                              m-k+1 ), ldv, work, ldwork )
                    ! c2 := c2 - w**t
                    do j = 1, k
                       do i = 1, n
                          c( m-k+j, i ) = c( m-k+j, i ) - work( i, j )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h'  where  c = ( c1  c2 )
                    ! w := c * v**t  =  (c1*v1**t + c2*v2**t)  (stored in work)
                    ! w := c2
                    do j = 1, k
                       call stdlib_${ri}$copy( m, c( 1, n-k+j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v2**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE', 'UNIT', m, k,one, v( 1, n-k+&
                              1 ), ldv, work, ldwork )
                    if( n>k ) then
                       ! w := w + c1 * v1**t
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m, k, n-k,one, c, ldc, v, &
                                 ldv, one, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**t
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', trans, 'NON-UNIT', m, k,one, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v
                    if( n>k ) then
                       ! c1 := c1 - w * v1
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, n-k, k,-one, work, &
                                 ldwork, v, ldv, one, c, ldc )
                    end if
                    ! w := w * v2
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', m,k, one, v( 1, &
                              n-k+1 ), ldv, work, ldwork )
                    ! c1 := c1 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, n-k+j ) = c( i, n-k+j ) - work( i, j )
                       end do
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$larfb


     pure subroutine stdlib_${ri}$larfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )
     !! DLARFB_GETT: applies a real Householder block reflector H from the
     !! left to a real (K+M)-by-N  "triangular-pentagonal" matrix
     !! composed of two block matrices: an upper trapezoidal K-by-N matrix A
     !! stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
     !! in the array B. The block reflector H is stored in a compact
     !! WY-representation, where the elementary reflectors are in the
     !! arrays A, B and T. See Further Details section.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: ident
           integer(ilp), intent(in) :: k, lda, ldb, ldt, ldwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lnotident
           integer(ilp) :: i, j
           ! Executable Statements 
           ! quick return if possible
           if( m<0 .or. n<=0 .or. k==0 .or. k>n )return
           lnotident = .not.stdlib_lsame( ident, 'I' )
           ! ------------------------------------------------------------------
           ! first step. computation of the column block 2:
              ! ( a2 ) := h * ( a2 )
              ! ( b2 )        ( b2 )
           ! ------------------------------------------------------------------
           if( n>k ) then
              ! col2_(1) compute w2: = a2. therefore, copy a2 = a(1:k, k+1:n)
              ! into w2=work(1:k, 1:n-k) column-by-column.
              do j = 1, n-k
                 call stdlib_${ri}$copy( k, a( 1, k+j ), 1, work( 1, j ), 1 )
              end do
              if( lnotident ) then
                 ! col2_(2) compute w2: = (v1**t) * w2 = (a1**t) * w2,
                 ! v1 is not an identy matrix, but unit lower-triangular
                 ! v1 stored in a1 (diagonal ones are not stored).
                 call stdlib_${ri}$trmm( 'L', 'L', 'T', 'U', k, n-k, one, a, lda,work, ldwork )
              end if
              ! col2_(3) compute w2: = w2 + (v2**t) * b2 = w2 + (b1**t) * b2
              ! v2 stored in b1.
              if( m>0 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', k, n-k, m, one, b, ldb,b( 1, k+1 ), ldb, one, work, &
                           ldwork )
              end if
              ! col2_(4) compute w2: = t * w2,
              ! t is upper-triangular.
              call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', k, n-k, one, t, ldt,work, ldwork )
              ! col2_(5) compute b2: = b2 - v2 * w2 = b2 - b1 * w2,
              ! v2 stored in b1.
              if( m>0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', m, n-k, k, -one, b, ldb,work, ldwork, one, b( 1, k+&
                           1 ), ldb )
              end if
              if( lnotident ) then
                 ! col2_(6) compute w2: = v1 * w2 = a1 * w2,
                 ! v1 is not an identity matrix, but unit lower-triangular,
                 ! v1 stored in a1 (diagonal ones are not stored).
                 call stdlib_${ri}$trmm( 'L', 'L', 'N', 'U', k, n-k, one, a, lda,work, ldwork )
              end if
              ! col2_(7) compute a2: = a2 - w2 =
                                   ! = a(1:k, k+1:n-k) - work(1:k, 1:n-k),
              ! column-by-column.
              do j = 1, n-k
                 do i = 1, k
                    a( i, k+j ) = a( i, k+j ) - work( i, j )
                 end do
              end do
           end if
           ! ------------------------------------------------------------------
           ! second step. computation of the column block 1:
              ! ( a1 ) := h * ( a1 )
              ! ( b1 )        (  0 )
           ! ------------------------------------------------------------------
           ! col1_(1) compute w1: = a1. copy the upper-triangular
           ! a1 = a(1:k, 1:k) into the upper-triangular
           ! w1 = work(1:k, 1:k) column-by-column.
           do j = 1, k
              call stdlib_${ri}$copy( j, a( 1, j ), 1, work( 1, j ), 1 )
           end do
           ! set the subdiagonal elements of w1 to zero column-by-column.
           do j = 1, k - 1
              do i = j + 1, k
                 work( i, j ) = zero
              end do
           end do
           if( lnotident ) then
              ! col1_(2) compute w1: = (v1**t) * w1 = (a1**t) * w1,
              ! v1 is not an identity matrix, but unit lower-triangular
              ! v1 stored in a1 (diagonal ones are not stored),
              ! w1 is upper-triangular with zeroes below the diagonal.
              call stdlib_${ri}$trmm( 'L', 'L', 'T', 'U', k, k, one, a, lda,work, ldwork )
           end if
           ! col1_(3) compute w1: = t * w1,
           ! t is upper-triangular,
           ! w1 is upper-triangular with zeroes below the diagonal.
           call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', k, k, one, t, ldt,work, ldwork )
           ! col1_(4) compute b1: = - v2 * w1 = - b1 * w1,
           ! v2 = b1, w1 is upper-triangular with zeroes below the diagonal.
           if( m>0 ) then
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'N', m, k, -one, work, ldwork,b, ldb )
           end if
           if( lnotident ) then
              ! col1_(5) compute w1: = v1 * w1 = a1 * w1,
              ! v1 is not an identity matrix, but unit lower-triangular
              ! v1 stored in a1 (diagonal ones are not stored),
              ! w1 is upper-triangular on input with zeroes below the diagonal,
              ! and square on output.
              call stdlib_${ri}$trmm( 'L', 'L', 'N', 'U', k, k, one, a, lda,work, ldwork )
              ! col1_(6) compute a1: = a1 - w1 = a(1:k, 1:k) - work(1:k, 1:k)
              ! column-by-column. a1 is upper-triangular on input.
              ! if ident, a1 is square on output, and w1 is square,
              ! if not ident, a1 is upper-triangular on output,
              ! w1 is upper-triangular.
              ! col1_(6)_a compute elements of a1 below the diagonal.
              do j = 1, k - 1
                 do i = j + 1, k
                    a( i, j ) = - work( i, j )
                 end do
              end do
           end if
           ! col1_(6)_b compute elements of a1 on and above the diagonal.
           do j = 1, k
              do i = 1, j
                 a( i, j ) = a( i, j ) - work( i, j )
              end do
           end do
           return
     end subroutine stdlib_${ri}$larfb_gett


     pure subroutine stdlib_${ri}$larfg( n, alpha, x, incx, tau )
     !! DLARFG: generates a real elementary reflector H of order n, such
     !! that
     !! H * ( alpha ) = ( beta ),   H**T * H = I.
     !! (   x   )   (   0  )
     !! where alpha and beta are scalars, and x is an (n-1)-element real
     !! vector. H is represented in the form
     !! H = I - tau * ( 1 ) * ( 1 v**T ) ,
     !! ( v )
     !! where tau is a real scalar and v is a real (n-1)-element
     !! vector.
     !! If the elements of x are all zero, then tau = 0 and H is taken to be
     !! the unit matrix.
     !! Otherwise  1 <= tau <= 2.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           real(${rk}$), intent(inout) :: alpha
           real(${rk}$), intent(out) :: tau
           ! Array Arguments 
           real(${rk}$), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, knt
           real(${rk}$) :: beta, rsafmn, safmin, xnorm
           ! Intrinsic Functions 
           intrinsic :: abs,sign
           ! Executable Statements 
           if( n<=1 ) then
              tau = zero
              return
           end if
           xnorm = stdlib_${ri}$nrm2( n-1, x, incx )
           if( xnorm==zero ) then
              ! h  =  i
              tau = zero
           else
              ! general case
              beta = -sign( stdlib_${ri}$lapy2( alpha, xnorm ), alpha )
              safmin = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'E' )
              knt = 0
              if( abs( beta )<safmin ) then
                 ! xnorm, beta may be inaccurate; scale x and recompute them
                 rsafmn = one / safmin
                 10 continue
                 knt = knt + 1
                 call stdlib_${ri}$scal( n-1, rsafmn, x, incx )
                 beta = beta*rsafmn
                 alpha = alpha*rsafmn
                 if( (abs( beta )<safmin) .and. (knt < 20) )go to 10
                 ! new beta is at most 1, at least safmin
                 xnorm = stdlib_${ri}$nrm2( n-1, x, incx )
                 beta = -sign( stdlib_${ri}$lapy2( alpha, xnorm ), alpha )
              end if
              tau = ( beta-alpha ) / beta
              call stdlib_${ri}$scal( n-1, one / ( alpha-beta ), x, incx )
              ! if alpha is subnormal, it may lose relative accuracy
              do j = 1, knt
                 beta = beta*safmin
              end do
              alpha = beta
           end if
           return
     end subroutine stdlib_${ri}$larfg


     subroutine stdlib_${ri}$larfgp( n, alpha, x, incx, tau )
     !! DLARFGP: generates a real elementary reflector H of order n, such
     !! that
     !! H * ( alpha ) = ( beta ),   H**T * H = I.
     !! (   x   )   (   0  )
     !! where alpha and beta are scalars, beta is non-negative, and x is
     !! an (n-1)-element real vector.  H is represented in the form
     !! H = I - tau * ( 1 ) * ( 1 v**T ) ,
     !! ( v )
     !! where tau is a real scalar and v is a real (n-1)-element
     !! vector.
     !! If the elements of x are all zero, then tau = 0 and H is taken to be
     !! the unit matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           real(${rk}$), intent(inout) :: alpha
           real(${rk}$), intent(out) :: tau
           ! Array Arguments 
           real(${rk}$), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, knt
           real(${rk}$) :: beta, bignum, savealpha, smlnum, xnorm
           ! Intrinsic Functions 
           intrinsic :: abs,sign
           ! Executable Statements 
           if( n<=0 ) then
              tau = zero
              return
           end if
           xnorm = stdlib_${ri}$nrm2( n-1, x, incx )
           if( xnorm==zero ) then
              ! h  =  [+/-1, 0; i], sign chosen so alpha >= 0
              if( alpha>=zero ) then
                 ! when tau.eq.zero, the vector is special-cased to be
                 ! all zeros in the application routines.  we do not need
                 ! to clear it.
                 tau = zero
              else
                 ! however, the application routines rely on explicit
                 ! zero checks when tau.ne.zero, and we must clear x.
                 tau = two
                 do j = 1, n-1
                    x( 1 + (j-1)*incx ) = 0
                 end do
                 alpha = -alpha
              end if
           else
              ! general case
              beta = sign( stdlib_${ri}$lapy2( alpha, xnorm ), alpha )
              smlnum = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'E' )
              knt = 0
              if( abs( beta )<smlnum ) then
                 ! xnorm, beta may be inaccurate; scale x and recompute them
                 bignum = one / smlnum
                 10 continue
                 knt = knt + 1
                 call stdlib_${ri}$scal( n-1, bignum, x, incx )
                 beta = beta*bignum
                 alpha = alpha*bignum
                 if( (abs( beta )<smlnum) .and. (knt < 20) )go to 10
                 ! new beta is at most 1, at least smlnum
                 xnorm = stdlib_${ri}$nrm2( n-1, x, incx )
                 beta = sign( stdlib_${ri}$lapy2( alpha, xnorm ), alpha )
              end if
              savealpha = alpha
              alpha = alpha + beta
              if( beta<zero ) then
                 beta = -beta
                 tau = -alpha / beta
              else
                 alpha = xnorm * (xnorm/alpha)
                 tau = alpha / beta
                 alpha = -alpha
              end if
              if ( abs(tau)<=smlnum ) then
                 ! in the case where the computed tau ends up being a denormalized number,
                 ! it loses relative accuracy. this is a big problem. solution: flush tau
                 ! to zero. this explains the next if statement.
                 ! (bug report provided by pat quillen from mathworks on jul 29, 2009.)
                 ! (thanks pat. thanks mathworks.)
                 if( savealpha>=zero ) then
                    tau = zero
                 else
                    tau = two
                    do j = 1, n-1
                       x( 1 + (j-1)*incx ) = 0
                    end do
                    beta = -savealpha
                 end if
              else
                 ! this is the general case.
                 call stdlib_${ri}$scal( n-1, one / alpha, x, incx )
              end if
              ! if beta is subnormal, it may lose relative accuracy
              do j = 1, knt
                 beta = beta*smlnum
              end do
              alpha = beta
           end if
           return
     end subroutine stdlib_${ri}$larfgp


     pure subroutine stdlib_${ri}$larft( direct, storev, n, k, v, ldv, tau, t, ldt )
     !! DLARFT: forms the triangular factor T of a real block reflector H
     !! of order n, which is defined as a product of k elementary reflectors.
     !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
     !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
     !! If STOREV = 'C', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th column of the array V, and
     !! H  =  I - V * T * V**T
     !! If STOREV = 'R', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th row of the array V, and
     !! H  =  I - V**T * T * V
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, storev
           integer(ilp), intent(in) :: k, ldt, ldv, n
           ! Array Arguments 
           real(${rk}$), intent(out) :: t(ldt,*)
           real(${rk}$), intent(in) :: tau(*), v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, prevlastv, lastv
           ! Executable Statements 
           ! quick return if possible
           if( n==0 )return
           if( stdlib_lsame( direct, 'F' ) ) then
              prevlastv = n
              do i = 1, k
                 prevlastv = max( i, prevlastv )
                 if( tau( i )==zero ) then
                    ! h(i)  =  i
                    do j = 1, i
                       t( j, i ) = zero
                    end do
                 else
                    ! general case
                    if( stdlib_lsame( storev, 'C' ) ) then
                       ! skip any trailing zeros.
                       do lastv = n, i+1, -1
                          if( v( lastv, i )/=zero ) exit
                       end do
                       do j = 1, i-1
                          t( j, i ) = -tau( i ) * v( i , j )
                       end do
                       j = min( lastv, prevlastv )
                       ! t(1:i-1,i) := - tau(i) * v(i:j,1:i-1)**t * v(i:j,i)
                       call stdlib_${ri}$gemv( 'TRANSPOSE', j-i, i-1, -tau( i ),v( i+1, 1 ), ldv, v( i+&
                                 1, i ), 1, one,t( 1, i ), 1 )
                    else
                       ! skip any trailing zeros.
                       do lastv = n, i+1, -1
                          if( v( i, lastv )/=zero ) exit
                       end do
                       do j = 1, i-1
                          t( j, i ) = -tau( i ) * v( j , i )
                       end do
                       j = min( lastv, prevlastv )
                       ! t(1:i-1,i) := - tau(i) * v(1:i-1,i:j) * v(i,i:j)**t
                       call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, j-i, -tau( i ),v( 1, i+1 ), ldv, v(&
                                  i, i+1 ), ldv, one,t( 1, i ), 1 )
                    end if
                    ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(1:i-1,i)
                    call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', i-1, t,ldt, t( 1, i ),&
                               1 )
                    t( i, i ) = tau( i )
                    if( i>1 ) then
                       prevlastv = max( prevlastv, lastv )
                    else
                       prevlastv = lastv
                    end if
                 end if
              end do
           else
              prevlastv = 1
              do i = k, 1, -1
                 if( tau( i )==zero ) then
                    ! h(i)  =  i
                    do j = i, k
                       t( j, i ) = zero
                    end do
                 else
                    ! general case
                    if( i<k ) then
                       if( stdlib_lsame( storev, 'C' ) ) then
                          ! skip any leading zeros.
                          do lastv = 1, i-1
                             if( v( lastv, i )/=zero ) exit
                          end do
                          do j = i+1, k
                             t( j, i ) = -tau( i ) * v( n-k+i , j )
                          end do
                          j = max( lastv, prevlastv )
                          ! t(i+1:k,i) = -tau(i) * v(j:n-k+i,i+1:k)**t * v(j:n-k+i,i)
                          call stdlib_${ri}$gemv( 'TRANSPOSE', n-k+i-j, k-i, -tau( i ),v( j, i+1 ), &
                                    ldv, v( j, i ), 1, one,t( i+1, i ), 1 )
                       else
                          ! skip any leading zeros.
                          do lastv = 1, i-1
                             if( v( i, lastv )/=zero ) exit
                          end do
                          do j = i+1, k
                             t( j, i ) = -tau( i ) * v( j, n-k+i )
                          end do
                          j = max( lastv, prevlastv )
                          ! t(i+1:k,i) = -tau(i) * v(i+1:k,j:n-k+i) * v(i,j:n-k+i)**t
                          call stdlib_${ri}$gemv( 'NO TRANSPOSE', k-i, n-k+i-j,-tau( i ), v( i+1, j ), &
                                    ldv, v( i, j ), ldv,one, t( i+1, i ), 1 )
                       end if
                       ! t(i+1:k,i) := t(i+1:k,i+1:k) * t(i+1:k,i)
                       call stdlib_${ri}$trmv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', k-i,t( i+1, i+1 ), &
                                 ldt, t( i+1, i ), 1 )
                       if( i>1 ) then
                          prevlastv = min( prevlastv, lastv )
                       else
                          prevlastv = lastv
                       end if
                    end if
                    t( i, i ) = tau( i )
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$larft


     pure subroutine stdlib_${ri}$larfx( side, m, n, v, tau, c, ldc, work )
     !! DLARFX: applies a real elementary reflector H to a real m by n
     !! matrix C, from either the left or the right. H is represented in the
     !! form
     !! H = I - tau * v * v**T
     !! where tau is a real scalar and v is a real vector.
     !! If tau = 0, then H is taken to be the unit matrix
     !! This version uses inline code if H has order < 11.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side
           integer(ilp), intent(in) :: ldc, m, n
           real(${rk}$), intent(in) :: tau
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(in) :: v(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j
           real(${rk}$) :: sum, t1, t10, t2, t3, t4, t5, t6, t7, t8, t9, v1, v10, v2, v3, v4, v5, v6, &
                     v7, v8, v9
           ! Executable Statements 
           if( tau==zero )return
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  h * c, where h has order m.
              go to ( 10, 30, 50, 70, 90, 110, 130, 150,170, 190 )m
              ! code for general m
              call stdlib_${ri}$larf( side, m, n, v, 1, tau, c, ldc, work )
              go to 410
              10 continue
              ! special code for 1 x 1 householder
              t1 = one - tau*v( 1 )*v( 1 )
              do j = 1, n
                 c( 1, j ) = t1*c( 1, j )
              end do
              go to 410
              30 continue
              ! special code for 2 x 2 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
              end do
              go to 410
              50 continue
              ! special code for 3 x 3 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
              end do
              go to 410
              70 continue
              ! special code for 4 x 4 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
              end do
              go to 410
              90 continue
              ! special code for 5 x 5 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j )
                           
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
              end do
              go to 410
              110 continue
              ! special code for 6 x 6 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
              end do
              go to 410
              130 continue
              ! special code for 7 x 7 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
              end do
              go to 410
              150 continue
              ! special code for 8 x 8 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              v8 = v( 8 )
              t8 = tau*v8
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j ) + v8*c( 8, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
                 c( 8, j ) = c( 8, j ) - sum*t8
              end do
              go to 410
              170 continue
              ! special code for 9 x 9 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              v8 = v( 8 )
              t8 = tau*v8
              v9 = v( 9 )
              t9 = tau*v9
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j ) + v8*c( 8, j ) + v9*c( 9, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
                 c( 8, j ) = c( 8, j ) - sum*t8
                 c( 9, j ) = c( 9, j ) - sum*t9
              end do
              go to 410
              190 continue
              ! special code for 10 x 10 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              v8 = v( 8 )
              t8 = tau*v8
              v9 = v( 9 )
              t9 = tau*v9
              v10 = v( 10 )
              t10 = tau*v10
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j ) + v8*c( 8, j ) + v9*c( 9, j ) +v10*c( 10, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
                 c( 8, j ) = c( 8, j ) - sum*t8
                 c( 9, j ) = c( 9, j ) - sum*t9
                 c( 10, j ) = c( 10, j ) - sum*t10
              end do
              go to 410
           else
              ! form  c * h, where h has order n.
              go to ( 210, 230, 250, 270, 290, 310, 330, 350,370, 390 )n
              ! code for general n
              call stdlib_${ri}$larf( side, m, n, v, 1, tau, c, ldc, work )
              go to 410
              210 continue
              ! special code for 1 x 1 householder
              t1 = one - tau*v( 1 )*v( 1 )
              do j = 1, m
                 c( j, 1 ) = t1*c( j, 1 )
              end do
              go to 410
              230 continue
              ! special code for 2 x 2 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
              end do
              go to 410
              250 continue
              ! special code for 3 x 3 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
              end do
              go to 410
              270 continue
              ! special code for 4 x 4 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
              end do
              go to 410
              290 continue
              ! special code for 5 x 5 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 )
                           
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
              end do
              go to 410
              310 continue
              ! special code for 6 x 6 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
              end do
              go to 410
              330 continue
              ! special code for 7 x 7 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
              end do
              go to 410
              350 continue
              ! special code for 8 x 8 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              v8 = v( 8 )
              t8 = tau*v8
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 ) + v8*c( j, 8 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
                 c( j, 8 ) = c( j, 8 ) - sum*t8
              end do
              go to 410
              370 continue
              ! special code for 9 x 9 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              v8 = v( 8 )
              t8 = tau*v8
              v9 = v( 9 )
              t9 = tau*v9
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 ) + v8*c( j, 8 ) + v9*c( j, 9 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
                 c( j, 8 ) = c( j, 8 ) - sum*t8
                 c( j, 9 ) = c( j, 9 ) - sum*t9
              end do
              go to 410
              390 continue
              ! special code for 10 x 10 householder
              v1 = v( 1 )
              t1 = tau*v1
              v2 = v( 2 )
              t2 = tau*v2
              v3 = v( 3 )
              t3 = tau*v3
              v4 = v( 4 )
              t4 = tau*v4
              v5 = v( 5 )
              t5 = tau*v5
              v6 = v( 6 )
              t6 = tau*v6
              v7 = v( 7 )
              t7 = tau*v7
              v8 = v( 8 )
              t8 = tau*v8
              v9 = v( 9 )
              t9 = tau*v9
              v10 = v( 10 )
              t10 = tau*v10
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 ) + v8*c( j, 8 ) + v9*c( j, 9 ) +v10*c( j, 10 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
                 c( j, 8 ) = c( j, 8 ) - sum*t8
                 c( j, 9 ) = c( j, 9 ) - sum*t9
                 c( j, 10 ) = c( j, 10 ) - sum*t10
              end do
              go to 410
           end if
           410 continue
           return
     end subroutine stdlib_${ri}$larfx


     pure subroutine stdlib_${ri}$larfy( uplo, n, v, incv, tau, c, ldc, work )
     !! DLARFY: applies an elementary reflector, or Householder matrix, H,
     !! to an n x n symmetric matrix C, from both the left and the right.
     !! H is represented in the form
     !! H = I - tau * v * v'
     !! where  tau  is a scalar and  v  is a vector.
     !! If  tau  is  zero, then  H  is taken to be the unit matrix.
        ! -- lapack test routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: incv, ldc, n
           real(${rk}$), intent(in) :: tau
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(in) :: v(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: alpha
           ! Executable Statements 
           if( tau==zero )return
           ! form  w:= c * v
           call stdlib_${ri}$symv( uplo, n, one, c, ldc, v, incv, zero, work, 1 )
           alpha = -half*tau*stdlib_${ri}$dot( n, work, 1, v, incv )
           call stdlib_${ri}$axpy( n, alpha, v, incv, work, 1 )
           ! c := c - v * w' - w * v'
           call stdlib_${ri}$syr2( uplo, n, -tau, v, incv, work, 1, c, ldc )
           return
     end subroutine stdlib_${ri}$larfy


     pure subroutine stdlib_${ri}$largv( n, x, incx, y, incy, c, incc )
     !! DLARGV: generates a vector of real plane rotations, determined by
     !! elements of the real vectors x and y. For i = 1,2,...,n
     !! (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
     !! ( -s(i)  c(i) ) ( y(i) ) = (   0  )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incc, incx, incy, n
           ! Array Arguments 
           real(${rk}$), intent(out) :: c(*)
           real(${rk}$), intent(inout) :: x(*), y(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ic, ix, iy
           real(${rk}$) :: f, g, t, tt
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           ix = 1
           iy = 1
           ic = 1
           loop_10: do i = 1, n
              f = x( ix )
              g = y( iy )
              if( g==zero ) then
                 c( ic ) = one
              else if( f==zero ) then
                 c( ic ) = zero
                 y( iy ) = one
                 x( ix ) = g
              else if( abs( f )>abs( g ) ) then
                 t = g / f
                 tt = sqrt( one+t*t )
                 c( ic ) = one / tt
                 y( iy ) = t*c( ic )
                 x( ix ) = f*tt
              else
                 t = f / g
                 tt = sqrt( one+t*t )
                 y( iy ) = one / tt
                 c( ic ) = t*y( iy )
                 x( ix ) = g*tt
              end if
              ic = ic + incc
              iy = iy + incy
              ix = ix + incx
           end do loop_10
           return
     end subroutine stdlib_${ri}$largv


     pure subroutine stdlib_${ri}$larnv( idist, iseed, n, x )
     !! DLARNV: returns a vector of n random real numbers from a uniform or
     !! normal distribution.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: idist, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: iseed(4)
           real(${rk}$), intent(out) :: x(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: lv = 128
           real(${rk}$), parameter :: twopi = 6.28318530717958647692528676655900576839e+0_${rk}$
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, il, il2, iv
           ! Local Arrays 
           real(${rk}$) :: u(lv)
           ! Intrinsic Functions 
           intrinsic :: cos,log,min,sqrt
           ! Executable Statements 
           do 40 iv = 1, n, lv / 2
              il = min( lv / 2, n-iv+1 )
              if( idist==3 ) then
                 il2 = 2*il
              else
                 il2 = il
              end if
              ! call stdlib_${ri}$laruv to generate il2 numbers from a uniform (0,1)
              ! distribution (il2 <= lv)
              call stdlib_${ri}$laruv( iseed, il2, u )
              if( idist==1 ) then
                 ! copy generated numbers
                 do i = 1, il
                    x( iv+i-1 ) = u( i )
                 end do
              else if( idist==2 ) then
                 ! convert generated numbers to uniform (-1,1) distribution
                 do i = 1, il
                    x( iv+i-1 ) = two*u( i ) - one
                 end do
              else if( idist==3 ) then
                 ! convert generated numbers to normal (0,1) distribution
                 do i = 1, il
                    x( iv+i-1 ) = sqrt( -two*log( u( 2*i-1 ) ) )*cos( twopi*u( 2*i ) )
                 end do
              end if
              40 continue
           return
     end subroutine stdlib_${ri}$larnv


     pure subroutine stdlib_${ri}$larra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
     !! Compute the splitting points with threshold SPLTOL.
     !! DLARRA: sets any "small" off-diagonal elements to zero.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, nsplit
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: spltol, tnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: isplit(*)
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(inout) :: e(*), e2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: eabs, tmp1
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! compute splitting points
           nsplit = 1
           if(spltol<zero) then
              ! criterion based on absolute off-diagonal value
              tmp1 = abs(spltol)* tnrm
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= tmp1) then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           else
              ! criterion that guarantees relative accuracy
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= spltol * sqrt(abs(d(i)))*sqrt(abs(d(i+1))) )then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           endif
           isplit( nsplit ) = n
           return
     end subroutine stdlib_${ri}$larra


     pure subroutine stdlib_${ri}$larrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
     !! Given the relatively robust representation(RRR) L D L^T, DLARRB:
     !! does "limited" bisection to refine the eigenvalues of L D L^T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses and their gaps are input in WERR
     !! and WGAP, respectively. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               work, iwork,pivmin, spdiam, twist, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset, twist
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: pivmin, rtol1, rtol2, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), lld(*)
           real(${rk}$), intent(inout) :: w(*), werr(*), wgap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: i, i1, ii, ip, iter, k, negcnt, next, nint, olnint, prev, r
           real(${rk}$) :: back, cvrgd, gap, left, lgap, mid, mnwdth, rgap, right, tmp, width
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           mnwdth = two * pivmin
           r = twist
           if((r<1).or.(r>n)) r = n
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           rgap = wgap( i1-offset )
           loop_75: do i = i1, ilast
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              right = w( ii ) + werr( ii )
              lgap = rgap
              rgap = wgap( ii )
              gap = min( lgap, rgap )
              ! make sure that [left,right] contains the desired eigenvalue
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - left
              ! do while( negcnt(left)>i-1 )
              back = werr( ii )
              20 continue
              negcnt = stdlib_${ri}$laneg( n, d, lld, left, pivmin, r )
              if( negcnt>i-1 ) then
                 left = left - back
                 back = two*back
                 go to 20
              end if
              ! do while( negcnt(right)<i )
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - right
              back = werr( ii )
              50 continue
              negcnt = stdlib_${ri}$laneg( n, d, lld, right, pivmin, r )
               if( negcnt<i ) then
                  right = right + back
                  back = two*back
                  go to 50
               end if
              width = half*abs( left - right )
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( width<=cvrgd .or. width<=mnwdth ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<ilast)) i1 = i + 1
                 if((prev>=i1).and.(i<=ilast)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = negcnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do ip = 1, olnint
              k = 2*i
              ii = i - offset
              rgap = wgap( ii )
              lgap = rgap
              if(ii>1) lgap = wgap( ii-1 )
              gap = min( lgap, rgap )
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( ( width<=cvrgd ) .or. ( width<=mnwdth ).or.( iter==maxitr ) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              negcnt = stdlib_${ri}$laneg( n, d, lld, mid, pivmin, r )
              if( negcnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = ifirst, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           do i = ifirst+1, ilast
              k = 2*i
              ii = i - offset
              wgap( ii-1 ) = max( zero,w(ii) - werr (ii) - w( ii-1 ) - werr( ii-1 ))
           end do
           return
     end subroutine stdlib_${ri}$larrb


     pure subroutine stdlib_${ri}$larrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
     !! Find the number of eigenvalues of the symmetric tridiagonal matrix T
     !! that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
     !! if JOBT = 'L'.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobt
           integer(ilp), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: pivmin, vl, vu
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: matt
           real(${rk}$) :: lpivot, rpivot, sl, su, tmp, tmp2
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           lcnt = 0
           rcnt = 0
           eigcnt = 0
           matt = stdlib_lsame( jobt, 'T' )
           if (matt) then
              ! sturm sequence count on t
              lpivot = d( 1 ) - vl
              rpivot = d( 1 ) - vu
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
              do i = 1, n-1
                 tmp = e(i)**2
                 lpivot = ( d( i+1 )-vl ) - tmp/lpivot
                 rpivot = ( d( i+1 )-vu ) - tmp/rpivot
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
              end do
           else
              ! sturm sequence count on l d l^t
              sl = -vl
              su = -vu
              do i = 1, n - 1
                 lpivot = d( i ) + sl
                 rpivot = d( i ) + su
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
                 tmp = e(i) * d(i) * e(i)
                 tmp2 = tmp / lpivot
                 if( tmp2==zero ) then
                    sl =  tmp - vl
                 else
                    sl = sl*tmp2 - vl
                 end if
                 tmp2 = tmp / rpivot
                 if( tmp2==zero ) then
                    su =  tmp - vu
                 else
                    su = su*tmp2 - vu
                 end if
              end do
              lpivot = d( n ) + sl
              rpivot = d( n ) + su
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
           endif
           eigcnt = rcnt - lcnt
           return
     end subroutine stdlib_${ri}$larrc


     pure subroutine stdlib_${ri}$larrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
     !! DLARRD: computes the eigenvalues of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from DSTEMR.
     !! The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n, nsplit
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: pivmin, reltol, vl, vu
           real(${rk}$), intent(out) :: wl, wu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(ilp), intent(in) :: isplit(*)
           real(${rk}$), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(${rk}$), intent(out) :: w(*), werr(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fudge = two
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: valrng = 2
           integer(ilp), parameter :: indrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: i, ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iout, &
                     irange, itmax, itmp1, itmp2, iw, iwoff, j, jblk, jdisc, je, jee, nb, nwl, nwu
           real(${rk}$) :: atoli, eps, gl, gu, rtoli, tmp1, tmp2, tnorm, uflow, wkill, wlu, &
                     wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,min
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           else
              irange = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( .not.(stdlib_lsame(order,'B').or.stdlib_lsame(order,'E')) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==valrng ) then
              if( vl>=vu )info = -5
           else if( irange==indrng .and.( il<1 .or. il>max( 1, n ) ) ) then
              info = -6
           else if( irange==indrng .and.( iu<min( n, il ) .or. iu>n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 ) return
           ! simplification:
           if( irange==indrng .and. il==1 .and. iu==n ) irange = 1
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           uflow = stdlib_${ri}$lamch( 'U' )
           ! special case when n=1
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
              endif
              return
           end if
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           nb = stdlib_ilaenv( 1, 'DSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 ) nb = 0
           ! find global spectral radius
           gl = d(1)
           gu = d(1)
           do i = 1,n
              gl =  min( gl, gers( 2*i - 1))
              gu = max( gu, gers(2*i) )
           end do
           ! compute global gerschgorin bounds and spectral diameter
           tnorm = max( abs( gl ), abs( gu ) )
           gl = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           gu = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           ! [jan/28/2009] remove the line below since spdiam variable not use
           ! spdiam = gu - gl
           ! input arguments for stdlib_${ri}$laebz:
           ! the relative tolerance.  an interval (a,b] lies within
           ! "relative tolerance" if  b-a < reltol*max(|a|,|b|),
           rtoli = reltol
           ! set the absolute tolerance for interval convergence to zero to force
           ! interval convergence based on relative size of the interval.
           ! this is dangerous because intervals might not converge when reltol is
           ! small. but at least a very small number should be selected so that for
           ! strongly graded matrices, the code can get relatively accurate
           ! eigenvalues.
           atoli = fudge*two*uflow + fudge*two*pivmin
           if( irange==indrng ) then
              ! range='i': compute an interval containing eigenvalues
              ! il through iu. the initial interval [gl,gu] from the global
              ! gerschgorin bounds gl and gu is refined by stdlib_${ri}$laebz.
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_${ri}$laebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin,d, e, e2, iwork( 5 )&
                        , work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iinfo /= 0 ) then
                 info = iinfo
                 return
              end if
              ! on exit, output intervals may not be ordered by ascending negcount
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              ! on exit, the interval [wl, wlu] contains a value with negcount nwl,
              ! and [wul, wu] contains a value with negcount nwu.
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           elseif( irange==valrng ) then
              wl = vl
              wu = vu
           elseif( irange==allrng ) then
              wl = gl
              wu = gu
           endif
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jblk = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jblk )
              in = iend - ioff
              if( in==1 ) then
                 ! 1x1 block
                 if( wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==allrng .or.( wl<d( ibegin )-pivmin.and. wu>= d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    iblock( m ) = jblk
                    indexw( m ) = 1
                 end if
              ! disabled 2x2 case because of a failure on the following matrix
              ! range = 'i', il = iu = 4
                ! original tridiagonal, d = [
                 ! -0.150102010615740e+00_${rk}$
                 ! -0.849897989384260e+00_${rk}$
                 ! -0.128208148052635e-15_${rk}$
                  ! 0.128257718286320e-15_${rk}$
                ! ];
                ! e = [
                 ! -0.357171383266986e+00_${rk}$
                 ! -0.180411241501588e-15_${rk}$
                 ! -0.175152352710251e-15_${rk}$
                ! ];
               ! else if( in==2 ) then
      ! *           2x2 block
                  ! disc = sqrt( (half*(d(ibegin)-d(iend)))**2 + e(ibegin)**2 )
                  ! tmp1 = half*(d(ibegin)+d(iend))
                  ! l1 = tmp1 - disc
                  ! if( wl>= l1-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l1-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l1-pivmin .and. wu>=
           ! $          l1-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l1
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 1
                  ! endif
                  ! l2 = tmp1 + disc
                  ! if( wl>= l2-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l2-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l2-pivmin .and. wu>=
           ! $          l2-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l2
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 2
                  ! endif
              else
                 ! general case - block of size in >= 2
                 ! compute local gerschgorin interval and use it as the initial
                 ! interval for stdlib_${ri}$laebz
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend
                    gl =  min( gl, gers( 2*j - 1))
                    gu = max( gu, gers(2*j) )
                 end do
                 ! [jan/28/2009]
                 ! change spdiam by tnorm in lines 2 and 3 thereafter
                 ! line 1: remove computation of spdiam (not useful anymore)
                 ! spdiam = gu - gl
                 ! gl = gl - fudge*spdiam*eps*in - fudge*pivmin
                 ! gu = gu + fudge*spdiam*eps*in + fudge*pivmin
                 gl = gl - fudge*tnorm*eps*in - fudge*pivmin
                 gu = gu + fudge*tnorm*eps*in + fudge*pivmin
                 if( irange>1 ) then
                    if( gu<wl ) then
                       ! the local block contains none of the wanted eigenvalues
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    ! refine search interval if possible, only range (wl,wu] matters
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! find negcount of initial interval boundaries gl and gu
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_${ri}$laebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 ),&
                            iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_${ri}$laebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( m+&
                            1 ), iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 ! copy eigenvalues into w and iblock
                 ! use -jblk for block number for unconverged eigenvalues.
                 ! loop over the number of output intervals from stdlib_${ri}$laebz
                 do j = 1, iout
                    ! eigenvalue approximation is middle point of interval
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! semi length of error interval
                    tmp2 = half*abs( work( j+n )-work( j+in+n ) )
                    if( j>iout-iinfo ) then
                       ! flag non-convergence.
                       ncnvrg = .true.
                       ib = -jblk
                    else
                       ib = jblk
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       werr( je ) = tmp2
                       indexw( je ) = je - iwoff
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==indrng ) then
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 ) then
                 im = 0
                 do je = 1, m
                    ! remove some of the smallest eigenvalues from the left so that
                    ! at the end idiscl =0. move all eigenvalues up to the left.
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscu>0 ) then
                 ! remove some of the largest eigenvalues from the right so that
                 ! at the end idiscu =0. move all eigenvalues up to the left.
                 im=m+1
                 do je = m, 1, -1
                    if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im - 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 jee = 0
                 do je = im, m
                    jee = jee + 1
                    w( jee ) = w( je )
                    werr( jee ) = werr( je )
                    indexw( jee ) = indexw( je )
                    iblock( jee ) = iblock( je )
                 end do
                 m = m-im+1
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic. (if n(w) is
                 ! monotone non-decreasing, this should never happen.)
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by marking the corresponding iblock = 0
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>=wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 ! now erase all eigenvalues with iblock set to zero
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           if(( irange==allrng .and. m/=n ).or.( irange==indrng .and. m/=iu-il+1 ) ) then
              toofew = .true.
           end if
           ! if order='b', do nothing the eigenvalues are already sorted by
              ! block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( stdlib_lsame(order,'E') .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    tmp2 = werr( ie )
                    itmp1 = iblock( ie )
                    itmp2 = indexw( ie )
                    w( ie ) = w( je )
                    werr( ie ) = werr( je )
                    iblock( ie ) = iblock( je )
                    indexw( ie ) = indexw( je )
                    w( je ) = tmp1
                    werr( je ) = tmp2
                    iblock( je ) = itmp1
                    indexw( je ) = itmp2
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_${ri}$larrd


     pure subroutine stdlib_${ri}$larre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
     !! To find the desired eigenvalues of a given real symmetric
     !! tridiagonal matrix T, DLARRE: sets any "small" off-diagonal
     !! elements to zero, and for each unreduced block T_i, it finds
     !! (a) a suitable shift at one end of the block's spectrum,
     !! (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
     !! (c) eigenvalues of each L_i D_i L_i^T.
     !! The representations and eigenvalues found are then used by
     !! DSTEMR to compute the eigenvectors of T.
     !! The accuracy varies depending on whether bisection is used to
     !! find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
     !! conpute all and then discard any unwanted one.
     !! As an added benefit, DLARRE also outputs the n
     !! Gerschgorin intervals for the matrices L_i D_i L_i^T.
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(${rk}$), intent(out) :: pivmin
           real(${rk}$), intent(in) :: rtol1, rtol2, spltol
           real(${rk}$), intent(inout) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(${rk}$), intent(inout) :: d(*), e(*), e2(*)
           real(${rk}$), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: hndrd = 100.0_${rk}$
           real(${rk}$), parameter :: pert = 8.0_${rk}$
           real(${rk}$), parameter :: fourth = one/four
           real(${rk}$), parameter :: fac = half
           real(${rk}$), parameter :: maxgrowth = 64.0_${rk}$
           real(${rk}$), parameter :: fudge = 2.0_${rk}$
           integer(ilp), parameter :: maxtry = 6
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: indrng = 2
           integer(ilp), parameter :: valrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: forceb, norep, usedqd
           integer(ilp) :: cnt, cnt1, cnt2, i, ibegin, idum, iend, iinfo, in, indl, indu, irange, &
                     j, jblk, mb, mm, wbegin, wend
           real(${rk}$) :: avgap, bsrtol, clwdth, dmax, dpivot, eabs, emax, eold, eps, gl, gu, isleft,&
                      isrght, rtl, rtol, s1, s2, safmin, sgndef, sigma, spdiam, tau, tmp, tmp1
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           end if
           m = 0
           ! get machine constants
           safmin = stdlib_${ri}$lamch( 'S' )
           eps = stdlib_${ri}$lamch( 'P' )
           ! set parameters
           rtl = sqrt(eps)
           bsrtol = sqrt(eps)
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 wgap(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
                 gers(1) = d( 1 )
                 gers(2) = d( 1 )
              endif
              ! store the shift for the initial rrr, which is zero in this case
              e(1) = zero
              return
           end if
           ! general case: tridiagonal matrix of order > 1
           ! init werr, wgap. compute gerschgorin intervals and spectral diameter.
           ! compute maximum off-diagonal entry and pivmin.
           gl = d(1)
           gu = d(1)
           eold = zero
           emax = zero
           e(n) = zero
           do i = 1,n
              werr(i) = zero
              wgap(i) = zero
              eabs = abs( e(i) )
              if( eabs >= emax ) then
                 emax = eabs
              end if
              tmp1 = eabs + eold
              gers( 2*i-1) = d(i) - tmp1
              gl =  min( gl, gers( 2*i - 1))
              gers( 2*i ) = d(i) + tmp1
              gu = max( gu, gers(2*i) )
              eold  = eabs
           end do
           ! the minimum pivot allowed in the sturm sequence for t
           pivmin = safmin * max( one, emax**2 )
           ! compute spectral diameter. the gerschgorin bounds give an
           ! estimate that is wrong by at most a factor of sqrt(2)
           spdiam = gu - gl
           ! compute splitting points
           call stdlib_${ri}$larra( n, d, e, e2, spltol, spdiam,nsplit, isplit, iinfo )
           ! can force use of bisection instead of faster dqds.
           ! option left in the code for future multisection work.
           forceb = .false.
           ! initialize usedqd, dqds should be used for allrng unless someone
           ! explicitly wants bisection.
           usedqd = (( irange==allrng ) .and. (.not.forceb))
           if( (irange==allrng) .and. (.not. forceb) ) then
              ! set interval [vl,vu] that contains all eigenvalues
              vl = gl
              vu = gu
           else
              ! we call stdlib_${ri}$larrd to find crude approximations to the eigenvalues
              ! in the desired range. in case irange = indrng, we also obtain the
              ! interval (vl,vu] that contains all the wanted eigenvalues.
              ! an interval [left,right] has converged if
              ! right-left<rtol*max(abs(left),abs(right))
              ! stdlib_${ri}$larrd needs a work of size 4*n, iwork of size 3*n
              call stdlib_${ri}$larrd( range, 'B', n, vl, vu, il, iu, gers,bsrtol, d, e, e2, pivmin, &
                        nsplit, isplit,mm, w, werr, vl, vu, iblock, indexw,work, iwork, iinfo )
              if( iinfo/=0 ) then
                 info = -1
                 return
              endif
              ! make sure that the entries m+1 to n in w, werr, iblock, indexw are 0
              do i = mm+1,n
                 w( i ) = zero
                 werr( i ) = zero
                 iblock( i ) = 0
                 indexw( i ) = 0
              end do
           end if
      ! **
           ! loop over unreduced blocks
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, nsplit
              iend = isplit( jblk )
              in = iend - ibegin + 1
              ! 1 x 1 block
              if( in==1 ) then
                 if( (irange==allrng).or.( (irange==valrng).and.( d( ibegin )>vl ).and.( d( &
                           ibegin )<=vu ) ).or. ( (irange==indrng).and.(iblock(wbegin)==jblk))) then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    wgap(m) = zero
                    iblock( m ) = jblk
                    indexw( m ) = 1
                    wbegin = wbegin + 1
                 endif
                 ! e( iend ) holds the shift for the initial rrr
                 e( iend ) = zero
                 ibegin = iend + 1
                 cycle loop_170
              end if
              ! blocks of size larger than 1x1
              ! e( iend ) will hold the shift for the initial rrr, for now set it =0
              e( iend ) = zero
              ! find local outer bounds gl,gu for the block
              gl = d(ibegin)
              gu = d(ibegin)
              do i = ibegin , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              if(.not. ((irange==allrng).and.(.not.forceb)) ) then
                 ! count the number of eigenvalues in the current block.
                 mb = 0
                 do i = wbegin,mm
                    if( iblock(i)==jblk ) then
                       mb = mb+1
                    else
                       goto 21
                    endif
                 end do
                 21 continue
                 if( mb==0) then
                    ! no eigenvalue in the current block lies in the desired range
                    ! e( iend ) holds the shift for the initial rrr
                    e( iend ) = zero
                    ibegin = iend + 1
                    cycle loop_170
                 else
                    ! decide whether dqds or bisection is more efficient
                    usedqd = ( (mb > fac*in) .and. (.not.forceb) )
                    wend = wbegin + mb - 1
                    ! calculate gaps for the current block
                    ! in later stages, when representations for individual
                    ! eigenvalues are different, we use sigma = e( iend ).
                    sigma = zero
                    do i = wbegin, wend - 1
                       wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                    end do
                    wgap( wend ) = max( zero,vu - sigma - (w( wend )+werr( wend )))
                    ! find local index of the first and last desired evalue.
                    indl = indexw(wbegin)
                    indu = indexw( wend )
                 endif
              endif
              if(( (irange==allrng) .and. (.not. forceb) ).or.usedqd) then
                 ! case of dqds
                 ! find approximations to the extremal eigenvalues of the block
                 call stdlib_${ri}$larrk( in, 1, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1, &
                           iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isleft = max(gl, tmp - tmp1- hndrd * eps* abs(tmp - tmp1))
                 call stdlib_${ri}$larrk( in, in, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1,&
                            iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isrght = min(gu, tmp + tmp1+ hndrd * eps * abs(tmp + tmp1))
                 ! improve the estimate of the spectral diameter
                 spdiam = isrght - isleft
              else
                 ! case of bisection
                 ! find approximations to the wanted extremal eigenvalues
                 isleft = max(gl, w(wbegin) - werr(wbegin)- hndrd * eps*abs(w(wbegin)- werr(&
                           wbegin) ))
                 isrght = min(gu,w(wend) + werr(wend)+ hndrd * eps * abs(w(wend)+ werr(wend)))
                           
              endif
              ! decide whether the base representation for the current block
              ! l_jblk d_jblk l_jblk^t = t_jblk - sigma_jblk i
              ! should be on the left or the right end of the current block.
              ! the strategy is to shift to the end which is "more populated"
              ! furthermore, decide whether to use dqds for the computation of
              ! dqds is chosen if all eigenvalues are desired or the number of
              ! eigenvalues to be computed is large compared to the blocksize.
              if( ( irange==allrng ) .and. (.not.forceb) ) then
                 ! if all the eigenvalues have to be computed, we use dqd
                 usedqd = .true.
                 ! indl is the local index of the first eigenvalue to compute
                 indl = 1
                 indu = in
                 ! mb =  number of eigenvalues to compute
                 mb = in
                 wend = wbegin + mb - 1
                 ! define 1/4 and 3/4 points of the spectrum
                 s1 = isleft + fourth * spdiam
                 s2 = isrght - fourth * spdiam
              else
                 ! stdlib_${ri}$larrd has computed iblock and indexw for each eigenvalue
                 ! approximation.
                 ! choose sigma
                 if( usedqd ) then
                    s1 = isleft + fourth * spdiam
                    s2 = isrght - fourth * spdiam
                 else
                    tmp = min(isrght,vu) -  max(isleft,vl)
                    s1 =  max(isleft,vl) + fourth * tmp
                    s2 =  min(isrght,vu) - fourth * tmp
                 endif
              endif
              ! compute the negcount at the 1/4 and 3/4 points
              if(mb>1) then
                 call stdlib_${ri}$larrc( 'T', in, s1, s2, d(ibegin),e(ibegin), pivmin, cnt, cnt1, &
                           cnt2, iinfo)
              endif
              if(mb==1) then
                 sigma = gl
                 sgndef = one
              elseif( cnt1 - indl >= indu - cnt2 ) then
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = max(isleft,gl)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get pos def matrix
                    ! for dqds
                    sigma = isleft
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = max(isleft,vl)
                 endif
                 sgndef = one
              else
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = min(isrght,gu)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get neg def matrix
                    ! for dqds
                    sigma = isrght
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = min(isrght,vu)
                 endif
                 sgndef = -one
              endif
              ! an initial sigma has been chosen that will be used for computing
              ! t - sigma i = l d l^t
              ! define the increment tau of the shift in case the initial shift
              ! needs to be refined to obtain a factorization with not too much
              ! element growth.
              if( usedqd ) then
                 ! the initial sigma was to the outer end of the spectrum
                 ! the matrix is definite and we need not retreat.
                 tau = spdiam*eps*n + two*pivmin
                 tau = max( tau,two*eps*abs(sigma) )
              else
                 if(mb>1) then
                    clwdth = w(wend) + werr(wend) - w(wbegin) - werr(wbegin)
                    avgap = abs(clwdth / real(wend-wbegin,KIND=${rk}$))
                    if( sgndef==one ) then
                       tau = half*max(wgap(wbegin),avgap)
                       tau = max(tau,werr(wbegin))
                    else
                       tau = half*max(wgap(wend-1),avgap)
                       tau = max(tau,werr(wend))
                    endif
                 else
                    tau = werr(wbegin)
                 endif
              endif
              loop_80: do idum = 1, maxtry
                 ! compute l d l^t factorization of tridiagonal matrix t - sigma i.
                 ! store d in work(1:in), l in work(in+1:2*in), and reciprocals of
                 ! pivots in work(2*in+1:3*in)
                 dpivot = d( ibegin ) - sigma
                 work( 1 ) = dpivot
                 dmax = abs( work(1) )
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*in+i ) = one / work( i )
                    tmp = e( j )*work( 2*in+i )
                    work( in+i ) = tmp
                    dpivot = ( d( j+1 )-sigma ) - tmp*e( j )
                    work( i+1 ) = dpivot
                    dmax = max( dmax, abs(dpivot) )
                    j = j + 1
                 end do
                 ! check for element growth
                 if( dmax > maxgrowth*spdiam ) then
                    norep = .true.
                 else
                    norep = .false.
                 endif
                 if( usedqd .and. .not.norep ) then
                    ! ensure the definiteness of the representation
                    ! all entries of d (of l d l^t) must have the same sign
                    do i = 1, in
                       tmp = sgndef*work( i )
                       if( tmp<zero ) norep = .true.
                    end do
                 endif
                 if(norep) then
                    ! note that in the case of irange=allrng, we use the gerschgorin
                    ! shift which makes the matrix definite. so we should end up
                    ! here really only in the case of irange = valrng or indrng.
                    if( idum==maxtry-1 ) then
                       if( sgndef==one ) then
                          ! the fudged gerschgorin shift should succeed
                          sigma =gl - fudge*spdiam*eps*n - fudge*two*pivmin
                       else
                          sigma =gu + fudge*spdiam*eps*n + fudge*two*pivmin
                       end if
                    else
                       sigma = sigma - sgndef * tau
                       tau = two * tau
                    end if
                 else
                    ! an initial rrr is found
                    go to 83
                 end if
              end do loop_80
              ! if the program reaches this point, no base representation could be
              ! found in maxtry iterations.
              info = 2
              return
              83 continue
              ! at this point, we have found an initial base representation
              ! t - sigma i = l d l^t with not too much element growth.
              ! store the shift.
              e( iend ) = sigma
              ! store d and l.
              call stdlib_${ri}$copy( in, work, 1, d( ibegin ), 1 )
              call stdlib_${ri}$copy( in-1, work( in+1 ), 1, e( ibegin ), 1 )
              if(mb>1 ) then
                 ! perturb each entry of the base representation by a small
                 ! (but random) relative amount to overcome difficulties with
                 ! glued matrices.
                 do i = 1, 4
                    iseed( i ) = 1
                 end do
                 call stdlib_${ri}$larnv(2, iseed, 2*in-1, work(1))
                 do i = 1,in-1
                    d(ibegin+i-1) = d(ibegin+i-1)*(one+eps*pert*work(i))
                    e(ibegin+i-1) = e(ibegin+i-1)*(one+eps*pert*work(in+i))
                 end do
                 d(iend) = d(iend)*(one+eps*four*work(in))
              endif
              ! don't update the gerschgorin intervals because keeping track
              ! of the updates would be too much work in stdlib_${ri}$larrv.
              ! we update w instead and use it to locate the proper gerschgorin
              ! intervals.
              ! compute the required eigenvalues of l d l' by bisection or dqds
              if ( .not.usedqd ) then
                 ! if stdlib_${ri}$larrd has been used, shift the eigenvalue approximations
                 ! according to their representation. this is necessary for
                 ! a uniform stdlib_${ri}$larrv since dqds computes eigenvalues of the
                 ! shifted representation. in stdlib_${ri}$larrv, w will always hold the
                 ! unshifted eigenvalue approximation.
                 do j=wbegin,wend
                    w(j) = w(j) - sigma
                    werr(j) = werr(j) + abs(w(j)) * eps
                 end do
                 ! call stdlib_${ri}$larrb to reduce eigenvalue error of the approximations
                 ! from stdlib_${ri}$larrd
                 do i = ibegin, iend-1
                    work( i ) = d( i ) * e( i )**2
                 end do
                 ! use bisection to find ev from indl to indu
                 call stdlib_${ri}$larrb(in, d(ibegin), work(ibegin),indl, indu, rtol1, rtol2, indl-1,&
                 w(wbegin), wgap(wbegin), werr(wbegin),work( 2*n+1 ), iwork, pivmin, spdiam,in, &
                           iinfo )
                 if( iinfo /= 0 ) then
                    info = -4
                    return
                 end if
                 ! stdlib_${ri}$larrb computes all gaps correctly except for the last one
                 ! record distance to vu/gu
                 wgap( wend ) = max( zero,( vu-sigma ) - ( w( wend ) + werr( wend ) ) )
                 do i = indl, indu
                    m = m + 1
                    iblock(m) = jblk
                    indexw(m) = i
                 end do
              else
                 ! call dqds to get all eigs (and then possibly delete unwanted
                 ! eigenvalues).
                 ! note that dqds finds the eigenvalues of the l d l^t representation
                 ! of t to high relative accuracy. high relative accuracy
                 ! might be lost when the shift of the rrr is subtracted to obtain
                 ! the eigenvalues of t. however, t is not guaranteed to define its
                 ! eigenvalues to high relative accuracy anyway.
                 ! set rtol to the order of the tolerance used in stdlib_${ri}$lasq2
                 ! this is an estimated error, the worst case bound is 4*n*eps
                 ! which is usually too large and requires unnecessary work to be
                 ! done by bisection when computing the eigenvectors
                 rtol = log(real(in,KIND=${rk}$)) * four * eps
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*i-1 ) = abs( d( j ) )
                    work( 2*i ) = e( j )*e( j )*work( 2*i-1 )
                    j = j + 1
                 end do
                 work( 2*in-1 ) = abs( d( iend ) )
                 work( 2*in ) = zero
                 call stdlib_${ri}$lasq2( in, work, iinfo )
                 if( iinfo /= 0 ) then
                    ! if iinfo = -5 then an index is part of a tight cluster
                    ! and should be changed. the index is in iwork(1) and the
                    ! gap is in work(n+1)
                    info = -5
                    return
                 else
                    ! test that all eigenvalues are positive as expected
                    do i = 1, in
                       if( work( i )<zero ) then
                          info = -6
                          return
                       endif
                    end do
                 end if
                 if( sgndef>zero ) then
                    do i = indl, indu
                       m = m + 1
                       w( m ) = work( in-i+1 )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 else
                    do i = indl, indu
                       m = m + 1
                       w( m ) = -work( i )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 end if
                 do i = m - mb + 1, m
                    ! the value of rtol below should be the tolerance in stdlib_${ri}$lasq2
                    werr( i ) = rtol * abs( w(i) )
                 end do
                 do i = m - mb + 1, m - 1
                    ! compute the right gap between the intervals
                    wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                 end do
                 wgap( m ) = max( zero,( vu-sigma ) - ( w( m ) + werr( m ) ) )
              end if
              ! proceed with next block
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_${ri}$larre


     pure subroutine stdlib_${ri}$larrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
     !! Given the initial representation L D L^T and its cluster of close
     !! eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
     !! W( CLEND ), DLARRF: finds a new relatively robust representation
     !! L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
     !! eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
               clgapr, pivmin, sigma,dplus, lplus, work, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: clstrt, clend, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(${rk}$), intent(out) :: sigma
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(${rk}$), intent(out) :: dplus(*), lplus(*), work(*)
           real(${rk}$), intent(inout) :: wgap(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: quart = 0.25_${rk}$
           real(${rk}$), parameter :: maxgrowth1 = 8._${rk}$
           real(${rk}$), parameter :: maxgrowth2 = 8._${rk}$
           integer(ilp), parameter :: ktrymax = 1
           integer(ilp), parameter :: sleft = 1
           integer(ilp), parameter :: sright = 2
           
           ! Local Scalars 
           logical(lk) :: dorrr1, forcer, nofail, sawnan1, sawnan2, tryrrr1
           integer(ilp) :: i, indx, ktry,    shift
           real(${rk}$) :: avgap, bestshift, clwdth, eps, fact, fail, fail2, growthbound, ldelta, &
           ldmax, lsigma, max1, max2, mingap, oldp, prod, rdelta, rdmax, rrr1, rrr2, rsigma, s, &
                     smlgrowth, tmp, znm2
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           fact = real(2**ktrymax,KIND=${rk}$)
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           shift = 0
           forcer = .false.
           ! note that we cannot guarantee that for any of the shifts tried,
           ! the factorization has a small or even moderate element growth.
           ! there could be ritz values at both ends of the cluster and despite
           ! backing off, there are examples where all factorizations tried
           ! (in ieee mode, allowing zero pivots
           ! element growth.
           ! for this reason, we should use pivmin in this subroutine so that at
           ! least the l d l^t factorization exists. it can be checked afterwards
           ! whether the element growth caused bad residuals/orthogonality.
           ! decide whether the code should accept the best among all
           ! representations despite large element growth or signal info=1
           ! setting nofail to .false. for quick fix for bug 113
           nofail = .false.
           ! compute the average gap length of the cluster
           clwdth = abs(w(clend)-w(clstrt)) + werr(clend) + werr(clstrt)
           avgap = clwdth / real(clend-clstrt,KIND=${rk}$)
           mingap = min(clgapl, clgapr)
           ! initial values for shifts to both ends of cluster
           lsigma = min(w( clstrt ),w( clend )) - werr( clstrt )
           rsigma = max(w( clstrt ),w( clend )) + werr( clend )
           ! use a small fudge to make sure that we really shift to the outside
           lsigma = lsigma - abs(lsigma)* four * eps
           rsigma = rsigma + abs(rsigma)* four * eps
           ! compute upper bounds for how much to back off the initial shifts
           ldmax = quart * mingap + two * pivmin
           rdmax = quart * mingap + two * pivmin
           ldelta = max(avgap,wgap( clstrt ))/fact
           rdelta = max(avgap,wgap( clend-1 ))/fact
           ! initialize the record of the best representation found
           s = stdlib_${ri}$lamch( 'S' )
           smlgrowth = one / s
           fail = real(n-1,KIND=${rk}$)*mingap/(spdiam*eps)
           fail2 = real(n-1,KIND=${rk}$)*mingap/(spdiam*sqrt(eps))
           bestshift = lsigma
           ! while (ktry <= ktrymax)
           ktry = 0
           growthbound = maxgrowth1*spdiam
           5 continue
           sawnan1 = .false.
           sawnan2 = .false.
           ! ensure that we do not back off too much of the initial shifts
           ldelta = min(ldmax,ldelta)
           rdelta = min(rdmax,rdelta)
           ! compute the element growth when shifting to both ends of the cluster
           ! accept the shift if there is no element growth at one of the two ends
           ! left end
           s = -lsigma
           dplus( 1 ) = d( 1 ) + s
           if(abs(dplus(1))<pivmin) then
              dplus(1) = -pivmin
              ! need to set sawnan1 because refined rrr test should not be used
              ! in this case
              sawnan1 = .true.
           endif
           max1 = abs( dplus( 1 ) )
           do i = 1, n - 1
              lplus( i ) = ld( i ) / dplus( i )
              s = s*lplus( i )*l( i ) - lsigma
              dplus( i+1 ) = d( i+1 ) + s
              if(abs(dplus(i+1))<pivmin) then
                 dplus(i+1) = -pivmin
                 ! need to set sawnan1 because refined rrr test should not be used
                 ! in this case
                 sawnan1 = .true.
              endif
              max1 = max( max1,abs(dplus(i+1)) )
           end do
           sawnan1 = sawnan1 .or.  stdlib_${ri}$isnan( max1 )
           if( forcer .or.(max1<=growthbound .and. .not.sawnan1 ) ) then
              sigma = lsigma
              shift = sleft
              goto 100
           endif
           ! right end
           s = -rsigma
           work( 1 ) = d( 1 ) + s
           if(abs(work(1))<pivmin) then
              work(1) = -pivmin
              ! need to set sawnan2 because refined rrr test should not be used
              ! in this case
              sawnan2 = .true.
           endif
           max2 = abs( work( 1 ) )
           do i = 1, n - 1
              work( n+i ) = ld( i ) / work( i )
              s = s*work( n+i )*l( i ) - rsigma
              work( i+1 ) = d( i+1 ) + s
              if(abs(work(i+1))<pivmin) then
                 work(i+1) = -pivmin
                 ! need to set sawnan2 because refined rrr test should not be used
                 ! in this case
                 sawnan2 = .true.
              endif
              max2 = max( max2,abs(work(i+1)) )
           end do
           sawnan2 = sawnan2 .or.  stdlib_${ri}$isnan( max2 )
           if( forcer .or.(max2<=growthbound .and. .not.sawnan2 ) ) then
              sigma = rsigma
              shift = sright
              goto 100
           endif
           ! if we are at this point, both shifts led to too much element growth
           ! record the better of the two shifts (provided it didn't lead to nan)
           if(sawnan1.and.sawnan2) then
              ! both max1 and max2 are nan
              goto 50
           else
              if( .not.sawnan1 ) then
                 indx = 1
                 if(max1<=smlgrowth) then
                    smlgrowth = max1
                    bestshift = lsigma
                 endif
              endif
              if( .not.sawnan2 ) then
                 if(sawnan1 .or. max2<=max1) indx = 2
                 if(max2<=smlgrowth) then
                    smlgrowth = max2
                    bestshift = rsigma
                 endif
              endif
           endif
           ! if we are here, both the left and the right shift led to
           ! element growth. if the element growth is moderate, then
           ! we may still accept the representation, if it passes a
           ! refined test for rrr. this test supposes that no nan occurred.
           ! moreover, we use the refined rrr test only for isolated clusters.
           if((clwdth<mingap/real(128,KIND=${rk}$)) .and.(min(max1,max2)<fail2).and.(.not.sawnan1)&
                     .and.(.not.sawnan2)) then
              dorrr1 = .true.
           else
              dorrr1 = .false.
           endif
           tryrrr1 = .true.
           if( tryrrr1 .and. dorrr1 ) then
           if(indx==1) then
              tmp = abs( dplus( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod =((dplus(i+1)*work(n+i+1))/(dplus(i)*work(n+i)))*oldp
                 else
                    prod = prod*abs(work(n+i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( dplus( i ) * prod ))
              end do
              rrr1 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr1<=maxgrowth2) then
                 sigma = lsigma
                 shift = sleft
                 goto 100
              endif
           else if(indx==2) then
              tmp = abs( work( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod = ((work(i+1)*lplus(i+1))/(work(i)*lplus(i)))*oldp
                 else
                    prod = prod*abs(lplus(i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( work( i ) * prod ))
              end do
              rrr2 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr2<=maxgrowth2) then
                 sigma = rsigma
                 shift = sright
                 goto 100
              endif
           end if
           endif
           50 continue
           if (ktry<ktrymax) then
              ! if we are here, both shifts failed also the rrr test.
              ! back off to the outside
              lsigma = max( lsigma - ldelta,lsigma - ldmax)
              rsigma = min( rsigma + rdelta,rsigma + rdmax )
              ldelta = two * ldelta
              rdelta = two * rdelta
              ktry = ktry + 1
              goto 5
           else
              ! none of the representations investigated satisfied our
              ! criteria. take the best one we found.
              if((smlgrowth<fail).or.nofail) then
                 lsigma = bestshift
                 rsigma = bestshift
                 forcer = .true.
                 goto 5
              else
                 info = 1
                 return
              endif
           end if
           100 continue
           if (shift==sleft) then
           elseif (shift==sright) then
              ! store new l and d back into dplus, lplus
              call stdlib_${ri}$copy( n, work, 1, dplus, 1 )
              call stdlib_${ri}$copy( n-1, work(n+1), 1, lplus, 1 )
           endif
           return
     end subroutine stdlib_${ri}$larrf


     pure subroutine stdlib_${ri}$larrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
     !! Given the initial eigenvalue approximations of T, DLARRJ:
     !! does  bisection to refine the eigenvalues of T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses in WERR. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               pivmin, spdiam, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: pivmin, rtol, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), e2(*)
           real(${rk}$), intent(inout) :: w(*), werr(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: cnt, i, i1, i2, ii, iter, j, k, next, nint, olnint, p, prev, &
                     savi1
           real(${rk}$) :: dplus, fac, left, mid, right, s, tmp, width
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           i2 = ilast
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           loop_75: do i = i1, i2
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              mid = w(ii)
              right = w( ii ) + werr( ii )
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              ! the following test prevents the test of converged intervals
              if( width<rtol*tmp ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<i2)) i1 = i + 1
                 if((prev>=i1).and.(i<=i2)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 ! make sure that [left,right] contains the desired eigenvalue
                 ! do while( cnt(left)>i-1 )
                 fac = one
                 20 continue
                 cnt = 0
                 s = left
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt>i-1 ) then
                    left = left - werr( ii )*fac
                    fac = two*fac
                    go to 20
                 end if
                 ! do while( cnt(right)<i )
                 fac = one
                 50 continue
                 cnt = 0
                 s = right
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt<i ) then
                    right = right + werr( ii )*fac
                    fac = two*fac
                    go to 50
                 end if
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = cnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           savi1 = i1
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do p = 1, olnint
              k = 2*i
              ii = i - offset
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              if( ( width<rtol*tmp ) .or.(iter==maxitr) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              cnt = 0
              s = mid
              dplus = d( 1 ) - s
              if( dplus<zero ) cnt = cnt + 1
              do j = 2, n
                 dplus = d( j ) - s - e2( j-1 )/dplus
                 if( dplus<zero ) cnt = cnt + 1
              end do
              if( cnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = savi1, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           return
     end subroutine stdlib_${ri}$larrj


     pure subroutine stdlib_${ri}$larrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
     !! DLARRK: computes one eigenvalue of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from DSTEMR.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: iw, n
           real(${rk}$), intent(in) :: pivmin, reltol, gl, gu
           real(${rk}$), intent(out) :: w, werr
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), e2(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fudge = two
           
           ! Local Scalars 
           integer(ilp) :: i, it, itmax, negcnt
           real(${rk}$) :: atoli, eps, left, mid, right, rtoli, tmp1, tmp2, tnorm
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           tnorm = max( abs( gl ), abs( gu ) )
           rtoli = reltol
           atoli = fudge*two*pivmin
           itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           info = -1
           left = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           right = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           it = 0
           10 continue
           ! check if interval converged or maximum number of iterations reached
           tmp1 = abs( right - left )
           tmp2 = max( abs(right), abs(left) )
           if( tmp1<max( atoli, pivmin, rtoli*tmp2 ) ) then
              info = 0
              goto 30
           endif
           if(it>itmax)goto 30
           ! count number of negative pivots for mid-point
           it = it + 1
           mid = half * (left + right)
           negcnt = 0
           tmp1 = d( 1 ) - mid
           if( abs( tmp1 )<pivmin )tmp1 = -pivmin
           if( tmp1<=zero )negcnt = negcnt + 1
           do i = 2, n
              tmp1 = d( i ) - e2( i-1 ) / tmp1 - mid
              if( abs( tmp1 )<pivmin )tmp1 = -pivmin
              if( tmp1<=zero )negcnt = negcnt + 1
           end do
           if(negcnt>=iw) then
              right = mid
           else
              left = mid
           endif
           goto 10
           30 continue
           ! converged or maximum number of iterations reached
           w = half * (left + right)
           werr = half * abs( right - left )
           return
     end subroutine stdlib_${ri}$larrk


     pure subroutine stdlib_${ri}$larrr( n, d, e, info )
     !! Perform tests to decide whether the symmetric tridiagonal matrix T
     !! warrants expensive computations which guarantee high relative accuracy
     !! in the eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(inout) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: relcond = 0.999_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: yesrel
           real(${rk}$) :: eps, safmin, smlnum, rmin, tmp, tmp2, offdig, offdig2
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! as a default, do not go for relative-accuracy preserving computations.
           info = 1
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           rmin = sqrt( smlnum )
           ! tests for relative accuracy
           ! test for scaled diagonal dominance
           ! scale the diagonal entries to one and check whether the sum of the
           ! off-diagonals is less than one
           ! the sdd relative error bounds have a 1/(1- 2*x) factor in them,
           ! x = max(offdig + offdig2), so when x is close to 1/2, no relative
           ! accuracy is promised.  in the notation of the code fragment below,
           ! 1/(1 - (offdig + offdig2)) is the condition number.
           ! we don't think it is worth going into "sdd mode" unless the relative
           ! condition number is reasonable, not 1/macheps.
           ! the threshold should be compatible with other thresholds used in the
           ! code. we set  offdig + offdig2 <= .999_${rk}$ =: relcond, it corresponds
           ! to losing at most 3 decimal digits: 1 / (1 - (offdig + offdig2)) <= 1000
           ! instead of the current offdig + offdig2 < 1
           yesrel = .true.
           offdig = zero
           tmp = sqrt(abs(d(1)))
           if (tmp<rmin) yesrel = .false.
           if(.not.yesrel) goto 11
           do i = 2, n
              tmp2 = sqrt(abs(d(i)))
              if (tmp2<rmin) yesrel = .false.
              if(.not.yesrel) goto 11
              offdig2 = abs(e(i-1))/(tmp*tmp2)
              if(offdig+offdig2>=relcond) yesrel = .false.
              if(.not.yesrel) goto 11
              tmp = tmp2
              offdig = offdig2
           end do
           11 continue
           if( yesrel ) then
              info = 0
              return
           else
           endif
           ! *** more to be implemented ***
           ! test if the lower bidiagonal matrix l from t = l d l^t
           ! (zero shift facto) is well conditioned
           ! test if the upper bidiagonal matrix u from t = u d u^t
           ! (zero shift facto) is well conditioned.
           ! in this case, the matrix needs to be flipped and, at the end
           ! of the eigenvector computation, the flip needs to be applied
           ! to the computed eigenvectors (and the support)
           return
     end subroutine stdlib_${ri}$larrr


     pure subroutine stdlib_${ri}$larrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! DLARRV: computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by DLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: minrgp, pivmin, vl, vu
           real(${rk}$), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(${rk}$), intent(in) :: gers(*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           real(${rk}$) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indwrk= 3*n+1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_${ri}$laset( 'FULL', n, zusedw, zero, zero,z(1,zusedl), ldz )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = one
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_${ri}$copy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       call stdlib_${ri}$copy( in, z( ibegin, j ), 1, d( ibegin ), 1 )
                       call stdlib_${ri}$copy( in-1, z( ibegin, j+1 ), 1, l( ibegin ),1 )
                       sigma = z( iend, j+1 )
                       ! set the corresponding entries in z to zero
                       call stdlib_${ri}$laset( 'FULL', in, 2, zero, zero,z( ibegin, j), ldz )
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_${ri}$larrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_${ri}$larrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_${ri}$larrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_${ri}$larrf needs lwork = 2*n
                          call stdlib_${ri}$larrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,z(ibegin, newftt),z(ibegin, newftt+1),work( indwrk ), &
                                    iinfo )
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_${ri}$larrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = ssigma
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=${rk}$)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_${ri}$larrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_${ri}$lar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_${ri}$lar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_${ri}$scal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_${ri}$larrv


     pure subroutine stdlib_${ri}$lartg( f, g, c, s, r )
     !! DLARTG: generates a plane rotation so that
     !! [  C  S  ]  .  [ F ]  =  [ R ]
     !! [ -S  C  ]     [ G ]     [ 0 ]
     !! where C**2 + S**2 = 1.
     !! The mathematical formulas used for C and S are
     !! R = sign(F) * sqrt(F**2 + G**2)
     !! C = F / R
     !! S = G / R
     !! Hence C >= 0. The algorithm used to compute these quantities
     !! incorporates scaling to avoid overflow or underflow in computing the
     !! square root of the sum of squares.
     !! This version is discontinuous in R at F = 0 but it returns the same
     !! C and S as ZLARTG for complex inputs (F,0) and (G,0).
     !! This is a more accurate version of the BLAS1 routine DROTG,
     !! with the following other differences:
     !! F and G are unchanged on return.
     !! If G=0, then C=1 and S=0.
     !! If F=0 and (G .ne. 0), then C=0 and S=sign(1,G) without doing any
     !! floating point operations (saves work in DBDSQR when
     !! there are zeros on the diagonal).
     !! If F exceeds G in magnitude, C will be positive.
     !! Below, wp=>dp stands for quad precision from LA_CONSTANTS module.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! february 2021
        ! Scalar Arguments 
        real(${rk}$), intent(out) :: c, r, s
        real(${rk}$), intent(in) :: f, g
        ! Local Scalars 
        real(${rk}$) :: d, f1, fs, g1, gs, p, u, uu
        ! Intrinsic Functions 
        intrinsic :: abs,sign,sqrt
        ! Executable Statements 
        f1 = abs( f )
        g1 = abs( g )
        if( g == zero ) then
           c = one
           s = zero
           r = f
        else if( f == zero ) then
           c = zero
           s = sign( one, g )
           r = g1
     else if( f1 > rtmin .and. f1 < rtmax .and.            g1 > rtmin .and. g1 < rtmax ) &
               then
           d = sqrt( f*f + g*g )
           p = one / d
           c = f1*p
           s = g*sign( p, f )
           r = sign( d, f )
        else
           u = min( safmax, max( safmin, f1, g1 ) )
           uu = one / u
           fs = f*uu
           gs = g*uu
           d = sqrt( fs*fs + gs*gs )
           p = one / d
           c = abs( fs )*p
           s = gs*sign( p, f )
           r = sign( d, f )*u
        end if
        return
     end subroutine stdlib_${ri}$lartg


     pure subroutine stdlib_${ri}$lartgp( f, g, cs, sn, r )
     !! DLARTGP: generates a plane rotation so that
     !! [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
     !! [ -SN  CS  ]     [ G ]     [ 0 ]
     !! This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
     !! with the following other differences:
     !! F and G are unchanged on return.
     !! If G=0, then CS=(+/-)1 and SN=0.
     !! If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.
     !! The sign is chosen so that R >= 0.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(out) :: cs, r, sn
           real(${rk}$), intent(in) :: f, g
        ! =====================================================================
           
           
           
           ! Local Scalars 
           ! logical            first
           integer(ilp) :: count, i
           real(${rk}$) :: eps, f1, g1, safmin, safmn2, safmx2, scale
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,sign,sqrt
           ! Save Statement 
           ! save               first, safmx2, safmin, safmn2
           ! Data Statements 
           ! data               first / .true. /
           ! Executable Statements 
           ! if( first ) then
              safmin = stdlib_${ri}$lamch( 'S' )
              eps = stdlib_${ri}$lamch( 'E' )
              safmn2 = stdlib_${ri}$lamch( 'B' )**int( log( safmin / eps ) /log( stdlib_${ri}$lamch( 'B' ) )&
                         / two,KIND=ilp)
              safmx2 = one / safmn2
              ! first = .false.
           ! end if
           if( g==zero ) then
              cs = sign( one, f )
              sn = zero
              r = abs( f )
           else if( f==zero ) then
              cs = zero
              sn = sign( one, g )
              r = abs( g )
           else
              f1 = f
              g1 = g
              scale = max( abs( f1 ), abs( g1 ) )
              if( scale>=safmx2 ) then
                 count = 0
                 10 continue
                 count = count + 1
                 f1 = f1*safmn2
                 g1 = g1*safmn2
                 scale = max( abs( f1 ), abs( g1 ) )
                 if( scale>=safmx2 .and. count < 20 )go to 10
                 r = sqrt( f1**2+g1**2 )
                 cs = f1 / r
                 sn = g1 / r
                 do i = 1, count
                    r = r*safmx2
                 end do
              else if( scale<=safmn2 ) then
                 count = 0
                 30 continue
                 count = count + 1
                 f1 = f1*safmx2
                 g1 = g1*safmx2
                 scale = max( abs( f1 ), abs( g1 ) )
                 if( scale<=safmn2 )go to 30
                 r = sqrt( f1**2+g1**2 )
                 cs = f1 / r
                 sn = g1 / r
                 do i = 1, count
                    r = r*safmn2
                 end do
              else
                 r = sqrt( f1**2+g1**2 )
                 cs = f1 / r
                 sn = g1 / r
              end if
              if( r<zero ) then
                 cs = -cs
                 sn = -sn
                 r = -r
              end if
           end if
           return
     end subroutine stdlib_${ri}$lartgp


     pure subroutine stdlib_${ri}$lartgs( x, y, sigma, cs, sn )
     !! DLARTGS: generates a plane rotation designed to introduce a bulge in
     !! Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
     !! problem. X and Y are the top-row entries, and SIGMA is the shift.
     !! The computed CS and SN define a plane rotation satisfying
     !! [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
     !! [ -SN  CS  ]     [    X * Y    ]     [ 0 ]
     !! with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
     !! rotation is by PI/2.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(out) :: cs, sn
           real(${rk}$), intent(in) :: sigma, x, y
        ! ===================================================================
           
           ! Local Scalars 
           real(${rk}$) :: r, s, thresh, w, z
           thresh = stdlib_${ri}$lamch('E')
           ! compute the first column of b**t*b - sigma^2*i, up to a scale
           ! factor.
           if( (sigma == zero .and. abs(x) < thresh) .or.(abs(x) == sigma .and. y == zero) ) &
                     then
              z = zero
              w = zero
           else if( sigma == zero ) then
              if( x >= zero ) then
                 z = x
                 w = y
              else
                 z = -x
                 w = -y
              end if
           else if( abs(x) < thresh ) then
              z = -sigma*sigma
              w = zero
           else
              if( x >= zero ) then
                 s = one
              else
                 s = negone
              end if
              z = s * (abs(x)-sigma) * (s+sigma/x)
              w = s * y
           end if
           ! generate the rotation.
           ! call stdlib_${ri}$lartgp( z, w, cs, sn, r ) might seem more natural;
           ! reordering the arguments ensures that if z = 0 then the rotation
           ! is by pi/2.
           call stdlib_${ri}$lartgp( w, z, sn, cs, r )
           return
           ! end stdlib_${ri}$lartgs
     end subroutine stdlib_${ri}$lartgs


     pure subroutine stdlib_${ri}$lartv( n, x, incx, y, incy, c, s, incc )
     !! DLARTV: applies a vector of real plane rotations to elements of the
     !! real vectors x and y. For i = 1,2,...,n
     !! ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
     !! ( y(i) )    ( -s(i)  c(i) ) ( y(i) )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incc, incx, incy, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: c(*), s(*)
           real(${rk}$), intent(inout) :: x(*), y(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ic, ix, iy
           real(${rk}$) :: xi, yi
           ! Executable Statements 
           ix = 1
           iy = 1
           ic = 1
           do i = 1, n
              xi = x( ix )
              yi = y( iy )
              x( ix ) = c( ic )*xi + s( ic )*yi
              y( iy ) = c( ic )*yi - s( ic )*xi
              ix = ix + incx
              iy = iy + incy
              ic = ic + incc
           end do
           return
     end subroutine stdlib_${ri}$lartv


     pure subroutine stdlib_${ri}$laruv( iseed, n, x )
     !! DLARUV: returns a vector of n random real numbers from a uniform (0,1)
     !! distribution (n <= 128).
     !! This is an auxiliary routine called by DLARNV and ZLARNV.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(inout) :: iseed(4)
           real(${rk}$), intent(out) :: x(n)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: lv = 128
           integer(ilp), parameter :: ipw2 = 4096
           real(${rk}$), parameter :: r = one/ipw2
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, i1, i2, i3, i4, it1, it2, it3, it4, j
           ! Local Arrays 
           integer(ilp) :: mm(lv,4)
           ! Intrinsic Functions 
           intrinsic :: real,min,mod
           ! Data Statements 
           mm(1,1:4)=[494,322,2508,2549]
           mm(2,1:4)=[2637,789,3754,1145]
           mm(3,1:4)=[255,1440,1766,2253]
           mm(4,1:4)=[2008,752,3572,305]
           mm(5,1:4)=[1253,2859,2893,3301]
           mm(6,1:4)=[3344,123,307,1065]
           mm(7,1:4)=[4084,1848,1297,3133]
           mm(8,1:4)=[1739,643,3966,2913]
           mm(9,1:4)=[3143,2405,758,3285]
           mm(10,1:4)=[3468,2638,2598,1241]
           mm(11,1:4)=[688,2344,3406,1197]
           mm(12,1:4)=[1657,46,2922,3729]
           mm(13,1:4)=[1238,3814,1038,2501]
           mm(14,1:4)=[3166,913,2934,1673]
           mm(15,1:4)=[1292,3649,2091,541]
           mm(16,1:4)=[3422,339,2451,2753]
           mm(17,1:4)=[1270,3808,1580,949]
           mm(18,1:4)=[2016,822,1958,2361]
           mm(19,1:4)=[154,2832,2055,1165]
           mm(20,1:4)=[2862,3078,1507,4081]
           mm(21,1:4)=[697,3633,1078,2725]
           mm(22,1:4)=[1706,2970,3273,3305]
           mm(23,1:4)=[491,637,17,3069]
           mm(24,1:4)=[931,2249,854,3617]
           mm(25,1:4)=[1444,2081,2916,3733]
           mm(26,1:4)=[444,4019,3971,409]
           mm(27,1:4)=[3577,1478,2889,2157]
           mm(28,1:4)=[3944,242,3831,1361]
           mm(29,1:4)=[2184,481,2621,3973]
           mm(30,1:4)=[1661,2075,1541,1865]
           mm(31,1:4)=[3482,4058,893,2525]
           mm(32,1:4)=[657,622,736,1409]
           mm(33,1:4)=[3023,3376,3992,3445]
           mm(34,1:4)=[3618,812,787,3577]
           mm(35,1:4)=[1267,234,2125,77]
           mm(36,1:4)=[1828,641,2364,3761]
           mm(37,1:4)=[164,4005,2460,2149]
           mm(38,1:4)=[3798,1122,257,1449]
           mm(39,1:4)=[3087,3135,1574,3005]
           mm(40,1:4)=[2400,2640,3912,225]
           mm(41,1:4)=[2870,2302,1216,85]
           mm(42,1:4)=[3876,40,3248,3673]
           mm(43,1:4)=[1905,1832,3401,3117]
           mm(44,1:4)=[1593,2247,2124,3089]
           mm(45,1:4)=[1797,2034,2762,1349]
           mm(46,1:4)=[1234,2637,149,2057]
           mm(47,1:4)=[3460,1287,2245,413]
           mm(48,1:4)=[328,1691,166,65]
           mm(49,1:4)=[2861,496,466,1845]
           mm(50,1:4)=[1950,1597,4018,697]
           mm(51,1:4)=[617,2394,1399,3085]
           mm(52,1:4)=[2070,2584,190,3441]
           mm(53,1:4)=[3331,1843,2879,1573]
           mm(54,1:4)=[769,336,153,3689]
           mm(55,1:4)=[1558,1472,2320,2941]
           mm(56,1:4)=[2412,2407,18,929]
           mm(57,1:4)=[2800,433,712,533]
           mm(58,1:4)=[189,2096,2159,2841]
           mm(59,1:4)=[287,1761,2318,4077]
           mm(60,1:4)=[2045,2810,2091,721]
           mm(61,1:4)=[1227,566,3443,2821]
           mm(62,1:4)=[2838,442,1510,2249]
           mm(63,1:4)=[209,41,449,2397]
           mm(64,1:4)=[2770,1238,1956,2817]
           mm(65,1:4)=[3654,1086,2201,245]
           mm(66,1:4)=[3993,603,3137,1913]
           mm(67,1:4)=[192,840,3399,1997]
           mm(68,1:4)=[2253,3168,1321,3121]
           mm(69,1:4)=[3491,1499,2271,997]
           mm(70,1:4)=[2889,1084,3667,1833]
           mm(71,1:4)=[2857,3438,2703,2877]
           mm(72,1:4)=[2094,2408,629,1633]
           mm(73,1:4)=[1818,1589,2365,981]
           mm(74,1:4)=[688,2391,2431,2009]
           mm(75,1:4)=[1407,288,1113,941]
           mm(76,1:4)=[634,26,3922,2449]
           mm(77,1:4)=[3231,512,2554,197]
           mm(78,1:4)=[815,1456,184,2441]
           mm(79,1:4)=[3524,171,2099,285]
           mm(80,1:4)=[1914,1677,3228,1473]
           mm(81,1:4)=[516,2657,4012,2741]
           mm(82,1:4)=[164,2270,1921,3129]
           mm(83,1:4)=[303,2587,3452,909]
           mm(84,1:4)=[2144,2961,3901,2801]
           mm(85,1:4)=[3480,1970,572,421]
           mm(86,1:4)=[119,1817,3309,4073]
           mm(87,1:4)=[3357,676,3171,2813]
           mm(88,1:4)=[837,1410,817,2337]
           mm(89,1:4)=[2826,3723,3039,1429]
           mm(90,1:4)=[2332,2803,1696,1177]
           mm(91,1:4)=[2089,3185,1256,1901]
           mm(92,1:4)=[3780,184,3715,81]
           mm(93,1:4)=[1700,663,2077,1669]
           mm(94,1:4)=[3712,499,3019,2633]
           mm(95,1:4)=[150,3784,1497,2269]
           mm(96,1:4)=[2000,1631,1101,129]
           mm(97,1:4)=[3375,1925,717,1141]
           mm(98,1:4)=[1621,3912,51,249]
           mm(99,1:4)=[3090,1398,981,3917]
           mm(100,1:4)=[3765,1349,1978,2481]
           mm(101,1:4)=[1149,1441,1813,3941]
           mm(102,1:4)=[3146,2224,3881,2217]
           mm(103,1:4)=[33,2411,76,2749]
           mm(104,1:4)=[3082,1907,3846,3041]
           mm(105,1:4)=[2741,3192,3694,1877]
           mm(106,1:4)=[359,2786,1682,345]
           mm(107,1:4)=[3316,382,124,2861]
           mm(108,1:4)=[1749,37,1660,1809]
           mm(109,1:4)=[185,759,3997,3141]
           mm(110,1:4)=[2784,2948,479,2825]
           mm(111,1:4)=[2202,1862,1141,157]
           mm(112,1:4)=[2199,3802,886,2881]
           mm(113,1:4)=[1364,2423,3514,3637]
           mm(114,1:4)=[1244,2051,1301,1465]
           mm(115,1:4)=[2020,2295,3604,2829]
           mm(116,1:4)=[3160,1332,1888,2161]
           mm(117,1:4)=[2785,1832,1836,3365]
           mm(118,1:4)=[2772,2405,1990,361]
           mm(119,1:4)=[1217,3638,2058,2685]
           mm(120,1:4)=[1822,3661,692,3745]
           mm(121,1:4)=[1245,327,1194,2325]
           mm(122,1:4)=[2252,3660,20,3609]
           mm(123,1:4)=[3904,716,3285,3821]
           mm(124,1:4)=[2774,1842,2046,3537]
           mm(125,1:4)=[997,3987,2107,517]
           mm(126,1:4)=[2573,1368,3508,3017]
           mm(127,1:4)=[1148,1848,3525,2141]
           mm(128,1:4)=[545,2366,3801,1537]
           ! Executable Statements 
           i1 = iseed( 1 )
           i2 = iseed( 2 )
           i3 = iseed( 3 )
           i4 = iseed( 4 )
           loop_10: do i = 1, min( n, lv )
           20 continue
              ! multiply the seed by i-th power of the multiplier modulo 2**48
              it4 = i4*mm( i, 4 )
              it3 = it4 / ipw2
              it4 = it4 - ipw2*it3
              it3 = it3 + i3*mm( i, 4 ) + i4*mm( i, 3 )
              it2 = it3 / ipw2
              it3 = it3 - ipw2*it2
              it2 = it2 + i2*mm( i, 4 ) + i3*mm( i, 3 ) + i4*mm( i, 2 )
              it1 = it2 / ipw2
              it2 = it2 - ipw2*it1
              it1 = it1 + i1*mm( i, 4 ) + i2*mm( i, 3 ) + i3*mm( i, 2 ) +i4*mm( i, 1 )
              it1 = mod( it1, ipw2 )
              ! convert 48-bit integer to a realnumber in the interval (0,1,KIND=${rk}$)
              x( i ) = r*( real( it1,KIND=${rk}$)+r*( real( it2,KIND=${rk}$)+r*( real( it3,KIND=${rk}$)+&
                        r*real( it4,KIND=${rk}$) ) ) )
              if (x( i )==1.0_${rk}$) then
                 ! if a real number has n bits of precision, and the first
                 ! n bits of the 48-bit integer above happen to be all 1 (which
                 ! will occur about once every 2**n calls), then x( i ) will
                 ! be rounded to exactly one.
                 ! since x( i ) is not supposed to return exactly 0.0_${rk}$ or 1.0_${rk}$,
                 ! the statistically correct thing to do in this situation is
                 ! simply to iterate again.
                 ! n.b. the case x( i ) = 0.0_${rk}$ should not be possible.
                 i1 = i1 + 2
                 i2 = i2 + 2
                 i3 = i3 + 2
                 i4 = i4 + 2
                 goto 20
              end if
           end do loop_10
           ! return final value of seed
           iseed( 1 ) = it1
           iseed( 2 ) = it2
           iseed( 3 ) = it3
           iseed( 4 ) = it4
           return
     end subroutine stdlib_${ri}$laruv


     pure subroutine stdlib_${ri}$larz( side, m, n, l, v, incv, tau, c, ldc, work )
     !! DLARZ: applies a real elementary reflector H to a real M-by-N
     !! matrix C, from either the left or the right. H is represented in the
     !! form
     !! H = I - tau * v * v**T
     !! where tau is a real scalar and v is a real vector.
     !! If tau = 0, then H is taken to be the unit matrix.
     !! H is a product of k elementary reflectors as returned by DTZRZF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side
           integer(ilp), intent(in) :: incv, l, ldc, m, n
           real(${rk}$), intent(in) :: tau
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(in) :: v(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Executable Statements 
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  h * c
              if( tau/=zero ) then
                 ! w( 1:n ) = c( 1, 1:n )
                 call stdlib_${ri}$copy( n, c, ldc, work, 1 )
                 ! w( 1:n ) = w( 1:n ) + c( m-l+1:m, 1:n )**t * v( 1:l )
                 call stdlib_${ri}$gemv( 'TRANSPOSE', l, n, one, c( m-l+1, 1 ), ldc, v,incv, one, work,&
                            1 )
                 ! c( 1, 1:n ) = c( 1, 1:n ) - tau * w( 1:n )
                 call stdlib_${ri}$axpy( n, -tau, work, 1, c, ldc )
                 ! c( m-l+1:m, 1:n ) = c( m-l+1:m, 1:n ) - ...
                                     ! tau * v( 1:l ) * w( 1:n )**t
                 call stdlib_${ri}$ger( l, n, -tau, v, incv, work, 1, c( m-l+1, 1 ),ldc )
              end if
           else
              ! form  c * h
              if( tau/=zero ) then
                 ! w( 1:m ) = c( 1:m, 1 )
                 call stdlib_${ri}$copy( m, c, 1, work, 1 )
                 ! w( 1:m ) = w( 1:m ) + c( 1:m, n-l+1:n, 1:n ) * v( 1:l )
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', m, l, one, c( 1, n-l+1 ), ldc,v, incv, one, &
                           work, 1 )
                 ! c( 1:m, 1 ) = c( 1:m, 1 ) - tau * w( 1:m )
                 call stdlib_${ri}$axpy( m, -tau, work, 1, c, 1 )
                 ! c( 1:m, n-l+1:n ) = c( 1:m, n-l+1:n ) - ...
                                     ! tau * w( 1:m ) * v( 1:l )**t
                 call stdlib_${ri}$ger( m, l, -tau, work, 1, v, incv, c( 1, n-l+1 ),ldc )
              end if
           end if
           return
     end subroutine stdlib_${ri}$larz


     pure subroutine stdlib_${ri}$larzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
     !! DLARZB: applies a real block reflector H or its transpose H**T to
     !! a real distributed M-by-N  C from the left or the right.
     !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
               ldc, work, ldwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, side, storev, trans
           integer(ilp), intent(in) :: k, l, ldc, ldt, ldv, ldwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*), t(ldt,*), v(ldv,*)
           real(${rk}$), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           character :: transt
           integer(ilp) :: i, info, j
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 )return
           ! check for currently supported options
           info = 0
           if( .not.stdlib_lsame( direct, 'B' ) ) then
              info = -3
           else if( .not.stdlib_lsame( storev, 'R' ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLARZB', -info )
              return
           end if
           if( stdlib_lsame( trans, 'N' ) ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  h * c  or  h**t * c
              ! w( 1:n, 1:k ) = c( 1:k, 1:n )**t
              do j = 1, k
                 call stdlib_${ri}$copy( n, c( j, 1 ), ldc, work( 1, j ), 1 )
              end do
              ! w( 1:n, 1:k ) = w( 1:n, 1:k ) + ...
                              ! c( m-l+1:m, 1:n )**t * v( 1:k, 1:l )**t
              if( l>0 )call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE', n, k, l, one,c( m-l+1, 1 ), &
                        ldc, v, ldv, one, work, ldwork )
              ! w( 1:n, 1:k ) = w( 1:n, 1:k ) * t**t  or  w( 1:m, 1:k ) * t
              call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', transt, 'NON-UNIT', n, k, one, t,ldt, work, &
                        ldwork )
              ! c( 1:k, 1:n ) = c( 1:k, 1:n ) - w( 1:n, 1:k )**t
              do j = 1, n
                 do i = 1, k
                    c( i, j ) = c( i, j ) - work( j, i )
                 end do
              end do
              ! c( m-l+1:m, 1:n ) = c( m-l+1:m, 1:n ) - ...
                                  ! v( 1:k, 1:l )**t * w( 1:n, 1:k )**t
              if( l>0 )call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE', l, n, k, -one, v, ldv,work, &
                        ldwork, one, c( m-l+1, 1 ), ldc )
           else if( stdlib_lsame( side, 'R' ) ) then
              ! form  c * h  or  c * h**t
              ! w( 1:m, 1:k ) = c( 1:m, 1:k )
              do j = 1, k
                 call stdlib_${ri}$copy( m, c( 1, j ), 1, work( 1, j ), 1 )
              end do
              ! w( 1:m, 1:k ) = w( 1:m, 1:k ) + ...
                              ! c( 1:m, n-l+1:n ) * v( 1:k, 1:l )**t
              if( l>0 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', m, k, l, one,c( 1, n-l+1 ),&
                         ldc, v, ldv, one, work, ldwork )
              ! w( 1:m, 1:k ) = w( 1:m, 1:k ) * t  or  w( 1:m, 1:k ) * t**t
              call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', trans, 'NON-UNIT', m, k, one, t,ldt, work, &
                        ldwork )
              ! c( 1:m, 1:k ) = c( 1:m, 1:k ) - w( 1:m, 1:k )
              do j = 1, k
                 do i = 1, m
                    c( i, j ) = c( i, j ) - work( i, j )
                 end do
              end do
              ! c( 1:m, n-l+1:n ) = c( 1:m, n-l+1:n ) - ...
                                  ! w( 1:m, 1:k ) * v( 1:k, 1:l )
              if( l>0 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, l, k, -one,work, &
                        ldwork, v, ldv, one, c( 1, n-l+1 ), ldc )
           end if
           return
     end subroutine stdlib_${ri}$larzb


     pure subroutine stdlib_${ri}$larzt( direct, storev, n, k, v, ldv, tau, t, ldt )
     !! DLARZT: forms the triangular factor T of a real block reflector
     !! H of order > n, which is defined as a product of k elementary
     !! reflectors.
     !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
     !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
     !! If STOREV = 'C', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th column of the array V, and
     !! H  =  I - V * T * V**T
     !! If STOREV = 'R', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th row of the array V, and
     !! H  =  I - V**T * T * V
     !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, storev
           integer(ilp), intent(in) :: k, ldt, ldv, n
           ! Array Arguments 
           real(${rk}$), intent(out) :: t(ldt,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, info, j
           ! Executable Statements 
           ! check for currently supported options
           info = 0
           if( .not.stdlib_lsame( direct, 'B' ) ) then
              info = -1
           else if( .not.stdlib_lsame( storev, 'R' ) ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLARZT', -info )
              return
           end if
           do i = k, 1, -1
              if( tau( i )==zero ) then
                 ! h(i)  =  i
                 do j = i, k
                    t( j, i ) = zero
                 end do
              else
                 ! general case
                 if( i<k ) then
                    ! t(i+1:k,i) = - tau(i) * v(i+1:k,1:n) * v(i,1:n)**t
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', k-i, n, -tau( i ),v( i+1, 1 ), ldv, v( i, &
                              1 ), ldv, zero,t( i+1, i ), 1 )
                    ! t(i+1:k,i) = t(i+1:k,i+1:k) * t(i+1:k,i)
                    call stdlib_${ri}$trmv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', k-i,t( i+1, i+1 ), &
                              ldt, t( i+1, i ), 1 )
                 end if
                 t( i, i ) = tau( i )
              end if
           end do
           return
     end subroutine stdlib_${ri}$larzt


     pure subroutine stdlib_${ri}$las2( f, g, h, ssmin, ssmax )
     !! DLAS2:  computes the singular values of the 2-by-2 matrix
     !! [  F   G  ]
     !! [  0   H  ].
     !! On return, SSMIN is the smaller singular value and SSMAX is the
     !! larger singular value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: f, g, h
           real(${rk}$), intent(out) :: ssmax, ssmin
        ! ====================================================================
           
           
           
           ! Local Scalars 
           real(${rk}$) :: as, at, au, c, fa, fhmn, fhmx, ga, ha
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           fa = abs( f )
           ga = abs( g )
           ha = abs( h )
           fhmn = min( fa, ha )
           fhmx = max( fa, ha )
           if( fhmn==zero ) then
              ssmin = zero
              if( fhmx==zero ) then
                 ssmax = ga
              else
                 ssmax = max( fhmx, ga )*sqrt( one+( min( fhmx, ga ) / max( fhmx, ga ) )**2 )
                           
              end if
           else
              if( ga<fhmx ) then
                 as = one + fhmn / fhmx
                 at = ( fhmx-fhmn ) / fhmx
                 au = ( ga / fhmx )**2
                 c = two / ( sqrt( as*as+au )+sqrt( at*at+au ) )
                 ssmin = fhmn*c
                 ssmax = fhmx / c
              else
                 au = fhmx / ga
                 if( au==zero ) then
                    ! avoid possible harmful underflow if exponent range
                    ! asymmetric (true ssmin may not underflow even if
                    ! au underflows)
                    ssmin = ( fhmn*fhmx ) / ga
                    ssmax = ga
                 else
                    as = one + fhmn / fhmx
                    at = ( fhmx-fhmn ) / fhmx
                    c = one / ( sqrt( one+( as*au )**2 )+sqrt( one+( at*au )**2 ) )
                    ssmin = ( fhmn*c )*au
                    ssmin = ssmin + ssmin
                    ssmax = ga / ( c+c )
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$las2


     pure subroutine stdlib_${ri}$lascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
     !! DLASCL: multiplies the M by N real matrix A by the real scalar
     !! CTO/CFROM.  This is done without over/underflow as long as the final
     !! result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
     !! A may be full, upper triangular, lower triangular, upper Hessenberg,
     !! or banded.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: type
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, lda, m, n
           real(${rk}$), intent(in) :: cfrom, cto
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: i, itype, j, k1, k2, k3, k4
           real(${rk}$) :: bignum, cfrom1, cfromc, cto1, ctoc, mul, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( stdlib_lsame( type, 'G' ) ) then
              itype = 0
           else if( stdlib_lsame( type, 'L' ) ) then
              itype = 1
           else if( stdlib_lsame( type, 'U' ) ) then
              itype = 2
           else if( stdlib_lsame( type, 'H' ) ) then
              itype = 3
           else if( stdlib_lsame( type, 'B' ) ) then
              itype = 4
           else if( stdlib_lsame( type, 'Q' ) ) then
              itype = 5
           else if( stdlib_lsame( type, 'Z' ) ) then
              itype = 6
           else
              itype = -1
           end if
           if( itype==-1 ) then
              info = -1
           else if( cfrom==zero .or. stdlib_${ri}$isnan(cfrom) ) then
              info = -4
           else if( stdlib_${ri}$isnan(cto) ) then
              info = -5
           else if( m<0 ) then
              info = -6
           else if( n<0 .or. ( itype==4 .and. n/=m ) .or.( itype==5 .and. n/=m ) ) then
              info = -7
           else if( itype<=3 .and. lda<max( 1, m ) ) then
              info = -9
           else if( itype>=4 ) then
              if( kl<0 .or. kl>max( m-1, 0 ) ) then
                 info = -2
              else if( ku<0 .or. ku>max( n-1, 0 ) .or.( ( itype==4 .or. itype==5 ) .and. kl/=ku ) &
                        )then
                 info = -3
              else if( ( itype==4 .and. lda<kl+1 ) .or.( itype==5 .and. lda<ku+1 ) .or.( itype==6 &
                        .and. lda<2*kl+ku+1 ) ) then
                 info = -9
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASCL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 )return
           ! get machine parameters
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           cfromc = cfrom
           ctoc = cto
           10 continue
           cfrom1 = cfromc*smlnum
           if( cfrom1==cfromc ) then
              ! cfromc is an inf.  multiply by a correctly signed zero for
              ! finite ctoc, or a nan if ctoc is infinite.
              mul = ctoc / cfromc
              done = .true.
              cto1 = ctoc
           else
              cto1 = ctoc / bignum
              if( cto1==ctoc ) then
                 ! ctoc is either 0 or an inf.  in both cases, ctoc itself
                 ! serves as the correct multiplication factor.
                 mul = ctoc
                 done = .true.
                 cfromc = one
              else if( abs( cfrom1 )>abs( ctoc ) .and. ctoc/=zero ) then
                 mul = smlnum
                 done = .false.
                 cfromc = cfrom1
              else if( abs( cto1 )>abs( cfromc ) ) then
                 mul = bignum
                 done = .false.
                 ctoc = cto1
              else
                 mul = ctoc / cfromc
                 done = .true.
              end if
           end if
           if( itype==0 ) then
              ! full matrix
              do j = 1, n
                 do i = 1, m
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==1 ) then
              ! lower triangular matrix
              do j = 1, n
                 do i = j, m
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==2 ) then
              ! upper triangular matrix
              do j = 1, n
                 do i = 1, min( j, m )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==3 ) then
              ! upper hessenberg matrix
              do j = 1, n
                 do i = 1, min( j+1, m )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==4 ) then
              ! lower half of a symmetric band matrix
              k3 = kl + 1
              k4 = n + 1
              do j = 1, n
                 do i = 1, min( k3, k4-j )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==5 ) then
              ! upper half of a symmetric band matrix
              k1 = ku + 2
              k3 = ku + 1
              do j = 1, n
                 do i = max( k1-j, 1 ), k3
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==6 ) then
              ! band matrix
              k1 = kl + ku + 2
              k2 = kl + 1
              k3 = 2*kl + ku + 1
              k4 = kl + ku + 1 + m
              do j = 1, n
                 do i = max( k1-j, k2 ), min( k3, k4-j )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           end if
           if( .not.done )go to 10
           return
     end subroutine stdlib_${ri}$lascl


     pure subroutine stdlib_${ri}$lasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )
     !! Using a divide and conquer approach, DLASD0: computes the singular
     !! value decomposition (SVD) of a real upper bidiagonal N-by-M
     !! matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
     !! The algorithm computes orthogonal matrices U and VT such that
     !! B = U * S * VT. The singular values S are overwritten on D.
     !! A related subroutine, DLASDA, computes only the singular values,
     !! and optionally, the singular vectors in compact form.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n, smlsiz, sqre
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, i1, ic, idxq, idxqc, im1, inode, itemp, iwk, j, lf, ll, lvl, m, ncc,&
                      nd, ndb1, ndiml, ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqrei
           real(${rk}$) :: alpha, beta
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -2
           end if
           m = n + sqre
           if( ldu<n ) then
              info = -6
           else if( ldvt<m ) then
              info = -8
           else if( smlsiz<3 ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD0', -info )
              return
           end if
           ! if the input matrix is too small, call stdlib_${ri}$lasdq to find the svd.
           if( n<=smlsiz ) then
              call stdlib_${ri}$lasdq( 'U', sqre, n, m, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work, &
                        info )
              return
           end if
           ! set up the computation tree.
           inode = 1
           ndiml = inode + n
           ndimr = ndiml + n
           idxq = ndimr + n
           iwk = idxq + n
           call stdlib_${ri}$lasdt( n, nlvl, nd, iwork( inode ), iwork( ndiml ),iwork( ndimr ), smlsiz &
                     )
           ! for the nodes on bottom level of the tree, solve
           ! their subproblems by stdlib_${ri}$lasdq.
           ndb1 = ( nd+1 ) / 2
           ncc = 0
           loop_30: do i = ndb1, nd
           ! ic : center row of each node
           ! nl : number of rows of left  subproblem
           ! nr : number of rows of right subproblem
           ! nlf: starting row of the left   subproblem
           ! nrf: starting row of the right  subproblem
              i1 = i - 1
              ic = iwork( inode+i1 )
              nl = iwork( ndiml+i1 )
              nlp1 = nl + 1
              nr = iwork( ndimr+i1 )
              nrp1 = nr + 1
              nlf = ic - nl
              nrf = ic + 1
              sqrei = 1
              call stdlib_${ri}$lasdq( 'U', sqrei, nl, nlp1, nl, ncc, d( nlf ), e( nlf ),vt( nlf, nlf )&
                        , ldvt, u( nlf, nlf ), ldu,u( nlf, nlf ), ldu, work, info )
              if( info/=0 ) then
                 return
              end if
              itemp = idxq + nlf - 2
              do j = 1, nl
                 iwork( itemp+j ) = j
              end do
              if( i==nd ) then
                 sqrei = sqre
              else
                 sqrei = 1
              end if
              nrp1 = nr + sqrei
              call stdlib_${ri}$lasdq( 'U', sqrei, nr, nrp1, nr, ncc, d( nrf ), e( nrf ),vt( nrf, nrf )&
                        , ldvt, u( nrf, nrf ), ldu,u( nrf, nrf ), ldu, work, info )
              if( info/=0 ) then
                 return
              end if
              itemp = idxq + ic
              do j = 1, nr
                 iwork( itemp+j-1 ) = j
              end do
           end do loop_30
           ! now conquer each subproblem bottom-up.
           loop_50: do lvl = nlvl, 1, -1
              ! find the first node lf and last node ll on the
              ! current level lvl.
              if( lvl==1 ) then
                 lf = 1
                 ll = 1
              else
                 lf = 2**( lvl-1 )
                 ll = 2*lf - 1
              end if
              do i = lf, ll
                 im1 = i - 1
                 ic = iwork( inode+im1 )
                 nl = iwork( ndiml+im1 )
                 nr = iwork( ndimr+im1 )
                 nlf = ic - nl
                 if( ( sqre==0 ) .and. ( i==ll ) ) then
                    sqrei = sqre
                 else
                    sqrei = 1
                 end if
                 idxqc = idxq + nlf - 1
                 alpha = d( ic )
                 beta = e( ic )
                 call stdlib_${ri}$lasd1( nl, nr, sqrei, d( nlf ), alpha, beta,u( nlf, nlf ), ldu, vt( &
                           nlf, nlf ), ldvt,iwork( idxqc ), iwork( iwk ), work, info )
              ! report the possible convergence failure.
                 if( info/=0 ) then
                    return
                 end if
              end do
           end do loop_50
           return
     end subroutine stdlib_${ri}$lasd0


     pure subroutine stdlib_${ri}$lasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork, &
     !! DLASD1: computes the SVD of an upper bidiagonal N-by-M matrix B,
     !! where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.
     !! A related subroutine DLASD7 handles the case in which the singular
     !! values (and the singular vectors in factored form) are desired.
     !! DLASD1 computes the SVD as follows:
     !! ( D1(in)    0    0       0 )
     !! B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
     !! (   0       0   D2(in)   0 )
     !! = U(out) * ( D(out) 0) * VT(out)
     !! where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
     !! with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
     !! elsewhere; and the entry b is empty if SQRE = 0.
     !! The left singular vectors of the original matrix are stored in U, and
     !! the transpose of the right singular vectors are stored in VT, and the
     !! singular values are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple singular values or when there are zeros in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLASD2.
     !! The second stage consists of calculating the updated
     !! singular values. This is done by finding the square roots of the
     !! roots of the secular equation via the routine DLASD4 (as called
     !! by DLASD3). This routine also calculates the singular vectors of
     !! the current problem.
     !! The final stage consists of computing the updated singular vectors
     !! directly using the updated singular values.  The singular vectors
     !! for the current problem are multiplied with the singular vectors
     !! from the overall problem.
               work, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, nl, nr, sqre
           real(${rk}$), intent(inout) :: alpha, beta
           ! Array Arguments 
           integer(ilp), intent(inout) :: idxq(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: coltyp, i, idx, idxc, idxp, iq, isigma, iu2, ivt2, iz, k, ldq, ldu2, &
                     ldvt2, m, n, n1, n2
           real(${rk}$) :: orgnrm
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( nl<1 ) then
              info = -1
           else if( nr<1 ) then
              info = -2
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD1', -info )
              return
           end if
           n = nl + nr + 1
           m = n + sqre
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_${ri}$lasd2 and stdlib_${ri}$lasd3.
           ldu2 = n
           ldvt2 = m
           iz = 1
           isigma = iz + m
           iu2 = isigma + n
           ivt2 = iu2 + ldu2*n
           iq = ivt2 + ldvt2*m
           idx = 1
           idxc = idx + n
           coltyp = idxc + n
           idxp = coltyp + n
           ! scale.
           orgnrm = max( abs( alpha ), abs( beta ) )
           d( nl+1 ) = zero
           do i = 1, n
              if( abs( d( i ) )>orgnrm ) then
                 orgnrm = abs( d( i ) )
              end if
           end do
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, info )
           alpha = alpha / orgnrm
           beta = beta / orgnrm
           ! deflate singular values.
           call stdlib_${ri}$lasd2( nl, nr, sqre, k, d, work( iz ), alpha, beta, u, ldu,vt, ldvt, work(&
            isigma ), work( iu2 ), ldu2,work( ivt2 ), ldvt2, iwork( idxp ), iwork( idx ),iwork( &
                      idxc ), idxq, iwork( coltyp ), info )
           ! solve secular equation and update singular vectors.
           ldq = k
           call stdlib_${ri}$lasd3( nl, nr, sqre, k, d, work( iq ), ldq, work( isigma ),u, ldu, work( &
           iu2 ), ldu2, vt, ldvt, work( ivt2 ),ldvt2, iwork( idxc ), iwork( coltyp ), work( iz ),&
                     info )
           ! report the convergence failure.
           if( info/=0 ) then
              return
           end if
           ! unscale.
           call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, info )
           ! prepare the idxq sorting permutation.
           n1 = k
           n2 = n - k
           call stdlib_${ri}$lamrg( n1, n2, d, 1, -1, idxq )
           return
     end subroutine stdlib_${ri}$lasd1


     pure subroutine stdlib_${ri}$lasd2( nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt,ldvt, dsigma, &
     !! DLASD2: merges the two sets of singular values together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! singular values are close together or if there is a tiny entry in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
     !! DLASD2 is called from DLASD1.
               u2, ldu2, vt2, ldvt2, idxp, idx,idxc, idxq, coltyp, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, k
           integer(ilp), intent(in) :: ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           real(${rk}$), intent(in) :: alpha, beta
           ! Array Arguments 
           integer(ilp), intent(out) :: coltyp(*), idx(*), idxc(*), idxp(*)
           integer(ilp), intent(inout) :: idxq(*)
           real(${rk}$), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: dsigma(*), u2(ldu2,*), vt2(ldvt2,*), z(*)
        ! =====================================================================
           
           ! Local Arrays 
           integer(ilp) :: ctot(4), psm(4)
           ! Local Scalars 
           integer(ilp) :: ct, i, idxi, idxj, idxjp, j, jp, jprev, k2, m, n, nlp1, nlp2
           real(${rk}$) :: c, eps, hlftol, s, tau, tol, z1
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( nl<1 ) then
              info = -1
           else if( nr<1 ) then
              info = -2
           else if( ( sqre/=1 ) .and. ( sqre/=0 ) ) then
              info = -3
           end if
           n = nl + nr + 1
           m = n + sqre
           if( ldu<n ) then
              info = -10
           else if( ldvt<m ) then
              info = -12
           else if( ldu2<n ) then
              info = -15
           else if( ldvt2<m ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD2', -info )
              return
           end if
           nlp1 = nl + 1
           nlp2 = nl + 2
           ! generate the first part of the vector z; and move the singular
           ! values in the first part of d one position backward.
           z1 = alpha*vt( nlp1, nlp1 )
           z( 1 ) = z1
           do i = nl, 1, -1
              z( i+1 ) = alpha*vt( i, nlp1 )
              d( i+1 ) = d( i )
              idxq( i+1 ) = idxq( i ) + 1
           end do
           ! generate the second part of the vector z.
           do i = nlp2, m
              z( i ) = beta*vt( i, nlp2 )
           end do
           ! initialize some reference arrays.
           do i = 2, nlp1
              coltyp( i ) = 1
           end do
           do i = nlp2, n
              coltyp( i ) = 2
           end do
           ! sort the singular values into increasing order
           do i = nlp2, n
              idxq( i ) = idxq( i ) + nlp1
           end do
           ! dsigma, idxc, idxc, and the first column of u2
           ! are used as storage space.
           do i = 2, n
              dsigma( i ) = d( idxq( i ) )
              u2( i, 1 ) = z( idxq( i ) )
              idxc( i ) = coltyp( idxq( i ) )
           end do
           call stdlib_${ri}$lamrg( nl, nr, dsigma( 2 ), 1, 1, idx( 2 ) )
           do i = 2, n
              idxi = 1 + idx( i )
              d( i ) = dsigma( idxi )
              z( i ) = u2( idxi, 1 )
              coltyp( i ) = idxc( idxi )
           end do
           ! calculate the allowable deflation tolerance
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tol = max( abs( alpha ), abs( beta ) )
           tol = eight*eps*max( abs( d( n ) ), tol )
           ! there are 2 kinds of deflation -- first a value in the z-vector
           ! is small, second two (or more) singular values are very close
           ! together (their difference is small).
           ! if the value in the z-vector is small, we simply permute the
           ! array so that the corresponding singular value is moved to the
           ! end.
           ! if two values in the d-vector are close, we perform a two-sided
           ! rotation designed to make one of the corresponding z-vector
           ! entries zero, and then permute the array so that the deflated
           ! singular value is moved to the end.
           ! if there are multiple singular values then the problem deflates.
           ! here the number of equal singular values are found.  as each equal
           ! singular value is found, an elementary reflector is computed to
           ! rotate the corresponding singular subspace so that the
           ! corresponding components of z are zero in this new basis.
           k = 1
           k2 = n + 1
           do j = 2, n
              if( abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 idxp( k2 ) = j
                 coltyp( j ) = 4
                 if( j==n )go to 120
              else
                 jprev = j
                 go to 90
              end if
           end do
           90 continue
           j = jprev
           100 continue
           j = j + 1
           if( j>n )go to 110
           if( abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              idxp( k2 ) = j
              coltyp( j ) = 4
           else
              ! check if singular values are close enough to allow deflation.
              if( abs( d( j )-d( jprev ) )<=tol ) then
                 ! deflation is possible.
                 s = z( jprev )
                 c = z( j )
                 ! find sqrt(a**2+b**2) without overflow or
                 ! destructive underflow.
                 tau = stdlib_${ri}$lapy2( c, s )
                 c = c / tau
                 s = -s / tau
                 z( j ) = tau
                 z( jprev ) = zero
                 ! apply back the givens rotation to the left and right
                 ! singular vector matrices.
                 idxjp = idxq( idx( jprev )+1 )
                 idxj = idxq( idx( j )+1 )
                 if( idxjp<=nlp1 ) then
                    idxjp = idxjp - 1
                 end if
                 if( idxj<=nlp1 ) then
                    idxj = idxj - 1
                 end if
                 call stdlib_${ri}$rot( n, u( 1, idxjp ), 1, u( 1, idxj ), 1, c, s )
                 call stdlib_${ri}$rot( m, vt( idxjp, 1 ), ldvt, vt( idxj, 1 ), ldvt, c,s )
                 if( coltyp( j )/=coltyp( jprev ) ) then
                    coltyp( j ) = 3
                 end if
                 coltyp( jprev ) = 4
                 k2 = k2 - 1
                 idxp( k2 ) = jprev
                 jprev = j
              else
                 k = k + 1
                 u2( k, 1 ) = z( jprev )
                 dsigma( k ) = d( jprev )
                 idxp( k ) = jprev
                 jprev = j
              end if
           end if
           go to 100
           110 continue
           ! record the last singular value.
           k = k + 1
           u2( k, 1 ) = z( jprev )
           dsigma( k ) = d( jprev )
           idxp( k ) = jprev
           120 continue
           ! count up the total number of the various types of columns, then
           ! form a permutation which positions the four column types into
           ! four groups of uniform structure (although one or more of these
           ! groups may be empty).
           do j = 1, 4
              ctot( j ) = 0
           end do
           do j = 2, n
              ct = coltyp( j )
              ctot( ct ) = ctot( ct ) + 1
           end do
           ! psm(*) = position in submatrix (of types 1 through 4)
           psm( 1 ) = 2
           psm( 2 ) = 2 + ctot( 1 )
           psm( 3 ) = psm( 2 ) + ctot( 2 )
           psm( 4 ) = psm( 3 ) + ctot( 3 )
           ! fill out the idxc array so that the permutation which it induces
           ! will place all type-1 columns first, all type-2 columns next,
           ! then all type-3's, and finally all type-4's, starting from the
           ! second column. this applies similarly to the rows of vt.
           do j = 2, n
              jp = idxp( j )
              ct = coltyp( jp )
              idxc( psm( ct ) ) = j
              psm( ct ) = psm( ct ) + 1
           end do
           ! sort the singular values and corresponding singular vectors into
           ! dsigma, u2, and vt2 respectively.  the singular values/vectors
           ! which were not deflated go into the first k slots of dsigma, u2,
           ! and vt2 respectively, while those which were deflated go into the
           ! last n - k slots, except that the first column/row will be treated
           ! separately.
           do j = 2, n
              jp = idxp( j )
              dsigma( j ) = d( jp )
              idxj = idxq( idx( idxp( idxc( j ) ) )+1 )
              if( idxj<=nlp1 ) then
                 idxj = idxj - 1
              end if
              call stdlib_${ri}$copy( n, u( 1, idxj ), 1, u2( 1, j ), 1 )
              call stdlib_${ri}$copy( m, vt( idxj, 1 ), ldvt, vt2( j, 1 ), ldvt2 )
           end do
           ! determine dsigma(1), dsigma(2) and z(1)
           dsigma( 1 ) = zero
           hlftol = tol / two
           if( abs( dsigma( 2 ) )<=hlftol )dsigma( 2 ) = hlftol
           if( m>n ) then
              z( 1 ) = stdlib_${ri}$lapy2( z1, z( m ) )
              if( z( 1 )<=tol ) then
                 c = one
                 s = zero
                 z( 1 ) = tol
              else
                 c = z1 / z( 1 )
                 s = z( m ) / z( 1 )
              end if
           else
              if( abs( z1 )<=tol ) then
                 z( 1 ) = tol
              else
                 z( 1 ) = z1
              end if
           end if
           ! move the rest of the updating row to z.
           call stdlib_${ri}$copy( k-1, u2( 2, 1 ), 1, z( 2 ), 1 )
           ! determine the first column of u2, the first row of vt2 and the
           ! last row of vt.
           call stdlib_${ri}$laset( 'A', n, 1, zero, zero, u2, ldu2 )
           u2( nlp1, 1 ) = one
           if( m>n ) then
              do i = 1, nlp1
                 vt( m, i ) = -s*vt( nlp1, i )
                 vt2( 1, i ) = c*vt( nlp1, i )
              end do
              do i = nlp2, m
                 vt2( 1, i ) = s*vt( m, i )
                 vt( m, i ) = c*vt( m, i )
              end do
           else
              call stdlib_${ri}$copy( m, vt( nlp1, 1 ), ldvt, vt2( 1, 1 ), ldvt2 )
           end if
           if( m>n ) then
              call stdlib_${ri}$copy( m, vt( m, 1 ), ldvt, vt2( m, 1 ), ldvt2 )
           end if
           ! the deflated singular values and their corresponding vectors go
           ! into the back of d, u, and v respectively.
           if( n>k ) then
              call stdlib_${ri}$copy( n-k, dsigma( k+1 ), 1, d( k+1 ), 1 )
              call stdlib_${ri}$lacpy( 'A', n, n-k, u2( 1, k+1 ), ldu2, u( 1, k+1 ),ldu )
              call stdlib_${ri}$lacpy( 'A', n-k, m, vt2( k+1, 1 ), ldvt2, vt( k+1, 1 ),ldvt )
           end if
           ! copy ctot into coltyp for referencing in stdlib_${ri}$lasd3.
           do j = 1, 4
              coltyp( j ) = ctot( j )
           end do
           return
     end subroutine stdlib_${ri}$lasd2


     pure subroutine stdlib_${ri}$lasd3( nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2,ldu2, vt, ldvt,&
     !! DLASD3: finds all the square roots of the roots of the secular
     !! equation, as defined by the values in D and Z.  It makes the
     !! appropriate calls to DLASD4 and then updates the singular
     !! vectors by matrix multiplication.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
     !! DLASD3 is called from DLASD1.
                vt2, ldvt2, idxc, ctot, z,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldq, ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           ! Array Arguments 
           integer(ilp), intent(in) :: ctot(*), idxc(*)
           real(${rk}$), intent(out) :: d(*), q(ldq,*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(inout) :: dsigma(*), vt2(ldvt2,*), z(*)
           real(${rk}$), intent(in) :: u2(ldu2,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: ctemp, i, j, jc, ktemp, m, n, nlp1, nlp2, nrp1
           real(${rk}$) :: rho, temp
           ! Intrinsic Functions 
           intrinsic :: abs,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( nl<1 ) then
              info = -1
           else if( nr<1 ) then
              info = -2
           else if( ( sqre/=1 ) .and. ( sqre/=0 ) ) then
              info = -3
           end if
           n = nl + nr + 1
           m = n + sqre
           nlp1 = nl + 1
           nlp2 = nl + 2
           if( ( k<1 ) .or. ( k>n ) ) then
              info = -4
           else if( ldq<k ) then
              info = -7
           else if( ldu<n ) then
              info = -10
           else if( ldu2<n ) then
              info = -12
           else if( ldvt<m ) then
              info = -14
           else if( ldvt2<m ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD3', -info )
              return
           end if
           ! quick return if possible
           if( k==1 ) then
              d( 1 ) = abs( z( 1 ) )
              call stdlib_${ri}$copy( m, vt2( 1, 1 ), ldvt2, vt( 1, 1 ), ldvt )
              if( z( 1 )>zero ) then
                 call stdlib_${ri}$copy( n, u2( 1, 1 ), 1, u( 1, 1 ), 1 )
              else
                 do i = 1, n
                    u( i, 1 ) = -u2( i, 1 )
                 end do
              end if
              return
           end if
           ! modify values dsigma(i) to make sure all dsigma(i)-dsigma(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dsigma(i) by 2*dsigma(i)-dsigma(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dsigma(i) if it is 1; this makes the subsequent
           ! subtractions dsigma(i)-dsigma(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dsigma(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dsigma(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dsigma(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, k
              dsigma( i ) = stdlib_${ri}$lamc3( dsigma( i ), dsigma( i ) ) - dsigma( i )
           end do
           ! keep a copy of z.
           call stdlib_${ri}$copy( k, z, 1, q, 1 )
           ! normalize z.
           rho = stdlib_${ri}$nrm2( k, z, 1 )
           call stdlib_${ri}$lascl( 'G', 0, 0, rho, one, k, 1, z, k, info )
           rho = rho*rho
           ! find the new singular values.
           do j = 1, k
              call stdlib_${ri}$lasd4( k, j, dsigma, z, u( 1, j ), rho, d( j ),vt( 1, j ), info )
                        
              ! if the zero finder fails, report the convergence failure.
              if( info/=0 ) then
                 return
              end if
           end do
           ! compute updated z.
           do i = 1, k
              z( i ) = u( i, k )*vt( i, k )
              do j = 1, i - 1
                 z( i ) = z( i )*( u( i, j )*vt( i, j ) /( dsigma( i )-dsigma( j ) ) /( dsigma( i &
                           )+dsigma( j ) ) )
              end do
              do j = i, k - 1
                 z( i ) = z( i )*( u( i, j )*vt( i, j ) /( dsigma( i )-dsigma( j+1 ) ) /( dsigma( &
                           i )+dsigma( j+1 ) ) )
              end do
              z( i ) = sign( sqrt( abs( z( i ) ) ), q( i, 1 ) )
           end do
           ! compute left singular vectors of the modified diagonal matrix,
           ! and store related information for the right singular vectors.
           do i = 1, k
              vt( 1, i ) = z( 1 ) / u( 1, i ) / vt( 1, i )
              u( 1, i ) = negone
              do j = 2, k
                 vt( j, i ) = z( j ) / u( j, i ) / vt( j, i )
                 u( j, i ) = dsigma( j )*vt( j, i )
              end do
              temp = stdlib_${ri}$nrm2( k, u( 1, i ), 1 )
              q( 1, i ) = u( 1, i ) / temp
              do j = 2, k
                 jc = idxc( j )
                 q( j, i ) = u( jc, i ) / temp
              end do
           end do
           ! update the left singular vector matrix.
           if( k==2 ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, k, k, one, u2, ldu2, q, ldq, zero, u,ldu )
              go to 100
           end if
           if( ctot( 1 )>0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', nl, k, ctot( 1 ), one, u2( 1, 2 ), ldu2,q( 2, 1 ), ldq,&
                         zero, u( 1, 1 ), ldu )
              if( ctot( 3 )>0 ) then
                 ktemp = 2 + ctot( 1 ) + ctot( 2 )
                 call stdlib_${ri}$gemm( 'N', 'N', nl, k, ctot( 3 ), one, u2( 1, ktemp ),ldu2, q( &
                           ktemp, 1 ), ldq, one, u( 1, 1 ), ldu )
              end if
           else if( ctot( 3 )>0 ) then
              ktemp = 2 + ctot( 1 ) + ctot( 2 )
              call stdlib_${ri}$gemm( 'N', 'N', nl, k, ctot( 3 ), one, u2( 1, ktemp ),ldu2, q( ktemp, &
                        1 ), ldq, zero, u( 1, 1 ), ldu )
           else
              call stdlib_${ri}$lacpy( 'F', nl, k, u2, ldu2, u, ldu )
           end if
           call stdlib_${ri}$copy( k, q( 1, 1 ), ldq, u( nlp1, 1 ), ldu )
           ktemp = 2 + ctot( 1 )
           ctemp = ctot( 2 ) + ctot( 3 )
           call stdlib_${ri}$gemm( 'N', 'N', nr, k, ctemp, one, u2( nlp2, ktemp ), ldu2,q( ktemp, 1 ), &
                     ldq, zero, u( nlp2, 1 ), ldu )
           ! generate the right singular vectors.
           100 continue
           do i = 1, k
              temp = stdlib_${ri}$nrm2( k, vt( 1, i ), 1 )
              q( i, 1 ) = vt( 1, i ) / temp
              do j = 2, k
                 jc = idxc( j )
                 q( i, j ) = vt( jc, i ) / temp
              end do
           end do
           ! update the right singular vector matrix.
           if( k==2 ) then
              call stdlib_${ri}$gemm( 'N', 'N', k, m, k, one, q, ldq, vt2, ldvt2, zero,vt, ldvt )
                        
              return
           end if
           ktemp = 1 + ctot( 1 )
           call stdlib_${ri}$gemm( 'N', 'N', k, nlp1, ktemp, one, q( 1, 1 ), ldq,vt2( 1, 1 ), ldvt2, &
                     zero, vt( 1, 1 ), ldvt )
           ktemp = 2 + ctot( 1 ) + ctot( 2 )
           if( ktemp<=ldvt2 )call stdlib_${ri}$gemm( 'N', 'N', k, nlp1, ctot( 3 ), one, q( 1, ktemp ),&
                     ldq, vt2( ktemp, 1 ), ldvt2, one, vt( 1, 1 ),ldvt )
           ktemp = ctot( 1 ) + 1
           nrp1 = nr + sqre
           if( ktemp>1 ) then
              do i = 1, k
                 q( i, ktemp ) = q( i, 1 )
              end do
              do i = nlp2, m
                 vt2( ktemp, i ) = vt2( 1, i )
              end do
           end if
           ctemp = 1 + ctot( 2 ) + ctot( 3 )
           call stdlib_${ri}$gemm( 'N', 'N', k, nrp1, ctemp, one, q( 1, ktemp ), ldq,vt2( ktemp, nlp2 )&
                     , ldvt2, zero, vt( 1, nlp2 ), ldvt )
           return
     end subroutine stdlib_${ri}$lasd3


     pure subroutine stdlib_${ri}$lasd4( n, i, d, z, delta, rho, sigma, work, info )
     !! This subroutine computes the square root of the I-th updated
     !! eigenvalue of a positive symmetric rank-one modification to
     !! a positive diagonal matrix whose entries are given as the squares
     !! of the corresponding entries in the array d, and that
     !! 0 <= D(i) < D(j)  for  i < j
     !! and that RHO > 0. This is arranged by the calling routine, and is
     !! no loss in generality.  The rank-one modified system is thus
     !! diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
     !! where we assume the Euclidean norm of Z is 1.
     !! The method consists of approximating the rational functions in the
     !! secular equation by simpler interpolating rational functions.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: rho
           real(${rk}$), intent(out) :: sigma
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), z(*)
           real(${rk}$), intent(out) :: delta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 400
           
           
           ! Local Scalars 
           logical(lk) :: orgati, swtch, swtch3, geomavg
           integer(ilp) :: ii, iim1, iip1, ip1, iter, j, niter
           real(${rk}$) :: a, b, c, delsq, delsq2, sq2, dphi, dpsi, dtiim, dtiip, dtipsq, dtisq, &
           dtnsq, dtnsq1, dw, eps, erretm, eta, phi, prew, psi, rhoinv, sglb, sgub, tau, tau2, &
                     temp, temp1, temp2, w
           ! Local Arrays 
           real(${rk}$) :: dd(3), zz(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           ! since this routine is called in an inner loop, we do no argument
           ! checking.
           ! quick return for n=1 and 2.
           info = 0
           if( n==1 ) then
              ! presumably, i=1 upon entry
              sigma = sqrt( d( 1 )*d( 1 )+rho*z( 1 )*z( 1 ) )
              delta( 1 ) = one
              work( 1 ) = one
              return
           end if
           if( n==2 ) then
              call stdlib_${ri}$lasd5( i, d, z, delta, rho, sigma, work )
              return
           end if
           ! compute machine epsilon
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           rhoinv = one / rho
           tau2= zero
           ! the case i = n
           if( i==n ) then
              ! initialize some basic variables
              ii = n - 1
              niter = 1
              ! calculate initial guess
              temp = rho / two
              ! if ||z||_2 is not one, then temp should be set to
              ! rho * ||z||_2^2 / two
              temp1 = temp / ( d( n )+sqrt( d( n )*d( n )+temp ) )
              do j = 1, n
                 work( j ) = d( j ) + d( n ) + temp1
                 delta( j ) = ( d( j )-d( n ) ) - temp1
              end do
              psi = zero
              do j = 1, n - 2
                 psi = psi + z( j )*z( j ) / ( delta( j )*work( j ) )
              end do
              c = rhoinv + psi
              w = c + z( ii )*z( ii ) / ( delta( ii )*work( ii ) ) +z( n )*z( n ) / ( delta( n )&
                        *work( n ) )
              if( w<=zero ) then
                 temp1 = sqrt( d( n )*d( n )+rho )
                 temp = z( n-1 )*z( n-1 ) / ( ( d( n-1 )+temp1 )*( d( n )-d( n-1 )+rho / ( d( n )+&
                           temp1 ) ) ) +z( n )*z( n ) / rho
                 ! the following tau2 is to approximate
                 ! sigma_n^2 - d( n )*d( n )
                 if( c<=temp ) then
                    tau = rho
                 else
                    delsq = ( d( n )-d( n-1 ) )*( d( n )+d( n-1 ) )
                    a = -c*delsq + z( n-1 )*z( n-1 ) + z( n )*z( n )
                    b = z( n )*z( n )*delsq
                    if( a<zero ) then
                       tau2 = two*b / ( sqrt( a*a+four*b*c )-a )
                    else
                       tau2 = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                    end if
                    tau = tau2 / ( d( n )+sqrt( d( n )*d( n )+tau2 ) )
                 end if
                 ! it can be proved that
                     ! d(n)^2+rho/2 <= sigma_n^2 < d(n)^2+tau2 <= d(n)^2+rho
              else
                 delsq = ( d( n )-d( n-1 ) )*( d( n )+d( n-1 ) )
                 a = -c*delsq + z( n-1 )*z( n-1 ) + z( n )*z( n )
                 b = z( n )*z( n )*delsq
                 ! the following tau2 is to approximate
                 ! sigma_n^2 - d( n )*d( n )
                 if( a<zero ) then
                    tau2 = two*b / ( sqrt( a*a+four*b*c )-a )
                 else
                    tau2 = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                 end if
                 tau = tau2 / ( d( n )+sqrt( d( n )*d( n )+tau2 ) )
                 ! it can be proved that
                 ! d(n)^2 < d(n)^2+tau2 < sigma(n)^2 < d(n)^2+rho/2
              end if
              ! the following tau is to approximate sigma_n - d( n )
               ! tau = tau2 / ( d( n )+sqrt( d( n )*d( n )+tau2 ) )
              sigma = d( n ) + tau
              do j = 1, n
                 delta( j ) = ( d( j )-d( n ) ) - tau
                 work( j ) = d( j ) + d( n ) + tau
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / ( delta( j )*work( j ) )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / ( delta( n )*work( n ) )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv
          ! $          + abs( tau2 )*( dpsi+dphi )
              w = rhoinv + phi + psi
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 go to 240
              end if
              ! calculate the new step
              niter = niter + 1
              dtnsq1 = work( n-1 )*delta( n-1 )
              dtnsq = work( n )*delta( n )
              c = w - dtnsq1*dpsi - dtnsq*dphi
              a = ( dtnsq+dtnsq1 )*w - dtnsq*dtnsq1*( dpsi+dphi )
              b = dtnsq*dtnsq1*w
              if( c<zero )c = abs( c )
              if( c==zero ) then
                 eta = rho - sigma*sigma
              else if( a>=zero ) then
                 eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>zero )eta = -w / ( dpsi+dphi )
              temp = eta - dtnsq
              if( temp>rho )eta = rho + dtnsq
              eta = eta / ( sigma+sqrt( eta+sigma*sigma ) )
              tau = tau + eta
              sigma = sigma + eta
              do j = 1, n
                 delta( j ) = delta( j ) - eta
                 work( j ) = work( j ) + eta
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / ( work( j )*delta( j ) )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              tau2 = work( n )*delta( n )
              temp = z( n ) / tau2
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv
          ! $          + abs( tau2 )*( dpsi+dphi )
              w = rhoinv + phi + psi
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_90: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    go to 240
                 end if
                 ! calculate the new step
                 dtnsq1 = work( n-1 )*delta( n-1 )
                 dtnsq = work( n )*delta( n )
                 c = w - dtnsq1*dpsi - dtnsq*dphi
                 a = ( dtnsq+dtnsq1 )*w - dtnsq1*dtnsq*( dpsi+dphi )
                 b = dtnsq1*dtnsq*w
                 if( a>=zero ) then
                    eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>zero )eta = -w / ( dpsi+dphi )
                 temp = eta - dtnsq
                 if( temp<=zero )eta = eta / two
                 eta = eta / ( sigma+sqrt( eta+sigma*sigma ) )
                 tau = tau + eta
                 sigma = sigma + eta
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                    work( j ) = work( j ) + eta
                 end do
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, ii
                    temp = z( j ) / ( work( j )*delta( j ) )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 tau2 = work( n )*delta( n )
                 temp = z( n ) / tau2
                 phi = z( n )*temp
                 dphi = temp*temp
                 erretm = eight*( -phi-psi ) + erretm - phi + rhoinv
          ! $             + abs( tau2 )*( dpsi+dphi )
                 w = rhoinv + phi + psi
              end do loop_90
              ! return with info = 1, niter = maxit and not converged
              info = 1
              go to 240
              ! end for the case i = n
           else
              ! the case for i < n
              niter = 1
              ip1 = i + 1
              ! calculate initial guess
              delsq = ( d( ip1 )-d( i ) )*( d( ip1 )+d( i ) )
              delsq2 = delsq / two
              sq2=sqrt( ( d( i )*d( i )+d( ip1 )*d( ip1 ) ) / two )
              temp = delsq2 / ( d( i )+sq2 )
              do j = 1, n
                 work( j ) = d( j ) + d( i ) + temp
                 delta( j ) = ( d( j )-d( i ) ) - temp
              end do
              psi = zero
              do j = 1, i - 1
                 psi = psi + z( j )*z( j ) / ( work( j )*delta( j ) )
              end do
              phi = zero
              do j = n, i + 2, -1
                 phi = phi + z( j )*z( j ) / ( work( j )*delta( j ) )
              end do
              c = rhoinv + psi + phi
              w = c + z( i )*z( i ) / ( work( i )*delta( i ) ) +z( ip1 )*z( ip1 ) / ( work( ip1 )&
                        *delta( ip1 ) )
              geomavg = .false.
              if( w>zero ) then
                 ! d(i)^2 < the ith sigma^2 < (d(i)^2+d(i+1)^2)/2
                 ! we choose d(i) as origin.
                 orgati = .true.
                 ii = i
                 sglb = zero
                 sgub = delsq2  / ( d( i )+sq2 )
                 a = c*delsq + z( i )*z( i ) + z( ip1 )*z( ip1 )
                 b = z( i )*z( i )*delsq
                 if( a>zero ) then
                    tau2 = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 else
                    tau2 = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 end if
                 ! tau2 now is an estimation of sigma^2 - d( i )^2. the
                 ! following, however, is the corresponding estimation of
                 ! sigma - d( i ).
                 tau = tau2 / ( d( i )+sqrt( d( i )*d( i )+tau2 ) )
                 temp = sqrt(eps)
                 if( (d(i)<=temp*d(ip1)).and.(abs(z(i))<=temp).and.(d(i)>zero) ) then
                    tau = min( ten*d(i), sgub )
                    geomavg = .true.
                 end if
              else
                 ! (d(i)^2+d(i+1)^2)/2 <= the ith sigma^2 < d(i+1)^2/2
                 ! we choose d(i+1) as origin.
                 orgati = .false.
                 ii = ip1
                 sglb = -delsq2  / ( d( ii )+sq2 )
                 sgub = zero
                 a = c*delsq - z( i )*z( i ) - z( ip1 )*z( ip1 )
                 b = z( ip1 )*z( ip1 )*delsq
                 if( a<zero ) then
                    tau2 = two*b / ( a-sqrt( abs( a*a+four*b*c ) ) )
                 else
                    tau2 = -( a+sqrt( abs( a*a+four*b*c ) ) ) / ( two*c )
                 end if
                 ! tau2 now is an estimation of sigma^2 - d( ip1 )^2. the
                 ! following, however, is the corresponding estimation of
                 ! sigma - d( ip1 ).
                 tau = tau2 / ( d( ip1 )+sqrt( abs( d( ip1 )*d( ip1 )+tau2 ) ) )
              end if
              sigma = d( ii ) + tau
              do j = 1, n
                 work( j ) = d( j ) + d( ii ) + tau
                 delta( j ) = ( d( j )-d( ii ) ) - tau
              end do
              iim1 = ii - 1
              iip1 = ii + 1
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / ( work( j )*delta( j ) )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / ( work( j )*delta( j ) )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              w = rhoinv + phi + psi
              ! w is the value of the secular function with
              ! its ii-th element removed.
              swtch3 = .false.
              if( orgati ) then
                 if( w<zero )swtch3 = .true.
              else
                 if( w>zero )swtch3 = .true.
              end if
              if( ii==1 .or. ii==n )swtch3 = .false.
              temp = z( ii ) / ( work( ii )*delta( ii ) )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = w + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv+ three*abs( temp )
          ! $          + abs( tau2 )*dw
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 go to 240
              end if
              if( w<=zero ) then
                 sglb = max( sglb, tau )
              else
                 sgub = min( sgub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              if( .not.swtch3 ) then
                 dtipsq = work( ip1 )*delta( ip1 )
                 dtisq = work( i )*delta( i )
                 if( orgati ) then
                    c = w - dtipsq*dw + delsq*( z( i ) / dtisq )**2
                 else
                    c = w - dtisq*dw - delsq*( z( ip1 ) / dtipsq )**2
                 end if
                 a = ( dtipsq+dtisq )*w - dtipsq*dtisq*dw
                 b = dtipsq*dtisq*w
                 if( c==zero ) then
                    if( a==zero ) then
                       if( orgati ) then
                          a = z( i )*z( i ) + dtipsq*dtipsq*( dpsi+dphi )
                       else
                          a = z( ip1 )*z( ip1 ) + dtisq*dtisq*( dpsi+dphi )
                       end if
                    end if
                    eta = b / a
                 else if( a<=zero ) then
                    eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 end if
              else
                 ! interpolation using three most relevant poles
                 dtiim = work( iim1 )*delta( iim1 )
                 dtiip = work( iip1 )*delta( iip1 )
                 temp = rhoinv + psi + phi
                 if( orgati ) then
                    temp1 = z( iim1 ) / dtiim
                    temp1 = temp1*temp1
                    c = ( temp - dtiip*( dpsi+dphi ) ) -( d( iim1 )-d( iip1 ) )*( d( iim1 )+d( &
                              iip1 ) )*temp1
                    zz( 1 ) = z( iim1 )*z( iim1 )
                    if( dpsi<temp1 ) then
                       zz( 3 ) = dtiip*dtiip*dphi
                    else
                       zz( 3 ) = dtiip*dtiip*( ( dpsi-temp1 )+dphi )
                    end if
                 else
                    temp1 = z( iip1 ) / dtiip
                    temp1 = temp1*temp1
                    c = ( temp - dtiim*( dpsi+dphi ) ) -( d( iip1 )-d( iim1 ) )*( d( iim1 )+d( &
                              iip1 ) )*temp1
                    if( dphi<temp1 ) then
                       zz( 1 ) = dtiim*dtiim*dpsi
                    else
                       zz( 1 ) = dtiim*dtiim*( dpsi+( dphi-temp1 ) )
                    end if
                    zz( 3 ) = z( iip1 )*z( iip1 )
                 end if
                 zz( 2 ) = z( ii )*z( ii )
                 dd( 1 ) = dtiim
                 dd( 2 ) = delta( ii )*work( ii )
                 dd( 3 ) = dtiip
                 call stdlib_${ri}$laed6( niter, orgati, c, dd, zz, w, eta, info )
                 if( info/=0 ) then
                    ! if info is not 0, i.e., stdlib_${ri}$laed6 failed, switch back
                    ! to 2 pole interpolation.
                    swtch3 = .false.
                    info = 0
                    dtipsq = work( ip1 )*delta( ip1 )
                    dtisq = work( i )*delta( i )
                    if( orgati ) then
                       c = w - dtipsq*dw + delsq*( z( i ) / dtisq )**2
                    else
                       c = w - dtisq*dw - delsq*( z( ip1 ) / dtipsq )**2
                    end if
                    a = ( dtipsq+dtisq )*w - dtipsq*dtisq*dw
                    b = dtipsq*dtisq*w
                    if( c==zero ) then
                       if( a==zero ) then
                          if( orgati ) then
                             a = z( i )*z( i ) + dtipsq*dtipsq*( dpsi+dphi )
                          else
                             a = z( ip1 )*z( ip1 ) + dtisq*dtisq*( dpsi+dphi)
                          end if
                       end if
                       eta = b / a
                    else if( a<=zero ) then
                       eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                    else
                       eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                    end if
                 end if
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>=zero )eta = -w / dw
              eta = eta / ( sigma+sqrt( sigma*sigma+eta ) )
              temp = tau + eta
              if( temp>sgub .or. temp<sglb ) then
                 if( w<zero ) then
                    eta = ( sgub-tau ) / two
                 else
                    eta = ( sglb-tau ) / two
                 end if
                 if( geomavg ) then
                    if( w < zero ) then
                       if( tau > zero ) then
                          eta = sqrt(sgub*tau)-tau
                       end if
                    else
                       if( sglb > zero ) then
                          eta = sqrt(sglb*tau)-tau
                       end if
                    end if
                 end if
              end if
              prew = w
              tau = tau + eta
              sigma = sigma + eta
              do j = 1, n
                 work( j ) = work( j ) + eta
                 delta( j ) = delta( j ) - eta
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / ( work( j )*delta( j ) )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / ( work( j )*delta( j ) )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              tau2 = work( ii )*delta( ii )
              temp = z( ii ) / tau2
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = rhoinv + phi + psi + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv+ three*abs( temp )
          ! $          + abs( tau2 )*dw
              swtch = .false.
              if( orgati ) then
                 if( -w>abs( prew ) / ten )swtch = .true.
              else
                 if( w>abs( prew ) / ten )swtch = .true.
              end if
              ! main loop to update the values of the array   delta and work
              iter = niter + 1
              loop_230: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
           ! $          .or. (sgub-sglb)<=eight*abs(sgub+sglb) ) then
                    go to 240
                 end if
                 if( w<=zero ) then
                    sglb = max( sglb, tau )
                 else
                    sgub = min( sgub, tau )
                 end if
                 ! calculate the new step
                 if( .not.swtch3 ) then
                    dtipsq = work( ip1 )*delta( ip1 )
                    dtisq = work( i )*delta( i )
                    if( .not.swtch ) then
                       if( orgati ) then
                          c = w - dtipsq*dw + delsq*( z( i ) / dtisq )**2
                       else
                          c = w - dtisq*dw - delsq*( z( ip1 ) / dtipsq )**2
                       end if
                    else
                       temp = z( ii ) / ( work( ii )*delta( ii ) )
                       if( orgati ) then
                          dpsi = dpsi + temp*temp
                       else
                          dphi = dphi + temp*temp
                       end if
                       c = w - dtisq*dpsi - dtipsq*dphi
                    end if
                    a = ( dtipsq+dtisq )*w - dtipsq*dtisq*dw
                    b = dtipsq*dtisq*w
                    if( c==zero ) then
                       if( a==zero ) then
                          if( .not.swtch ) then
                             if( orgati ) then
                                a = z( i )*z( i ) + dtipsq*dtipsq*( dpsi+dphi )
                             else
                                a = z( ip1 )*z( ip1 ) +dtisq*dtisq*( dpsi+dphi )
                             end if
                          else
                             a = dtisq*dtisq*dpsi + dtipsq*dtipsq*dphi
                          end if
                       end if
                       eta = b / a
                    else if( a<=zero ) then
                       eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                    else
                       eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                    end if
                 else
                    ! interpolation using three most relevant poles
                    dtiim = work( iim1 )*delta( iim1 )
                    dtiip = work( iip1 )*delta( iip1 )
                    temp = rhoinv + psi + phi
                    if( swtch ) then
                       c = temp - dtiim*dpsi - dtiip*dphi
                       zz( 1 ) = dtiim*dtiim*dpsi
                       zz( 3 ) = dtiip*dtiip*dphi
                    else
                       if( orgati ) then
                          temp1 = z( iim1 ) / dtiim
                          temp1 = temp1*temp1
                          temp2 = ( d( iim1 )-d( iip1 ) )*( d( iim1 )+d( iip1 ) )*temp1
                          c = temp - dtiip*( dpsi+dphi ) - temp2
                          zz( 1 ) = z( iim1 )*z( iim1 )
                          if( dpsi<temp1 ) then
                             zz( 3 ) = dtiip*dtiip*dphi
                          else
                             zz( 3 ) = dtiip*dtiip*( ( dpsi-temp1 )+dphi )
                          end if
                       else
                          temp1 = z( iip1 ) / dtiip
                          temp1 = temp1*temp1
                          temp2 = ( d( iip1 )-d( iim1 ) )*( d( iim1 )+d( iip1 ) )*temp1
                          c = temp - dtiim*( dpsi+dphi ) - temp2
                          if( dphi<temp1 ) then
                             zz( 1 ) = dtiim*dtiim*dpsi
                          else
                             zz( 1 ) = dtiim*dtiim*( dpsi+( dphi-temp1 ) )
                          end if
                          zz( 3 ) = z( iip1 )*z( iip1 )
                       end if
                    end if
                    dd( 1 ) = dtiim
                    dd( 2 ) = delta( ii )*work( ii )
                    dd( 3 ) = dtiip
                    call stdlib_${ri}$laed6( niter, orgati, c, dd, zz, w, eta, info )
                    if( info/=0 ) then
                       ! if info is not 0, i.e., stdlib_${ri}$laed6 failed, switch
                       ! back to two pole interpolation
                       swtch3 = .false.
                       info = 0
                       dtipsq = work( ip1 )*delta( ip1 )
                       dtisq = work( i )*delta( i )
                       if( .not.swtch ) then
                          if( orgati ) then
                             c = w - dtipsq*dw + delsq*( z( i )/dtisq )**2
                          else
                             c = w - dtisq*dw - delsq*( z( ip1 )/dtipsq )**2
                          end if
                       else
                          temp = z( ii ) / ( work( ii )*delta( ii ) )
                          if( orgati ) then
                             dpsi = dpsi + temp*temp
                          else
                             dphi = dphi + temp*temp
                          end if
                          c = w - dtisq*dpsi - dtipsq*dphi
                       end if
                       a = ( dtipsq+dtisq )*w - dtipsq*dtisq*dw
                       b = dtipsq*dtisq*w
                       if( c==zero ) then
                          if( a==zero ) then
                             if( .not.swtch ) then
                                if( orgati ) then
                                   a = z( i )*z( i ) + dtipsq*dtipsq*( dpsi+dphi )
                                else
                                   a = z( ip1 )*z( ip1 ) +dtisq*dtisq*( dpsi+dphi )
                                end if
                             else
                                a = dtisq*dtisq*dpsi + dtipsq*dtipsq*dphi
                             end if
                          end if
                          eta = b / a
                       else if( a<=zero ) then
                          eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                       else
                          eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                       end if
                    end if
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>=zero )eta = -w / dw
                 eta = eta / ( sigma+sqrt( sigma*sigma+eta ) )
                 temp=tau+eta
                 if( temp>sgub .or. temp<sglb ) then
                    if( w<zero ) then
                       eta = ( sgub-tau ) / two
                    else
                       eta = ( sglb-tau ) / two
                    end if
                    if( geomavg ) then
                       if( w < zero ) then
                          if( tau > zero ) then
                             eta = sqrt(sgub*tau)-tau
                          end if
                       else
                          if( sglb > zero ) then
                             eta = sqrt(sglb*tau)-tau
                          end if
                       end if
                    end if
                 end if
                 prew = w
                 tau = tau + eta
                 sigma = sigma + eta
                 do j = 1, n
                    work( j ) = work( j ) + eta
                    delta( j ) = delta( j ) - eta
                 end do
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, iim1
                    temp = z( j ) / ( work( j )*delta( j ) )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 dphi = zero
                 phi = zero
                 do j = n, iip1, -1
                    temp = z( j ) / ( work( j )*delta( j ) )
                    phi = phi + z( j )*temp
                    dphi = dphi + temp*temp
                    erretm = erretm + phi
                 end do
                 tau2 = work( ii )*delta( ii )
                 temp = z( ii ) / tau2
                 dw = dpsi + dphi + temp*temp
                 temp = z( ii )*temp
                 w = rhoinv + phi + psi + temp
                 erretm = eight*( phi-psi ) + erretm + two*rhoinv+ three*abs( temp )
          ! $             + abs( tau2 )*dw
                 if( w*prew>zero .and. abs( w )>abs( prew ) / ten )swtch = .not.swtch
              end do loop_230
              ! return with info = 1, niter = maxit and not converged
              info = 1
           end if
           240 continue
           return
     end subroutine stdlib_${ri}$lasd4


     pure subroutine stdlib_${ri}$lasd5( i, d, z, delta, rho, dsigma, work )
     !! This subroutine computes the square root of the I-th eigenvalue
     !! of a positive symmetric rank-one modification of a 2-by-2 diagonal
     !! matrix
     !! diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .
     !! The diagonal entries in the array D are assumed to satisfy
     !! 0 <= D(i) < D(j)  for  i < j .
     !! We also assume RHO > 0 and that the Euclidean norm of the vector
     !! Z is one.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i
           real(${rk}$), intent(out) :: dsigma
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(2), z(2)
           real(${rk}$), intent(out) :: delta(2), work(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: b, c, del, delsq, tau, w
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           del = d( 2 ) - d( 1 )
           delsq = del*( d( 2 )+d( 1 ) )
           if( i==1 ) then
              w = one + four*rho*( z( 2 )*z( 2 ) / ( d( 1 )+three*d( 2 ) )-z( 1 )*z( 1 ) / ( &
                        three*d( 1 )+d( 2 ) ) ) / del
              if( w>zero ) then
                 b = delsq + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 1 )*z( 1 )*delsq
                 ! b > zero, always
                 ! the following tau is dsigma * dsigma - d( 1 ) * d( 1 )
                 tau = two*c / ( b+sqrt( abs( b*b-four*c ) ) )
                 ! the following tau is dsigma - d( 1 )
                 tau = tau / ( d( 1 )+sqrt( d( 1 )*d( 1 )+tau ) )
                 dsigma = d( 1 ) + tau
                 delta( 1 ) = -tau
                 delta( 2 ) = del - tau
                 work( 1 ) = two*d( 1 ) + tau
                 work( 2 ) = ( d( 1 )+tau ) + d( 2 )
                 ! delta( 1 ) = -z( 1 ) / tau
                 ! delta( 2 ) = z( 2 ) / ( del-tau )
              else
                 b = -delsq + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 2 )*z( 2 )*delsq
                 ! the following tau is dsigma * dsigma - d( 2 ) * d( 2 )
                 if( b>zero ) then
                    tau = -two*c / ( b+sqrt( b*b+four*c ) )
                 else
                    tau = ( b-sqrt( b*b+four*c ) ) / two
                 end if
                 ! the following tau is dsigma - d( 2 )
                 tau = tau / ( d( 2 )+sqrt( abs( d( 2 )*d( 2 )+tau ) ) )
                 dsigma = d( 2 ) + tau
                 delta( 1 ) = -( del+tau )
                 delta( 2 ) = -tau
                 work( 1 ) = d( 1 ) + tau + d( 2 )
                 work( 2 ) = two*d( 2 ) + tau
                 ! delta( 1 ) = -z( 1 ) / ( del+tau )
                 ! delta( 2 ) = -z( 2 ) / tau
              end if
              ! temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              ! delta( 1 ) = delta( 1 ) / temp
              ! delta( 2 ) = delta( 2 ) / temp
           else
              ! now i=2
              b = -delsq + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
              c = rho*z( 2 )*z( 2 )*delsq
              ! the following tau is dsigma * dsigma - d( 2 ) * d( 2 )
              if( b>zero ) then
                 tau = ( b+sqrt( b*b+four*c ) ) / two
              else
                 tau = two*c / ( -b+sqrt( b*b+four*c ) )
              end if
              ! the following tau is dsigma - d( 2 )
              tau = tau / ( d( 2 )+sqrt( d( 2 )*d( 2 )+tau ) )
              dsigma = d( 2 ) + tau
              delta( 1 ) = -( del+tau )
              delta( 2 ) = -tau
              work( 1 ) = d( 1 ) + tau + d( 2 )
              work( 2 ) = two*d( 2 ) + tau
              ! delta( 1 ) = -z( 1 ) / ( del+tau )
              ! delta( 2 ) = -z( 2 ) / tau
              ! temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              ! delta( 1 ) = delta( 1 ) / temp
              ! delta( 2 ) = delta( 2 ) / temp
           end if
           return
     end subroutine stdlib_${ri}$lasd5


     pure subroutine stdlib_${ri}$lasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
     !! DLASD6: computes the SVD of an updated upper bidiagonal matrix B
     !! obtained by merging two smaller ones by appending a row. This
     !! routine is used only for the problem which requires all singular
     !! values and optionally singular vector matrices in factored form.
     !! B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
     !! A related subroutine, DLASD1, handles the case in which all singular
     !! values and singular vectors of the bidiagonal matrix are desired.
     !! DLASD6 computes the SVD as follows:
     !! ( D1(in)    0    0       0 )
     !! B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
     !! (   0       0   D2(in)   0 )
     !! = U(out) * ( D(out) 0) * VT(out)
     !! where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
     !! with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
     !! elsewhere; and the entry b is empty if SQRE = 0.
     !! The singular values of B can be computed using D1, D2, the first
     !! components of all the right singular vectors of the lower block, and
     !! the last components of all the right singular vectors of the upper
     !! block. These components are stored and updated in VF and VL,
     !! respectively, in DLASD6. Hence U and VT are not explicitly
     !! referenced.
     !! The singular values are stored in D. The algorithm consists of two
     !! stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple singular values or if there is a zero
     !! in the Z vector. For each such occurrence the dimension of the
     !! secular equation problem is reduced by one. This stage is
     !! performed by the routine DLASD7.
     !! The second stage consists of calculating the updated
     !! singular values. This is done by finding the roots of the
     !! secular equation via the routine DLASD4 (as called by DLASD8).
     !! This routine also updates VF and VL and computes the distances
     !! between the updated singular values and the old singular
     !! values.
     !! DLASD6 is called from DLASDA.
     givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, info )
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: givptr, info, k
           integer(ilp), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(${rk}$), intent(inout) :: alpha, beta
           real(${rk}$), intent(out) :: c, s
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(ldgcol,*), iwork(*), perm(*)
           integer(ilp), intent(inout) :: idxq(*)
           real(${rk}$), intent(inout) :: d(*), vf(*), vl(*)
           real(${rk}$), intent(out) :: difl(*), difr(*), givnum(ldgnum,*), poles(ldgnum,*), work(*), &
                     z(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, idx, idxc, idxp, isigma, ivfw, ivlw, iw, m, n, n1, n2
           real(${rk}$) :: orgnrm
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           n = nl + nr + 1
           m = n + sqre
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( nl<1 ) then
              info = -2
           else if( nr<1 ) then
              info = -3
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -4
           else if( ldgcol<n ) then
              info = -14
           else if( ldgnum<n ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD6', -info )
              return
           end if
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_${ri}$lasd7 and stdlib_${ri}$lasd8.
           isigma = 1
           iw = isigma + n
           ivfw = iw + m
           ivlw = ivfw + m
           idx = 1
           idxc = idx + n
           idxp = idxc + n
           ! scale.
           orgnrm = max( abs( alpha ), abs( beta ) )
           d( nl+1 ) = zero
           do i = 1, n
              if( abs( d( i ) )>orgnrm ) then
                 orgnrm = abs( d( i ) )
              end if
           end do
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, info )
           alpha = alpha / orgnrm
           beta = beta / orgnrm
           ! sort and deflate singular values.
           call stdlib_${ri}$lasd7( icompq, nl, nr, sqre, k, d, z, work( iw ), vf,work( ivfw ), vl, &
           work( ivlw ), alpha, beta,work( isigma ), iwork( idx ), iwork( idxp ), idxq,perm, &
                     givptr, givcol, ldgcol, givnum, ldgnum, c, s,info )
           ! solve secular equation, compute difl, difr, and update vf, vl.
           call stdlib_${ri}$lasd8( icompq, k, d, z, vf, vl, difl, difr, ldgnum,work( isigma ), work( &
                     iw ), info )
           ! report the possible convergence failure.
           if( info/=0 ) then
              return
           end if
           ! save the poles if icompq = 1.
           if( icompq==1 ) then
              call stdlib_${ri}$copy( k, d, 1, poles( 1, 1 ), 1 )
              call stdlib_${ri}$copy( k, work( isigma ), 1, poles( 1, 2 ), 1 )
           end if
           ! unscale.
           call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, info )
           ! prepare the idxq sorting permutation.
           n1 = k
           n2 = n - k
           call stdlib_${ri}$lamrg( n1, n2, d, 1, -1, idxq )
           return
     end subroutine stdlib_${ri}$lasd6


     pure subroutine stdlib_${ri}$lasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
     !! DLASD7: merges the two sets of singular values together into a single
     !! sorted set. Then it tries to deflate the size of the problem. There
     !! are two ways in which deflation can occur:  when two or more singular
     !! values are close together or if there is a tiny entry in the Z
     !! vector. For each such occurrence the order of the related
     !! secular equation problem is reduced by one.
     !! DLASD7 is called from DLASD6.
     beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, info )
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: givptr, info, k
           integer(ilp), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(${rk}$), intent(in) :: alpha, beta
           real(${rk}$), intent(out) :: c, s
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(ldgcol,*), idx(*), idxp(*), perm(*)
           integer(ilp), intent(inout) :: idxq(*)
           real(${rk}$), intent(inout) :: d(*), vf(*), vl(*)
           real(${rk}$), intent(out) :: dsigma(*), givnum(ldgnum,*), vfw(*), vlw(*), z(*), zw(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, idxi, idxj, idxjp, j, jp, jprev, k2, m, n, nlp1, nlp2
           real(${rk}$) :: eps, hlftol, tau, tol, z1
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           n = nl + nr + 1
           m = n + sqre
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( nl<1 ) then
              info = -2
           else if( nr<1 ) then
              info = -3
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -4
           else if( ldgcol<n ) then
              info = -22
           else if( ldgnum<n ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD7', -info )
              return
           end if
           nlp1 = nl + 1
           nlp2 = nl + 2
           if( icompq==1 ) then
              givptr = 0
           end if
           ! generate the first part of the vector z and move the singular
           ! values in the first part of d one position backward.
           z1 = alpha*vl( nlp1 )
           vl( nlp1 ) = zero
           tau = vf( nlp1 )
           do i = nl, 1, -1
              z( i+1 ) = alpha*vl( i )
              vl( i ) = zero
              vf( i+1 ) = vf( i )
              d( i+1 ) = d( i )
              idxq( i+1 ) = idxq( i ) + 1
           end do
           vf( 1 ) = tau
           ! generate the second part of the vector z.
           do i = nlp2, m
              z( i ) = beta*vf( i )
              vf( i ) = zero
           end do
           ! sort the singular values into increasing order
           do i = nlp2, n
              idxq( i ) = idxq( i ) + nlp1
           end do
           ! dsigma, idxc, idxc, and zw are used as storage space.
           do i = 2, n
              dsigma( i ) = d( idxq( i ) )
              zw( i ) = z( idxq( i ) )
              vfw( i ) = vf( idxq( i ) )
              vlw( i ) = vl( idxq( i ) )
           end do
           call stdlib_${ri}$lamrg( nl, nr, dsigma( 2 ), 1, 1, idx( 2 ) )
           do i = 2, n
              idxi = 1 + idx( i )
              d( i ) = dsigma( idxi )
              z( i ) = zw( idxi )
              vf( i ) = vfw( idxi )
              vl( i ) = vlw( idxi )
           end do
           ! calculate the allowable deflation tolerance
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tol = max( abs( alpha ), abs( beta ) )
           tol = eight*eight*eps*max( abs( d( n ) ), tol )
           ! there are 2 kinds of deflation -- first a value in the z-vector
           ! is small, second two (or more) singular values are very close
           ! together (their difference is small).
           ! if the value in the z-vector is small, we simply permute the
           ! array so that the corresponding singular value is moved to the
           ! end.
           ! if two values in the d-vector are close, we perform a two-sided
           ! rotation designed to make one of the corresponding z-vector
           ! entries zero, and then permute the array so that the deflated
           ! singular value is moved to the end.
           ! if there are multiple singular values then the problem deflates.
           ! here the number of equal singular values are found.  as each equal
           ! singular value is found, an elementary reflector is computed to
           ! rotate the corresponding singular subspace so that the
           ! corresponding components of z are zero in this new basis.
           k = 1
           k2 = n + 1
           do j = 2, n
              if( abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 idxp( k2 ) = j
                 if( j==n )go to 100
              else
                 jprev = j
                 go to 70
              end if
           end do
           70 continue
           j = jprev
           80 continue
           j = j + 1
           if( j>n )go to 90
           if( abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              idxp( k2 ) = j
           else
              ! check if singular values are close enough to allow deflation.
              if( abs( d( j )-d( jprev ) )<=tol ) then
                 ! deflation is possible.
                 s = z( jprev )
                 c = z( j )
                 ! find sqrt(a**2+b**2) without overflow or
                 ! destructive underflow.
                 tau = stdlib_${ri}$lapy2( c, s )
                 z( j ) = tau
                 z( jprev ) = zero
                 c = c / tau
                 s = -s / tau
                 ! record the appropriate givens rotation
                 if( icompq==1 ) then
                    givptr = givptr + 1
                    idxjp = idxq( idx( jprev )+1 )
                    idxj = idxq( idx( j )+1 )
                    if( idxjp<=nlp1 ) then
                       idxjp = idxjp - 1
                    end if
                    if( idxj<=nlp1 ) then
                       idxj = idxj - 1
                    end if
                    givcol( givptr, 2 ) = idxjp
                    givcol( givptr, 1 ) = idxj
                    givnum( givptr, 2 ) = c
                    givnum( givptr, 1 ) = s
                 end if
                 call stdlib_${ri}$rot( 1, vf( jprev ), 1, vf( j ), 1, c, s )
                 call stdlib_${ri}$rot( 1, vl( jprev ), 1, vl( j ), 1, c, s )
                 k2 = k2 - 1
                 idxp( k2 ) = jprev
                 jprev = j
              else
                 k = k + 1
                 zw( k ) = z( jprev )
                 dsigma( k ) = d( jprev )
                 idxp( k ) = jprev
                 jprev = j
              end if
           end if
           go to 80
           90 continue
           ! record the last singular value.
           k = k + 1
           zw( k ) = z( jprev )
           dsigma( k ) = d( jprev )
           idxp( k ) = jprev
           100 continue
           ! sort the singular values into dsigma. the singular values which
           ! were not deflated go into the first k slots of dsigma, except
           ! that dsigma(1) is treated separately.
           do j = 2, n
              jp = idxp( j )
              dsigma( j ) = d( jp )
              vfw( j ) = vf( jp )
              vlw( j ) = vl( jp )
           end do
           if( icompq==1 ) then
              do j = 2, n
                 jp = idxp( j )
                 perm( j ) = idxq( idx( jp )+1 )
                 if( perm( j )<=nlp1 ) then
                    perm( j ) = perm( j ) - 1
                 end if
              end do
           end if
           ! the deflated singular values go back into the last n - k slots of
           ! d.
           call stdlib_${ri}$copy( n-k, dsigma( k+1 ), 1, d( k+1 ), 1 )
           ! determine dsigma(1), dsigma(2), z(1), vf(1), vl(1), vf(m), and
           ! vl(m).
           dsigma( 1 ) = zero
           hlftol = tol / two
           if( abs( dsigma( 2 ) )<=hlftol )dsigma( 2 ) = hlftol
           if( m>n ) then
              z( 1 ) = stdlib_${ri}$lapy2( z1, z( m ) )
              if( z( 1 )<=tol ) then
                 c = one
                 s = zero
                 z( 1 ) = tol
              else
                 c = z1 / z( 1 )
                 s = -z( m ) / z( 1 )
              end if
              call stdlib_${ri}$rot( 1, vf( m ), 1, vf( 1 ), 1, c, s )
              call stdlib_${ri}$rot( 1, vl( m ), 1, vl( 1 ), 1, c, s )
           else
              if( abs( z1 )<=tol ) then
                 z( 1 ) = tol
              else
                 z( 1 ) = z1
              end if
           end if
           ! restore z, vf, and vl.
           call stdlib_${ri}$copy( k-1, zw( 2 ), 1, z( 2 ), 1 )
           call stdlib_${ri}$copy( n-1, vfw( 2 ), 1, vf( 2 ), 1 )
           call stdlib_${ri}$copy( n-1, vlw( 2 ), 1, vl( 2 ), 1 )
           return
     end subroutine stdlib_${ri}$lasd7


     pure subroutine stdlib_${ri}$lasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
     !! DLASD8: finds the square roots of the roots of the secular equation,
     !! as defined by the values in DSIGMA and Z. It makes the appropriate
     !! calls to DLASD4, and stores, for each  element in D, the distance
     !! to its two nearest poles (elements in DSIGMA). It also updates
     !! the arrays VF and VL, the first and last components of all the
     !! right singular vectors of the original bidiagonal matrix.
     !! DLASD8 is called from DLASD6.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, k, lddifr
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(out) :: d(*), difl(*), difr(lddifr,*), work(*)
           real(${rk}$), intent(inout) :: dsigma(*), vf(*), vl(*), z(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iwk1, iwk2, iwk2i, iwk3, iwk3i, j
           real(${rk}$) :: diflj, difrj, dj, dsigj, dsigjp, rho, temp
           ! Intrinsic Functions 
           intrinsic :: abs,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( k<1 ) then
              info = -2
           else if( lddifr<k ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASD8', -info )
              return
           end if
           ! quick return if possible
           if( k==1 ) then
              d( 1 ) = abs( z( 1 ) )
              difl( 1 ) = d( 1 )
              if( icompq==1 ) then
                 difl( 2 ) = one
                 difr( 1, 2 ) = one
              end if
              return
           end if
           ! modify values dsigma(i) to make sure all dsigma(i)-dsigma(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dsigma(i) by 2*dsigma(i)-dsigma(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dsigma(i) if it is 1; this makes the subsequent
           ! subtractions dsigma(i)-dsigma(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dsigma(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dsigma(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, k
              dsigma( i ) = stdlib_${ri}$lamc3( dsigma( i ), dsigma( i ) ) - dsigma( i )
           end do
           ! book keeping.
           iwk1 = 1
           iwk2 = iwk1 + k
           iwk3 = iwk2 + k
           iwk2i = iwk2 - 1
           iwk3i = iwk3 - 1
           ! normalize z.
           rho = stdlib_${ri}$nrm2( k, z, 1 )
           call stdlib_${ri}$lascl( 'G', 0, 0, rho, one, k, 1, z, k, info )
           rho = rho*rho
           ! initialize work(iwk3).
           call stdlib_${ri}$laset( 'A', k, 1, one, one, work( iwk3 ), k )
           ! compute the updated singular values, the arrays difl, difr,
           ! and the updated z.
           do j = 1, k
              call stdlib_${ri}$lasd4( k, j, dsigma, z, work( iwk1 ), rho, d( j ),work( iwk2 ), info )
                        
              ! if the root finder fails, report the convergence failure.
              if( info/=0 ) then
                 return
              end if
              work( iwk3i+j ) = work( iwk3i+j )*work( j )*work( iwk2i+j )
              difl( j ) = -work( j )
              difr( j, 1 ) = -work( j+1 )
              do i = 1, j - 1
                 work( iwk3i+i ) = work( iwk3i+i )*work( i )*work( iwk2i+i ) / ( dsigma( i )-&
                           dsigma( j ) ) / ( dsigma( i )+dsigma( j ) )
              end do
              do i = j + 1, k
                 work( iwk3i+i ) = work( iwk3i+i )*work( i )*work( iwk2i+i ) / ( dsigma( i )-&
                           dsigma( j ) ) / ( dsigma( i )+dsigma( j ) )
              end do
           end do
           ! compute updated z.
           do i = 1, k
              z( i ) = sign( sqrt( abs( work( iwk3i+i ) ) ), z( i ) )
           end do
           ! update vf and vl.
           do j = 1, k
              diflj = difl( j )
              dj = d( j )
              dsigj = -dsigma( j )
              if( j<k ) then
                 difrj = -difr( j, 1 )
                 dsigjp = -dsigma( j+1 )
              end if
              work( j ) = -z( j ) / diflj / ( dsigma( j )+dj )
              do i = 1, j - 1
                 work( i ) = z( i ) / ( stdlib_${ri}$lamc3( dsigma( i ), dsigj )-diflj )/ ( dsigma( i )&
                           +dj )
              end do
              do i = j + 1, k
                 work( i ) = z( i ) / ( stdlib_${ri}$lamc3( dsigma( i ), dsigjp )+difrj )/ ( dsigma( i &
                           )+dj )
              end do
              temp = stdlib_${ri}$nrm2( k, work, 1 )
              work( iwk2i+j ) = stdlib_${ri}$dot( k, work, 1, vf, 1 ) / temp
              work( iwk3i+j ) = stdlib_${ri}$dot( k, work, 1, vl, 1 ) / temp
              if( icompq==1 ) then
                 difr( j, 2 ) = temp
              end if
           end do
           call stdlib_${ri}$copy( k, work( iwk2 ), 1, vf, 1 )
           call stdlib_${ri}$copy( k, work( iwk3 ), 1, vl, 1 )
           return
     end subroutine stdlib_${ri}$lasd8


     pure subroutine stdlib_${ri}$lasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z, &
     !! Using a divide and conquer approach, DLASDA: computes the singular
     !! value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
     !! B with diagonal D and offdiagonal E, where M = N + SQRE. The
     !! algorithm computes the singular values in the SVD B = U * S * VT.
     !! The orthogonal matrices U and VT are optionally computed in
     !! compact form.
     !! A related subroutine, DLASD0, computes the singular values and
     !! the singular vectors in explicit form.
               poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldgcol, ldu, n, smlsiz, sqre
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(ldgcol,*), givptr(*), iwork(*), k(*), perm(ldgcol,&
                     *)
           real(${rk}$), intent(out) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), &
                     s(*), u(ldu,*), vt(ldu,*), work(*), z(ldu,*)
           real(${rk}$), intent(inout) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, ic, idxq, idxqi, im1, inode, itemp, iwk, j, lf, ll, lvl, lvl2, &
           m, ncc, nd, ndb1, ndiml, ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, nru, nwork1, &
                     nwork2, smlszp, sqrei, vf, vfi, vl, vli
           real(${rk}$) :: alpha, beta
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( smlsiz<3 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -4
           else if( ldu<( n+sqre ) ) then
              info = -8
           else if( ldgcol<n ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASDA', -info )
              return
           end if
           m = n + sqre
           ! if the input matrix is too small, call stdlib_${ri}$lasdq to find the svd.
           if( n<=smlsiz ) then
              if( icompq==0 ) then
                 call stdlib_${ri}$lasdq( 'U', sqre, n, 0, 0, 0, d, e, vt, ldu, u, ldu,u, ldu, work, &
                           info )
              else
                 call stdlib_${ri}$lasdq( 'U', sqre, n, m, n, 0, d, e, vt, ldu, u, ldu,u, ldu, work, &
                           info )
              end if
              return
           end if
           ! book-keeping and  set up the computation tree.
           inode = 1
           ndiml = inode + n
           ndimr = ndiml + n
           idxq = ndimr + n
           iwk = idxq + n
           ncc = 0
           nru = 0
           smlszp = smlsiz + 1
           vf = 1
           vl = vf + m
           nwork1 = vl + m
           nwork2 = nwork1 + smlszp*smlszp
           call stdlib_${ri}$lasdt( n, nlvl, nd, iwork( inode ), iwork( ndiml ),iwork( ndimr ), smlsiz &
                     )
           ! for the nodes on bottom level of the tree, solve
           ! their subproblems by stdlib_${ri}$lasdq.
           ndb1 = ( nd+1 ) / 2
           loop_30: do i = ndb1, nd
              ! ic : center row of each node
              ! nl : number of rows of left  subproblem
              ! nr : number of rows of right subproblem
              ! nlf: starting row of the left   subproblem
              ! nrf: starting row of the right  subproblem
              i1 = i - 1
              ic = iwork( inode+i1 )
              nl = iwork( ndiml+i1 )
              nlp1 = nl + 1
              nr = iwork( ndimr+i1 )
              nlf = ic - nl
              nrf = ic + 1
              idxqi = idxq + nlf - 2
              vfi = vf + nlf - 1
              vli = vl + nlf - 1
              sqrei = 1
              if( icompq==0 ) then
                 call stdlib_${ri}$laset( 'A', nlp1, nlp1, zero, one, work( nwork1 ),smlszp )
                 call stdlib_${ri}$lasdq( 'U', sqrei, nl, nlp1, nru, ncc, d( nlf ),e( nlf ), work( &
                 nwork1 ), smlszp,work( nwork2 ), nl, work( nwork2 ), nl,work( nwork2 ), info )
                           
                 itemp = nwork1 + nl*smlszp
                 call stdlib_${ri}$copy( nlp1, work( nwork1 ), 1, work( vfi ), 1 )
                 call stdlib_${ri}$copy( nlp1, work( itemp ), 1, work( vli ), 1 )
              else
                 call stdlib_${ri}$laset( 'A', nl, nl, zero, one, u( nlf, 1 ), ldu )
                 call stdlib_${ri}$laset( 'A', nlp1, nlp1, zero, one, vt( nlf, 1 ), ldu )
                 call stdlib_${ri}$lasdq( 'U', sqrei, nl, nlp1, nl, ncc, d( nlf ),e( nlf ), vt( nlf, 1 &
                           ), ldu, u( nlf, 1 ), ldu,u( nlf, 1 ), ldu, work( nwork1 ), info )
                 call stdlib_${ri}$copy( nlp1, vt( nlf, 1 ), 1, work( vfi ), 1 )
                 call stdlib_${ri}$copy( nlp1, vt( nlf, nlp1 ), 1, work( vli ), 1 )
              end if
              if( info/=0 ) then
                 return
              end if
              do j = 1, nl
                 iwork( idxqi+j ) = j
              end do
              if( ( i==nd ) .and. ( sqre==0 ) ) then
                 sqrei = 0
              else
                 sqrei = 1
              end if
              idxqi = idxqi + nlp1
              vfi = vfi + nlp1
              vli = vli + nlp1
              nrp1 = nr + sqrei
              if( icompq==0 ) then
                 call stdlib_${ri}$laset( 'A', nrp1, nrp1, zero, one, work( nwork1 ),smlszp )
                 call stdlib_${ri}$lasdq( 'U', sqrei, nr, nrp1, nru, ncc, d( nrf ),e( nrf ), work( &
                 nwork1 ), smlszp,work( nwork2 ), nr, work( nwork2 ), nr,work( nwork2 ), info )
                           
                 itemp = nwork1 + ( nrp1-1 )*smlszp
                 call stdlib_${ri}$copy( nrp1, work( nwork1 ), 1, work( vfi ), 1 )
                 call stdlib_${ri}$copy( nrp1, work( itemp ), 1, work( vli ), 1 )
              else
                 call stdlib_${ri}$laset( 'A', nr, nr, zero, one, u( nrf, 1 ), ldu )
                 call stdlib_${ri}$laset( 'A', nrp1, nrp1, zero, one, vt( nrf, 1 ), ldu )
                 call stdlib_${ri}$lasdq( 'U', sqrei, nr, nrp1, nr, ncc, d( nrf ),e( nrf ), vt( nrf, 1 &
                           ), ldu, u( nrf, 1 ), ldu,u( nrf, 1 ), ldu, work( nwork1 ), info )
                 call stdlib_${ri}$copy( nrp1, vt( nrf, 1 ), 1, work( vfi ), 1 )
                 call stdlib_${ri}$copy( nrp1, vt( nrf, nrp1 ), 1, work( vli ), 1 )
              end if
              if( info/=0 ) then
                 return
              end if
              do j = 1, nr
                 iwork( idxqi+j ) = j
              end do
           end do loop_30
           ! now conquer each subproblem bottom-up.
           j = 2**nlvl
           loop_50: do lvl = nlvl, 1, -1
              lvl2 = lvl*2 - 1
              ! find the first node lf and last node ll on
              ! the current level lvl.
              if( lvl==1 ) then
                 lf = 1
                 ll = 1
              else
                 lf = 2**( lvl-1 )
                 ll = 2*lf - 1
              end if
              loop_40: do i = lf, ll
                 im1 = i - 1
                 ic = iwork( inode+im1 )
                 nl = iwork( ndiml+im1 )
                 nr = iwork( ndimr+im1 )
                 nlf = ic - nl
                 nrf = ic + 1
                 if( i==ll ) then
                    sqrei = sqre
                 else
                    sqrei = 1
                 end if
                 vfi = vf + nlf - 1
                 vli = vl + nlf - 1
                 idxqi = idxq + nlf - 1
                 alpha = d( ic )
                 beta = e( ic )
                 if( icompq==0 ) then
                    call stdlib_${ri}$lasd6( icompq, nl, nr, sqrei, d( nlf ),work( vfi ), work( vli ), &
                    alpha, beta,iwork( idxqi ), perm, givptr( 1 ), givcol,ldgcol, givnum, ldu, &
                    poles, difl, difr, z,k( 1 ), c( 1 ), s( 1 ), work( nwork1 ),iwork( iwk ), &
                              info )
                 else
                    j = j - 1
                    call stdlib_${ri}$lasd6( icompq, nl, nr, sqrei, d( nlf ),work( vfi ), work( vli ), &
                    alpha, beta,iwork( idxqi ), perm( nlf, lvl ),givptr( j ), givcol( nlf, lvl2 ),&
                     ldgcol,givnum( nlf, lvl2 ), ldu,poles( nlf, lvl2 ), difl( nlf, lvl ),difr( &
                     nlf, lvl2 ), z( nlf, lvl ), k( j ),c( j ), s( j ), work( nwork1 ),iwork( iwk &
                               ), info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
              end do loop_40
           end do loop_50
           return
     end subroutine stdlib_${ri}$lasda


     pure subroutine stdlib_${ri}$lasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, ldc, &
     !! DLASDQ: computes the singular value decomposition (SVD) of a real
     !! (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
     !! E, accumulating the transformations if desired. Letting B denote
     !! the input bidiagonal matrix, the algorithm computes orthogonal
     !! matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
     !! of P). The singular values S are overwritten on D.
     !! The input matrix U  is changed to U  * Q  if desired.
     !! The input matrix VT is changed to P**T * VT if desired.
     !! The input matrix C  is changed to Q**T * C  if desired.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3, for a detailed description of the algorithm.
               work, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru, sqre
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: rotate
           integer(ilp) :: i, isub, iuplo, j, np1, sqre1
           real(${rk}$) :: cs, r, smin, sn
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( iuplo==0 ) then
              info = -1
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ncvt<0 ) then
              info = -4
           else if( nru<0 ) then
              info = -5
           else if( ncc<0 ) then
              info = -6
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -10
           else if( ldu<max( 1, nru ) ) then
              info = -12
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASDQ', -info )
              return
           end if
           if( n==0 )return
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           np1 = n + 1
           sqre1 = sqre
           ! if matrix non-square upper bidiagonal, rotate to be lower
           ! bidiagonal.  the rotations are on the right.
           if( ( iuplo==1 ) .and. ( sqre1==1 ) ) then
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( rotate ) then
                    work( i ) = cs
                    work( n+i ) = sn
                 end if
              end do
              call stdlib_${ri}$lartg( d( n ), e( n ), cs, sn, r )
              d( n ) = r
              e( n ) = zero
              if( rotate ) then
                 work( n ) = cs
                 work( n+n ) = sn
              end if
              iuplo = 2
              sqre1 = 0
              ! update singular vectors if desired.
              if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', np1, ncvt, work( 1 ),work( np1 ), vt, &
                        ldvt )
           end if
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left.
           if( iuplo==2 ) then
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( rotate ) then
                    work( i ) = cs
                    work( n+i ) = sn
                 end if
              end do
              ! if matrix (n+1)-by-n lower bidiagonal, one additional
              ! rotation is needed.
              if( sqre1==1 ) then
                 call stdlib_${ri}$lartg( d( n ), e( n ), cs, sn, r )
                 d( n ) = r
                 if( rotate ) then
                    work( n ) = cs
                    work( n+n ) = sn
                 end if
              end if
              ! update singular vectors if desired.
              if( nru>0 ) then
                 if( sqre1==0 ) then
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, n, work( 1 ),work( np1 ), u, ldu )
                              
                 else
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, np1, work( 1 ),work( np1 ), u, ldu )
                              
                 end if
              end if
              if( ncc>0 ) then
                 if( sqre1==0 ) then
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', n, ncc, work( 1 ),work( np1 ), c, ldc )
                              
                 else
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', np1, ncc, work( 1 ),work( np1 ), c, ldc )
                              
                 end if
              end if
           end if
           ! call stdlib_${ri}$bdsqr to compute the svd of the reduced real
           ! n-by-n upper bidiagonal matrix.
           call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c,ldc, work, info )
                     
           ! sort the singular values into ascending order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n
              ! scan for smallest d(i).
              isub = i
              smin = d( i )
              do j = i + 1, n
                 if( d( j )<smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=i ) then
                 ! swap singular values and vectors.
                 d( isub ) = d( i )
                 d( i ) = smin
                 if( ncvt>0 )call stdlib_${ri}$swap( ncvt, vt( isub, 1 ), ldvt, vt( i, 1 ), ldvt )
                           
                 if( nru>0 )call stdlib_${ri}$swap( nru, u( 1, isub ), 1, u( 1, i ), 1 )
                 if( ncc>0 )call stdlib_${ri}$swap( ncc, c( isub, 1 ), ldc, c( i, 1 ), ldc )
              end if
           end do
           return
     end subroutine stdlib_${ri}$lasdq


     pure subroutine stdlib_${ri}$lasdt( n, lvl, nd, inode, ndiml, ndimr, msub )
     !! DLASDT: creates a tree of subproblems for bidiagonal divide and
     !! conquer.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: lvl, nd
           integer(ilp), intent(in) :: msub, n
           ! Array Arguments 
           integer(ilp), intent(out) :: inode(*), ndiml(*), ndimr(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, il, ir, llst, maxn, ncrnt, nlvl
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           intrinsic :: real,int,log,max
           ! Executable Statements 
           ! find the number of levels on the tree.
           maxn = max( 1, n )
           temp = log( real( maxn,KIND=${rk}$) / real( msub+1,KIND=${rk}$) ) / log( two )
           lvl = int( temp,KIND=ilp) + 1
           i = n / 2
           inode( 1 ) = i + 1
           ndiml( 1 ) = i
           ndimr( 1 ) = n - i - 1
           il = 0
           ir = 1
           llst = 1
           do nlvl = 1, lvl - 1
              ! constructing the tree at (nlvl+1)-st level. the number of
              ! nodes created on this level is llst * 2.
              do i = 0, llst - 1
                 il = il + 2
                 ir = ir + 2
                 ncrnt = llst + i
                 ndiml( il ) = ndiml( ncrnt ) / 2
                 ndimr( il ) = ndiml( ncrnt ) - ndiml( il ) - 1
                 inode( il ) = inode( ncrnt ) - ndimr( il ) - 1
                 ndiml( ir ) = ndimr( ncrnt ) / 2
                 ndimr( ir ) = ndimr( ncrnt ) - ndiml( ir ) - 1
                 inode( ir ) = inode( ncrnt ) + ndiml( ir ) + 1
              end do
              llst = llst*2
           end do
           nd = llst*2 - 1
           return
     end subroutine stdlib_${ri}$lasdt


     pure subroutine stdlib_${ri}$laset( uplo, m, n, alpha, beta, a, lda )
     !! DLASET: initializes an m-by-n matrix A to BETA on the diagonal and
     !! ALPHA on the offdiagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, m, n
           real(${rk}$), intent(in) :: alpha, beta
           ! Array Arguments 
           real(${rk}$), intent(out) :: a(lda,*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! set the strictly upper triangular or trapezoidal part of the
              ! array to alpha.
              do j = 2, n
                 do i = 1, min( j-1, m )
                    a( i, j ) = alpha
                 end do
              end do
           else if( stdlib_lsame( uplo, 'L' ) ) then
              ! set the strictly lower triangular or trapezoidal part of the
              ! array to alpha.
              do j = 1, min( m, n )
                 do i = j + 1, m
                    a( i, j ) = alpha
                 end do
              end do
           else
              ! set the leading m-by-n submatrix to alpha.
              do j = 1, n
                 do i = 1, m
                    a( i, j ) = alpha
                 end do
              end do
           end if
           ! set the first min(m,n) diagonal elements to beta.
           do i = 1, min( m, n )
              a( i, i ) = beta
           end do
           return
     end subroutine stdlib_${ri}$laset


     pure subroutine stdlib_${ri}$lasq1( n, d, e, work, info )
     !! DLASQ1: computes the singular values of a real N-by-N bidiagonal
     !! matrix with diagonal D and off-diagonal E. The singular values
     !! are computed to high relative accuracy, in the absence of
     !! denormalization, underflow and overflow. The algorithm was first
     !! presented in
     !! "Accurate singular values and differential qd algorithms" by K. V.
     !! Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
     !! 1994,
     !! and the present implementation is described in "An implementation of
     !! the dqds Algorithm (Positive Case)", LAPACK Working Note.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iinfo
           real(${rk}$) :: eps, scale, safmin, sigmn, sigmx
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DLASQ1', -info )
              return
           else if( n==0 ) then
              return
           else if( n==1 ) then
              d( 1 ) = abs( d( 1 ) )
              return
           else if( n==2 ) then
              call stdlib_${ri}$las2( d( 1 ), e( 1 ), d( 2 ), sigmn, sigmx )
              d( 1 ) = sigmx
              d( 2 ) = sigmn
              return
           end if
           ! estimate the largest singular value.
           sigmx = zero
           do i = 1, n - 1
              d( i ) = abs( d( i ) )
              sigmx = max( sigmx, abs( e( i ) ) )
           end do
           d( n ) = abs( d( n ) )
           ! early return if sigmx is zero (matrix is already diagonal).
           if( sigmx==zero ) then
              call stdlib_${ri}$lasrt( 'D', n, d, iinfo )
              return
           end if
           do i = 1, n
              sigmx = max( sigmx, d( i ) )
           end do
           ! copy d and e into work (in the z format) and scale (squaring the
           ! input data makes scaling by a power of the radix pointless).
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           scale = sqrt( eps / safmin )
           call stdlib_${ri}$copy( n, d, 1, work( 1 ), 2 )
           call stdlib_${ri}$copy( n-1, e, 1, work( 2 ), 2 )
           call stdlib_${ri}$lascl( 'G', 0, 0, sigmx, scale, 2*n-1, 1, work, 2*n-1,iinfo )
           ! compute the q's and e's.
           do i = 1, 2*n - 1
              work( i ) = work( i )**2
           end do
           work( 2*n ) = zero
           call stdlib_${ri}$lasq2( n, work, info )
           if( info==0 ) then
              do i = 1, n
                 d( i ) = sqrt( work( i ) )
              end do
              call stdlib_${ri}$lascl( 'G', 0, 0, scale, sigmx, n, 1, d, n, iinfo )
           else if( info==2 ) then
           ! maximum number of iterations exceeded.  move data from work
           ! into d and e so the calling subroutine can try to finish
              do i = 1, n
                 d( i ) = sqrt( work( 2*i-1 ) )
                 e( i ) = sqrt( work( 2*i ) )
              end do
              call stdlib_${ri}$lascl( 'G', 0, 0, scale, sigmx, n, 1, d, n, iinfo )
              call stdlib_${ri}$lascl( 'G', 0, 0, scale, sigmx, n, 1, e, n, iinfo )
           end if
           return
     end subroutine stdlib_${ri}$lasq1


     pure subroutine stdlib_${ri}$lasq2( n, z, info )
     !! DLASQ2: computes all the eigenvalues of the symmetric positive
     !! definite tridiagonal matrix associated with the qd array Z to high
     !! relative accuracy are computed to high relative accuracy, in the
     !! absence of denormalization, underflow and overflow.
     !! To see the relation of Z to the tridiagonal matrix, let L be a
     !! unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
     !! let U be an upper bidiagonal matrix with 1's above and diagonal
     !! Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
     !! symmetric tridiagonal to which it is similar.
     !! Note : DLASQ2 defines a logical variable, IEEE, which is true
     !! on machines which follow ieee-754 floating-point standard in their
     !! handling of infinities and NaNs, and false otherwise. This variable
     !! is passed to DLASQ3.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: z(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: cbias = 1.50_${rk}$
           real(${rk}$), parameter :: hundrd = 100.0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: ieee
           integer(ilp) :: i0, i1, i4, iinfo, ipn4, iter, iwhila, iwhilb, k, kmin, n0, n1, nbig, &
                     ndiv, nfail, pp, splt, ttype
           real(${rk}$) :: d, dee, deemin, desig, dmin, dmin1, dmin2, dn, dn1, dn2, e, emax, emin, &
           eps, g, oldemn, qmax, qmin, s, safmin, sigma, t, tau, temp, tol, tol2, trace, zmax, &
                     tempe, tempq
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min,sqrt
           ! Executable Statements 
           ! test the input arguments.
           ! (in case stdlib_${ri}$lasq2 is not called by stdlib_${ri}$lasq1)
           info = 0
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           tol = eps*hundrd
           tol2 = tol**2
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DLASQ2', 1 )
              return
           else if( n==0 ) then
              return
           else if( n==1 ) then
              ! 1-by-1 case.
              if( z( 1 )<zero ) then
                 info = -201
                 call stdlib_xerbla( 'DLASQ2', 2 )
              end if
              return
           else if( n==2 ) then
              ! 2-by-2 case.
              if( z( 1 )<zero ) then
                 info = -201
                 call stdlib_xerbla( 'DLASQ2', 2 )
                 return
              else if( z( 2 )<zero ) then
                 info = -202
                 call stdlib_xerbla( 'DLASQ2', 2 )
                 return
              else if( z( 3 )<zero ) then
                info = -203
                call stdlib_xerbla( 'DLASQ2', 2 )
                return
              else if( z( 3 )>z( 1 ) ) then
                 d = z( 3 )
                 z( 3 ) = z( 1 )
                 z( 1 ) = d
              end if
              z( 5 ) = z( 1 ) + z( 2 ) + z( 3 )
              if( z( 2 )>z( 3 )*tol2 ) then
                 t = half*( ( z( 1 )-z( 3 ) )+z( 2 ) )
                 s = z( 3 )*( z( 2 ) / t )
                 if( s<=t ) then
                    s = z( 3 )*( z( 2 ) / ( t*( one+sqrt( one+s / t ) ) ) )
                 else
                    s = z( 3 )*( z( 2 ) / ( t+sqrt( t )*sqrt( t+s ) ) )
                 end if
                 t = z( 1 ) + ( s+z( 2 ) )
                 z( 3 ) = z( 3 )*( z( 1 ) / t )
                 z( 1 ) = t
              end if
              z( 2 ) = z( 3 )
              z( 6 ) = z( 2 ) + z( 1 )
              return
           end if
           ! check for negative data and compute sums of q's and e's.
           z( 2*n ) = zero
           emin = z( 2 )
           qmax = zero
           zmax = zero
           d = zero
           e = zero
           do k = 1, 2*( n-1 ), 2
              if( z( k )<zero ) then
                 info = -( 200+k )
                 call stdlib_xerbla( 'DLASQ2', 2 )
                 return
              else if( z( k+1 )<zero ) then
                 info = -( 200+k+1 )
                 call stdlib_xerbla( 'DLASQ2', 2 )
                 return
              end if
              d = d + z( k )
              e = e + z( k+1 )
              qmax = max( qmax, z( k ) )
              emin = min( emin, z( k+1 ) )
              zmax = max( qmax, zmax, z( k+1 ) )
           end do
           if( z( 2*n-1 )<zero ) then
              info = -( 200+2*n-1 )
              call stdlib_xerbla( 'DLASQ2', 2 )
              return
           end if
           d = d + z( 2*n-1 )
           qmax = max( qmax, z( 2*n-1 ) )
           zmax = max( qmax, zmax )
           ! check for diagonality.
           if( e==zero ) then
              do k = 2, n
                 z( k ) = z( 2*k-1 )
              end do
              call stdlib_${ri}$lasrt( 'D', n, z, iinfo )
              z( 2*n-1 ) = d
              return
           end if
           trace = d + e
           ! check for zero data.
           if( trace==zero ) then
              z( 2*n-1 ) = zero
              return
           end if
           ! check whether the machine is ieee conformable.
           ieee = ( stdlib_ilaenv( 10, 'DLASQ2', 'N', 1, 2, 3, 4 )==1 )
           ! rearrange data for locality: z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...).
           do k = 2*n, 2, -2
              z( 2*k ) = zero
              z( 2*k-1 ) = z( k )
              z( 2*k-2 ) = zero
              z( 2*k-3 ) = z( k-1 )
           end do
           i0 = 1
           n0 = n
           ! reverse the qd-array, if warranted.
           if( cbias*z( 4*i0-3 )<z( 4*n0-3 ) ) then
              ipn4 = 4*( i0+n0 )
              do i4 = 4*i0, 2*( i0+n0-1 ), 4
                 temp = z( i4-3 )
                 z( i4-3 ) = z( ipn4-i4-3 )
                 z( ipn4-i4-3 ) = temp
                 temp = z( i4-1 )
                 z( i4-1 ) = z( ipn4-i4-5 )
                 z( ipn4-i4-5 ) = temp
              end do
           end if
           ! initial split checking via dqd and li's test.
           pp = 0
           loop_80: do k = 1, 2
              d = z( 4*n0+pp-3 )
              do i4 = 4*( n0-1 ) + pp, 4*i0 + pp, -4
                 if( z( i4-1 )<=tol2*d ) then
                    z( i4-1 ) = -zero
                    d = z( i4-3 )
                 else
                    d = z( i4-3 )*( d / ( d+z( i4-1 ) ) )
                 end if
              end do
              ! dqd maps z to zz plus li's test.
              emin = z( 4*i0+pp+1 )
              d = z( 4*i0+pp-3 )
              do i4 = 4*i0 + pp, 4*( n0-1 ) + pp, 4
                 z( i4-2*pp-2 ) = d + z( i4-1 )
                 if( z( i4-1 )<=tol2*d ) then
                    z( i4-1 ) = -zero
                    z( i4-2*pp-2 ) = d
                    z( i4-2*pp ) = zero
                    d = z( i4+1 )
                 else if( safmin*z( i4+1 )<z( i4-2*pp-2 ) .and.safmin*z( i4-2*pp-2 )<z( i4+1 ) ) &
                           then
                    temp = z( i4+1 ) / z( i4-2*pp-2 )
                    z( i4-2*pp ) = z( i4-1 )*temp
                    d = d*temp
                 else
                    z( i4-2*pp ) = z( i4+1 )*( z( i4-1 ) / z( i4-2*pp-2 ) )
                    d = z( i4+1 )*( d / z( i4-2*pp-2 ) )
                 end if
                 emin = min( emin, z( i4-2*pp ) )
              end do
              z( 4*n0-pp-2 ) = d
              ! now find qmax.
              qmax = z( 4*i0-pp-2 )
              do i4 = 4*i0 - pp + 2, 4*n0 - pp - 2, 4
                 qmax = max( qmax, z( i4 ) )
              end do
              ! prepare for the next iteration on k.
              pp = 1 - pp
           end do loop_80
           ! initialise variables to pass to stdlib_${ri}$lasq3.
           ttype = 0
           dmin1 = zero
           dmin2 = zero
           dn    = zero
           dn1   = zero
           dn2   = zero
           g     = zero
           tau   = zero
           iter = 2
           nfail = 0
           ndiv = 2*( n0-i0 )
           loop_160: do iwhila = 1, n + 1
              if( n0<1 )go to 170
              ! while array unfinished do
              ! e(n0) holds the value of sigma when submatrix in i0:n0
              ! splits from the rest of the array, but is negated.
              desig = zero
              if( n0==n ) then
                 sigma = zero
              else
                 sigma = -z( 4*n0-1 )
              end if
              if( sigma<zero ) then
                 info = 1
                 return
              end if
              ! find last unreduced submatrix's top index i0, find qmax and
              ! emin. find gershgorin-type bound if q's much greater than e's.
              emax = zero
              if( n0>i0 ) then
                 emin = abs( z( 4*n0-5 ) )
              else
                 emin = zero
              end if
              qmin = z( 4*n0-3 )
              qmax = qmin
              do i4 = 4*n0, 8, -4
                 if( z( i4-5 )<=zero )go to 100
                 if( qmin>=four*emax ) then
                    qmin = min( qmin, z( i4-3 ) )
                    emax = max( emax, z( i4-5 ) )
                 end if
                 qmax = max( qmax, z( i4-7 )+z( i4-5 ) )
                 emin = min( emin, z( i4-5 ) )
              end do
              i4 = 4
              100 continue
              i0 = i4 / 4
              pp = 0
              if( n0-i0>1 ) then
                 dee = z( 4*i0-3 )
                 deemin = dee
                 kmin = i0
                 do i4 = 4*i0+1, 4*n0-3, 4
                    dee = z( i4 )*( dee /( dee+z( i4-2 ) ) )
                    if( dee<=deemin ) then
                       deemin = dee
                       kmin = ( i4+3 )/4
                    end if
                 end do
                 if( (kmin-i0)*2<n0-kmin .and.deemin<=half*z(4*n0-3) ) then
                    ipn4 = 4*( i0+n0 )
                    pp = 2
                    do i4 = 4*i0, 2*( i0+n0-1 ), 4
                       temp = z( i4-3 )
                       z( i4-3 ) = z( ipn4-i4-3 )
                       z( ipn4-i4-3 ) = temp
                       temp = z( i4-2 )
                       z( i4-2 ) = z( ipn4-i4-2 )
                       z( ipn4-i4-2 ) = temp
                       temp = z( i4-1 )
                       z( i4-1 ) = z( ipn4-i4-5 )
                       z( ipn4-i4-5 ) = temp
                       temp = z( i4 )
                       z( i4 ) = z( ipn4-i4-4 )
                       z( ipn4-i4-4 ) = temp
                    end do
                 end if
              end if
              ! put -(initial shift) into dmin.
              dmin = -max( zero, qmin-two*sqrt( qmin )*sqrt( emax ) )
              ! now i0:n0 is unreduced.
              ! pp = 0 for ping, pp = 1 for pong.
              ! pp = 2 indicates that flipping was applied to the z array and
                     ! and that the tests for deflation upon entry in stdlib_${ri}$lasq3
                     ! should not be performed.
              nbig = 100*( n0-i0+1 )
              loop_140: do iwhilb = 1, nbig
                 if( i0>n0 )go to 150
                 ! while submatrix unfinished take a good dqds step.
                 call stdlib_${ri}$lasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,iter, ndiv, &
                           ieee, ttype, dmin1, dmin2, dn, dn1,dn2, g, tau )
                 pp = 1 - pp
                 ! when emin is very small check for splits.
                 if( pp==0 .and. n0-i0>=3 ) then
                    if( z( 4*n0 )<=tol2*qmax .or.z( 4*n0-1 )<=tol2*sigma ) then
                       splt = i0 - 1
                       qmax = z( 4*i0-3 )
                       emin = z( 4*i0-1 )
                       oldemn = z( 4*i0 )
                       do i4 = 4*i0, 4*( n0-3 ), 4
                          if( z( i4 )<=tol2*z( i4-3 ) .or.z( i4-1 )<=tol2*sigma ) then
                             z( i4-1 ) = -sigma
                             splt = i4 / 4
                             qmax = zero
                             emin = z( i4+3 )
                             oldemn = z( i4+4 )
                          else
                             qmax = max( qmax, z( i4+1 ) )
                             emin = min( emin, z( i4-1 ) )
                             oldemn = min( oldemn, z( i4 ) )
                          end if
                       end do
                       z( 4*n0-1 ) = emin
                       z( 4*n0 ) = oldemn
                       i0 = splt + 1
                    end if
                 end if
              end do loop_140
              info = 2
              ! maximum number of iterations exceeded, restore the shift
              ! sigma and place the new d's and e's in a qd array.
              ! this might need to be done for several blocks
              i1 = i0
              n1 = n0
              145 continue
              tempq = z( 4*i0-3 )
              z( 4*i0-3 ) = z( 4*i0-3 ) + sigma
              do k = i0+1, n0
                 tempe = z( 4*k-5 )
                 z( 4*k-5 ) = z( 4*k-5 ) * (tempq / z( 4*k-7 ))
                 tempq = z( 4*k-3 )
                 z( 4*k-3 ) = z( 4*k-3 ) + sigma + tempe - z( 4*k-5 )
              end do
              ! prepare to do this on the previous block if there is one
              if( i1>1 ) then
                 n1 = i1-1
                 do while( ( i1>=2 ) .and. ( z(4*i1-5)>=zero ) )
                    i1 = i1 - 1
                 end do
                 sigma = -z(4*n1-1)
                 go to 145
              end if
              do k = 1, n
                 z( 2*k-1 ) = z( 4*k-3 )
              ! only the block 1..n0 is unfinished.  the rest of the e's
              ! must be essentially zero, although sometimes other data
              ! has been stored in them.
                 if( k<n0 ) then
                    z( 2*k ) = z( 4*k-1 )
                 else
                    z( 2*k ) = 0
                 end if
              end do
              return
              ! end iwhilb
              150 continue
           end do loop_160
           info = 3
           return
           ! end iwhila
           170 continue
           ! move q's to the front.
           do k = 2, n
              z( k ) = z( 4*k-3 )
           end do
           ! sort and compute sum of eigenvalues.
           call stdlib_${ri}$lasrt( 'D', n, z, iinfo )
           e = zero
           do k = n, 1, -1
              e = e + z( k )
           end do
           ! store trace, sum(eigenvalues) and information on performance.
           z( 2*n+1 ) = trace
           z( 2*n+2 ) = e
           z( 2*n+3 ) = real( iter,KIND=${rk}$)
           z( 2*n+4 ) = real( ndiv,KIND=${rk}$) / real( n**2,KIND=${rk}$)
           z( 2*n+5 ) = hundrd*nfail / real( iter,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$lasq2


     pure subroutine stdlib_${ri}$lasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,iter, ndiv, &
     !! DLASQ3: checks for deflation, computes a shift (TAU) and calls dqds.
     !! In case of failure it changes shifts, and tries again until output
     !! is positive.
               ieee, ttype, dmin1, dmin2, dn, dn1,dn2, g, tau )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: ieee
           integer(ilp), intent(in) :: i0
           integer(ilp), intent(inout) :: iter, n0, ndiv, nfail, pp
           real(${rk}$), intent(inout) :: desig, dmin1, dmin2, dn, dn1, dn2, g, qmax, tau
           real(${rk}$), intent(out) :: dmin, sigma
           ! Array Arguments 
           real(${rk}$), intent(inout) :: z(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: cbias = 1.50_${rk}$
           real(${rk}$), parameter :: qurtr = 0.250_${rk}$
           real(${rk}$), parameter :: hundrd = 100.0_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: ipn4, j4, n0in, nn
           integer(ilp), intent(inout) :: ttype
           real(${rk}$) :: eps, s, t, temp, tol, tol2
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           n0in = n0
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           tol = eps*hundrd
           tol2 = tol**2
           ! check for deflation.
           10 continue
           if( n0<i0 )return
           if( n0==i0 )go to 20
           nn = 4*n0 + pp
           if( n0==( i0+1 ) )go to 40
           ! check whether e(n0-1) is negligible, 1 eigenvalue.
           if( z( nn-5 )>tol2*( sigma+z( nn-3 ) ) .and.z( nn-2*pp-4 )>tol2*z( nn-7 ) )go to &
                     30
           20 continue
           z( 4*n0-3 ) = z( 4*n0+pp-3 ) + sigma
           n0 = n0 - 1
           go to 10
           ! check  whether e(n0-2) is negligible, 2 eigenvalues.
           30 continue
           if( z( nn-9 )>tol2*sigma .and.z( nn-2*pp-8 )>tol2*z( nn-11 ) )go to 50
           40 continue
           if( z( nn-3 )>z( nn-7 ) ) then
              s = z( nn-3 )
              z( nn-3 ) = z( nn-7 )
              z( nn-7 ) = s
           end if
           t = half*( ( z( nn-7 )-z( nn-3 ) )+z( nn-5 ) )
           if( z( nn-5 )>z( nn-3 )*tol2.and.t/=zero ) then
              s = z( nn-3 )*( z( nn-5 ) / t )
              if( s<=t ) then
                 s = z( nn-3 )*( z( nn-5 ) /( t*( one+sqrt( one+s / t ) ) ) )
              else
                 s = z( nn-3 )*( z( nn-5 ) / ( t+sqrt( t )*sqrt( t+s ) ) )
              end if
              t = z( nn-7 ) + ( s+z( nn-5 ) )
              z( nn-3 ) = z( nn-3 )*( z( nn-7 ) / t )
              z( nn-7 ) = t
           end if
           z( 4*n0-7 ) = z( nn-7 ) + sigma
           z( 4*n0-3 ) = z( nn-3 ) + sigma
           n0 = n0 - 2
           go to 10
           50 continue
           if( pp==2 )pp = 0
           ! reverse the qd-array, if warranted.
           if( dmin<=zero .or. n0<n0in ) then
              if( cbias*z( 4*i0+pp-3 )<z( 4*n0+pp-3 ) ) then
                 ipn4 = 4*( i0+n0 )
                 do j4 = 4*i0, 2*( i0+n0-1 ), 4
                    temp = z( j4-3 )
                    z( j4-3 ) = z( ipn4-j4-3 )
                    z( ipn4-j4-3 ) = temp
                    temp = z( j4-2 )
                    z( j4-2 ) = z( ipn4-j4-2 )
                    z( ipn4-j4-2 ) = temp
                    temp = z( j4-1 )
                    z( j4-1 ) = z( ipn4-j4-5 )
                    z( ipn4-j4-5 ) = temp
                    temp = z( j4 )
                    z( j4 ) = z( ipn4-j4-4 )
                    z( ipn4-j4-4 ) = temp
                 end do
                 if( n0-i0<=4 ) then
                    z( 4*n0+pp-1 ) = z( 4*i0+pp-1 )
                    z( 4*n0-pp ) = z( 4*i0-pp )
                 end if
                 dmin2 = min( dmin2, z( 4*n0+pp-1 ) )
                 z( 4*n0+pp-1 ) = min( z( 4*n0+pp-1 ), z( 4*i0+pp-1 ),z( 4*i0+pp+3 ) )
                 z( 4*n0-pp ) = min( z( 4*n0-pp ), z( 4*i0-pp ),z( 4*i0-pp+4 ) )
                 qmax = max( qmax, z( 4*i0+pp-3 ), z( 4*i0+pp+1 ) )
                 dmin = -zero
              end if
           end if
           ! choose a shift.
           call stdlib_${ri}$lasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn, dn1,dn2, tau, ttype, &
                     g )
           ! call dqds until dmin > 0.
           70 continue
           call stdlib_${ri}$lasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2, dn,dn1, dn2, ieee, &
                     eps )
           ndiv = ndiv + ( n0-i0+2 )
           iter = iter + 1
           ! check status.
           if( dmin>=zero .and. dmin1>=zero ) then
              ! success.
              go to 90
           else if( dmin<zero .and. dmin1>zero .and.z( 4*( n0-1 )-pp )<tol*( sigma+dn1 ) .and.abs(&
                      dn )<tol*sigma ) then
              ! convergence hidden by negative dn.
              z( 4*( n0-1 )-pp+2 ) = zero
              dmin = zero
              go to 90
           else if( dmin<zero ) then
              ! tau too big. select new tau and try again.
              nfail = nfail + 1
              if( ttype<-22 ) then
                 ! failed twice. play it safe.
                 tau = zero
              else if( dmin1>zero ) then
                 ! late failure. gives excellent shift.
                 tau = ( tau+dmin )*( one-two*eps )
                 ttype = ttype - 11
              else
                 ! early failure. divide by 4.
                 tau = qurtr*tau
                 ttype = ttype - 12
              end if
              go to 70
           else if( stdlib_${ri}$isnan( dmin ) ) then
              ! nan.
              if( tau==zero ) then
                 go to 80
              else
                 tau = zero
                 go to 70
              end if
           else
              ! possible underflow. play it safe.
              go to 80
           end if
           ! risk of underflow.
           80 continue
           call stdlib_${ri}$lasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn, dn1, dn2 )
           ndiv = ndiv + ( n0-i0+2 )
           iter = iter + 1
           tau = zero
           90 continue
           if( tau<sigma ) then
              desig = desig + tau
              t = sigma + desig
              desig = desig - ( t-sigma )
           else
              t = sigma + tau
              desig = sigma - ( t-tau ) + desig
           end if
           sigma = t
           return
     end subroutine stdlib_${ri}$lasq3


     pure subroutine stdlib_${ri}$lasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
     !! DLASQ4: computes an approximation TAU to the smallest eigenvalue
     !! using values of d from the previous transform.
               ttype, g )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i0, n0, n0in, pp
           integer(ilp), intent(out) :: ttype
           real(${rk}$), intent(in) :: dmin, dmin1, dmin2, dn, dn1, dn2
           real(${rk}$), intent(inout) :: g
           real(${rk}$), intent(out) :: tau
           ! Array Arguments 
           real(${rk}$), intent(in) :: z(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: cnst1 = 0.5630_${rk}$
           real(${rk}$), parameter :: cnst2 = 1.010_${rk}$
           real(${rk}$), parameter :: cnst3 = 1.050_${rk}$
           real(${rk}$), parameter :: qurtr = 0.250_${rk}$
           real(${rk}$), parameter :: third = 0.3330_${rk}$
           real(${rk}$), parameter :: hundrd = 100.0_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: i4, nn, np
           real(${rk}$) :: a2, b1, b2, gam, gap1, gap2, s
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! a negative dmin forces the shift to take that absolute value
           ! ttype records the type of shift.
           if( dmin<=zero ) then
              tau = -dmin
              ttype = -1
              return
           end if
           nn = 4*n0 + pp
           if( n0in==n0 ) then
              ! no eigenvalues deflated.
              if( dmin==dn .or. dmin==dn1 ) then
                 b1 = sqrt( z( nn-3 ) )*sqrt( z( nn-5 ) )
                 b2 = sqrt( z( nn-7 ) )*sqrt( z( nn-9 ) )
                 a2 = z( nn-7 ) + z( nn-5 )
                 ! cases 2 and 3.
                 if( dmin==dn .and. dmin1==dn1 ) then
                    gap2 = dmin2 - a2 - dmin2*qurtr
                    if( gap2>zero .and. gap2>b2 ) then
                       gap1 = a2 - dn - ( b2 / gap2 )*b2
                    else
                       gap1 = a2 - dn - ( b1+b2 )
                    end if
                    if( gap1>zero .and. gap1>b1 ) then
                       s = max( dn-( b1 / gap1 )*b1, half*dmin )
                       ttype = -2
                    else
                       s = zero
                       if( dn>b1 )s = dn - b1
                       if( a2>( b1+b2 ) )s = min( s, a2-( b1+b2 ) )
                       s = max( s, third*dmin )
                       ttype = -3
                    end if
                 else
                    ! case 4.
                    ttype = -4
                    s = qurtr*dmin
                    if( dmin==dn ) then
                       gam = dn
                       a2 = zero
                       if( z( nn-5 ) > z( nn-7 ) )return
                       b2 = z( nn-5 ) / z( nn-7 )
                       np = nn - 9
                    else
                       np = nn - 2*pp
                       gam = dn1
                       if( z( np-4 ) > z( np-2 ) )return
                       a2 = z( np-4 ) / z( np-2 )
                       if( z( nn-9 ) > z( nn-11 ) )return
                       b2 = z( nn-9 ) / z( nn-11 )
                       np = nn - 13
                    end if
                    ! approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2
                    do i4 = np, 4*i0 - 1 + pp, -4
                       if( b2==zero )go to 20
                       b1 = b2
                       if( z( i4 ) > z( i4-2 ) )return
                       b2 = b2*( z( i4 ) / z( i4-2 ) )
                       a2 = a2 + b2
                       if( hundrd*max( b2, b1 )<a2 .or. cnst1<a2 )go to 20
                    end do
                    20 continue
                    a2 = cnst3*a2
                    ! rayleigh quotient residual bound.
                    if( a2<cnst1 )s = gam*( one-sqrt( a2 ) ) / ( one+a2 )
                 end if
              else if( dmin==dn2 ) then
                 ! case 5.
                 ttype = -5
                 s = qurtr*dmin
                 ! compute contribution to norm squared from i > nn-2.
                 np = nn - 2*pp
                 b1 = z( np-2 )
                 b2 = z( np-6 )
                 gam = dn2
                 if( z( np-8 )>b2 .or. z( np-4 )>b1 )return
                 a2 = ( z( np-8 ) / b2 )*( one+z( np-4 ) / b1 )
                 ! approximate contribution to norm squared from i < nn-2.
                 if( n0-i0>2 ) then
                    b2 = z( nn-13 ) / z( nn-15 )
                    a2 = a2 + b2
                    do i4 = nn - 17, 4*i0 - 1 + pp, -4
                       if( b2==zero )go to 40
                       b1 = b2
                       if( z( i4 ) > z( i4-2 ) )return
                       b2 = b2*( z( i4 ) / z( i4-2 ) )
                       a2 = a2 + b2
                       if( hundrd*max( b2, b1 )<a2 .or. cnst1<a2 )go to 40
                    end do
                    40 continue
                    a2 = cnst3*a2
                 end if
                 if( a2<cnst1 )s = gam*( one-sqrt( a2 ) ) / ( one+a2 )
              else
                 ! case 6, no information to guide us.
                 if( ttype==-6 ) then
                    g = g + third*( one-g )
                 else if( ttype==-18 ) then
                    g = qurtr*third
                 else
                    g = qurtr
                 end if
                 s = g*dmin
                 ttype = -6
              end if
           else if( n0in==( n0+1 ) ) then
              ! one eigenvalue just deflated. use dmin1, dn1 for dmin and dn.
              if( dmin1==dn1 .and. dmin2==dn2 ) then
                 ! cases 7 and 8.
                 ttype = -7
                 s = third*dmin1
                 if( z( nn-5 )>z( nn-7 ) )return
                 b1 = z( nn-5 ) / z( nn-7 )
                 b2 = b1
                 if( b2==zero )go to 60
                 do i4 = 4*n0 - 9 + pp, 4*i0 - 1 + pp, -4
                    a2 = b1
                    if( z( i4 )>z( i4-2 ) )return
                    b1 = b1*( z( i4 ) / z( i4-2 ) )
                    b2 = b2 + b1
                    if( hundrd*max( b1, a2 )<b2 )go to 60
                 end do
                 60 continue
                 b2 = sqrt( cnst3*b2 )
                 a2 = dmin1 / ( one+b2**2 )
                 gap2 = half*dmin2 - a2
                 if( gap2>zero .and. gap2>b2*a2 ) then
                    s = max( s, a2*( one-cnst2*a2*( b2 / gap2 )*b2 ) )
                 else
                    s = max( s, a2*( one-cnst2*b2 ) )
                    ttype = -8
                 end if
              else
                 ! case 9.
                 s = qurtr*dmin1
                 if( dmin1==dn1 )s = half*dmin1
                 ttype = -9
              end if
           else if( n0in==( n0+2 ) ) then
              ! two eigenvalues deflated. use dmin2, dn2 for dmin and dn.
              ! cases 10 and 11.
              if( dmin2==dn2 .and. two*z( nn-5 )<z( nn-7 ) ) then
                 ttype = -10
                 s = third*dmin2
                 if( z( nn-5 )>z( nn-7 ) )return
                 b1 = z( nn-5 ) / z( nn-7 )
                 b2 = b1
                 if( b2==zero )go to 80
                 do i4 = 4*n0 - 9 + pp, 4*i0 - 1 + pp, -4
                    if( z( i4 )>z( i4-2 ) )return
                    b1 = b1*( z( i4 ) / z( i4-2 ) )
                    b2 = b2 + b1
                    if( hundrd*b1<b2 )go to 80
                 end do
                 80 continue
                 b2 = sqrt( cnst3*b2 )
                 a2 = dmin2 / ( one+b2**2 )
                 gap2 = z( nn-7 ) + z( nn-9 ) -sqrt( z( nn-11 ) )*sqrt( z( nn-9 ) ) - a2
                 if( gap2>zero .and. gap2>b2*a2 ) then
                    s = max( s, a2*( one-cnst2*a2*( b2 / gap2 )*b2 ) )
                 else
                    s = max( s, a2*( one-cnst2*b2 ) )
                 end if
              else
                 s = qurtr*dmin2
                 ttype = -11
              end if
           else if( n0in>( n0+2 ) ) then
              ! case 12, more than two eigenvalues deflated. no information.
              s = zero
              ttype = -12
           end if
           tau = s
           return
     end subroutine stdlib_${ri}$lasq4


     pure subroutine stdlib_${ri}$lasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, dnm2, &
     !! DLASQ5: computes one dqds transform in ping-pong form, one
     !! version for IEEE machines another for non IEEE machines.
               ieee, eps )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: ieee
           integer(ilp), intent(in) :: i0, n0, pp
           real(${rk}$), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(${rk}$), intent(inout) :: tau
           real(${rk}$), intent(in) :: sigma, eps
           ! Array Arguments 
           real(${rk}$), intent(inout) :: z(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j4, j4p2
           real(${rk}$) :: d, emin, temp, dthresh
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( ( n0-i0-1 )<=0 )return
           dthresh = eps*(sigma+tau)
           if( tau<dthresh*half ) tau = zero
           if( tau/=zero ) then
           j4 = 4*i0 + pp - 3
           emin = z( j4+4 )
           d = z( j4 ) - tau
           dmin = d
           dmin1 = -z( j4 )
           if( ieee ) then
              ! code for ieee arithmetic.
              if( pp==0 ) then
                 do j4 = 4*i0, 4*( n0-3 ), 4
                    z( j4-2 ) = d + z( j4-1 )
                    temp = z( j4+1 ) / z( j4-2 )
                    d = d*temp - tau
                    dmin = min( dmin, d )
                    z( j4 ) = z( j4-1 )*temp
                    emin = min( z( j4 ), emin )
                 end do
              else
                 do j4 = 4*i0, 4*( n0-3 ), 4
                    z( j4-3 ) = d + z( j4 )
                    temp = z( j4+2 ) / z( j4-3 )
                    d = d*temp - tau
                    dmin = min( dmin, d )
                    z( j4-1 ) = z( j4 )*temp
                    emin = min( z( j4-1 ), emin )
                 end do
              end if
              ! unroll last two steps.
              dnm2 = d
              dmin2 = dmin
              j4 = 4*( n0-2 ) - pp
              j4p2 = j4 + 2*pp - 1
              z( j4-2 ) = dnm2 + z( j4p2 )
              z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
              dnm1 = z( j4p2+2 )*( dnm2 / z( j4-2 ) ) - tau
              dmin = min( dmin, dnm1 )
              dmin1 = dmin
              j4 = j4 + 4
              j4p2 = j4 + 2*pp - 1
              z( j4-2 ) = dnm1 + z( j4p2 )
              z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
              dn = z( j4p2+2 )*( dnm1 / z( j4-2 ) ) - tau
              dmin = min( dmin, dn )
           else
              ! code for non ieee arithmetic.
              if( pp==0 ) then
                 do j4 = 4*i0, 4*( n0-3 ), 4
                    z( j4-2 ) = d + z( j4-1 )
                    if( d<zero ) then
                       return
                    else
                       z( j4 ) = z( j4+1 )*( z( j4-1 ) / z( j4-2 ) )
                       d = z( j4+1 )*( d / z( j4-2 ) ) - tau
                    end if
                    dmin = min( dmin, d )
                    emin = min( emin, z( j4 ) )
                 end do
              else
                 do j4 = 4*i0, 4*( n0-3 ), 4
                    z( j4-3 ) = d + z( j4 )
                    if( d<zero ) then
                       return
                    else
                       z( j4-1 ) = z( j4+2 )*( z( j4 ) / z( j4-3 ) )
                       d = z( j4+2 )*( d / z( j4-3 ) ) - tau
                    end if
                    dmin = min( dmin, d )
                    emin = min( emin, z( j4-1 ) )
                 end do
              end if
              ! unroll last two steps.
              dnm2 = d
              dmin2 = dmin
              j4 = 4*( n0-2 ) - pp
              j4p2 = j4 + 2*pp - 1
              z( j4-2 ) = dnm2 + z( j4p2 )
              if( dnm2<zero ) then
                 return
              else
                 z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
                 dnm1 = z( j4p2+2 )*( dnm2 / z( j4-2 ) ) - tau
              end if
              dmin = min( dmin, dnm1 )
              dmin1 = dmin
              j4 = j4 + 4
              j4p2 = j4 + 2*pp - 1
              z( j4-2 ) = dnm1 + z( j4p2 )
              if( dnm1<zero ) then
                 return
              else
                 z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
                 dn = z( j4p2+2 )*( dnm1 / z( j4-2 ) ) - tau
              end if
              dmin = min( dmin, dn )
           end if
           else
           ! this is the version that sets d's to zero if they are small enough
              j4 = 4*i0 + pp - 3
              emin = z( j4+4 )
              d = z( j4 ) - tau
              dmin = d
              dmin1 = -z( j4 )
              if( ieee ) then
           ! code for ieee arithmetic.
                 if( pp==0 ) then
                    do j4 = 4*i0, 4*( n0-3 ), 4
                       z( j4-2 ) = d + z( j4-1 )
                       temp = z( j4+1 ) / z( j4-2 )
                       d = d*temp - tau
                       if( d<dthresh ) d = zero
                       dmin = min( dmin, d )
                       z( j4 ) = z( j4-1 )*temp
                       emin = min( z( j4 ), emin )
                    end do
                 else
                    do j4 = 4*i0, 4*( n0-3 ), 4
                       z( j4-3 ) = d + z( j4 )
                       temp = z( j4+2 ) / z( j4-3 )
                       d = d*temp - tau
                       if( d<dthresh ) d = zero
                       dmin = min( dmin, d )
                       z( j4-1 ) = z( j4 )*temp
                       emin = min( z( j4-1 ), emin )
                    end do
                 end if
           ! unroll last two steps.
                 dnm2 = d
                 dmin2 = dmin
                 j4 = 4*( n0-2 ) - pp
                 j4p2 = j4 + 2*pp - 1
                 z( j4-2 ) = dnm2 + z( j4p2 )
                 z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
                 dnm1 = z( j4p2+2 )*( dnm2 / z( j4-2 ) ) - tau
                 dmin = min( dmin, dnm1 )
                 dmin1 = dmin
                 j4 = j4 + 4
                 j4p2 = j4 + 2*pp - 1
                 z( j4-2 ) = dnm1 + z( j4p2 )
                 z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
                 dn = z( j4p2+2 )*( dnm1 / z( j4-2 ) ) - tau
                 dmin = min( dmin, dn )
              else
           ! code for non ieee arithmetic.
                 if( pp==0 ) then
                    do j4 = 4*i0, 4*( n0-3 ), 4
                       z( j4-2 ) = d + z( j4-1 )
                       if( d<zero ) then
                          return
                       else
                          z( j4 ) = z( j4+1 )*( z( j4-1 ) / z( j4-2 ) )
                          d = z( j4+1 )*( d / z( j4-2 ) ) - tau
                       end if
                       if( d<dthresh) d = zero
                       dmin = min( dmin, d )
                       emin = min( emin, z( j4 ) )
                    end do
                 else
                    do j4 = 4*i0, 4*( n0-3 ), 4
                       z( j4-3 ) = d + z( j4 )
                       if( d<zero ) then
                          return
                       else
                          z( j4-1 ) = z( j4+2 )*( z( j4 ) / z( j4-3 ) )
                          d = z( j4+2 )*( d / z( j4-3 ) ) - tau
                       end if
                       if( d<dthresh) d = zero
                       dmin = min( dmin, d )
                       emin = min( emin, z( j4-1 ) )
                    end do
                 end if
           ! unroll last two steps.
                 dnm2 = d
                 dmin2 = dmin
                 j4 = 4*( n0-2 ) - pp
                 j4p2 = j4 + 2*pp - 1
                 z( j4-2 ) = dnm2 + z( j4p2 )
                 if( dnm2<zero ) then
                    return
                 else
                    z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
                    dnm1 = z( j4p2+2 )*( dnm2 / z( j4-2 ) ) - tau
                 end if
                 dmin = min( dmin, dnm1 )
                 dmin1 = dmin
                 j4 = j4 + 4
                 j4p2 = j4 + 2*pp - 1
                 z( j4-2 ) = dnm1 + z( j4p2 )
                 if( dnm1<zero ) then
                    return
                 else
                    z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
                    dn = z( j4p2+2 )*( dnm1 / z( j4-2 ) ) - tau
                 end if
                 dmin = min( dmin, dn )
              end if
           end if
           z( j4+2 ) = dn
           z( 4*n0-pp ) = emin
           return
     end subroutine stdlib_${ri}$lasq5


     pure subroutine stdlib_${ri}$lasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
     !! DLASQ6: computes one dqd (shift equal to zero) transform in
     !! ping-pong form, with protection against underflow and overflow.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i0, n0, pp
           real(${rk}$), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           ! Array Arguments 
           real(${rk}$), intent(inout) :: z(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j4, j4p2
           real(${rk}$) :: d, emin, safmin, temp
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( ( n0-i0-1 )<=0 )return
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           j4 = 4*i0 + pp - 3
           emin = z( j4+4 )
           d = z( j4 )
           dmin = d
           if( pp==0 ) then
              do j4 = 4*i0, 4*( n0-3 ), 4
                 z( j4-2 ) = d + z( j4-1 )
                 if( z( j4-2 )==zero ) then
                    z( j4 ) = zero
                    d = z( j4+1 )
                    dmin = d
                    emin = zero
                 else if( safmin*z( j4+1 )<z( j4-2 ) .and.safmin*z( j4-2 )<z( j4+1 ) ) &
                           then
                    temp = z( j4+1 ) / z( j4-2 )
                    z( j4 ) = z( j4-1 )*temp
                    d = d*temp
                 else
                    z( j4 ) = z( j4+1 )*( z( j4-1 ) / z( j4-2 ) )
                    d = z( j4+1 )*( d / z( j4-2 ) )
                 end if
                 dmin = min( dmin, d )
                 emin = min( emin, z( j4 ) )
              end do
           else
              do j4 = 4*i0, 4*( n0-3 ), 4
                 z( j4-3 ) = d + z( j4 )
                 if( z( j4-3 )==zero ) then
                    z( j4-1 ) = zero
                    d = z( j4+2 )
                    dmin = d
                    emin = zero
                 else if( safmin*z( j4+2 )<z( j4-3 ) .and.safmin*z( j4-3 )<z( j4+2 ) ) &
                           then
                    temp = z( j4+2 ) / z( j4-3 )
                    z( j4-1 ) = z( j4 )*temp
                    d = d*temp
                 else
                    z( j4-1 ) = z( j4+2 )*( z( j4 ) / z( j4-3 ) )
                    d = z( j4+2 )*( d / z( j4-3 ) )
                 end if
                 dmin = min( dmin, d )
                 emin = min( emin, z( j4-1 ) )
              end do
           end if
           ! unroll last two steps.
           dnm2 = d
           dmin2 = dmin
           j4 = 4*( n0-2 ) - pp
           j4p2 = j4 + 2*pp - 1
           z( j4-2 ) = dnm2 + z( j4p2 )
           if( z( j4-2 )==zero ) then
              z( j4 ) = zero
              dnm1 = z( j4p2+2 )
              dmin = dnm1
              emin = zero
           else if( safmin*z( j4p2+2 )<z( j4-2 ) .and.safmin*z( j4-2 )<z( j4p2+2 ) ) then
              temp = z( j4p2+2 ) / z( j4-2 )
              z( j4 ) = z( j4p2 )*temp
              dnm1 = dnm2*temp
           else
              z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
              dnm1 = z( j4p2+2 )*( dnm2 / z( j4-2 ) )
           end if
           dmin = min( dmin, dnm1 )
           dmin1 = dmin
           j4 = j4 + 4
           j4p2 = j4 + 2*pp - 1
           z( j4-2 ) = dnm1 + z( j4p2 )
           if( z( j4-2 )==zero ) then
              z( j4 ) = zero
              dn = z( j4p2+2 )
              dmin = dn
              emin = zero
           else if( safmin*z( j4p2+2 )<z( j4-2 ) .and.safmin*z( j4-2 )<z( j4p2+2 ) ) then
              temp = z( j4p2+2 ) / z( j4-2 )
              z( j4 ) = z( j4p2 )*temp
              dn = dnm1*temp
           else
              z( j4 ) = z( j4p2+2 )*( z( j4p2 ) / z( j4-2 ) )
              dn = z( j4p2+2 )*( dnm1 / z( j4-2 ) )
           end if
           dmin = min( dmin, dn )
           z( j4+2 ) = dn
           z( 4*n0-pp ) = emin
           return
     end subroutine stdlib_${ri}$lasq6


     pure subroutine stdlib_${ri}$lasr( side, pivot, direct, m, n, c, s, a, lda )
     !! DLASR: applies a sequence of plane rotations to a real matrix A,
     !! from either the left or the right.
     !! When SIDE = 'L', the transformation takes the form
     !! A := P*A
     !! and when SIDE = 'R', the transformation takes the form
     !! A := A*P**T
     !! where P is an orthogonal matrix consisting of a sequence of z plane
     !! rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
     !! and P**T is the transpose of P.
     !! When DIRECT = 'F' (Forward sequence), then
     !! P = P(z-1) * ... * P(2) * P(1)
     !! and when DIRECT = 'B' (Backward sequence), then
     !! P = P(1) * P(2) * ... * P(z-1)
     !! where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
     !! R(k) = (  c(k)  s(k) )
     !! = ( -s(k)  c(k) ).
     !! When PIVOT = 'V' (Variable pivot), the rotation is performed
     !! for the plane (k,k+1), i.e., P(k) has the form
     !! P(k) = (  1                                            )
     !! (       ...                                     )
     !! (              1                                )
     !! (                   c(k)  s(k)                  )
     !! (                  -s(k)  c(k)                  )
     !! (                                1              )
     !! (                                     ...       )
     !! (                                            1  )
     !! where R(k) appears as a rank-2 modification to the identity matrix in
     !! rows and columns k and k+1.
     !! When PIVOT = 'T' (Top pivot), the rotation is performed for the
     !! plane (1,k+1), so P(k) has the form
     !! P(k) = (  c(k)                    s(k)                 )
     !! (         1                                     )
     !! (              ...                              )
     !! (                     1                         )
     !! ( -s(k)                    c(k)                 )
     !! (                                 1             )
     !! (                                      ...      )
     !! (                                             1 )
     !! where R(k) appears in rows and columns 1 and k+1.
     !! Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
     !! performed for the plane (k,z), giving P(k) the form
     !! P(k) = ( 1                                             )
     !! (      ...                                      )
     !! (             1                                 )
     !! (                  c(k)                    s(k) )
     !! (                         1                     )
     !! (                              ...              )
     !! (                                     1         )
     !! (                 -s(k)                    c(k) )
     !! where R(k) appears in rows and columns k and z.  The rotations are
     !! performed without ever forming P(k) explicitly.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, pivot, side
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: c(*), s(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, info, j
           real(${rk}$) :: ctemp, stemp, temp
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.( stdlib_lsame( side, 'L' ) .or. stdlib_lsame( side, 'R' ) ) ) then
              info = 1
           else if( .not.( stdlib_lsame( pivot, 'V' ) .or. stdlib_lsame( pivot,'T' ) .or. &
                     stdlib_lsame( pivot, 'B' ) ) ) then
              info = 2
           else if( .not.( stdlib_lsame( direct, 'F' ) .or. stdlib_lsame( direct, 'B' ) ) )&
                     then
              info = 3
           else if( m<0 ) then
              info = 4
           else if( n<0 ) then
              info = 5
           else if( lda<max( 1, m ) ) then
              info = 9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASR ', info )
              return
           end if
           ! quick return if possible
           if( ( m==0 ) .or. ( n==0 ) )return
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  p * a
              if( stdlib_lsame( pivot, 'V' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, m - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j+1, i )
                             a( j+1, i ) = ctemp*temp - stemp*a( j, i )
                             a( j, i ) = stemp*temp + ctemp*a( j, i )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = m - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j+1, i )
                             a( j+1, i ) = ctemp*temp - stemp*a( j, i )
                             a( j, i ) = stemp*temp + ctemp*a( j, i )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'T' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 2, m
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = ctemp*temp - stemp*a( 1, i )
                             a( 1, i ) = stemp*temp + ctemp*a( 1, i )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = m, 2, -1
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = ctemp*temp - stemp*a( 1, i )
                             a( 1, i ) = stemp*temp + ctemp*a( 1, i )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'B' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, m - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = stemp*a( m, i ) + ctemp*temp
                             a( m, i ) = ctemp*a( m, i ) - stemp*temp
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = m - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = stemp*a( m, i ) + ctemp*temp
                             a( m, i ) = ctemp*a( m, i ) - stemp*temp
                          end do
                       end if
                    end do
                 end if
              end if
           else if( stdlib_lsame( side, 'R' ) ) then
              ! form a * p**t
              if( stdlib_lsame( pivot, 'V' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, n - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j+1 )
                             a( i, j+1 ) = ctemp*temp - stemp*a( i, j )
                             a( i, j ) = stemp*temp + ctemp*a( i, j )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = n - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j+1 )
                             a( i, j+1 ) = ctemp*temp - stemp*a( i, j )
                             a( i, j ) = stemp*temp + ctemp*a( i, j )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'T' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 2, n
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = ctemp*temp - stemp*a( i, 1 )
                             a( i, 1 ) = stemp*temp + ctemp*a( i, 1 )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = n, 2, -1
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = ctemp*temp - stemp*a( i, 1 )
                             a( i, 1 ) = stemp*temp + ctemp*a( i, 1 )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'B' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, n - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = stemp*a( i, n ) + ctemp*temp
                             a( i, n ) = ctemp*a( i, n ) - stemp*temp
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = n - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = stemp*a( i, n ) + ctemp*temp
                             a( i, n ) = ctemp*a( i, n ) - stemp*temp
                          end do
                       end if
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$lasr


     pure subroutine stdlib_${ri}$lasrt( id, n, d, info )
     !! Sort the numbers in D in increasing order (if ID = 'I') or
     !! in decreasing order (if ID = 'D' ).
     !! Use Quick Sort, reverting to Insertion sort on arrays of
     !! size <= 20. Dimension of STACK limits N to about 2**32.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: id
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: select = 20
           
           ! Local Scalars 
           integer(ilp) :: dir, endd, i, j, start, stkpnt
           real(${rk}$) :: d1, d2, d3, dmnmx, tmp
           ! Local Arrays 
           integer(ilp) :: stack(2,32)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           dir = -1
           if( stdlib_lsame( id, 'D' ) ) then
              dir = 0
           else if( stdlib_lsame( id, 'I' ) ) then
              dir = 1
           end if
           if( dir==-1 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLASRT', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           stkpnt = 1
           stack( 1, 1 ) = 1
           stack( 2, 1 ) = n
           10 continue
           start = stack( 1, stkpnt )
           endd = stack( 2, stkpnt )
           stkpnt = stkpnt - 1
           if( endd-start<=select .and. endd-start>0 ) then
              ! do insertion sort on d( start:endd )
              if( dir==0 ) then
                 ! sort into decreasing order
                 loop_30: do i = start + 1, endd
                    do j = i, start + 1, -1
                       if( d( j )>d( j-1 ) ) then
                          dmnmx = d( j )
                          d( j ) = d( j-1 )
                          d( j-1 ) = dmnmx
                       else
                          cycle loop_30
                       end if
                    end do
                 end do loop_30
              else
                 ! sort into increasing order
                 loop_50: do i = start + 1, endd
                    do j = i, start + 1, -1
                       if( d( j )<d( j-1 ) ) then
                          dmnmx = d( j )
                          d( j ) = d( j-1 )
                          d( j-1 ) = dmnmx
                       else
                          cycle loop_50
                       end if
                    end do
                 end do loop_50
              end if
           else if( endd-start>select ) then
              ! partition d( start:endd ) and stack parts, largest one first
              ! choose partition entry as median of 3
              d1 = d( start )
              d2 = d( endd )
              i = ( start+endd ) / 2
              d3 = d( i )
              if( d1<d2 ) then
                 if( d3<d1 ) then
                    dmnmx = d1
                 else if( d3<d2 ) then
                    dmnmx = d3
                 else
                    dmnmx = d2
                 end if
              else
                 if( d3<d2 ) then
                    dmnmx = d2
                 else if( d3<d1 ) then
                    dmnmx = d3
                 else
                    dmnmx = d1
                 end if
              end if
              if( dir==0 ) then
                 ! sort into decreasing order
                 i = start - 1
                 j = endd + 1
                 60 continue
                 70 continue
                 j = j - 1
                 if( d( j )<dmnmx )go to 70
                 80 continue
                 i = i + 1
                 if( d( i )>dmnmx )go to 80
                 if( i<j ) then
                    tmp = d( i )
                    d( i ) = d( j )
                    d( j ) = tmp
                    go to 60
                 end if
                 if( j-start>endd-j-1 ) then
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = start
                    stack( 2, stkpnt ) = j
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = j + 1
                    stack( 2, stkpnt ) = endd
                 else
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = j + 1
                    stack( 2, stkpnt ) = endd
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = start
                    stack( 2, stkpnt ) = j
                 end if
              else
                 ! sort into increasing order
                 i = start - 1
                 j = endd + 1
                 90 continue
                 100 continue
                 j = j - 1
                 if( d( j )>dmnmx )go to 100
                 110 continue
                 i = i + 1
                 if( d( i )<dmnmx )go to 110
                 if( i<j ) then
                    tmp = d( i )
                    d( i ) = d( j )
                    d( j ) = tmp
                    go to 90
                 end if
                 if( j-start>endd-j-1 ) then
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = start
                    stack( 2, stkpnt ) = j
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = j + 1
                    stack( 2, stkpnt ) = endd
                 else
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = j + 1
                    stack( 2, stkpnt ) = endd
                    stkpnt = stkpnt + 1
                    stack( 1, stkpnt ) = start
                    stack( 2, stkpnt ) = j
                 end if
              end if
           end if
           if( stkpnt>0 )go to 10
           return
     end subroutine stdlib_${ri}$lasrt


     pure subroutine stdlib_${ri}$lassq( n, x, incx, scl, sumsq )
     !! DLASSQ:  returns the values  scl  and  smsq  such that
     !! ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
     !! where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
     !! assumed to be non-negative.
     !! scale and sumsq must be supplied in SCALE and SUMSQ and
     !! scl and smsq are overwritten on SCALE and SUMSQ respectively.
     !! If scale * sqrt( sumsq ) > tbig then
     !! we require:   scale >= sqrt( TINY*EPS ) / sbig   on entry,
     !! and if 0 < scale * sqrt( sumsq ) < tsml then
     !! we require:   scale <= sqrt( HUGE ) / ssml       on entry,
     !! where
     !! tbig -- upper threshold for values whose square is representable;
     !! sbig -- scaling constant for big numbers; \see la_constants.f90
     !! tsml -- lower threshold for values whose square is representable;
     !! ssml -- scaling constant for small numbers; \see la_constants.f90
     !! and
     !! TINY*EPS -- tiniest representable number;
     !! HUGE     -- biggest representable number.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
        ! Scalar Arguments 
     integer(ilp), intent(in) :: incx, n
        real(${rk}$), intent(inout) :: scl, sumsq
        ! Array Arguments 
        real(${rk}$), intent(in) :: x(*)
        ! Local Scalars 
     integer(ilp) :: i, ix
     logical(lk) :: notbig
        real(${rk}$) :: abig, amed, asml, ax, ymax, ymin
        ! quick return if possible
        if( ieee_is_nan(scl) .or. ieee_is_nan(sumsq) ) return
        if( sumsq == zero ) scl = one
        if( scl == zero ) then
           scl = one
           sumsq = zero
        end if
        if (n <= 0) then
           return
        end if
        ! compute the sum of squares in 3 accumulators:
           ! abig -- sums of squares scaled down to avoid overflow
           ! asml -- sums of squares scaled up to avoid underflow
           ! amed -- sums of squares that do not require scaling
        ! the thresholds and multipliers are
           ! tbig -- values bigger than this are scaled down by sbig
           ! tsml -- values smaller than this are scaled up by ssml
        notbig = .true.
        asml = zero
        amed = zero
        abig = zero
        ix = 1
        if( incx < 0 ) ix = 1 - (n-1)*incx
        do i = 1, n
           ax = abs(x(ix))
           if (ax > tbig) then
              abig = abig + (ax*sbig)**2
              notbig = .false.
           else if (ax < tsml) then
              if (notbig) asml = asml + (ax*ssml)**2
           else
              amed = amed + ax**2
           end if
           ix = ix + incx
        end do
        ! put the existing sum of squares into one of the accumulators
        if( sumsq > zero ) then
           ax = scl*sqrt( sumsq )
           if (ax > tbig) then
              ! we assume scl >= sqrt( tiny*eps ) / sbig
              abig = abig + (scl*sbig)**2 * sumsq
           else if (ax < tsml) then
              ! we assume scl <= sqrt( huge ) / ssml
              if (notbig) asml = asml + (scl*ssml)**2 * sumsq
           else
              amed = amed + scl**2 * sumsq
           end if
        end if
        ! combine abig and amed or amed and asml if more than one
        ! accumulator was used.
        if (abig > zero) then
           ! combine abig and amed if abig > 0.
           if (amed > zero .or. ieee_is_nan(amed)) then
              abig = abig + (amed*sbig)*sbig
           end if
           scl = one / sbig
           sumsq = abig
        else if (asml > zero) then
           ! combine amed and asml if asml > 0.
           if (amed > zero .or. ieee_is_nan(amed)) then
              amed = sqrt(amed)
              asml = sqrt(asml) / ssml
              if (asml > amed) then
                 ymin = amed
                 ymax = asml
              else
                 ymin = asml
                 ymax = amed
              end if
              scl = one
              sumsq = ymax**2*( one + (ymin/ymax)**2 )
           else
              scl = one / ssml
              sumsq = asml
           end if
        else
           ! otherwise all values are mid-range or zero
           scl = one
           sumsq = amed
        end if
        return
     end subroutine stdlib_${ri}$lassq


     pure subroutine stdlib_${ri}$lasv2( f, g, h, ssmin, ssmax, snr, csr, snl, csl )
     !! DLASV2: computes the singular value decomposition of a 2-by-2
     !! triangular matrix
     !! [  F   G  ]
     !! [  0   H  ].
     !! On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
     !! smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
     !! right singular vectors for abs(SSMAX), giving the decomposition
     !! [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
     !! [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(out) :: csl, csr, snl, snr, ssmax, ssmin
           real(${rk}$), intent(in) :: f, g, h
       ! =====================================================================
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: gasmal, swap
           integer(ilp) :: pmax
           real(${rk}$) :: a, clt, crt, d, fa, ft, ga, gt, ha, ht, l, m, mm, r, s, slt, srt, t, temp, &
                     tsign, tt
           ! Intrinsic Functions 
           intrinsic :: abs,sign,sqrt
           ! Executable Statements 
           ft = f
           fa = abs( ft )
           ht = h
           ha = abs( h )
           ! pmax points to the maximum absolute element of matrix
             ! pmax = 1 if f largest in absolute values
             ! pmax = 2 if g largest in absolute values
             ! pmax = 3 if h largest in absolute values
           pmax = 1
           swap = ( ha>fa )
           if( swap ) then
              pmax = 3
              temp = ft
              ft = ht
              ht = temp
              temp = fa
              fa = ha
              ha = temp
              ! now fa .ge. ha
           end if
           gt = g
           ga = abs( gt )
           if( ga==zero ) then
              ! diagonal matrix
              ssmin = ha
              ssmax = fa
              clt = one
              crt = one
              slt = zero
              srt = zero
           else
              gasmal = .true.
              if( ga>fa ) then
                 pmax = 2
                 if( ( fa / ga )<stdlib_${ri}$lamch( 'EPS' ) ) then
                    ! case of very large ga
                    gasmal = .false.
                    ssmax = ga
                    if( ha>one ) then
                       ssmin = fa / ( ga / ha )
                    else
                       ssmin = ( fa / ga )*ha
                    end if
                    clt = one
                    slt = ht / gt
                    srt = one
                    crt = ft / gt
                 end if
              end if
              if( gasmal ) then
                 ! normal case
                 d = fa - ha
                 if( d==fa ) then
                    ! copes with infinite f or h
                    l = one
                 else
                    l = d / fa
                 end if
                 ! note that 0 .le. l .le. 1
                 m = gt / ft
                 ! note that abs(m) .le. 1/macheps
                 t = two - l
                 ! note that t .ge. 1
                 mm = m*m
                 tt = t*t
                 s = sqrt( tt+mm )
                 ! note that 1 .le. s .le. 1 + 1/macheps
                 if( l==zero ) then
                    r = abs( m )
                 else
                    r = sqrt( l*l+mm )
                 end if
                 ! note that 0 .le. r .le. 1 + 1/macheps
                 a = half*( s+r )
                 ! note that 1 .le. a .le. 1 + abs(m)
                 ssmin = ha / a
                 ssmax = fa*a
                 if( mm==zero ) then
                    ! note that m is very tiny
                    if( l==zero ) then
                       t = sign( two, ft )*sign( one, gt )
                    else
                       t = gt / sign( d, ft ) + m / t
                    end if
                 else
                    t = ( m / ( s+t )+m / ( r+l ) )*( one+a )
                 end if
                 l = sqrt( t*t+four )
                 crt = two / l
                 srt = t / l
                 clt = ( crt+srt*m ) / a
                 slt = ( ht / ft )*srt / a
              end if
           end if
           if( swap ) then
              csl = srt
              snl = crt
              csr = slt
              snr = clt
           else
              csl = clt
              snl = slt
              csr = crt
              snr = srt
           end if
           ! correct signs of ssmax and ssmin
           if( pmax==1 )tsign = sign( one, csr )*sign( one, csl )*sign( one, f )
           if( pmax==2 )tsign = sign( one, snr )*sign( one, csl )*sign( one, g )
           if( pmax==3 )tsign = sign( one, snr )*sign( one, snl )*sign( one, h )
           ssmax = sign( ssmax, tsign )
           ssmin = sign( ssmin, tsign*sign( one, f )*sign( one, h ) )
           return
     end subroutine stdlib_${ri}$lasv2


     pure subroutine stdlib_${ri}$laswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
     !! DLASWLQ: computes a blocked Tall-Skinny LQ factorization of
     !! a real M-by-N matrix A for M <= N:
     !! A = ( L 0 ) *  Q,
     !! where:
     !! Q is a n-by-N orthogonal matrix, stored on exit in an implicit
     !! form in the elements above the diagonal of the array A and in
     !! the elements of the array T;
     !! L is a lower-triangular M-by-M matrix stored on exit in
     !! the elements on and below the diagonal of the array A.
     !! 0 is a M-by-(N-M) zero matrix, if M < N, and is not stored.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, mb, nb, lwork, ldt
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ii, kk, ctr
           ! External Subroutines 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
             info = -1
           else if( n<0 .or. n<m ) then
             info = -2
           else if( mb<1 .or. ( mb>m .and. m>0 )) then
             info = -3
           else if( nb<0 ) then
             info = -4
           else if( lda<max( 1, m ) ) then
             info = -6
           else if( ldt<mb ) then
             info = -8
           else if( ( lwork<m*mb) .and. (.not.lquery) ) then
             info = -10
           end if
           if( info==0)  then
           work(1) = mb*m
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DLASWLQ', -info )
             return
           else if (lquery) then
            return
           end if
           ! quick return if possible
           if( min(m,n)==0 ) then
               return
           end if
           ! the lq decomposition
            if((m>=n).or.(nb<=m).or.(nb>=n)) then
             call stdlib_${ri}$gelqt( m, n, mb, a, lda, t, ldt, work, info)
             return
            end if
            kk = mod((n-m),(nb-m))
            ii=n-kk+1
            ! compute the lq factorization of the first block a(1:m,1:nb)
            call stdlib_${ri}$gelqt( m, nb, mb, a(1,1), lda, t, ldt, work, info)
            ctr = 1
            do i = nb+1, ii-nb+m , (nb-m)
            ! compute the qr factorization of the current block a(1:m,i:i+nb-m)
              call stdlib_${ri}$tplqt( m, nb-m, 0, mb, a(1,1), lda, a( 1, i ),lda, t(1, ctr * m + 1),&
                        ldt, work, info )
              ctr = ctr + 1
            end do
           ! compute the qr factorization of the last block a(1:m,ii:n)
            if (ii<=n) then
             call stdlib_${ri}$tplqt( m, kk, 0, mb, a(1,1), lda, a( 1, ii ),lda, t(1, ctr * m + 1), &
                       ldt,work, info )
            end if
           work( 1 ) = m * mb
           return
     end subroutine stdlib_${ri}$laswlq


     pure subroutine stdlib_${ri}$laswp( n, a, lda, k1, k2, ipiv, incx )
     !! DLASWP: performs a series of row interchanges on the matrix A.
     !! One row interchange is initiated for each of rows K1 through K2 of A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, k1, k2, lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, i1, i2, inc, ip, ix, ix0, j, k, n32
           real(${rk}$) :: temp
           ! Executable Statements 
           ! interchange row i with row ipiv(k1+(i-k1)*abs(incx)) for each of rows
           ! k1 through k2.
           if( incx>0 ) then
              ix0 = k1
              i1 = k1
              i2 = k2
              inc = 1
           else if( incx<0 ) then
              ix0 = k1 + ( k1-k2 )*incx
              i1 = k2
              i2 = k1
              inc = -1
           else
              return
           end if
           n32 = ( n / 32 )*32
           if( n32/=0 ) then
              do j = 1, n32, 32
                 ix = ix0
                 do i = i1, i2, inc
                    ip = ipiv( ix )
                    if( ip/=i ) then
                       do k = j, j + 31
                          temp = a( i, k )
                          a( i, k ) = a( ip, k )
                          a( ip, k ) = temp
                       end do
                    end if
                    ix = ix + incx
                 end do
              end do
           end if
           if( n32/=n ) then
              n32 = n32 + 1
              ix = ix0
              do i = i1, i2, inc
                 ip = ipiv( ix )
                 if( ip/=i ) then
                    do k = n32, n
                       temp = a( i, k )
                       a( i, k ) = a( ip, k )
                       a( ip, k ) = temp
                    end do
                 end if
                 ix = ix + incx
              end do
           end if
           return
     end subroutine stdlib_${ri}$laswp


     pure subroutine stdlib_${ri}$lasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! DLASY2: solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(${rk}$), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(${rk}$), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(${rk}$) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(${rk}$) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_i${ri}$amax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_${ri}$copy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_${ri}$swap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_${ri}$swap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_${ri}$lasy2


     pure subroutine stdlib_${ri}$lasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! DLASYF: computes a partial factorization of a real symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(${rk}$) :: absakk, alpha, colmax, d11, d21, d22, r1, rowmax, t
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_${ri}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ), lda,w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_${ri}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_${ri}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( &
                              imax, kw+1 ), ldw, one,w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_i${ri}$amax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = abs( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ri}$amax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_${ri}$copy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_${ri}$copy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ri}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_${ri}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = one / a( k, k )
                    call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k, -one,a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw, one,a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_${ri}$swap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_${ri}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ), lda,w( k, 1 ), ldw, &
                        one, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_${ri}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_${ri}$copy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, one, w( k, k+1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_i${ri}$amax( imax-k, w( k, k+1 ), 1 )
                    rowmax = abs( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ri}$amax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_${ri}$copy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_${ri}$copy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ri}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = one / a( k, k )
                       call stdlib_${ri}$scal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_${ri}$swap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ri}$lasyf


     pure subroutine stdlib_${ri}$lasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a real symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), h(ldh,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           real(${rk}$) :: piv, alpha
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_${ri}$sytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( 1, j ), 1,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_${ri}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_${ri}$axpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_${ri}$axpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_i${ri}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ri}$swap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_${ri}$swap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_${ri}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ri}$swap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_${ri}$copy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=zero ) then
                       alpha = one / a( k, j+1 )
                       call stdlib_${ri}$copy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_${ri}$scal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_${ri}$laset( 'FULL', 1, m-j-1, zero, zero,a( k, j+2 ), lda)
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_${ri}$sytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( j, 1 ), lda,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_${ri}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_${ri}$axpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_${ri}$axpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_i${ri}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ri}$swap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_${ri}$swap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_${ri}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ri}$swap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_${ri}$copy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=zero ) then
                       alpha = one / a( j+1, k )
                       call stdlib_${ri}$copy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_${ri}$scal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_${ri}$laset( 'FULL', m-j-1, 1, zero, zero,a( j+2, k ), lda )
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_${ri}$lasyf_aa


     pure subroutine stdlib_${ri}$lasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! DLASYF_RK: computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF_RK is an auxiliary routine called by DSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, dtemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_${ri}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_${ri}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_${ri}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = abs( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_${ri}$copy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_${ri}$swap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ri}$copy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_${ri}$swap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = zero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, one, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_${ri}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ri}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ri}$copy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = abs( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_${ri}$copy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_${ri}$swap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_${ri}$copy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_${ri}$swap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = zero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ),ldw, one, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ri}$lasyf_rk


     pure subroutine stdlib_${ri}$lasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! DLASYF_ROOK: computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF_ROOK is an auxiliary routine called by DSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, dtemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_${ri}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_${ri}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_${ri}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = abs( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_${ri}$copy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_${ri}$swap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ri}$copy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_${ri}$swap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,one, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_${ri}$swap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_${ri}$swap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_${ri}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ri}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ri}$copy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = abs( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_${ri}$copy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_${ri}$swap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_${ri}$copy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_${ri}$swap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_${ri}$swap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_${ri}$swap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ri}$lasyf_rook


     pure subroutine stdlib_${ri}$lat2s( uplo, n, a, lda, sa, ldsa, info )
     !! DLAT2S: converts a DOUBLE PRECISION triangular matrix, SA, to a SINGLE
     !! PRECISION triangular matrix, A.
     !! RMAX is the overflow for the SINGLE PRECISION arithmetic
     !! DLAS2S checks that all the entries of A are between -RMAX and
     !! RMAX. If not the conversion is aborted and a flag is raised.
     !! This is an auxiliary routine so there is no argument checking.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldsa, n
           ! Array Arguments 
           real(dp), intent(out) :: sa(ldsa,*)
           real(${rk}$), intent(in) :: a(lda,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: rmax
           logical(lk) :: upper
           ! Executable Statements 
           rmax = stdlib_dlamch( 'O' )
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
              do j = 1, n
                 do i = 1, j
                    if( ( a( i, j )<-rmax ) .or. ( a( i, j )>rmax ) )then
                       info = 1
                       go to 50
                    end if
                    sa( i, j ) = a( i, j )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    if( ( a( i, j )<-rmax ) .or. ( a( i, j )>rmax ) )then
                       info = 1
                       go to 50
                    end if
                    sa( i, j ) = a( i, j )
                 end do
              end do
           end if
           50 continue
           return
     end subroutine stdlib_${ri}$lat2s


     pure subroutine stdlib_${ri}$latbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm, &
     !! DLATBS: solves one of the triangular systems
     !! A *x = s*b  or  A**T*x = s*b
     !! with scaling to prevent overflow, where A is an upper or lower
     !! triangular band matrix.  Here A**T denotes the transpose of A, x and b
     !! are n-element vectors, and s is a scaling factor, usually less than
     !! or equal to 1, chosen so that the components of x will be less than
     !! the overflow threshold.  If the unscaled problem will not cause
     !! overflow, the Level 2 BLAS routine DTBSV is called.  If the matrix A
     !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
     !! non-trivial solution to A*x = 0 is returned.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, normin, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(inout) :: cnorm(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           integer(ilp) :: i, imax, j, jfirst, jinc, jlast, jlen, maind
           real(${rk}$) :: bignum, grow, rec, smlnum, sumj, tjj, tjjs, tmax, tscal, uscal, xbnd, xj, &
                     xmax
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           ! test the input parameters.
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( .not.stdlib_lsame( normin, 'Y' ) .and. .not.stdlib_lsame( normin, 'N' ) ) &
                     then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( kd<0 ) then
              info = -6
           else if( ldab<kd+1 ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLATBS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine machine dependent parameters to control overflow.
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           bignum = one / smlnum
           scale = one
           if( stdlib_lsame( normin, 'N' ) ) then
              ! compute the 1-norm of each column, not including the diagonal.
              if( upper ) then
                 ! a is upper triangular.
                 do j = 1, n
                    jlen = min( kd, j-1 )
                    cnorm( j ) = stdlib_${ri}$asum( jlen, ab( kd+1-jlen, j ), 1 )
                 end do
              else
                 ! a is lower triangular.
                 do j = 1, n
                    jlen = min( kd, n-j )
                    if( jlen>0 ) then
                       cnorm( j ) = stdlib_${ri}$asum( jlen, ab( 2, j ), 1 )
                    else
                       cnorm( j ) = zero
                    end if
                 end do
              end if
           end if
           ! scale the column norms by tscal if the maximum element in cnorm is
           ! greater than bignum.
           imax = stdlib_i${ri}$amax( n, cnorm, 1 )
           tmax = cnorm( imax )
           if( tmax<=bignum ) then
              tscal = one
           else
              tscal = one / ( smlnum*tmax )
              call stdlib_${ri}$scal( n, tscal, cnorm, 1 )
           end if
           ! compute a bound on the computed solution vector to see if the
           ! level 2 blas routine stdlib_${ri}$tbsv can be used.
           j = stdlib_i${ri}$amax( n, x, 1 )
           xmax = abs( x( j ) )
           xbnd = xmax
           if( notran ) then
              ! compute the growth in a * x = b.
              if( upper ) then
                 jfirst = n
                 jlast = 1
                 jinc = -1
                 maind = kd + 1
              else
                 jfirst = 1
                 jlast = n
                 jinc = 1
                 maind = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 50
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, g(0) = max{x(i), i=1,...,n}.
                 grow = one / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 50
                    ! m(j) = g(j-1) / abs(a(j,j))
                    tjj = abs( ab( maind, j ) )
                    xbnd = min( xbnd, min( one, tjj )*grow )
                    if( tjj+cnorm( j )>=smlnum ) then
                       ! g(j) = g(j-1)*( 1 + cnorm(j) / abs(a(j,j)) )
                       grow = grow*( tjj / ( tjj+cnorm( j ) ) )
                    else
                       ! g(j) could overflow, set grow to 0.
                       grow = zero
                    end if
                 end do
                 grow = xbnd
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, one / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 50
                    ! g(j) = g(j-1)*( 1 + cnorm(j) )
                    grow = grow*( one / ( one+cnorm( j ) ) )
                 end do
              end if
              50 continue
           else
              ! compute the growth in a**t * x = b.
              if( upper ) then
                 jfirst = 1
                 jlast = n
                 jinc = 1
                 maind = kd + 1
              else
                 jfirst = n
                 jlast = 1
                 jinc = -1
                 maind = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 80
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, m(0) = max{x(i), i=1,...,n}.
                 grow = one / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 80
                    ! g(j) = max( g(j-1), m(j-1)*( 1 + cnorm(j) ) )
                    xj = one + cnorm( j )
                    grow = min( grow, xbnd / xj )
                    ! m(j) = m(j-1)*( 1 + cnorm(j) ) / abs(a(j,j))
                    tjj = abs( ab( maind, j ) )
                    if( xj>tjj )xbnd = xbnd*( tjj / xj )
                 end do
                 grow = min( grow, xbnd )
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, one / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 80
                    ! g(j) = ( 1 + cnorm(j) )*g(j-1)
                    xj = one + cnorm( j )
                    grow = grow / xj
                 end do
              end if
              80 continue
           end if
           if( ( grow*tscal )>smlnum ) then
              ! use the level 2 blas solve if the reciprocal of the bound on
              ! elements of x is not too small.
              call stdlib_${ri}$tbsv( uplo, trans, diag, n, kd, ab, ldab, x, 1 )
           else
              ! use a level 1 blas solve, scaling intermediate results.
              if( xmax>bignum ) then
                 ! scale x so that its components are less than or equal to
                 ! bignum in absolute value.
                 scale = bignum / xmax
                 call stdlib_${ri}$scal( n, scale, x, 1 )
                 xmax = bignum
              end if
              if( notran ) then
                 ! solve a * x = b
                 loop_110: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) / a(j,j), scaling x if necessary.
                    xj = abs( x( j ) )
                    if( nounit ) then
                       tjjs = ab( maind, j )*tscal
                    else
                       tjjs = tscal
                       if( tscal==one )go to 100
                    end if
                    tjj = abs( tjjs )
                    if( tjj>smlnum ) then
                          ! abs(a(j,j)) > smlnum:
                       if( tjj<one ) then
                          if( xj>tjj*bignum ) then
                                ! scale x by 1/b(j).
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j ) = x( j ) / tjjs
                       xj = abs( x( j ) )
                    else if( tjj>zero ) then
                          ! 0 < abs(a(j,j)) <= smlnum:
                       if( xj>tjj*bignum ) then
                             ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum
                             ! to avoid overflow when dividing by a(j,j).
                          rec = ( tjj*bignum ) / xj
                          if( cnorm( j )>one ) then
                                ! scale by 1/cnorm(j) to avoid overflow when
                                ! multiplying x(j) times column j.
                             rec = rec / cnorm( j )
                          end if
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                       x( j ) = x( j ) / tjjs
                       xj = abs( x( j ) )
                    else
                          ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                          ! scale = 0, and compute a solution to a*x = 0.
                       do i = 1, n
                          x( i ) = zero
                       end do
                       x( j ) = one
                       xj = one
                       scale = zero
                       xmax = zero
                    end if
                    100 continue
                    ! scale x if necessary to avoid overflow when adding a
                    ! multiple of column j of a.
                    if( xj>one ) then
                       rec = one / xj
                       if( cnorm( j )>( bignum-xmax )*rec ) then
                          ! scale x by 1/(2*abs(x(j))).
                          rec = rec*half
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                       end if
                    else if( xj*cnorm( j )>( bignum-xmax ) ) then
                       ! scale x by 1/2.
                       call stdlib_${ri}$scal( n, half, x, 1 )
                       scale = scale*half
                    end if
                    if( upper ) then
                       if( j>1 ) then
                          ! compute the update
                             ! x(max(1,j-kd):j-1) := x(max(1,j-kd):j-1) -
                                                   ! x(j)* a(max(1,j-kd):j-1,j)
                          jlen = min( kd, j-1 )
                          call stdlib_${ri}$axpy( jlen, -x( j )*tscal,ab( kd+1-jlen, j ), 1, x( j-jlen &
                                    ), 1 )
                          i = stdlib_i${ri}$amax( j-1, x, 1 )
                          xmax = abs( x( i ) )
                       end if
                    else if( j<n ) then
                       ! compute the update
                          ! x(j+1:min(j+kd,n)) := x(j+1:min(j+kd,n)) -
                                                ! x(j) * a(j+1:min(j+kd,n),j)
                       jlen = min( kd, n-j )
                       if( jlen>0 )call stdlib_${ri}$axpy( jlen, -x( j )*tscal, ab( 2, j ), 1,x( j+1 ),&
                                  1 )
                       i = j + stdlib_i${ri}$amax( n-j, x( j+1 ), 1 )
                       xmax = abs( x( i ) )
                    end if
                 end do loop_110
              else
                 ! solve a**t * x = b
                 loop_160: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = abs( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = ab( maind, j )*tscal
                       else
                          tjjs = tscal
                       end if
                       tjj = abs( tjjs )
                       if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                          rec = min( one, rec*tjj )
                          uscal = uscal / tjjs
                       end if
                       if( rec<one ) then
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    sumj = zero
                    if( uscal==one ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_${ri}$dot to perform the dot product.
                       if( upper ) then
                          jlen = min( kd, j-1 )
                          sumj = stdlib_${ri}$dot( jlen, ab( kd+1-jlen, j ), 1,x( j-jlen ), 1 )
                       else
                          jlen = min( kd, n-j )
                          if( jlen>0 )sumj = stdlib_${ri}$dot( jlen, ab( 2, j ), 1, x( j+1 ), 1 )
                                    
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          jlen = min( kd, j-1 )
                          do i = 1, jlen
                             sumj = sumj + ( ab( kd+i-jlen, j )*uscal )*x( j-jlen-1+i )
                          end do
                       else
                          jlen = min( kd, n-j )
                          do i = 1, jlen
                             sumj = sumj + ( ab( i+1, j )*uscal )*x( j+i )
                          end do
                       end if
                    end if
                    if( uscal==tscal ) then
                       ! compute x(j) := ( x(j) - sumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - sumj
                       xj = abs( x( j ) )
                       if( nounit ) then
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjjs = ab( maind, j )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 150
                       end if
                       tjj = abs( tjjs )
                       if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                          if( tjj<one ) then
                             if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                rec = one / xj
                                call stdlib_${ri}$scal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                          end if
                          x( j ) = x( j ) / tjjs
                       else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                          if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                             rec = ( tjj*bignum ) / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                          x( j ) = x( j ) / tjjs
                       else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0, and compute a solution to a**t*x = 0.
                          do i = 1, n
                             x( i ) = zero
                          end do
                          x( j ) = one
                          scale = zero
                          xmax = zero
                       end if
                       150 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - sumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = x( j ) / tjjs - sumj
                    end if
                    xmax = max( xmax, abs( x( j ) ) )
                 end do loop_160
              end if
              scale = scale / tscal
           end if
           ! scale the column norms by 1/tscal for return.
           if( tscal/=one ) then
              call stdlib_${ri}$scal( n, one / tscal, cnorm, 1 )
           end if
           return
     end subroutine stdlib_${ri}$latbs


     pure subroutine stdlib_${ri}$latdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
     !! DLATDF: uses the LU factorization of the n-by-n matrix Z computed by
     !! DGETC2 and computes a contribution to the reciprocal Dif-estimate
     !! by solving Z * x = b for x, and choosing the r.h.s. b such that
     !! the norm of x is as large as possible. On entry RHS = b holds the
     !! contribution from earlier solved sub-systems, and on return RHS = x.
     !! The factorization of Z returned by DGETC2 has the form Z = P*L*U*Q,
     !! where P and Q are permutation matrices. L is lower triangular with
     !! unit diagonal elements and U is upper triangular.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ijob, ldz, n
           real(${rk}$), intent(inout) :: rdscal, rdsum
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*), jpiv(*)
           real(${rk}$), intent(inout) :: rhs(*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxdim = 8
           
           
           ! Local Scalars 
           integer(ilp) :: i, info, j, k
           real(${rk}$) :: bm, bp, pmone, sminu, splus, temp
           ! Local Arrays 
           integer(ilp) :: iwork(maxdim)
           real(${rk}$) :: work(4*maxdim), xm(maxdim), xp(maxdim)
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( ijob/=2 ) then
              ! apply permutations ipiv to rhs
              call stdlib_${ri}$laswp( 1, rhs, ldz, 1, n-1, ipiv, 1 )
              ! solve for l-part choosing rhs either to +1 or -1.
              pmone = -one
              loop_10: do j = 1, n - 1
                 bp = rhs( j ) + one
                 bm = rhs( j ) - one
                 splus = one
                 ! look-ahead for l-part rhs(1:n-1) = + or -1, splus and
                 ! smin computed more efficiently than in bsolve [1].
                 splus = splus + stdlib_${ri}$dot( n-j, z( j+1, j ), 1, z( j+1, j ), 1 )
                 sminu = stdlib_${ri}$dot( n-j, z( j+1, j ), 1, rhs( j+1 ), 1 )
                 splus = splus*rhs( j )
                 if( splus>sminu ) then
                    rhs( j ) = bp
                 else if( sminu>splus ) then
                    rhs( j ) = bm
                 else
                    ! in this case the updating sums are equal and we can
                    ! choose rhs(j) +1 or -1. the first time this happens
                    ! we choose -1, thereafter +1. this is a simple way to
                    ! get good estimates of matrices like byers well-known
                    ! example (see [1]). (not done in bsolve.)
                    rhs( j ) = rhs( j ) + pmone
                    pmone = one
                 end if
                 ! compute the remaining r.h.s.
                 temp = -rhs( j )
                 call stdlib_${ri}$axpy( n-j, temp, z( j+1, j ), 1, rhs( j+1 ), 1 )
              end do loop_10
              ! solve for u-part, look-ahead for rhs(n) = +-1. this is not done
              ! in bsolve and will hopefully give us a better estimate because
              ! any ill-conditioning of the original matrix is transferred to u
              ! and not to l. u(n, n) is an approximation to sigma_min(lu).
              call stdlib_${ri}$copy( n-1, rhs, 1, xp, 1 )
              xp( n ) = rhs( n ) + one
              rhs( n ) = rhs( n ) - one
              splus = zero
              sminu = zero
              do i = n, 1, -1
                 temp = one / z( i, i )
                 xp( i ) = xp( i )*temp
                 rhs( i ) = rhs( i )*temp
                 do k = i + 1, n
                    xp( i ) = xp( i ) - xp( k )*( z( i, k )*temp )
                    rhs( i ) = rhs( i ) - rhs( k )*( z( i, k )*temp )
                 end do
                 splus = splus + abs( xp( i ) )
                 sminu = sminu + abs( rhs( i ) )
              end do
              if( splus>sminu )call stdlib_${ri}$copy( n, xp, 1, rhs, 1 )
              ! apply the permutations jpiv to the computed solution (rhs)
              call stdlib_${ri}$laswp( 1, rhs, ldz, 1, n-1, jpiv, -1 )
              ! compute the sum of squares
              call stdlib_${ri}$lassq( n, rhs, 1, rdscal, rdsum )
           else
              ! ijob = 2, compute approximate nullvector xm of z
              call stdlib_${ri}$gecon( 'I', n, z, ldz, one, temp, work, iwork, info )
              call stdlib_${ri}$copy( n, work( n+1 ), 1, xm, 1 )
              ! compute rhs
              call stdlib_${ri}$laswp( 1, xm, ldz, 1, n-1, ipiv, -1 )
              temp = one / sqrt( stdlib_${ri}$dot( n, xm, 1, xm, 1 ) )
              call stdlib_${ri}$scal( n, temp, xm, 1 )
              call stdlib_${ri}$copy( n, xm, 1, xp, 1 )
              call stdlib_${ri}$axpy( n, one, rhs, 1, xp, 1 )
              call stdlib_${ri}$axpy( n, -one, xm, 1, rhs, 1 )
              call stdlib_${ri}$gesc2( n, z, ldz, rhs, ipiv, jpiv, temp )
              call stdlib_${ri}$gesc2( n, z, ldz, xp, ipiv, jpiv, temp )
              if( stdlib_${ri}$asum( n, xp, 1 )>stdlib_${ri}$asum( n, rhs, 1 ) )call stdlib_${ri}$copy( n, xp, 1,&
                         rhs, 1 )
              ! compute the sum of squares
              call stdlib_${ri}$lassq( n, rhs, 1, rdscal, rdsum )
           end if
           return
     end subroutine stdlib_${ri}$latdf


     pure subroutine stdlib_${ri}$latps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )
     !! DLATPS: solves one of the triangular systems
     !! A *x = s*b  or  A**T*x = s*b
     !! with scaling to prevent overflow, where A is an upper or lower
     !! triangular matrix stored in packed form.  Here A**T denotes the
     !! transpose of A, x and b are n-element vectors, and s is a scaling
     !! factor, usually less than or equal to 1, chosen so that the
     !! components of x will be less than the overflow threshold.  If the
     !! unscaled problem will not cause overflow, the Level 2 BLAS routine
     !! DTPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
     !! then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, normin, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: cnorm(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           integer(ilp) :: i, imax, ip, j, jfirst, jinc, jlast, jlen
           real(${rk}$) :: bignum, grow, rec, smlnum, sumj, tjj, tjjs, tmax, tscal, uscal, xbnd, xj, &
                     xmax
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           ! test the input parameters.
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( .not.stdlib_lsame( normin, 'Y' ) .and. .not.stdlib_lsame( normin, 'N' ) ) &
                     then
              info = -4
           else if( n<0 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLATPS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine machine dependent parameters to control overflow.
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           bignum = one / smlnum
           scale = one
           if( stdlib_lsame( normin, 'N' ) ) then
              ! compute the 1-norm of each column, not including the diagonal.
              if( upper ) then
                 ! a is upper triangular.
                 ip = 1
                 do j = 1, n
                    cnorm( j ) = stdlib_${ri}$asum( j-1, ap( ip ), 1 )
                    ip = ip + j
                 end do
              else
                 ! a is lower triangular.
                 ip = 1
                 do j = 1, n - 1
                    cnorm( j ) = stdlib_${ri}$asum( n-j, ap( ip+1 ), 1 )
                    ip = ip + n - j + 1
                 end do
                 cnorm( n ) = zero
              end if
           end if
           ! scale the column norms by tscal if the maximum element in cnorm is
           ! greater than bignum.
           imax = stdlib_i${ri}$amax( n, cnorm, 1 )
           tmax = cnorm( imax )
           if( tmax<=bignum ) then
              tscal = one
           else
              tscal = one / ( smlnum*tmax )
              call stdlib_${ri}$scal( n, tscal, cnorm, 1 )
           end if
           ! compute a bound on the computed solution vector to see if the
           ! level 2 blas routine stdlib_${ri}$tpsv can be used.
           j = stdlib_i${ri}$amax( n, x, 1 )
           xmax = abs( x( j ) )
           xbnd = xmax
           if( notran ) then
              ! compute the growth in a * x = b.
              if( upper ) then
                 jfirst = n
                 jlast = 1
                 jinc = -1
              else
                 jfirst = 1
                 jlast = n
                 jinc = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 50
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, g(0) = max{x(i), i=1,...,n}.
                 grow = one / max( xbnd, smlnum )
                 xbnd = grow
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = n
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 50
                    ! m(j) = g(j-1) / abs(a(j,j))
                    tjj = abs( ap( ip ) )
                    xbnd = min( xbnd, min( one, tjj )*grow )
                    if( tjj+cnorm( j )>=smlnum ) then
                       ! g(j) = g(j-1)*( 1 + cnorm(j) / abs(a(j,j)) )
                       grow = grow*( tjj / ( tjj+cnorm( j ) ) )
                    else
                       ! g(j) could overflow, set grow to 0.
                       grow = zero
                    end if
                    ip = ip + jinc*jlen
                    jlen = jlen - 1
                 end do
                 grow = xbnd
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, one / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 50
                    ! g(j) = g(j-1)*( 1 + cnorm(j) )
                    grow = grow*( one / ( one+cnorm( j ) ) )
                 end do
              end if
              50 continue
           else
              ! compute the growth in a**t * x = b.
              if( upper ) then
                 jfirst = 1
                 jlast = n
                 jinc = 1
              else
                 jfirst = n
                 jlast = 1
                 jinc = -1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 80
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, m(0) = max{x(i), i=1,...,n}.
                 grow = one / max( xbnd, smlnum )
                 xbnd = grow
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = 1
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 80
                    ! g(j) = max( g(j-1), m(j-1)*( 1 + cnorm(j) ) )
                    xj = one + cnorm( j )
                    grow = min( grow, xbnd / xj )
                    ! m(j) = m(j-1)*( 1 + cnorm(j) ) / abs(a(j,j))
                    tjj = abs( ap( ip ) )
                    if( xj>tjj )xbnd = xbnd*( tjj / xj )
                    jlen = jlen + 1
                    ip = ip + jinc*jlen
                 end do
                 grow = min( grow, xbnd )
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, one / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 80
                    ! g(j) = ( 1 + cnorm(j) )*g(j-1)
                    xj = one + cnorm( j )
                    grow = grow / xj
                 end do
              end if
              80 continue
           end if
           if( ( grow*tscal )>smlnum ) then
              ! use the level 2 blas solve if the reciprocal of the bound on
              ! elements of x is not too small.
              call stdlib_${ri}$tpsv( uplo, trans, diag, n, ap, x, 1 )
           else
              ! use a level 1 blas solve, scaling intermediate results.
              if( xmax>bignum ) then
                 ! scale x so that its components are less than or equal to
                 ! bignum in absolute value.
                 scale = bignum / xmax
                 call stdlib_${ri}$scal( n, scale, x, 1 )
                 xmax = bignum
              end if
              if( notran ) then
                 ! solve a * x = b
                 ip = jfirst*( jfirst+1 ) / 2
                 loop_110: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) / a(j,j), scaling x if necessary.
                    xj = abs( x( j ) )
                    if( nounit ) then
                       tjjs = ap( ip )*tscal
                    else
                       tjjs = tscal
                       if( tscal==one )go to 100
                    end if
                    tjj = abs( tjjs )
                    if( tjj>smlnum ) then
                          ! abs(a(j,j)) > smlnum:
                       if( tjj<one ) then
                          if( xj>tjj*bignum ) then
                                ! scale x by 1/b(j).
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j ) = x( j ) / tjjs
                       xj = abs( x( j ) )
                    else if( tjj>zero ) then
                          ! 0 < abs(a(j,j)) <= smlnum:
                       if( xj>tjj*bignum ) then
                             ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum
                             ! to avoid overflow when dividing by a(j,j).
                          rec = ( tjj*bignum ) / xj
                          if( cnorm( j )>one ) then
                                ! scale by 1/cnorm(j) to avoid overflow when
                                ! multiplying x(j) times column j.
                             rec = rec / cnorm( j )
                          end if
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                       x( j ) = x( j ) / tjjs
                       xj = abs( x( j ) )
                    else
                          ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                          ! scale = 0, and compute a solution to a*x = 0.
                       do i = 1, n
                          x( i ) = zero
                       end do
                       x( j ) = one
                       xj = one
                       scale = zero
                       xmax = zero
                    end if
                    100 continue
                    ! scale x if necessary to avoid overflow when adding a
                    ! multiple of column j of a.
                    if( xj>one ) then
                       rec = one / xj
                       if( cnorm( j )>( bignum-xmax )*rec ) then
                          ! scale x by 1/(2*abs(x(j))).
                          rec = rec*half
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                       end if
                    else if( xj*cnorm( j )>( bignum-xmax ) ) then
                       ! scale x by 1/2.
                       call stdlib_${ri}$scal( n, half, x, 1 )
                       scale = scale*half
                    end if
                    if( upper ) then
                       if( j>1 ) then
                          ! compute the update
                             ! x(1:j-1) := x(1:j-1) - x(j) * a(1:j-1,j)
                          call stdlib_${ri}$axpy( j-1, -x( j )*tscal, ap( ip-j+1 ), 1, x,1 )
                          i = stdlib_i${ri}$amax( j-1, x, 1 )
                          xmax = abs( x( i ) )
                       end if
                       ip = ip - j
                    else
                       if( j<n ) then
                          ! compute the update
                             ! x(j+1:n) := x(j+1:n) - x(j) * a(j+1:n,j)
                          call stdlib_${ri}$axpy( n-j, -x( j )*tscal, ap( ip+1 ), 1,x( j+1 ), 1 )
                                    
                          i = j + stdlib_i${ri}$amax( n-j, x( j+1 ), 1 )
                          xmax = abs( x( i ) )
                       end if
                       ip = ip + n - j + 1
                    end if
                 end do loop_110
              else
                 ! solve a**t * x = b
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = 1
                 loop_160: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = abs( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = ap( ip )*tscal
                       else
                          tjjs = tscal
                       end if
                       tjj = abs( tjjs )
                       if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                          rec = min( one, rec*tjj )
                          uscal = uscal / tjjs
                       end if
                       if( rec<one ) then
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    sumj = zero
                    if( uscal==one ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_${ri}$dot to perform the dot product.
                       if( upper ) then
                          sumj = stdlib_${ri}$dot( j-1, ap( ip-j+1 ), 1, x, 1 )
                       else if( j<n ) then
                          sumj = stdlib_${ri}$dot( n-j, ap( ip+1 ), 1, x( j+1 ), 1 )
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          do i = 1, j - 1
                             sumj = sumj + ( ap( ip-j+i )*uscal )*x( i )
                          end do
                       else if( j<n ) then
                          do i = 1, n - j
                             sumj = sumj + ( ap( ip+i )*uscal )*x( j+i )
                          end do
                       end if
                    end if
                    if( uscal==tscal ) then
                       ! compute x(j) := ( x(j) - sumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - sumj
                       xj = abs( x( j ) )
                       if( nounit ) then
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjjs = ap( ip )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 150
                       end if
                       tjj = abs( tjjs )
                       if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                          if( tjj<one ) then
                             if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                rec = one / xj
                                call stdlib_${ri}$scal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                          end if
                          x( j ) = x( j ) / tjjs
                       else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                          if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                             rec = ( tjj*bignum ) / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                          x( j ) = x( j ) / tjjs
                       else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0, and compute a solution to a**t*x = 0.
                          do i = 1, n
                             x( i ) = zero
                          end do
                          x( j ) = one
                          scale = zero
                          xmax = zero
                       end if
                       150 continue
                    else
                       ! compute x(j) := x(j) / a(j,j)  - sumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = x( j ) / tjjs - sumj
                    end if
                    xmax = max( xmax, abs( x( j ) ) )
                    jlen = jlen + 1
                    ip = ip + jinc*jlen
                 end do loop_160
              end if
              scale = scale / tscal
           end if
           ! scale the column norms by 1/tscal for return.
           if( tscal/=one ) then
              call stdlib_${ri}$scal( n, one / tscal, cnorm, 1 )
           end if
           return
     end subroutine stdlib_${ri}$latps


     pure subroutine stdlib_${ri}$latrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! DLATRD: reduces NB rows and columns of a real symmetric matrix A to
     !! symmetric tridiagonal form by an orthogonal similarity
     !! transformation Q**T * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by DSYTRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           real(${rk}$) :: alpha
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i, n-i, -one, a( 1, i+1 ),lda, w( i, iw+1 )&
                              , ldw, one, a( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i, n-i, -one, w( 1, iw+1 ),ldw, a( i, i+1 )&
                              , lda, one, a( 1, i ), 1 )
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    call stdlib_${ri}$larfg( i-1, a( i-1, i ), a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = a( i-1, i )
                    a( i-1, i ) = one
                    ! compute w(1:i-1,i)
                    call stdlib_${ri}$symv( 'UPPER', i-1, one, a, lda, a( 1, i ), 1,zero, w( 1, iw ), &
                              1 )
                    if( i<n ) then
                       call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i, one, w( 1, iw+1 ),ldw, a( 1, i ),&
                                  1, zero, w( i+1, iw ), 1 )
                       call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i, -one,a( 1, i+1 ), lda, w( i+1,&
                                  iw ), 1, one,w( 1, iw ), 1 )
                       call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i, one, a( 1, i+1 ),lda, a( 1, i ), &
                                 1, zero, w( i+1, iw ), 1 )
                       call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i, -one,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, one,w( 1, iw ), 1 )
                    end if
                    call stdlib_${ri}$scal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -half*tau( i-1 )*stdlib_${ri}$dot( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_${ri}$axpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              do i = 1, nb
                 ! update a(i:n,i)
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -one, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, one, a( i, i ), 1 )
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -one, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, one, a( i, i ), 1 )
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    call stdlib_${ri}$larfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
                              
                    e( i ) = a( i+1, i )
                    a( i+1, i ) = one
                    ! compute w(i+1:n,i)
                    call stdlib_${ri}$symv( 'LOWER', n-i, one, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero,&
                               w( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i, i-1, one, w( i+1, 1 ), ldw,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i-1, -one, a( i+1, 1 ),lda, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i, i-1, one, a( i+1, 1 ), lda,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i-1, -one, w( i+1, 1 ),ldw, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_${ri}$scal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -half*tau( i )*stdlib_${ri}$dot( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_${ri}$axpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$latrd


     pure subroutine stdlib_${ri}$latrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info )
     !! DLATRS: solves one of the triangular systems
     !! A *x = s*b  or  A**T *x = s*b
     !! with scaling to prevent overflow.  Here A is an upper or lower
     !! triangular matrix, A**T denotes the transpose of A, x and b are
     !! n-element vectors, and s is a scaling factor, usually less than
     !! or equal to 1, chosen so that the components of x will be less than
     !! the overflow threshold.  If the unscaled problem will not cause
     !! overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A
     !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
     !! non-trivial solution to A*x = 0 is returned.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, normin, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: cnorm(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           integer(ilp) :: i, imax, j, jfirst, jinc, jlast
           real(${rk}$) :: bignum, grow, rec, smlnum, sumj, tjj, tjjs, tmax, tscal, uscal, xbnd, xj, &
                     xmax
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           ! test the input parameters.
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( .not.stdlib_lsame( normin, 'Y' ) .and. .not.stdlib_lsame( normin, 'N' ) ) &
                     then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLATRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine machine dependent parameters to control overflow.
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           bignum = one / smlnum
           scale = one
           if( stdlib_lsame( normin, 'N' ) ) then
              ! compute the 1-norm of each column, not including the diagonal.
              if( upper ) then
                 ! a is upper triangular.
                 do j = 1, n
                    cnorm( j ) = stdlib_${ri}$asum( j-1, a( 1, j ), 1 )
                 end do
              else
                 ! a is lower triangular.
                 do j = 1, n - 1
                    cnorm( j ) = stdlib_${ri}$asum( n-j, a( j+1, j ), 1 )
                 end do
                 cnorm( n ) = zero
              end if
           end if
           ! scale the column norms by tscal if the maximum element in cnorm is
           ! greater than bignum.
           imax = stdlib_i${ri}$amax( n, cnorm, 1 )
           tmax = cnorm( imax )
           if( tmax<=bignum ) then
              tscal = one
           else
              tscal = one / ( smlnum*tmax )
              call stdlib_${ri}$scal( n, tscal, cnorm, 1 )
           end if
           ! compute a bound on the computed solution vector to see if the
           ! level 2 blas routine stdlib_${ri}$trsv can be used.
           j = stdlib_i${ri}$amax( n, x, 1 )
           xmax = abs( x( j ) )
           xbnd = xmax
           if( notran ) then
              ! compute the growth in a * x = b.
              if( upper ) then
                 jfirst = n
                 jlast = 1
                 jinc = -1
              else
                 jfirst = 1
                 jlast = n
                 jinc = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 50
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, g(0) = max{x(i), i=1,...,n}.
                 grow = one / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 50
                    ! m(j) = g(j-1) / abs(a(j,j))
                    tjj = abs( a( j, j ) )
                    xbnd = min( xbnd, min( one, tjj )*grow )
                    if( tjj+cnorm( j )>=smlnum ) then
                       ! g(j) = g(j-1)*( 1 + cnorm(j) / abs(a(j,j)) )
                       grow = grow*( tjj / ( tjj+cnorm( j ) ) )
                    else
                       ! g(j) could overflow, set grow to 0.
                       grow = zero
                    end if
                 end do
                 grow = xbnd
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, one / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 50
                    ! g(j) = g(j-1)*( 1 + cnorm(j) )
                    grow = grow*( one / ( one+cnorm( j ) ) )
                 end do
              end if
              50 continue
           else
              ! compute the growth in a**t * x = b.
              if( upper ) then
                 jfirst = 1
                 jlast = n
                 jinc = 1
              else
                 jfirst = n
                 jlast = 1
                 jinc = -1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 80
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, m(0) = max{x(i), i=1,...,n}.
                 grow = one / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 80
                    ! g(j) = max( g(j-1), m(j-1)*( 1 + cnorm(j) ) )
                    xj = one + cnorm( j )
                    grow = min( grow, xbnd / xj )
                    ! m(j) = m(j-1)*( 1 + cnorm(j) ) / abs(a(j,j))
                    tjj = abs( a( j, j ) )
                    if( xj>tjj )xbnd = xbnd*( tjj / xj )
                 end do
                 grow = min( grow, xbnd )
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, one / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 80
                    ! g(j) = ( 1 + cnorm(j) )*g(j-1)
                    xj = one + cnorm( j )
                    grow = grow / xj
                 end do
              end if
              80 continue
           end if
           if( ( grow*tscal )>smlnum ) then
              ! use the level 2 blas solve if the reciprocal of the bound on
              ! elements of x is not too small.
              call stdlib_${ri}$trsv( uplo, trans, diag, n, a, lda, x, 1 )
           else
              ! use a level 1 blas solve, scaling intermediate results.
              if( xmax>bignum ) then
                 ! scale x so that its components are less than or equal to
                 ! bignum in absolute value.
                 scale = bignum / xmax
                 call stdlib_${ri}$scal( n, scale, x, 1 )
                 xmax = bignum
              end if
              if( notran ) then
                 ! solve a * x = b
                 loop_110: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) / a(j,j), scaling x if necessary.
                    xj = abs( x( j ) )
                    if( nounit ) then
                       tjjs = a( j, j )*tscal
                    else
                       tjjs = tscal
                       if( tscal==one )go to 100
                    end if
                    tjj = abs( tjjs )
                    if( tjj>smlnum ) then
                          ! abs(a(j,j)) > smlnum:
                       if( tjj<one ) then
                          if( xj>tjj*bignum ) then
                                ! scale x by 1/b(j).
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j ) = x( j ) / tjjs
                       xj = abs( x( j ) )
                    else if( tjj>zero ) then
                          ! 0 < abs(a(j,j)) <= smlnum:
                       if( xj>tjj*bignum ) then
                             ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum
                             ! to avoid overflow when dividing by a(j,j).
                          rec = ( tjj*bignum ) / xj
                          if( cnorm( j )>one ) then
                                ! scale by 1/cnorm(j) to avoid overflow when
                                ! multiplying x(j) times column j.
                             rec = rec / cnorm( j )
                          end if
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                       x( j ) = x( j ) / tjjs
                       xj = abs( x( j ) )
                    else
                          ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                          ! scale = 0, and compute a solution to a*x = 0.
                       do i = 1, n
                          x( i ) = zero
                       end do
                       x( j ) = one
                       xj = one
                       scale = zero
                       xmax = zero
                    end if
                    100 continue
                    ! scale x if necessary to avoid overflow when adding a
                    ! multiple of column j of a.
                    if( xj>one ) then
                       rec = one / xj
                       if( cnorm( j )>( bignum-xmax )*rec ) then
                          ! scale x by 1/(2*abs(x(j))).
                          rec = rec*half
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                       end if
                    else if( xj*cnorm( j )>( bignum-xmax ) ) then
                       ! scale x by 1/2.
                       call stdlib_${ri}$scal( n, half, x, 1 )
                       scale = scale*half
                    end if
                    if( upper ) then
                       if( j>1 ) then
                          ! compute the update
                             ! x(1:j-1) := x(1:j-1) - x(j) * a(1:j-1,j)
                          call stdlib_${ri}$axpy( j-1, -x( j )*tscal, a( 1, j ), 1, x,1 )
                          i = stdlib_i${ri}$amax( j-1, x, 1 )
                          xmax = abs( x( i ) )
                       end if
                    else
                       if( j<n ) then
                          ! compute the update
                             ! x(j+1:n) := x(j+1:n) - x(j) * a(j+1:n,j)
                          call stdlib_${ri}$axpy( n-j, -x( j )*tscal, a( j+1, j ), 1,x( j+1 ), 1 )
                                    
                          i = j + stdlib_i${ri}$amax( n-j, x( j+1 ), 1 )
                          xmax = abs( x( i ) )
                       end if
                    end if
                 end do loop_110
              else
                 ! solve a**t * x = b
                 loop_160: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = abs( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = a( j, j )*tscal
                       else
                          tjjs = tscal
                       end if
                       tjj = abs( tjjs )
                       if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                          rec = min( one, rec*tjj )
                          uscal = uscal / tjjs
                       end if
                       if( rec<one ) then
                          call stdlib_${ri}$scal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    sumj = zero
                    if( uscal==one ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_${ri}$dot to perform the dot product.
                       if( upper ) then
                          sumj = stdlib_${ri}$dot( j-1, a( 1, j ), 1, x, 1 )
                       else if( j<n ) then
                          sumj = stdlib_${ri}$dot( n-j, a( j+1, j ), 1, x( j+1 ), 1 )
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          do i = 1, j - 1
                             sumj = sumj + ( a( i, j )*uscal )*x( i )
                          end do
                       else if( j<n ) then
                          do i = j + 1, n
                             sumj = sumj + ( a( i, j )*uscal )*x( i )
                          end do
                       end if
                    end if
                    if( uscal==tscal ) then
                       ! compute x(j) := ( x(j) - sumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - sumj
                       xj = abs( x( j ) )
                       if( nounit ) then
                          tjjs = a( j, j )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 150
                       end if
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                       tjj = abs( tjjs )
                       if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                          if( tjj<one ) then
                             if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                rec = one / xj
                                call stdlib_${ri}$scal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                          end if
                          x( j ) = x( j ) / tjjs
                       else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                          if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                             rec = ( tjj*bignum ) / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                          x( j ) = x( j ) / tjjs
                       else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0, and compute a solution to a**t*x = 0.
                          do i = 1, n
                             x( i ) = zero
                          end do
                          x( j ) = one
                          scale = zero
                          xmax = zero
                       end if
                       150 continue
                    else
                       ! compute x(j) := x(j) / a(j,j)  - sumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = x( j ) / tjjs - sumj
                    end if
                    xmax = max( xmax, abs( x( j ) ) )
                 end do loop_160
              end if
              scale = scale / tscal
           end if
           ! scale the column norms by 1/tscal for return.
           if( tscal/=one ) then
              call stdlib_${ri}$scal( n, one / tscal, cnorm, 1 )
           end if
           return
     end subroutine stdlib_${ri}$latrs


     pure subroutine stdlib_${ri}$latrz( m, n, l, a, lda, tau, work )
     !! DLATRZ: factors the M-by-(M+L) real upper trapezoidal matrix
     !! [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means
     !! of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal
     !! matrix and, R and A1 are M-by-M upper triangular matrices.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: l, lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           ! Executable Statements 
           ! test the input arguments
           ! quick return if possible
           if( m==0 ) then
              return
           else if( m==n ) then
              do i = 1, n
                 tau( i ) = zero
              end do
              return
           end if
           do i = m, 1, -1
              ! generate elementary reflector h(i) to annihilate
              ! [ a(i,i) a(i,n-l+1:n) ]
              call stdlib_${ri}$larfg( l+1, a( i, i ), a( i, n-l+1 ), lda, tau( i ) )
              ! apply h(i) to a(1:i-1,i:n) from the right
              call stdlib_${ri}$larz( 'RIGHT', i-1, n-i+1, l, a( i, n-l+1 ), lda,tau( i ), a( 1, i ), &
                        lda, work )
           end do
           return
     end subroutine stdlib_${ri}$latrz


     pure subroutine stdlib_${ri}$latsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
     !! DLATSQR: computes a blocked Tall-Skinny QR factorization of
     !! a real M-by-N matrix A for M >= N:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix, stored on exit in an implicit
     !! form in the elements below the diagonal of the array A and in
     !! the elements of the array T;
     !! R is an upper-triangular N-by-N matrix, stored on exit in
     !! the elements on and above the diagonal of the array A.
     !! 0 is a (M-N)-by-N zero matrix, and is not stored.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, mb, nb, ldt, lwork
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ii, kk, ctr
           ! External Subroutines 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
             info = -1
           else if( n<0 .or. m<n ) then
             info = -2
           else if( mb<1 ) then
             info = -3
           else if( nb<1 .or. ( nb>n .and. n>0 )) then
             info = -4
           else if( lda<max( 1, m ) ) then
             info = -6
           else if( ldt<nb ) then
             info = -8
           else if( lwork<(n*nb) .and. (.not.lquery) ) then
             info = -10
           end if
           if( info==0)  then
             work(1) = nb*n
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'DLATSQR', -info )
             return
           else if (lquery) then
            return
           end if
           ! quick return if possible
           if( min(m,n)==0 ) then
               return
           end if
           ! the qr decomposition
            if ((mb<=n).or.(mb>=m)) then
              call stdlib_${ri}$geqrt( m, n, nb, a, lda, t, ldt, work, info)
              return
            end if
            kk = mod((m-n),(mb-n))
            ii=m-kk+1
            ! compute the qr factorization of the first block a(1:mb,1:n)
            call stdlib_${ri}$geqrt( mb, n, nb, a(1,1), lda, t, ldt, work, info )
            ctr = 1
            do i = mb+1, ii-mb+n ,  (mb-n)
            ! compute the qr factorization of the current block a(i:i+mb-n,1:n)
              call stdlib_${ri}$tpqrt( mb-n, n, 0, nb, a(1,1), lda, a( i, 1 ), lda,t(1, ctr * n + 1),&
                        ldt, work, info )
              ctr = ctr + 1
            end do
            ! compute the qr factorization of the last block a(ii:m,1:n)
            if (ii<=m) then
              call stdlib_${ri}$tpqrt( kk, n, 0, nb, a(1,1), lda, a( ii, 1 ), lda,t(1, ctr * n + 1), &
                        ldt,work, info )
            end if
           work( 1 ) = n*nb
           return
     end subroutine stdlib_${ri}$latsqr


     pure subroutine stdlib_${ri}$lauu2( uplo, n, a, lda, info )
     !! DLAUU2: computes the product U * U**T or L**T * L, where the triangular
     !! factor U or L is stored in the upper or lower triangular part of
     !! the array A.
     !! If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
     !! overwriting the factor U in A.
     !! If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
     !! overwriting the factor L in A.
     !! This is the unblocked form of the algorithm, calling Level 2 BLAS.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAUU2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! compute the product u * u**t.
              do i = 1, n
                 aii = a( i, i )
                 if( i<n ) then
                    a( i, i ) = stdlib_${ri}$dot( n-i+1, a( i, i ), lda, a( i, i ), lda )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i, one, a( 1, i+1 ),lda, a( i, i+1 )&
                              , lda, aii, a( 1, i ), 1 )
                 else
                    call stdlib_${ri}$scal( i, aii, a( 1, i ), 1 )
                 end if
              end do
           else
              ! compute the product l**t * l.
              do i = 1, n
                 aii = a( i, i )
                 if( i<n ) then
                    a( i, i ) = stdlib_${ri}$dot( n-i+1, a( i, i ), 1, a( i, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i, i-1, one, a( i+1, 1 ), lda,a( i+1, i ), &
                              1, aii, a( i, 1 ), lda )
                 else
                    call stdlib_${ri}$scal( i, aii, a( i, 1 ), lda )
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$lauu2


     pure subroutine stdlib_${ri}$lauum( uplo, n, a, lda, info )
     !! DLAUUM: computes the product U * U**T or L**T * L, where the triangular
     !! factor U or L is stored in the upper or lower triangular part of
     !! the array A.
     !! If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
     !! overwriting the factor U in A.
     !! If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
     !! overwriting the factor L in A.
     !! This is the blocked form of the algorithm, calling Level 3 BLAS.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ib, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAUUM', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'DLAUUM', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_${ri}$lauu2( uplo, n, a, lda, info )
           else
              ! use blocked code
              if( upper ) then
                 ! compute the product u * u**t.
                 do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, ib, one, a( &
                              i, i ), lda, a( 1, i ),lda )
                    call stdlib_${ri}$lauu2( 'UPPER', ib, a( i, i ), lda, info )
                    if( i+ib<=n ) then
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', i-1, ib,n-i-ib+1, one, a( &
                                 1, i+ib ), lda,a( i, i+ib ), lda, one, a( 1, i ), lda )
                       call stdlib_${ri}$syrk( 'UPPER', 'NO TRANSPOSE', ib, n-i-ib+1,one, a( i, i+ib ),&
                                  lda, one, a( i, i ),lda )
                    end if
                 end do
              else
                 ! compute the product l**t * l.
                 do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    call stdlib_${ri}$trmm( 'LEFT', 'LOWER', 'TRANSPOSE', 'NON-UNIT', ib,i-1, one, a( &
                              i, i ), lda, a( i, 1 ), lda )
                    call stdlib_${ri}$lauu2( 'LOWER', ib, a( i, i ), lda, info )
                    if( i+ib<=n ) then
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', ib, i-1,n-i-ib+1, one, a( &
                                 i+ib, i ), lda,a( i+ib, 1 ), lda, one, a( i, 1 ), lda )
                       call stdlib_${ri}$syrk( 'LOWER', 'TRANSPOSE', ib, n-i-ib+1, one,a( i+ib, i ), &
                                 lda, one, a( i, i ), lda )
                    end if
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$lauum


     pure subroutine stdlib_${ri}$opgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! DOPGTR: generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! DSPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*), tau(*)
           real(${rk}$), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DOPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = zero
              end do
              do i = 1, n - 1
                 q( i, n ) = zero
              end do
              q( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_${ri}$org2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = one
              do i = 2, n
                 q( i, 1 ) = zero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = zero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_${ri}$org2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_${ri}$opgtr


     pure subroutine stdlib_${ri}$opmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! DOPMTR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by DSPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DOPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i)
                 aii = ap( ii )
                 ap( ii ) = one
                 call stdlib_${ri}$larf( side, mi, ni, ap( ii-i+1 ), 1, tau( i ), c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = one
                 if( left ) then
                    ! h(i) is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i)
                 call stdlib_${ri}$larf( side, mi, ni, ap( ii ), 1, tau( i ),c( ic, jc ), ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$opmtr


     subroutine stdlib_${ri}$orbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
     !! DORBDB: simultaneously bidiagonalizes the blocks of an M-by-M
     !! partitioned orthogonal matrix X:
     !! [ B11 | B12 0  0 ]
     !! [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T
     !! X = [-----------] = [---------] [----------------] [---------]   .
     !! [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
     !! [  0  |  0  0  I ]
     !! X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
     !! not the case, then X must be transposed and/or permuted. This can be
     !! done in constant time using the TRANS and SIGNS options. See DORCSD
     !! for details.)
     !! The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
     !! (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
     !! represented implicitly by Householder vectors.
     !! B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
     !! implicitly by angles THETA, PHI.
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: signs, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           ! Array Arguments 
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
        ! ====================================================================
           ! Parameters 
           real(${rk}$), parameter :: realone = 1.0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery
           integer(ilp) :: i, lworkmin, lworkopt
           real(${rk}$) :: z1, z2, z3, z4
           ! Intrinsic Functions
           intrinsic :: atan2,cos,max,sin
           ! Executable Statements 
           ! test input arguments
           info = 0
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( .not. stdlib_lsame( signs, 'O' ) ) then
              z1 = realone
              z2 = realone
              z3 = realone
              z4 = realone
           else
              z1 = realone
              z2 = -realone
              z3 = realone
              z4 = -realone
           end if
           lquery = lwork == -1
           if( m < 0 ) then
              info = -3
           else if( p < 0 .or. p > m ) then
              info = -4
           else if( q < 0 .or. q > p .or. q > m-p .or.q > m-q ) then
              info = -5
           else if( colmajor .and. ldx11 < max( 1, p ) ) then
              info = -7
           else if( .not.colmajor .and. ldx11 < max( 1, q ) ) then
              info = -7
           else if( colmajor .and. ldx12 < max( 1, p ) ) then
              info = -9
           else if( .not.colmajor .and. ldx12 < max( 1, m-q ) ) then
              info = -9
           else if( colmajor .and. ldx21 < max( 1, m-p ) ) then
              info = -11
           else if( .not.colmajor .and. ldx21 < max( 1, q ) ) then
              info = -11
           else if( colmajor .and. ldx22 < max( 1, m-p ) ) then
              info = -13
           else if( .not.colmajor .and. ldx22 < max( 1, m-q ) ) then
              info = -13
           end if
           ! compute workspace
           if( info == 0 ) then
              lworkopt = m - q
              lworkmin = m - q
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -21
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'XORBDB', -info )
              return
           else if( lquery ) then
              return
           end if
           ! handle column-major and row-major separately
           if( colmajor ) then
              ! reduce columns 1, ..., q of x11, x12, x21, and x22
              do i = 1, q
                 if( i == 1 ) then
                    call stdlib_${ri}$scal( p-i+1, z1, x11(i,i), 1 )
                 else
                    call stdlib_${ri}$scal( p-i+1, z1*cos(phi(i-1)), x11(i,i), 1 )
                    call stdlib_${ri}$axpy( p-i+1, -z1*z3*z4*sin(phi(i-1)), x12(i,i-1),1, x11(i,i), 1 )
                              
                 end if
                 if( i == 1 ) then
                    call stdlib_${ri}$scal( m-p-i+1, z2, x21(i,i), 1 )
                 else
                    call stdlib_${ri}$scal( m-p-i+1, z2*cos(phi(i-1)), x21(i,i), 1 )
                    call stdlib_${ri}$axpy( m-p-i+1, -z2*z3*z4*sin(phi(i-1)), x22(i,i-1),1, x21(i,i), &
                              1 )
                 end if
                 theta(i) = atan2( stdlib_${ri}$nrm2( m-p-i+1, x21(i,i), 1 ),stdlib_${ri}$nrm2( p-i+1, x11(&
                           i,i), 1 ) )
                 if( p > i ) then
                    call stdlib_${ri}$larfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
                 else if( p == i ) then
                    call stdlib_${ri}$larfgp( p-i+1, x11(i,i), x11(i,i), 1, taup1(i) )
                 end if
                 x11(i,i) = one
                 if ( m-p > i ) then
                    call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1,taup2(i) )
                 else if ( m-p == i ) then
                    call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i,i), 1, taup2(i) )
                 end if
                 x21(i,i) = one
                 if ( q > i ) then
                    call stdlib_${ri}$larf( 'L', p-i+1, q-i, x11(i,i), 1, taup1(i),x11(i,i+1), ldx11, &
                              work )
                 end if
                 if ( m-q+1 > i ) then
                    call stdlib_${ri}$larf( 'L', p-i+1, m-q-i+1, x11(i,i), 1, taup1(i),x12(i,i), ldx12,&
                               work )
                 end if
                 if ( q > i ) then
                    call stdlib_${ri}$larf( 'L', m-p-i+1, q-i, x21(i,i), 1, taup2(i),x21(i,i+1), ldx21,&
                               work )
                 end if
                 if ( m-q+1 > i ) then
                    call stdlib_${ri}$larf( 'L', m-p-i+1, m-q-i+1, x21(i,i), 1, taup2(i),x22(i,i), &
                              ldx22, work )
                 end if
                 if( i < q ) then
                    call stdlib_${ri}$scal( q-i, -z1*z3*sin(theta(i)), x11(i,i+1),ldx11 )
                    call stdlib_${ri}$axpy( q-i, z2*z3*cos(theta(i)), x21(i,i+1), ldx21,x11(i,i+1), &
                              ldx11 )
                 end if
                 call stdlib_${ri}$scal( m-q-i+1, -z1*z4*sin(theta(i)), x12(i,i), ldx12 )
                 call stdlib_${ri}$axpy( m-q-i+1, z2*z4*cos(theta(i)), x22(i,i), ldx22,x12(i,i), ldx12 &
                           )
                 if( i < q )phi(i) = atan2( stdlib_${ri}$nrm2( q-i, x11(i,i+1), ldx11 ),stdlib_${ri}$nrm2( &
                           m-q-i+1, x12(i,i), ldx12 ) )
                 if( i < q ) then
                    if ( q-i == 1 ) then
                       call stdlib_${ri}$larfgp( q-i, x11(i,i+1), x11(i,i+1), ldx11,tauq1(i) )
                    else
                       call stdlib_${ri}$larfgp( q-i, x11(i,i+1), x11(i,i+2), ldx11,tauq1(i) )
                    end if
                    x11(i,i+1) = one
                 end if
                 if ( q+i-1 < m ) then
                    if ( m-q == i ) then
                       call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i,i), ldx12,tauq2(i) )
                    else
                       call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i,i+1), ldx12,tauq2(i) )
                                 
                    end if
                 end if
                 x12(i,i) = one
                 if( i < q ) then
                    call stdlib_${ri}$larf( 'R', p-i, q-i, x11(i,i+1), ldx11, tauq1(i),x11(i+1,i+1), &
                              ldx11, work )
                    call stdlib_${ri}$larf( 'R', m-p-i, q-i, x11(i,i+1), ldx11, tauq1(i),x21(i+1,i+1), &
                              ldx21, work )
                 end if
                 if ( p > i ) then
                    call stdlib_${ri}$larf( 'R', p-i, m-q-i+1, x12(i,i), ldx12, tauq2(i),x12(i+1,i), &
                              ldx12, work )
                 end if
                 if ( m-p > i ) then
                    call stdlib_${ri}$larf( 'R', m-p-i, m-q-i+1, x12(i,i), ldx12,tauq2(i), x22(i+1,i), &
                              ldx22, work )
                 end if
              end do
              ! reduce columns q + 1, ..., p of x12, x22
              do i = q + 1, p
                 call stdlib_${ri}$scal( m-q-i+1, -z1*z4, x12(i,i), ldx12 )
                 if ( i >= m-q ) then
                    call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i,i), ldx12,tauq2(i) )
                 else
                    call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i,i+1), ldx12,tauq2(i) )
                 end if
                 x12(i,i) = one
                 if ( p > i ) then
                    call stdlib_${ri}$larf( 'R', p-i, m-q-i+1, x12(i,i), ldx12, tauq2(i),x12(i+1,i), &
                              ldx12, work )
                 end if
                 if( m-p-q >= 1 )call stdlib_${ri}$larf( 'R', m-p-q, m-q-i+1, x12(i,i), ldx12,tauq2(i),&
                            x22(q+1,i), ldx22, work )
              end do
              ! reduce columns p + 1, ..., m - q of x12, x22
              do i = 1, m - p - q
                 call stdlib_${ri}$scal( m-p-q-i+1, z2*z4, x22(q+i,p+i), ldx22 )
                 if ( i == m-p-q ) then
                    call stdlib_${ri}$larfgp( m-p-q-i+1, x22(q+i,p+i), x22(q+i,p+i),ldx22, tauq2(p+i) )
                              
                 else
                    call stdlib_${ri}$larfgp( m-p-q-i+1, x22(q+i,p+i), x22(q+i,p+i+1),ldx22, tauq2(p+i)&
                               )
                 end if
                 x22(q+i,p+i) = one
                 if ( i < m-p-q ) then
                    call stdlib_${ri}$larf( 'R', m-p-q-i, m-p-q-i+1, x22(q+i,p+i), ldx22,tauq2(p+i), &
                              x22(q+i+1,p+i), ldx22, work )
                 end if
              end do
           else
              ! reduce columns 1, ..., q of x11, x12, x21, x22
              do i = 1, q
                 if( i == 1 ) then
                    call stdlib_${ri}$scal( p-i+1, z1, x11(i,i), ldx11 )
                 else
                    call stdlib_${ri}$scal( p-i+1, z1*cos(phi(i-1)), x11(i,i), ldx11 )
                    call stdlib_${ri}$axpy( p-i+1, -z1*z3*z4*sin(phi(i-1)), x12(i-1,i),ldx12, x11(i,i),&
                               ldx11 )
                 end if
                 if( i == 1 ) then
                    call stdlib_${ri}$scal( m-p-i+1, z2, x21(i,i), ldx21 )
                 else
                    call stdlib_${ri}$scal( m-p-i+1, z2*cos(phi(i-1)), x21(i,i), ldx21 )
                    call stdlib_${ri}$axpy( m-p-i+1, -z2*z3*z4*sin(phi(i-1)), x22(i-1,i),ldx22, x21(i,&
                              i), ldx21 )
                 end if
                 theta(i) = atan2( stdlib_${ri}$nrm2( m-p-i+1, x21(i,i), ldx21 ),stdlib_${ri}$nrm2( p-i+1, &
                           x11(i,i), ldx11 ) )
                 call stdlib_${ri}$larfgp( p-i+1, x11(i,i), x11(i,i+1), ldx11, taup1(i) )
                 x11(i,i) = one
                 if ( i == m-p ) then
                    call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i,i), ldx21,taup2(i) )
                 else
                    call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i,i+1), ldx21,taup2(i) )
                 end if
                 x21(i,i) = one
                 if ( q > i ) then
                    call stdlib_${ri}$larf( 'R', q-i, p-i+1, x11(i,i), ldx11, taup1(i),x11(i+1,i), &
                              ldx11, work )
                 end if
                 if ( m-q+1 > i ) then
                    call stdlib_${ri}$larf( 'R', m-q-i+1, p-i+1, x11(i,i), ldx11,taup1(i), x12(i,i), &
                              ldx12, work )
                 end if
                 if ( q > i ) then
                    call stdlib_${ri}$larf( 'R', q-i, m-p-i+1, x21(i,i), ldx21, taup2(i),x21(i+1,i), &
                              ldx21, work )
                 end if
                 if ( m-q+1 > i ) then
                    call stdlib_${ri}$larf( 'R', m-q-i+1, m-p-i+1, x21(i,i), ldx21,taup2(i), x22(i,i), &
                              ldx22, work )
                 end if
                 if( i < q ) then
                    call stdlib_${ri}$scal( q-i, -z1*z3*sin(theta(i)), x11(i+1,i), 1 )
                    call stdlib_${ri}$axpy( q-i, z2*z3*cos(theta(i)), x21(i+1,i), 1,x11(i+1,i), 1 )
                              
                 end if
                 call stdlib_${ri}$scal( m-q-i+1, -z1*z4*sin(theta(i)), x12(i,i), 1 )
                 call stdlib_${ri}$axpy( m-q-i+1, z2*z4*cos(theta(i)), x22(i,i), 1,x12(i,i), 1 )
                           
                 if( i < q )phi(i) = atan2( stdlib_${ri}$nrm2( q-i, x11(i+1,i), 1 ),stdlib_${ri}$nrm2( m-q-&
                           i+1, x12(i,i), 1 ) )
                 if( i < q ) then
                    if ( q-i == 1) then
                       call stdlib_${ri}$larfgp( q-i, x11(i+1,i), x11(i+1,i), 1,tauq1(i) )
                    else
                       call stdlib_${ri}$larfgp( q-i, x11(i+1,i), x11(i+2,i), 1,tauq1(i) )
                    end if
                    x11(i+1,i) = one
                 end if
                 if ( m-q > i ) then
                    call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i+1,i), 1,tauq2(i) )
                 else
                    call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i,i), 1,tauq2(i) )
                 end if
                 x12(i,i) = one
                 if( i < q ) then
                    call stdlib_${ri}$larf( 'L', q-i, p-i, x11(i+1,i), 1, tauq1(i),x11(i+1,i+1), ldx11,&
                               work )
                    call stdlib_${ri}$larf( 'L', q-i, m-p-i, x11(i+1,i), 1, tauq1(i),x21(i+1,i+1), &
                              ldx21, work )
                 end if
                 call stdlib_${ri}$larf( 'L', m-q-i+1, p-i, x12(i,i), 1, tauq2(i),x12(i,i+1), ldx12, &
                           work )
                 if ( m-p-i > 0 ) then
                    call stdlib_${ri}$larf( 'L', m-q-i+1, m-p-i, x12(i,i), 1, tauq2(i),x22(i,i+1), &
                              ldx22, work )
                 end if
              end do
              ! reduce columns q + 1, ..., p of x12, x22
              do i = q + 1, p
                 call stdlib_${ri}$scal( m-q-i+1, -z1*z4, x12(i,i), 1 )
                 call stdlib_${ri}$larfgp( m-q-i+1, x12(i,i), x12(i+1,i), 1, tauq2(i) )
                 x12(i,i) = one
                 if ( p > i ) then
                    call stdlib_${ri}$larf( 'L', m-q-i+1, p-i, x12(i,i), 1, tauq2(i),x12(i,i+1), ldx12,&
                               work )
                 end if
                 if( m-p-q >= 1 )call stdlib_${ri}$larf( 'L', m-q-i+1, m-p-q, x12(i,i), 1, tauq2(i),&
                           x22(i,q+1), ldx22, work )
              end do
              ! reduce columns p + 1, ..., m - q of x12, x22
              do i = 1, m - p - q
                 call stdlib_${ri}$scal( m-p-q-i+1, z2*z4, x22(p+i,q+i), 1 )
                 if ( m-p-q == i ) then
                    call stdlib_${ri}$larfgp( m-p-q-i+1, x22(p+i,q+i), x22(p+i,q+i), 1,tauq2(p+i) )
                              
                 else
                    call stdlib_${ri}$larfgp( m-p-q-i+1, x22(p+i,q+i), x22(p+i+1,q+i), 1,tauq2(p+i) )
                              
                    call stdlib_${ri}$larf( 'L', m-p-q-i+1, m-p-q-i, x22(p+i,q+i), 1,tauq2(p+i), x22(p+&
                              i,q+i+1), ldx22, work )
                 end if
                 x22(p+i,q+i) = one
              end do
           end if
           return
     end subroutine stdlib_${ri}$orbdb


     subroutine stdlib_${ri}$orbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! DORBDB1: simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
     !! M-P, or M-Q. Routines DORBDB2, DORBDB3, and DORBDB4 handle cases in
     !! which Q is not the minimum dimension.
     !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
     !! angles THETA, PHI.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( p < q .or. m-p < q ) then
              info = -2
           else if( q < 0 .or. m-q < q ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( p-1, m-p-1, q-1 )
              iorbdb5 = 2
              lorbdb5 = q-2
              lworkopt = max( ilarf+llarf-1, iorbdb5+lorbdb5-1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB1', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce columns 1, ..., q of x11 and x21
           do i = 1, q
              call stdlib_${ri}$larfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
              call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1, taup2(i) )
              theta(i) = atan2( x21(i,i), x11(i,i) )
              c = cos( theta(i) )
              s = sin( theta(i) )
              x11(i,i) = one
              x21(i,i) = one
              call stdlib_${ri}$larf( 'L', p-i+1, q-i, x11(i,i), 1, taup1(i), x11(i,i+1),ldx11, work(&
                        ilarf) )
              call stdlib_${ri}$larf( 'L', m-p-i+1, q-i, x21(i,i), 1, taup2(i),x21(i,i+1), ldx21, work(&
                        ilarf) )
              if( i < q ) then
                 call stdlib_${ri}$rot( q-i, x11(i,i+1), ldx11, x21(i,i+1), ldx21, c, s )
                 call stdlib_${ri}$larfgp( q-i, x21(i,i+1), x21(i,i+2), ldx21, tauq1(i) )
                 s = x21(i,i+1)
                 x21(i,i+1) = one
                 call stdlib_${ri}$larf( 'R', p-i, q-i, x21(i,i+1), ldx21, tauq1(i),x11(i+1,i+1), &
                           ldx11, work(ilarf) )
                 call stdlib_${ri}$larf( 'R', m-p-i, q-i, x21(i,i+1), ldx21, tauq1(i),x21(i+1,i+1), &
                           ldx21, work(ilarf) )
                 c = sqrt( stdlib_${ri}$nrm2( p-i, x11(i+1,i+1), 1 )**2+ stdlib_${ri}$nrm2( m-p-i, x21(i+1,&
                           i+1), 1 )**2 )
                 phi(i) = atan2( s, c )
                 call stdlib_${ri}$orbdb5( p-i, m-p-i, q-i-1, x11(i+1,i+1), 1,x21(i+1,i+1), 1, x11(i+1,&
                           i+2), ldx11,x21(i+1,i+2), ldx21, work(iorbdb5), lorbdb5,childinfo )
              end if
           end do
           return
     end subroutine stdlib_${ri}$orbdb1


     subroutine stdlib_${ri}$orbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! DORBDB2: simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
     !! Q, or M-Q. Routines DORBDB1, DORBDB3, and DORBDB4 handle cases in
     !! which P is not the minimum dimension.
     !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
     !! angles THETA, PHI.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( p < 0 .or. p > m-p ) then
              info = -2
           else if( q < 0 .or. q < p .or. m-q < p ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( p-1, m-p, q-1 )
              iorbdb5 = 2
              lorbdb5 = q-1
              lworkopt = max( ilarf+llarf-1, iorbdb5+lorbdb5-1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB2', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce rows 1, ..., p of x11 and x21
           do i = 1, p
              if( i > 1 ) then
                 call stdlib_${ri}$rot( q-i+1, x11(i,i), ldx11, x21(i-1,i), ldx21, c, s )
              end if
              call stdlib_${ri}$larfgp( q-i+1, x11(i,i), x11(i,i+1), ldx11, tauq1(i) )
              c = x11(i,i)
              x11(i,i) = one
              call stdlib_${ri}$larf( 'R', p-i, q-i+1, x11(i,i), ldx11, tauq1(i),x11(i+1,i), ldx11, &
                        work(ilarf) )
              call stdlib_${ri}$larf( 'R', m-p-i+1, q-i+1, x11(i,i), ldx11, tauq1(i),x21(i,i), ldx21, &
                        work(ilarf) )
              s = sqrt( stdlib_${ri}$nrm2( p-i, x11(i+1,i), 1 )**2+ stdlib_${ri}$nrm2( m-p-i+1, x21(i,i), 1 &
                        )**2 )
              theta(i) = atan2( s, c )
              call stdlib_${ri}$orbdb5( p-i, m-p-i+1, q-i, x11(i+1,i), 1, x21(i,i), 1,x11(i+1,i+1), &
                        ldx11, x21(i,i+1), ldx21,work(iorbdb5), lorbdb5, childinfo )
              call stdlib_${ri}$scal( p-i, negone, x11(i+1,i), 1 )
              call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1, taup2(i) )
              if( i < p ) then
                 call stdlib_${ri}$larfgp( p-i, x11(i+1,i), x11(i+2,i), 1, taup1(i) )
                 phi(i) = atan2( x11(i+1,i), x21(i,i) )
                 c = cos( phi(i) )
                 s = sin( phi(i) )
                 x11(i+1,i) = one
                 call stdlib_${ri}$larf( 'L', p-i, q-i, x11(i+1,i), 1, taup1(i),x11(i+1,i+1), ldx11, &
                           work(ilarf) )
              end if
              x21(i,i) = one
              call stdlib_${ri}$larf( 'L', m-p-i+1, q-i, x21(i,i), 1, taup2(i),x21(i,i+1), ldx21, work(&
                        ilarf) )
           end do
           ! reduce the bottom-right portion of x21 to the identity matrix
           do i = p + 1, q
              call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1, taup2(i) )
              x21(i,i) = one
              call stdlib_${ri}$larf( 'L', m-p-i+1, q-i, x21(i,i), 1, taup2(i),x21(i,i+1), ldx21, work(&
                        ilarf) )
           end do
           return
     end subroutine stdlib_${ri}$orbdb2


     subroutine stdlib_${ri}$orbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! DORBDB3: simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
     !! Q, or M-Q. Routines DORBDB1, DORBDB2, and DORBDB4 handle cases in
     !! which M-P is not the minimum dimension.
     !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
     !! implicitly by angles THETA, PHI.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( 2*p < m .or. p > m ) then
              info = -2
           else if( q < m-p .or. m-q < m-p ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( p, m-p-1, q-1 )
              iorbdb5 = 2
              lorbdb5 = q-1
              lworkopt = max( ilarf+llarf-1, iorbdb5+lorbdb5-1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce rows 1, ..., m-p of x11 and x21
           do i = 1, m-p
              if( i > 1 ) then
                 call stdlib_${ri}$rot( q-i+1, x11(i-1,i), ldx11, x21(i,i), ldx11, c, s )
              end if
              call stdlib_${ri}$larfgp( q-i+1, x21(i,i), x21(i,i+1), ldx21, tauq1(i) )
              s = x21(i,i)
              x21(i,i) = one
              call stdlib_${ri}$larf( 'R', p-i+1, q-i+1, x21(i,i), ldx21, tauq1(i),x11(i,i), ldx11, &
                        work(ilarf) )
              call stdlib_${ri}$larf( 'R', m-p-i, q-i+1, x21(i,i), ldx21, tauq1(i),x21(i+1,i), ldx21, &
                        work(ilarf) )
              c = sqrt( stdlib_${ri}$nrm2( p-i+1, x11(i,i), 1 )**2+ stdlib_${ri}$nrm2( m-p-i, x21(i+1,i), 1 &
                        )**2 )
              theta(i) = atan2( s, c )
              call stdlib_${ri}$orbdb5( p-i+1, m-p-i, q-i, x11(i,i), 1, x21(i+1,i), 1,x11(i,i+1), &
                        ldx11, x21(i+1,i+1), ldx21,work(iorbdb5), lorbdb5, childinfo )
              call stdlib_${ri}$larfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
              if( i < m-p ) then
                 call stdlib_${ri}$larfgp( m-p-i, x21(i+1,i), x21(i+2,i), 1, taup2(i) )
                 phi(i) = atan2( x21(i+1,i), x11(i,i) )
                 c = cos( phi(i) )
                 s = sin( phi(i) )
                 x21(i+1,i) = one
                 call stdlib_${ri}$larf( 'L', m-p-i, q-i, x21(i+1,i), 1, taup2(i),x21(i+1,i+1), ldx21, &
                           work(ilarf) )
              end if
              x11(i,i) = one
              call stdlib_${ri}$larf( 'L', p-i+1, q-i, x11(i,i), 1, taup1(i), x11(i,i+1),ldx11, work(&
                        ilarf) )
           end do
           ! reduce the bottom-right portion of x11 to the identity matrix
           do i = m-p + 1, q
              call stdlib_${ri}$larfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
              x11(i,i) = one
              call stdlib_${ri}$larf( 'L', p-i+1, q-i, x11(i,i), 1, taup1(i), x11(i,i+1),ldx11, work(&
                        ilarf) )
           end do
           return
     end subroutine stdlib_${ri}$orbdb3


     subroutine stdlib_${ri}$orbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! DORBDB4: simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
     !! M-P, or Q. Routines DORBDB1, DORBDB2, and DORBDB3 handle cases in
     !! which M-Q is not the minimum dimension.
     !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
     !! implicitly by angles THETA, PHI.
               phantom, work, lwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, j, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( p < m-q .or. m-p < m-q ) then
              info = -2
           else if( q < m-q .or. q > m ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( q-1, p-1, m-p-1 )
              iorbdb5 = 2
              lorbdb5 = q
              lworkopt = ilarf + llarf - 1
              lworkopt = max( lworkopt, iorbdb5 + lorbdb5 - 1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB4', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce columns 1, ..., m-q of x11 and x21
           do i = 1, m-q
              if( i == 1 ) then
                 do j = 1, m
                    phantom(j) = zero
                 end do
                 call stdlib_${ri}$orbdb5( p, m-p, q, phantom(1), 1, phantom(p+1), 1,x11, ldx11, x21, &
                           ldx21, work(iorbdb5),lorbdb5, childinfo )
                 call stdlib_${ri}$scal( p, negone, phantom(1), 1 )
                 call stdlib_${ri}$larfgp( p, phantom(1), phantom(2), 1, taup1(1) )
                 call stdlib_${ri}$larfgp( m-p, phantom(p+1), phantom(p+2), 1, taup2(1) )
                 theta(i) = atan2( phantom(1), phantom(p+1) )
                 c = cos( theta(i) )
                 s = sin( theta(i) )
                 phantom(1) = one
                 phantom(p+1) = one
                 call stdlib_${ri}$larf( 'L', p, q, phantom(1), 1, taup1(1), x11, ldx11,work(ilarf) )
                           
                 call stdlib_${ri}$larf( 'L', m-p, q, phantom(p+1), 1, taup2(1), x21,ldx21, work(ilarf)&
                            )
              else
                 call stdlib_${ri}$orbdb5( p-i+1, m-p-i+1, q-i+1, x11(i,i-1), 1,x21(i,i-1), 1, x11(i,i)&
                           , ldx11, x21(i,i),ldx21, work(iorbdb5), lorbdb5, childinfo )
                 call stdlib_${ri}$scal( p-i+1, negone, x11(i,i-1), 1 )
                 call stdlib_${ri}$larfgp( p-i+1, x11(i,i-1), x11(i+1,i-1), 1, taup1(i) )
                 call stdlib_${ri}$larfgp( m-p-i+1, x21(i,i-1), x21(i+1,i-1), 1,taup2(i) )
                 theta(i) = atan2( x11(i,i-1), x21(i,i-1) )
                 c = cos( theta(i) )
                 s = sin( theta(i) )
                 x11(i,i-1) = one
                 x21(i,i-1) = one
                 call stdlib_${ri}$larf( 'L', p-i+1, q-i+1, x11(i,i-1), 1, taup1(i),x11(i,i), ldx11, &
                           work(ilarf) )
                 call stdlib_${ri}$larf( 'L', m-p-i+1, q-i+1, x21(i,i-1), 1, taup2(i),x21(i,i), ldx21, &
                           work(ilarf) )
              end if
              call stdlib_${ri}$rot( q-i+1, x11(i,i), ldx11, x21(i,i), ldx21, s, -c )
              call stdlib_${ri}$larfgp( q-i+1, x21(i,i), x21(i,i+1), ldx21, tauq1(i) )
              c = x21(i,i)
              x21(i,i) = one
              call stdlib_${ri}$larf( 'R', p-i, q-i+1, x21(i,i), ldx21, tauq1(i),x11(i+1,i), ldx11, &
                        work(ilarf) )
              call stdlib_${ri}$larf( 'R', m-p-i, q-i+1, x21(i,i), ldx21, tauq1(i),x21(i+1,i), ldx21, &
                        work(ilarf) )
              if( i < m-q ) then
                 s = sqrt( stdlib_${ri}$nrm2( p-i, x11(i+1,i), 1 )**2+ stdlib_${ri}$nrm2( m-p-i, x21(i+1,i),&
                            1 )**2 )
                 phi(i) = atan2( s, c )
              end if
           end do
           ! reduce the bottom-right portion of x11 to [ i 0 ]
           do i = m - q + 1, p
              call stdlib_${ri}$larfgp( q-i+1, x11(i,i), x11(i,i+1), ldx11, tauq1(i) )
              x11(i,i) = one
              call stdlib_${ri}$larf( 'R', p-i, q-i+1, x11(i,i), ldx11, tauq1(i),x11(i+1,i), ldx11, &
                        work(ilarf) )
              call stdlib_${ri}$larf( 'R', q-p, q-i+1, x11(i,i), ldx11, tauq1(i),x21(m-q+1,i), ldx21, &
                        work(ilarf) )
           end do
           ! reduce the bottom-right portion of x21 to [ 0 i ]
           do i = p + 1, q
              call stdlib_${ri}$larfgp( q-i+1, x21(m-q+i-p,i), x21(m-q+i-p,i+1), ldx21,tauq1(i) )
                        
              x21(m-q+i-p,i) = one
              call stdlib_${ri}$larf( 'R', q-i, q-i+1, x21(m-q+i-p,i), ldx21, tauq1(i),x21(m-q+i-p+1,i)&
                        , ldx21, work(ilarf) )
           end do
           return
     end subroutine stdlib_${ri}$orbdb4


     pure subroutine stdlib_${ri}$orbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
     !! DORBDB5: orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           intrinsic :: max
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_${ri}$nrm2(m1,x1,incx1) /= zero.or. stdlib_${ri}$nrm2(m2,x2,incx2) /= zero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = zero
              end do
              x1(i) = one
              do j = 1, m2
                 x2(j) = zero
              end do
              call stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_${ri}$nrm2(m1,x1,incx1) /= zero.or. stdlib_${ri}$nrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = zero
              end do
              do j = 1, m2
                 x2(j) = zero
              end do
              x2(i) = one
              call stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_${ri}$nrm2(m1,x1,incx1) /= zero.or. stdlib_${ri}$nrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_${ri}$orbdb5


     pure subroutine stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
     !! DORBDB6: orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: alphasq = 0.01_${rk}$
           real(${rk}$), parameter :: realone = 1.0_${rk}$
           real(${rk}$), parameter :: realzero = 0.0_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           intrinsic :: max
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ri}$lassq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_${ri}$gemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_${ri}$gemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_${ri}$gemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_${ri}$gemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ri}$lassq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is zero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == zero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = zero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_${ri}$gemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_${ri}$gemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_${ri}$gemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_${ri}$gemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to zero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = zero
              end do
              do i = 1, m2
                 x2(i) = zero
              end do
           end if
           return
     end subroutine stdlib_${ri}$orbdb6


     recursive subroutine stdlib_${ri}$orcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     !! DORCSD: computes the CS decomposition of an M-by-M partitioned
     !! orthogonal matrix X:
     !! [  I  0  0 |  0  0  0 ]
     !! [  0  C  0 |  0 -S  0 ]
     !! [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T
     !! X = [-----------] = [---------] [---------------------] [---------]   .
     !! [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
     !! [  0  S  0 |  0  C  0 ]
     !! [  0  0  I |  0  0  0 ]
     !! X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
     !! (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
     !! R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
     !! which R = MIN(P,M-P,Q,M-Q).
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lwork, m, p, q
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(out) :: theta(*)
           real(${rk}$), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           real(${rk}$), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
        ! ===================================================================
           
           ! Local Scalars 
           character :: transt, signst
           integer(ilp) :: childinfo, i, ib11d, ib11e, ib12d, ib12e, ib21d, ib21e, ib22d, ib22e, &
           ibbcsd, iorbdb, iorglq, iorgqr, iphi, itaup1, itaup2, itauq1, itauq2, j, lbbcsdwork, &
           lbbcsdworkmin, lbbcsdworkopt, lorbdbwork, lorbdbworkmin, lorbdbworkopt, lorglqwork, &
           lorglqworkmin, lorglqworkopt, lorgqrwork, lorgqrworkmin, lorgqrworkopt, lworkmin, &
                     lworkopt
           logical(lk) :: colmajor, defaultsigns, lquery, wantu1, wantu2, wantv1t, wantv2t
           ! Intrinsic Functions
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test input arguments
           info = 0
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           defaultsigns = .not. stdlib_lsame( signs, 'O' )
           lquery = lwork == -1
           if( m < 0 ) then
              info = -7
           else if( p < 0 .or. p > m ) then
              info = -8
           else if( q < 0 .or. q > m ) then
              info = -9
           else if ( colmajor .and.  ldx11 < max( 1, p ) ) then
             info = -11
           else if (.not. colmajor .and. ldx11 < max( 1, q ) ) then
             info = -11
           else if (colmajor .and. ldx12 < max( 1, p ) ) then
             info = -13
           else if (.not. colmajor .and. ldx12 < max( 1, m-q ) ) then
             info = -13
           else if (colmajor .and. ldx21 < max( 1, m-p ) ) then
             info = -15
           else if (.not. colmajor .and. ldx21 < max( 1, q ) ) then
             info = -15
           else if (colmajor .and. ldx22 < max( 1, m-p ) ) then
             info = -17
           else if (.not. colmajor .and. ldx22 < max( 1, m-q ) ) then
             info = -17
           else if( wantu1 .and. ldu1 < p ) then
              info = -20
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -22
           else if( wantv1t .and. ldv1t < q ) then
              info = -24
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -26
           end if
           ! work with transpose if convenient
           if( info == 0 .and. min( p, m-p ) < min( q, m-q ) ) then
              if( colmajor ) then
                 transt = 'T'
              else
                 transt = 'N'
              end if
              if( defaultsigns ) then
                 signst = 'O'
              else
                 signst = 'D'
              end if
              call stdlib_${ri}$orcsd( jobv1t, jobv2t, jobu1, jobu2, transt, signst, m,q, p, x11, &
              ldx11, x21, ldx21, x12, ldx12, x22,ldx22, theta, v1t, ldv1t, v2t, ldv2t, u1, ldu1,&
                        u2, ldu2, work, lwork, iwork, info )
              return
           end if
           ! work with permutation [ 0 i; i 0 ] * x * [ 0 i; i 0 ] if
           ! convenient
           if( info == 0 .and. m-q < q ) then
              if( defaultsigns ) then
                 signst = 'O'
              else
                 signst = 'D'
              end if
              call stdlib_${ri}$orcsd( jobu2, jobu1, jobv2t, jobv1t, trans, signst, m,m-p, m-q, x22, &
              ldx22, x21, ldx21, x12, ldx12, x11,ldx11, theta, u2, ldu2, u1, ldu1, v2t, ldv2t, &
                        v1t,ldv1t, work, lwork, iwork, info )
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iphi = 2
              itaup1 = iphi + max( 1, q - 1 )
              itaup2 = itaup1 + max( 1, p )
              itauq1 = itaup2 + max( 1, m - p )
              itauq2 = itauq1 + max( 1, q )
              iorgqr = itauq2 + max( 1, m - q )
              call stdlib_${ri}$orgqr( m-q, m-q, m-q, u1, max(1,m-q), u1, work, -1,childinfo )
              lorgqrworkopt = int( work(1),KIND=ilp)
              lorgqrworkmin = max( 1, m - q )
              iorglq = itauq2 + max( 1, m - q )
              call stdlib_${ri}$orglq( m-q, m-q, m-q, u1, max(1,m-q), u1, work, -1,childinfo )
              lorglqworkopt = int( work(1),KIND=ilp)
              lorglqworkmin = max( 1, m - q )
              iorbdb = itauq2 + max( 1, m - q )
              call stdlib_${ri}$orbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                        ldx22, theta, v1t, u1, u2, v1t,v2t, work, -1, childinfo )
              lorbdbworkopt = int( work(1),KIND=ilp)
              lorbdbworkmin = lorbdbworkopt
              ib11d = itauq2 + max( 1, m - q )
              ib11e = ib11d + max( 1, q )
              ib12d = ib11e + max( 1, q - 1 )
              ib12e = ib12d + max( 1, q )
              ib21d = ib12e + max( 1, q - 1 )
              ib21e = ib21d + max( 1, q )
              ib22d = ib21e + max( 1, q - 1 )
              ib22e = ib22d + max( 1, q )
              ibbcsd = ib22e + max( 1, q - 1 )
              call stdlib_${ri}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, theta, u1, &
              ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, u1, u1, u1, u1, u1, u1, u1, u1, work, -1,&
                        childinfo )
              lbbcsdworkopt = int( work(1),KIND=ilp)
              lbbcsdworkmin = lbbcsdworkopt
              lworkopt = max( iorgqr + lorgqrworkopt, iorglq + lorglqworkopt,iorbdb + &
                        lorbdbworkopt, ibbcsd + lbbcsdworkopt ) - 1
              lworkmin = max( iorgqr + lorgqrworkmin, iorglq + lorglqworkmin,iorbdb + &
                        lorbdbworkopt, ibbcsd + lbbcsdworkmin ) - 1
              work(1) = max(lworkopt,lworkmin)
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -22
              else
                 lorgqrwork = lwork - iorgqr + 1
                 lorglqwork = lwork - iorglq + 1
                 lorbdbwork = lwork - iorbdb + 1
                 lbbcsdwork = lwork - ibbcsd + 1
              end if
           end if
           ! abort if any illegal arguments
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! transform to bidiagonal block form
           call stdlib_${ri}$orbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21,ldx21, x22, &
           ldx22, theta, work(iphi), work(itaup1),work(itaup2), work(itauq1), work(itauq2),work(&
                     iorbdb), lorbdbwork, childinfo )
           ! accumulate householder reflectors
           if( colmajor ) then
              if( wantu1 .and. p > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', p, q, x11, ldx11, u1, ldu1 )
                 call stdlib_${ri}$orgqr( p, p, q, u1, ldu1, work(itaup1), work(iorgqr),lorgqrwork, &
                           info)
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', m-p, q, x21, ldx21, u2, ldu2 )
                 call stdlib_${ri}$orgqr( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorgqr), lorgqrwork,&
                            info )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', q-1, q-1, x11(1,2), ldx11, v1t(2,2),ldv1t )
                 v1t(1, 1) = one
                 do j = 2, q
                    v1t(1,j) = zero
                    v1t(j,1) = zero
                 end do
                 call stdlib_${ri}$orglq( q-1, q-1, q-1, v1t(2,2), ldv1t, work(itauq1),work(iorglq), &
                           lorglqwork, info )
              end if
              if( wantv2t .and. m-q > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', p, m-q, x12, ldx12, v2t, ldv2t )
                 if (m-p > q) then
                    call stdlib_${ri}$lacpy( 'U', m-p-q, m-p-q, x22(q+1,p+1), ldx22,v2t(p+1,p+1), &
                              ldv2t )
                 end if
                 if (m > q) then
                    call stdlib_${ri}$orglq( m-q, m-q, m-q, v2t, ldv2t, work(itauq2),work(iorglq), &
                              lorglqwork, info )
                 end if
              end if
           else
              if( wantu1 .and. p > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', q, p, x11, ldx11, u1, ldu1 )
                 call stdlib_${ri}$orglq( p, p, q, u1, ldu1, work(itaup1), work(iorglq),lorglqwork, &
                           info)
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', q, m-p, x21, ldx21, u2, ldu2 )
                 call stdlib_${ri}$orglq( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorglq), lorglqwork,&
                            info )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', q-1, q-1, x11(2,1), ldx11, v1t(2,2),ldv1t )
                 v1t(1, 1) = one
                 do j = 2, q
                    v1t(1,j) = zero
                    v1t(j,1) = zero
                 end do
                 call stdlib_${ri}$orgqr( q-1, q-1, q-1, v1t(2,2), ldv1t, work(itauq1),work(iorgqr), &
                           lorgqrwork, info )
              end if
              if( wantv2t .and. m-q > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', m-q, p, x12, ldx12, v2t, ldv2t )
                 call stdlib_${ri}$lacpy( 'L', m-p-q, m-p-q, x22(p+1,q+1), ldx22,v2t(p+1,p+1), ldv2t )
                           
                 call stdlib_${ri}$orgqr( m-q, m-q, m-q, v2t, ldv2t, work(itauq2),work(iorgqr), &
                           lorgqrwork, info )
              end if
           end if
           ! compute the csd of the matrix in bidiagonal-block form
           call stdlib_${ri}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta,work(iphi), u1,&
            ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, work(ib11d), work(ib11e), work(ib12d),work(&
            ib12e), work(ib21d), work(ib21e), work(ib22d),work(ib22e), work(ibbcsd), lbbcsdwork, &
                      info )
           ! permute rows and columns to place identity submatrices in top-
           ! left corner of (1,1)-block and/or bottom-right corner of (1,2)-
           ! block and/or bottom-right corner of (2,1)-block and/or top-left
           ! corner of (2,2)-block
           if( q > 0 .and. wantu2 ) then
              do i = 1, q
                 iwork(i) = m - p - q + i
              end do
              do i = q + 1, m - p
                 iwork(i) = i - q
              end do
              if( colmajor ) then
                 call stdlib_${ri}$lapmt( .false., m-p, m-p, u2, ldu2, iwork )
              else
                 call stdlib_${ri}$lapmr( .false., m-p, m-p, u2, ldu2, iwork )
              end if
           end if
           if( m > 0 .and. wantv2t ) then
              do i = 1, p
                 iwork(i) = m - p - q + i
              end do
              do i = p + 1, m - q
                 iwork(i) = i - p
              end do
              if( .not. colmajor ) then
                 call stdlib_${ri}$lapmt( .false., m-q, m-q, v2t, ldv2t, iwork )
              else
                 call stdlib_${ri}$lapmr( .false., m-q, m-q, v2t, ldv2t, iwork )
              end if
           end if
           return
           ! end stdlib_${ri}$orcsd
     end subroutine stdlib_${ri}$orcsd


     subroutine stdlib_${ri}$orcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
     !! DORCSD2BY1: computes the CS decomposition of an M-by-Q matrix X with
     !! orthonormal columns that has been partitioned into a 2-by-1 block
     !! structure:
     !! [  I1 0  0 ]
     !! [  0  C  0 ]
     !! [ X11 ]   [ U1 |    ] [  0  0  0 ]
     !! X = [-----] = [---------] [----------] V1**T .
     !! [ X21 ]   [    | U2 ] [  0  0  0 ]
     !! [  0  S  0 ]
     !! [  0  0  I2]
     !! X11 is P-by-Q. The orthogonal matrices U1, U2, and V1 are P-by-P,
     !! (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
     !! nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
     !! R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
     !! K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
        ! -- lapack computational routine (3.5.0_${rk}$) --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           ! Array Arguments 
           real(${rk}$), intent(out) :: theta(*)
           real(${rk}$), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, ib11d, ib11e, ib12d, ib12e, ib21d, ib21e, ib22d, ib22e, &
           ibbcsd, iorbdb, iorglq, iorgqr, iphi, itaup1, itaup2, itauq1, j, lbbcsd, lorbdb, &
           lorglq, lorglqmin, lorglqopt, lorgqr, lorgqrmin, lorgqropt, lworkmin, lworkopt, &
                     r
           logical(lk) :: lquery, wantu1, wantu2, wantv1t
           ! Local Arrays 
           real(${rk}$) :: dum1(1), dum2(1,1)
           ! Intrinsic Function 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test input arguments
           info = 0
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           lquery = lwork == -1
           if( m < 0 ) then
              info = -4
           else if( p < 0 .or. p > m ) then
              info = -5
           else if( q < 0 .or. q > m ) then
              info = -6
           else if( ldx11 < max( 1, p ) ) then
              info = -8
           else if( ldx21 < max( 1, m-p ) ) then
              info = -10
           else if( wantu1 .and. ldu1 < max( 1, p ) ) then
              info = -13
           else if( wantu2 .and. ldu2 < max( 1, m - p ) ) then
              info = -15
           else if( wantv1t .and. ldv1t < max( 1, q ) ) then
              info = -17
           end if
           r = min( p, m-p, q, m-q )
           ! compute workspace
             ! work layout:
           ! |-------------------------------------------------------|
           ! | lworkopt (1)                                          |
           ! |-------------------------------------------------------|
           ! | phi (max(1,r-1))                                      |
           ! |-------------------------------------------------------|
           ! | taup1 (max(1,p))                        | b11d (r)    |
           ! | taup2 (max(1,m-p))                      | b11e (r-1)  |
           ! | tauq1 (max(1,q))                        | b12d (r)    |
           ! |-----------------------------------------| b12e (r-1)  |
           ! | stdlib_${ri}$orbdb work | stdlib_${ri}$orgqr work | stdlib_${ri}$orglq work | b21d (r)    |
           ! |             |             |             | b21e (r-1)  |
           ! |             |             |             | b22d (r)    |
           ! |             |             |             | b22e (r-1)  |
           ! |             |             |             | stdlib_${ri}$bbcsd work |
           ! |-------------------------------------------------------|
           if( info == 0 ) then
              iphi = 2
              ib11d = iphi + max( 1, r-1 )
              ib11e = ib11d + max( 1, r )
              ib12d = ib11e + max( 1, r - 1 )
              ib12e = ib12d + max( 1, r )
              ib21d = ib12e + max( 1, r - 1 )
              ib21e = ib21d + max( 1, r )
              ib22d = ib21e + max( 1, r - 1 )
              ib22e = ib22d + max( 1, r )
              ibbcsd = ib22e + max( 1, r - 1 )
              itaup1 = iphi + max( 1, r-1 )
              itaup2 = itaup1 + max( 1, p )
              itauq1 = itaup2 + max( 1, m-p )
              iorbdb = itauq1 + max( 1, q )
              iorgqr = itauq1 + max( 1, q )
              iorglq = itauq1 + max( 1, q )
              lorgqrmin = 1
              lorgqropt = 1
              lorglqmin = 1
              lorglqopt = 1
              if( r == q ) then
                 call stdlib_${ri}$orbdb1( m, p, q, x11, ldx11, x21, ldx21, theta,dum1, dum1, dum1, &
                           dum1, work,-1, childinfo )
                 lorbdb = int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_${ri}$orgqr( p, p, q, u1, ldu1, dum1, work(1), -1,childinfo )
                    lorgqrmin = max( lorgqrmin, p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 endif
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_${ri}$orgqr( m-p, m-p, q, u2, ldu2, dum1, work(1),-1, childinfo )
                              
                    lorgqrmin = max( lorgqrmin, m-p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_${ri}$orglq( q-1, q-1, q-1, v1t, ldv1t,dum1, work(1), -1, childinfo )
                              
                    lorglqmin = max( lorglqmin, q-1 )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_${ri}$bbcsd( jobu1, jobu2, jobv1t, 'N', 'N', m, p, q, theta,dum1, u1, &
                 ldu1, u2, ldu2, v1t, ldv1t,dum2, 1, dum1, dum1, dum1,dum1, dum1, dum1, dum1,dum1,&
                            work(1), -1, childinfo )
                 lbbcsd = int( work(1),KIND=ilp)
              else if( r == p ) then
                 call stdlib_${ri}$orbdb2( m, p, q, x11, ldx11, x21, ldx21, theta,dum1, dum1, dum1, &
                           dum1,work(1), -1, childinfo )
                 lorbdb = int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_${ri}$orgqr( p-1, p-1, p-1, u1(2,2), ldu1, dum1,work(1), -1, childinfo &
                              )
                    lorgqrmin = max( lorgqrmin, p-1 )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_${ri}$orgqr( m-p, m-p, q, u2, ldu2, dum1, work(1),-1, childinfo )
                              
                    lorgqrmin = max( lorgqrmin, m-p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_${ri}$orglq( q, q, r, v1t, ldv1t, dum1, work(1), -1,childinfo )
                    lorglqmin = max( lorglqmin, q )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_${ri}$bbcsd( jobv1t, 'N', jobu1, jobu2, 'T', m, q, p, theta,dum1, v1t, &
                 ldv1t, dum2, 1, u1, ldu1,u2, ldu2, dum1, dum1, dum1,dum1, dum1, dum1, dum1,dum1, &
                           work(1), -1, childinfo )
                 lbbcsd = int( work(1),KIND=ilp)
              else if( r == m-p ) then
                 call stdlib_${ri}$orbdb3( m, p, q, x11, ldx11, x21, ldx21, theta,dum1, dum1, dum1, &
                           dum1,work(1), -1, childinfo )
                 lorbdb = int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_${ri}$orgqr( p, p, q, u1, ldu1, dum1, work(1), -1,childinfo )
                    lorgqrmin = max( lorgqrmin, p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_${ri}$orgqr( m-p-1, m-p-1, m-p-1, u2(2,2), ldu2,dum1, work(1), -1, &
                              childinfo )
                    lorgqrmin = max( lorgqrmin, m-p-1 )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_${ri}$orglq( q, q, r, v1t, ldv1t, dum1, work(1), -1,childinfo )
                    lorglqmin = max( lorglqmin, q )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_${ri}$bbcsd( 'N', jobv1t, jobu2, jobu1, 'T', m, m-q, m-p,theta, dum1, &
                 dum2, 1, v1t, ldv1t, u2,ldu2, u1, ldu1, dum1, dum1, dum1,dum1, dum1, dum1, dum1,&
                           dum1, work(1), -1, childinfo )
                 lbbcsd = int( work(1),KIND=ilp)
              else
                 call stdlib_${ri}$orbdb4( m, p, q, x11, ldx11, x21, ldx21, theta,dum1, dum1, dum1, &
                           dum1,dum1, work(1), -1, childinfo )
                 lorbdb = m + int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_${ri}$orgqr( p, p, m-q, u1, ldu1, dum1, work(1), -1,childinfo )
                    lorgqrmin = max( lorgqrmin, p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_${ri}$orgqr( m-p, m-p, m-q, u2, ldu2, dum1, work(1),-1, childinfo )
                              
                    lorgqrmin = max( lorgqrmin, m-p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_${ri}$orglq( q, q, q, v1t, ldv1t, dum1, work(1), -1,childinfo )
                    lorglqmin = max( lorglqmin, q )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_${ri}$bbcsd( jobu2, jobu1, 'N', jobv1t, 'N', m, m-p, m-q,theta, dum1, u2, &
                 ldu2, u1, ldu1, dum2,1, v1t, ldv1t, dum1, dum1, dum1,dum1, dum1, dum1, dum1,dum1,&
                            work(1), -1, childinfo )
                 lbbcsd = int( work(1),KIND=ilp)
              end if
              lworkmin = max( iorbdb+lorbdb-1,iorgqr+lorgqrmin-1,iorglq+lorglqmin-1,ibbcsd+lbbcsd-&
                        1 )
              lworkopt = max( iorbdb+lorbdb-1,iorgqr+lorgqropt-1,iorglq+lorglqopt-1,ibbcsd+lbbcsd-&
                        1 )
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                 info = -19
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORCSD2BY1', -info )
              return
           else if( lquery ) then
              return
           end if
           lorgqr = lwork-iorgqr+1
           lorglq = lwork-iorglq+1
           ! handle four cases separately: r = q, r = p, r = m-p, and r = m-q,
           ! in which r = min(p,m-p,q,m-q)
           if( r == q ) then
              ! case 1: r = q
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_${ri}$orbdb1( m, p, q, x11, ldx11, x21, ldx21, theta,work(iphi), work(itaup1)&
                        , work(itaup2),work(itauq1), work(iorbdb), lorbdb, childinfo )
              ! accumulate householder reflectors
              if( wantu1 .and. p > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', p, q, x11, ldx11, u1, ldu1 )
                 call stdlib_${ri}$orgqr( p, p, q, u1, ldu1, work(itaup1), work(iorgqr),lorgqr, &
                           childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', m-p, q, x21, ldx21, u2, ldu2 )
                 call stdlib_${ri}$orgqr( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 v1t(1,1) = one
                 do j = 2, q
                    v1t(1,j) = zero
                    v1t(j,1) = zero
                 end do
                 call stdlib_${ri}$lacpy( 'U', q-1, q-1, x21(1,2), ldx21, v1t(2,2),ldv1t )
                 call stdlib_${ri}$orglq( q-1, q-1, q-1, v1t(2,2), ldv1t, work(itauq1),work(iorglq), &
                           lorglq, childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_${ri}$bbcsd( jobu1, jobu2, jobv1t, 'N', 'N', m, p, q, theta,work(iphi), u1, &
              ldu1, u2, ldu2, v1t, ldv1t,dum2, 1, work(ib11d), work(ib11e),work(ib12d), work(&
              ib12e), work(ib21d),work(ib21e), work(ib22d), work(ib22e),work(ibbcsd), lbbcsd, &
                        childinfo )
              ! permute rows and columns to place zero submatrices in
              ! preferred positions
              if( q > 0 .and. wantu2 ) then
                 do i = 1, q
                    iwork(i) = m - p - q + i
                 end do
                 do i = q + 1, m - p
                    iwork(i) = i - q
                 end do
                 call stdlib_${ri}$lapmt( .false., m-p, m-p, u2, ldu2, iwork )
              end if
           else if( r == p ) then
              ! case 2: r = p
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_${ri}$orbdb2( m, p, q, x11, ldx11, x21, ldx21, theta,work(iphi), work(itaup1)&
                        , work(itaup2),work(itauq1), work(iorbdb), lorbdb, childinfo )
              ! accumulate householder reflectors
              if( wantu1 .and. p > 0 ) then
                 u1(1,1) = one
                 do j = 2, p
                    u1(1,j) = zero
                    u1(j,1) = zero
                 end do
                 call stdlib_${ri}$lacpy( 'L', p-1, p-1, x11(2,1), ldx11, u1(2,2), ldu1 )
                 call stdlib_${ri}$orgqr( p-1, p-1, p-1, u1(2,2), ldu1, work(itaup1),work(iorgqr), &
                           lorgqr, childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', m-p, q, x21, ldx21, u2, ldu2 )
                 call stdlib_${ri}$orgqr( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', p, q, x11, ldx11, v1t, ldv1t )
                 call stdlib_${ri}$orglq( q, q, r, v1t, ldv1t, work(itauq1),work(iorglq), lorglq, &
                           childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_${ri}$bbcsd( jobv1t, 'N', jobu1, jobu2, 'T', m, q, p, theta,work(iphi), v1t, &
              ldv1t, dum2, 1, u1, ldu1, u2,ldu2, work(ib11d), work(ib11e), work(ib12d),work(ib12e)&
              , work(ib21d), work(ib21e),work(ib22d), work(ib22e), work(ibbcsd), lbbcsd,childinfo &
                        )
              ! permute rows and columns to place identity submatrices in
              ! preferred positions
              if( q > 0 .and. wantu2 ) then
                 do i = 1, q
                    iwork(i) = m - p - q + i
                 end do
                 do i = q + 1, m - p
                    iwork(i) = i - q
                 end do
                 call stdlib_${ri}$lapmt( .false., m-p, m-p, u2, ldu2, iwork )
              end if
           else if( r == m-p ) then
              ! case 3: r = m-p
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_${ri}$orbdb3( m, p, q, x11, ldx11, x21, ldx21, theta,work(iphi), work(itaup1)&
                        , work(itaup2),work(itauq1), work(iorbdb), lorbdb, childinfo )
              ! accumulate householder reflectors
              if( wantu1 .and. p > 0 ) then
                 call stdlib_${ri}$lacpy( 'L', p, q, x11, ldx11, u1, ldu1 )
                 call stdlib_${ri}$orgqr( p, p, q, u1, ldu1, work(itaup1), work(iorgqr),lorgqr, &
                           childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 u2(1,1) = one
                 do j = 2, m-p
                    u2(1,j) = zero
                    u2(j,1) = zero
                 end do
                 call stdlib_${ri}$lacpy( 'L', m-p-1, m-p-1, x21(2,1), ldx21, u2(2,2),ldu2 )
                 call stdlib_${ri}$orgqr( m-p-1, m-p-1, m-p-1, u2(2,2), ldu2,work(itaup2), work(iorgqr)&
                           , lorgqr, childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', m-p, q, x21, ldx21, v1t, ldv1t )
                 call stdlib_${ri}$orglq( q, q, r, v1t, ldv1t, work(itauq1),work(iorglq), lorglq, &
                           childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_${ri}$bbcsd( 'N', jobv1t, jobu2, jobu1, 'T', m, m-q, m-p,theta, work(iphi), &
              dum2, 1, v1t, ldv1t, u2,ldu2, u1, ldu1, work(ib11d), work(ib11e),work(ib12d), work(&
              ib12e), work(ib21d),work(ib21e), work(ib22d), work(ib22e),work(ibbcsd), lbbcsd, &
                        childinfo )
              ! permute rows and columns to place identity submatrices in
              ! preferred positions
              if( q > r ) then
                 do i = 1, r
                    iwork(i) = q - r + i
                 end do
                 do i = r + 1, q
                    iwork(i) = i - r
                 end do
                 if( wantu1 ) then
                    call stdlib_${ri}$lapmt( .false., p, q, u1, ldu1, iwork )
                 end if
                 if( wantv1t ) then
                    call stdlib_${ri}$lapmr( .false., q, q, v1t, ldv1t, iwork )
                 end if
              end if
           else
              ! case 4: r = m-q
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_${ri}$orbdb4( m, p, q, x11, ldx11, x21, ldx21, theta,work(iphi), work(itaup1)&
              , work(itaup2),work(itauq1), work(iorbdb), work(iorbdb+m),lorbdb-m, childinfo )
                        
              ! accumulate householder reflectors
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_${ri}$copy( m-p, work(iorbdb+p), 1, u2, 1 )
              end if
              if( wantu1 .and. p > 0 ) then
                 call stdlib_${ri}$copy( p, work(iorbdb), 1, u1, 1 )
                 do j = 2, p
                    u1(1,j) = zero
                 end do
                 call stdlib_${ri}$lacpy( 'L', p-1, m-q-1, x11(2,1), ldx11, u1(2,2),ldu1 )
                 call stdlib_${ri}$orgqr( p, p, m-q, u1, ldu1, work(itaup1),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 do j = 2, m-p
                    u2(1,j) = zero
                 end do
                 call stdlib_${ri}$lacpy( 'L', m-p-1, m-q-1, x21(2,1), ldx21, u2(2,2),ldu2 )
                 call stdlib_${ri}$orgqr( m-p, m-p, m-q, u2, ldu2, work(itaup2),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_${ri}$lacpy( 'U', m-q, q, x21, ldx21, v1t, ldv1t )
                 call stdlib_${ri}$lacpy( 'U', p-(m-q), q-(m-q), x11(m-q+1,m-q+1), ldx11,v1t(m-q+1,m-q+&
                           1), ldv1t )
                 call stdlib_${ri}$lacpy( 'U', -p+q, q-p, x21(m-q+1,p+1), ldx21,v1t(p+1,p+1), ldv1t )
                           
                 call stdlib_${ri}$orglq( q, q, q, v1t, ldv1t, work(itauq1),work(iorglq), lorglq, &
                           childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_${ri}$bbcsd( jobu2, jobu1, 'N', jobv1t, 'N', m, m-p, m-q,theta, work(iphi), &
              u2, ldu2, u1, ldu1, dum2,1, v1t, ldv1t, work(ib11d), work(ib11e),work(ib12d), work(&
              ib12e), work(ib21d),work(ib21e), work(ib22d), work(ib22e),work(ibbcsd), lbbcsd, &
                        childinfo )
              ! permute rows and columns to place identity submatrices in
              ! preferred positions
              if( p > r ) then
                 do i = 1, r
                    iwork(i) = p - r + i
                 end do
                 do i = r + 1, p
                    iwork(i) = i - r
                 end do
                 if( wantu1 ) then
                    call stdlib_${ri}$lapmt( .false., p, p, u1, ldu1, iwork )
                 end if
                 if( wantv1t ) then
                    call stdlib_${ri}$lapmr( .false., p, q, v1t, ldv1t, iwork )
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$orcsd2by1


     pure subroutine stdlib_${ri}$org2l( m, n, k, a, lda, tau, work, info )
     !! DORG2L: generates an m by n real matrix Q with orthonormal columns,
     !! which is defined as the last n columns of a product of k elementary
     !! reflectors of order m
     !! Q  =  H(k) . . . H(2) H(1)
     !! as returned by DGEQLF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, j, l
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORG2L', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           ! initialise columns 1:n-k to columns of the unit matrix
           do j = 1, n - k
              do l = 1, m
                 a( l, j ) = zero
              end do
              a( m-n+j, j ) = one
           end do
           do i = 1, k
              ii = n - k + i
              ! apply h(i) to a(1:m-k+i,1:n-k+i) from the left
              a( m-n+ii, ii ) = one
              call stdlib_${ri}$larf( 'LEFT', m-n+ii, ii-1, a( 1, ii ), 1, tau( i ), a,lda, work )
                        
              call stdlib_${ri}$scal( m-n+ii-1, -tau( i ), a( 1, ii ), 1 )
              a( m-n+ii, ii ) = one - tau( i )
              ! set a(m-k+i+1:m,n-k+i) to zero
              do l = m - n + ii + 1, m
                 a( l, ii ) = zero
              end do
           end do
           return
     end subroutine stdlib_${ri}$org2l


     pure subroutine stdlib_${ri}$org2r( m, n, k, a, lda, tau, work, info )
     !! DORG2R: generates an m by n real matrix Q with orthonormal columns,
     !! which is defined as the first n columns of a product of k elementary
     !! reflectors of order m
     !! Q  =  H(1) H(2) . . . H(k)
     !! as returned by DGEQRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORG2R', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           ! initialise columns k+1:n to columns of the unit matrix
           do j = k + 1, n
              do l = 1, m
                 a( l, j ) = zero
              end do
              a( j, j ) = one
           end do
           do i = k, 1, -1
              ! apply h(i) to a(i:m,i:n) from the left
              if( i<n ) then
                 a( i, i ) = one
                 call stdlib_${ri}$larf( 'LEFT', m-i+1, n-i, a( i, i ), 1, tau( i ),a( i, i+1 ), lda, &
                           work )
              end if
              if( i<m )call stdlib_${ri}$scal( m-i, -tau( i ), a( i+1, i ), 1 )
              a( i, i ) = one - tau( i )
              ! set a(1:i-1,i) to zero
              do l = 1, i - 1
                 a( l, i ) = zero
              end do
           end do
           return
     end subroutine stdlib_${ri}$org2r


     pure subroutine stdlib_${ri}$orgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
     !! DORGBR: generates one of the real orthogonal matrices Q or P**T
     !! determined by DGEBRD when reducing a real matrix A to bidiagonal
     !! form: A = Q * B * P**T.  Q and P**T are defined as products of
     !! elementary reflectors H(i) or G(i) respectively.
     !! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
     !! is of order M:
     !! if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
     !! columns of Q, where m >= n >= k;
     !! if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
     !! M-by-M matrix.
     !! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
     !! is of order N:
     !! if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
     !! rows of P**T, where n >= m >= k;
     !! if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
     !! an N-by-N matrix.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantq
           integer(ilp) :: i, iinfo, j, lwkopt, mn
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantq = stdlib_lsame( vect, 'Q' )
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'P' ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 .or. ( wantq .and. ( n>m .or. n<min( m,k ) ) ) .or. ( .not.wantq .and. ( &
                     m>n .or. m<min( n, k ) ) ) ) then
              info = -3
           else if( k<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( lwork<max( 1, mn ) .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              work( 1 ) = 1
              if( wantq ) then
                 if( m>=k ) then
                    call stdlib_${ri}$orgqr( m, n, k, a, lda, tau, work, -1, iinfo )
                 else
                    if( m>1 ) then
                       call stdlib_${ri}$orgqr( m-1, m-1, m-1, a, lda, tau, work, -1,iinfo )
                    end if
                 end if
              else
                 if( k<n ) then
                    call stdlib_${ri}$orglq( m, n, k, a, lda, tau, work, -1, iinfo )
                 else
                    if( n>1 ) then
                       call stdlib_${ri}$orglq( n-1, n-1, n-1, a, lda, tau, work, -1,iinfo )
                    end if
                 end if
              end if
              lwkopt = work( 1 )
              lwkopt = max (lwkopt, mn)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGBR', -info )
              return
           else if( lquery ) then
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( wantq ) then
              ! form q, determined by a call to stdlib_${ri}$gebrd to reduce an m-by-k
              ! matrix
              if( m>=k ) then
                 ! if m >= k, assume m >= n >= k
                 call stdlib_${ri}$orgqr( m, n, k, a, lda, tau, work, lwork, iinfo )
              else
                 ! if m < k, assume m = n
                 ! shift the vectors which define the elementary reflectors one
                 ! column to the right, and set the first row and column of q
                 ! to those of the unit matrix
                 do j = m, 2, -1
                    a( 1, j ) = zero
                    do i = j + 1, m
                       a( i, j ) = a( i, j-1 )
                    end do
                 end do
                 a( 1, 1 ) = one
                 do i = 2, m
                    a( i, 1 ) = zero
                 end do
                 if( m>1 ) then
                    ! form q(2:m,2:m)
                    call stdlib_${ri}$orgqr( m-1, m-1, m-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                              
                 end if
              end if
           else
              ! form p**t, determined by a call to stdlib_${ri}$gebrd to reduce a k-by-n
              ! matrix
              if( k<n ) then
                 ! if k < n, assume k <= m <= n
                 call stdlib_${ri}$orglq( m, n, k, a, lda, tau, work, lwork, iinfo )
              else
                 ! if k >= n, assume m = n
                 ! shift the vectors which define the elementary reflectors one
                 ! row downward, and set the first row and column of p**t to
                 ! those of the unit matrix
                 a( 1, 1 ) = one
                 do i = 2, n
                    a( i, 1 ) = zero
                 end do
                 do j = 2, n
                    do i = j - 1, 2, -1
                       a( i, j ) = a( i-1, j )
                    end do
                    a( 1, j ) = zero
                 end do
                 if( n>1 ) then
                    ! form p**t(2:n,2:n)
                    call stdlib_${ri}$orglq( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                              
                 end if
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$orgbr


     pure subroutine stdlib_${ri}$orghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DORGHR: generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_${ri}$orgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$orghr


     pure subroutine stdlib_${ri}$orgl2( m, n, k, a, lda, tau, work, info )
     !! DORGL2: generates an m by n real matrix Q with orthonormal rows,
     !! which is defined as the first m rows of a product of k elementary
     !! reflectors of order n
     !! Q  =  H(k) . . . H(2) H(1)
     !! as returned by DGELQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGL2', -info )
              return
           end if
           ! quick return if possible
           if( m<=0 )return
           if( k<m ) then
              ! initialise rows k+1:m to rows of the unit matrix
              do j = 1, n
                 do l = k + 1, m
                    a( l, j ) = zero
                 end do
                 if( j>k .and. j<=m )a( j, j ) = one
              end do
           end if
           do i = k, 1, -1
              ! apply h(i) to a(i:m,i:n) from the right
              if( i<n ) then
                 if( i<m ) then
                    a( i, i ) = one
                    call stdlib_${ri}$larf( 'RIGHT', m-i, n-i+1, a( i, i ), lda,tau( i ), a( i+1, i ), &
                              lda, work )
                 end if
                 call stdlib_${ri}$scal( n-i, -tau( i ), a( i, i+1 ), lda )
              end if
              a( i, i ) = one - tau( i )
              ! set a(i,1:i-1) to zero
              do l = 1, i - 1
                 a( i, l ) = zero
              end do
           end do
           return
     end subroutine stdlib_${ri}$orgl2


     pure subroutine stdlib_${ri}$orglq( m, n, k, a, lda, tau, work, lwork, info )
     !! DORGLQ: generates an M-by-N real matrix Q with orthonormal rows,
     !! which is defined as the first M rows of a product of K elementary
     !! reflectors of order N
     !! Q  =  H(k) . . . H(2) H(1)
     !! as returned by DGELQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, j, ki, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'DORGLQ', ' ', m, n, k, -1 )
           lwkopt = max( 1, m )*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( lwork<max( 1, m ) .and. .not.lquery ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGLQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m<=0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DORGLQ', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DORGLQ', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the last block.
              ! the first kk rows are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              ! set a(kk+1:m,1:kk) to zero.
              do j = 1, kk
                 do i = kk + 1, m
                    a( i, j ) = zero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the last or only block.
           if( kk<m )call stdlib_${ri}$orgl2( m-kk, n-kk, k-kk, a( kk+1, kk+1 ), lda,tau( kk+1 ), work,&
                      iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = ki + 1, 1, -nb
                 ib = min( nb, k-i+1 )
                 if( i+ib<=m ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_${ri}$larft( 'FORWARD', 'ROWWISE', n-i+1, ib, a( i, i ),lda, tau( i ), &
                              work, ldwork )
                    ! apply h**t to a(i+ib:m,i:n) from the right
                    call stdlib_${ri}$larfb( 'RIGHT', 'TRANSPOSE', 'FORWARD', 'ROWWISE',m-i-ib+1, n-i+&
                    1, ib, a( i, i ), lda, work,ldwork, a( i+ib, i ), lda, work( ib+1 ),ldwork )
                              
                 end if
                 ! apply h**t to columns i:n of current block
                 call stdlib_${ri}$orgl2( ib, n-i+1, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 ! set columns 1:i-1 of current block to zero
                 do j = 1, i - 1
                    do l = i, i + ib - 1
                       a( l, j ) = zero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$orglq


     pure subroutine stdlib_${ri}$orgql( m, n, k, a, lda, tau, work, lwork, info )
     !! DORGQL: generates an M-by-N real matrix Q with orthonormal columns,
     !! which is defined as the last N columns of a product of K elementary
     !! reflectors of order M
     !! Q  =  H(k) . . . H(2) H(1)
     !! as returned by DGEQLF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, j, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'DORGQL', ' ', m, n, k, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<max( 1, n ) .and. .not.lquery ) then
                 info = -8
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGQL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DORGQL', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DORGQL', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the first block.
              ! the last kk columns are handled by the block method.
              kk = min( k, ( ( k-nx+nb-1 ) / nb )*nb )
              ! set a(m-kk+1:m,1:n-kk) to zero.
              do j = 1, n - kk
                 do i = m - kk + 1, m
                    a( i, j ) = zero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the first or only block.
           call stdlib_${ri}$org2l( m-kk, n-kk, k-kk, a, lda, tau, work, iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = k - kk + 1, k, nb
                 ib = min( nb, k-i+1 )
                 if( n-k+i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_${ri}$larft( 'BACKWARD', 'COLUMNWISE', m-k+i+ib-1, ib,a( 1, n-k+i ), &
                              lda, tau( i ), work, ldwork )
                    ! apply h to a(1:m-k+i+ib-1,1:n-k+i-1) from the left
                    call stdlib_${ri}$larfb( 'LEFT', 'NO TRANSPOSE', 'BACKWARD','COLUMNWISE', m-k+i+ib-&
                    1, n-k+i-1, ib,a( 1, n-k+i ), lda, work, ldwork, a, lda,work( ib+1 ), ldwork )
                              
                 end if
                 ! apply h to rows 1:m-k+i+ib-1 of current block
                 call stdlib_${ri}$org2l( m-k+i+ib-1, ib, ib, a( 1, n-k+i ), lda,tau( i ), work, iinfo &
                           )
                 ! set rows m-k+i+ib:m of current block to zero
                 do j = n - k + i, n - k + i + ib - 1
                    do l = m - k + i + ib, m
                       a( l, j ) = zero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$orgql


     pure subroutine stdlib_${ri}$orgqr( m, n, k, a, lda, tau, work, lwork, info )
     !! DORGQR: generates an M-by-N real matrix Q with orthonormal columns,
     !! which is defined as the first N columns of a product of K elementary
     !! reflectors of order M
     !! Q  =  H(1) H(2) . . . H(k)
     !! as returned by DGEQRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, j, ki, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'DORGQR', ' ', m, n, k, -1 )
           lwkopt = max( 1, n )*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGQR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DORGQR', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DORGQR', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the last block.
              ! the first kk columns are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              ! set a(1:kk,kk+1:n) to zero.
              do j = kk + 1, n
                 do i = 1, kk
                    a( i, j ) = zero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the last or only block.
           if( kk<n )call stdlib_${ri}$org2r( m-kk, n-kk, k-kk, a( kk+1, kk+1 ), lda,tau( kk+1 ), work,&
                      iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = ki + 1, 1, -nb
                 ib = min( nb, k-i+1 )
                 if( i+ib<=n ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_${ri}$larft( 'FORWARD', 'COLUMNWISE', m-i+1, ib,a( i, i ), lda, tau( i &
                              ), work, ldwork )
                    ! apply h to a(i:m,i+ib:n) from the left
                    call stdlib_${ri}$larfb( 'LEFT', 'NO TRANSPOSE', 'FORWARD','COLUMNWISE', m-i+1, n-&
                    i-ib+1, ib,a( i, i ), lda, work, ldwork, a( i, i+ib ),lda, work( ib+1 ), &
                              ldwork )
                 end if
                 ! apply h to rows i:m of current block
                 call stdlib_${ri}$org2r( m-i+1, ib, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 ! set rows 1:i-1 of current block to zero
                 do j = i, i + ib - 1
                    do l = 1, i - 1
                       a( l, j ) = zero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$orgqr


     pure subroutine stdlib_${ri}$orgr2( m, n, k, a, lda, tau, work, info )
     !! DORGR2: generates an m by n real matrix Q with orthonormal rows,
     !! which is defined as the last m rows of a product of k elementary
     !! reflectors of order n
     !! Q  =  H(1) H(2) . . . H(k)
     !! as returned by DGERQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, j, l
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGR2', -info )
              return
           end if
           ! quick return if possible
           if( m<=0 )return
           if( k<m ) then
              ! initialise rows 1:m-k to rows of the unit matrix
              do j = 1, n
                 do l = 1, m - k
                    a( l, j ) = zero
                 end do
                 if( j>n-m .and. j<=n-k )a( m-n+j, j ) = one
              end do
           end if
           do i = 1, k
              ii = m - k + i
              ! apply h(i) to a(1:m-k+i,1:n-k+i) from the right
              a( ii, n-m+ii ) = one
              call stdlib_${ri}$larf( 'RIGHT', ii-1, n-m+ii, a( ii, 1 ), lda, tau( i ),a, lda, work )
                        
              call stdlib_${ri}$scal( n-m+ii-1, -tau( i ), a( ii, 1 ), lda )
              a( ii, n-m+ii ) = one - tau( i )
              ! set a(m-k+i,n-k+i+1:n) to zero
              do l = n - m + ii + 1, n
                 a( ii, l ) = zero
              end do
           end do
           return
     end subroutine stdlib_${ri}$orgr2


     pure subroutine stdlib_${ri}$orgrq( m, n, k, a, lda, tau, work, lwork, info )
     !! DORGRQ: generates an M-by-N real matrix Q with orthonormal rows,
     !! which is defined as the last M rows of a product of K elementary
     !! reflectors of order N
     !! Q  =  H(1) H(2) . . . H(k)
     !! as returned by DGERQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, ii, iinfo, iws, j, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'DORGRQ', ' ', m, n, k, -1 )
                 lwkopt = m*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<max( 1, m ) .and. .not.lquery ) then
                 info = -8
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGRQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m<=0 ) then
              return
           end if
           nbmin = 2
           nx = 0
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DORGRQ', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DORGRQ', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the first block.
              ! the last kk rows are handled by the block method.
              kk = min( k, ( ( k-nx+nb-1 ) / nb )*nb )
              ! set a(1:m-kk,n-kk+1:n) to zero.
              do j = n - kk + 1, n
                 do i = 1, m - kk
                    a( i, j ) = zero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the first or only block.
           call stdlib_${ri}$orgr2( m-kk, n-kk, k-kk, a, lda, tau, work, iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = k - kk + 1, k, nb
                 ib = min( nb, k-i+1 )
                 ii = m - k + i
                 if( ii>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_${ri}$larft( 'BACKWARD', 'ROWWISE', n-k+i+ib-1, ib,a( ii, 1 ), lda, &
                              tau( i ), work, ldwork )
                    ! apply h**t to a(1:m-k+i-1,1:n-k+i+ib-1) from the right
                    call stdlib_${ri}$larfb( 'RIGHT', 'TRANSPOSE', 'BACKWARD', 'ROWWISE',ii-1, n-k+i+&
                              ib-1, ib, a( ii, 1 ), lda, work,ldwork, a, lda, work( ib+1 ), ldwork )
                 end if
                 ! apply h**t to columns 1:n-k+i+ib-1 of current block
                 call stdlib_${ri}$orgr2( ib, n-k+i+ib-1, ib, a( ii, 1 ), lda, tau( i ),work, iinfo )
                           
                 ! set columns n-k+i+ib:n of current block to zero
                 do l = n - k + i + ib, n
                    do j = ii, ii + ib - 1
                       a( j, l ) = zero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_${ri}$orgrq


     pure subroutine stdlib_${ri}$orgtr( uplo, n, a, lda, tau, work, lwork, info )
     !! DORGTR: generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! DSYTRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if( upper ) then
                 nb = stdlib_ilaenv( 1, 'DORGQL', ' ', n-1, n-1, n-1, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors one
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = zero
              end do
              do i = 1, n - 1
                 a( i, n ) = zero
              end do
              a( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_${ri}$orgql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors one
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = zero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = one
              do i = 2, n
                 a( i, 1 ) = zero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_${ri}$orgqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$orgtr


     pure subroutine stdlib_${ri}$orgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
     !! DORGTSQR: generates an M-by-N real matrix Q_out with orthonormal columns,
     !! which are the first N columns of a product of real orthogonal
     !! matrices of order M which are returned by DLATSQR
     !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
     !! See the documentation for DLATSQR.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, lwork, m, n, mb, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: iinfo, ldc, lworkopt, lc, lw, nblocal, j
           ! Intrinsic Functions 
           intrinsic :: real,max,min
           ! Executable Statements 
           ! test the input parameters
           lquery  = lwork==-1
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. m<n ) then
              info = -2
           else if( mb<=n ) then
              info = -3
           else if( nb<1 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldt<max( 1, min( nb, n ) ) ) then
              info = -8
           else
              ! test the input lwork for the dimension of the array work.
              ! this workspace is used to store array c(ldc, n) and work(lwork)
              ! in the call to stdlib_${ri}$lamtsqr. see the documentation for stdlib_${ri}$lamtsqr.
              if( lwork<2 .and. (.not.lquery) ) then
                 info = -10
              else
                 ! set block size for column blocks
                 nblocal = min( nb, n )
                 ! lwork = -1, then set the size for the array c(ldc,n)
                 ! in stdlib_${ri}$lamtsqr call and set the optimal size of the work array
                 ! work(lwork) in stdlib_${ri}$lamtsqr call.
                 ldc = m
                 lc = ldc*n
                 lw = n * nblocal
                 lworkopt = lc+lw
                 if( ( lwork<max( 1, lworkopt ) ).and.(.not.lquery) ) then
                    info = -10
                 end if
              end if
           end if
           ! handle error in the input parameters and return workspace query.
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGTSQR', -info )
              return
           else if ( lquery ) then
              work( 1 ) = real( lworkopt,KIND=${rk}$)
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              work( 1 ) = real( lworkopt,KIND=${rk}$)
              return
           end if
           ! (1) form explicitly the tall-skinny m-by-n left submatrix q1_in
           ! of m-by-m orthogonal matrix q_in, which is implicitly stored in
           ! the subdiagonal part of input array a and in the input array t.
           ! perform by the following operation using the routine stdlib_${ri}$lamtsqr.
               ! q1_in = q_in * ( i ), where i is a n-by-n identity matrix,
                              ! ( 0 )        0 is a (m-n)-by-n zero matrix.
           ! (1a) form m-by-n matrix in the array work(1:ldc*n) with ones
           ! on the diagonal and zeros elsewhere.
           call stdlib_${ri}$laset( 'F', m, n, zero, one, work, ldc )
           ! (1b)  on input, work(1:ldc*n) stores ( i );
                                                ! ( 0 )
                 ! on output, work(1:ldc*n) stores q1_in.
           call stdlib_${ri}$lamtsqr( 'L', 'N', m, n, n, mb, nblocal, a, lda, t, ldt,work, ldc, work( &
                     lc+1 ), lw, iinfo )
           ! (2) copy the result from the part of the work array (1:m,1:n)
           ! with the leading dimension ldc that starts at work(1) into
           ! the output array a(1:m,1:n) column-by-column.
           do j = 1, n
              call stdlib_${ri}$copy( m, work( (j-1)*ldc + 1 ), 1, a( 1, j ), 1 )
           end do
           work( 1 ) = real( lworkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$orgtsqr


     pure subroutine stdlib_${ri}$orgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )
     !! DORGTSQR_ROW: generates an M-by-N real matrix Q_out with
     !! orthonormal columns from the output of DLATSQR. These N orthonormal
     !! columns are the first N columns of a product of complex unitary
     !! matrices Q(k)_in of order M, which are returned by DLATSQR in
     !! a special format.
     !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
     !! The input matrices Q(k)_in are stored in row and column blocks in A.
     !! See the documentation of DLATSQR for more details on the format of
     !! Q(k)_in, where each Q(k)_in is represented by block Householder
     !! transformations. This routine calls an auxiliary routine DLARFB_GETT,
     !! where the computation is performed on each individual block. The
     !! algorithm first sweeps NB-sized column blocks from the right to left
     !! starting in the bottom row block and continues to the top row block
     !! (hence _ROW in the routine name). This sweep is in reverse order of
     !! the order in which DLATSQR generates the output blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, lwork, m, n, mb, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: nblocal, mb2, m_plus_one, itmp, ib_bottom, lworkopt, &
                     num_all_row_blocks, jb_t, ib, imb, kb, kb_last, knb, mb1
           ! Local Arrays 
           real(${rk}$) :: dummy(1,1)
           ! Intrinsic Functions 
           intrinsic :: real,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery  = lwork==-1
           if( m<0 ) then
              info = -1
           else if( n<0 .or. m<n ) then
              info = -2
           else if( mb<=n ) then
              info = -3
           else if( nb<1 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldt<max( 1, min( nb, n ) ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           nblocal = min( nb, n )
           ! determine the workspace size.
           if( info==0 ) then
              lworkopt = nblocal * max( nblocal, ( n - nblocal ) )
           end if
           ! handle error in the input parameters and handle the workspace query.
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGTSQR_ROW', -info )
              return
           else if ( lquery ) then
              work( 1 ) = real( lworkopt,KIND=${rk}$)
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              work( 1 ) = real( lworkopt,KIND=${rk}$)
              return
           end if
           ! (0) set the upper-triangular part of the matrix a to zero and
           ! its diagonal elements to one.
           call stdlib_${ri}$laset('U', m, n, zero, one, a, lda )
           ! kb_last is the column index of the last column block reflector
           ! in the matrices t and v.
           kb_last = ( ( n-1 ) / nblocal ) * nblocal + 1
           ! (1) bottom-up loop over row blocks of a, except the top row block.
           ! note: if mb>=m, then the loop is never executed.
           if ( mb<m ) then
              ! mb2 is the row blocking size for the row blocks before the
              ! first top row block in the matrix a. ib is the row index for
              ! the row blocks in the matrix a before the first top row block.
              ! ib_bottom is the row index for the last bottom row block
              ! in the matrix a. jb_t is the column index of the corresponding
              ! column block in the matrix t.
              ! initialize variables.
              ! num_all_row_blocks is the number of row blocks in the matrix a
              ! including the first row block.
              mb2 = mb - n
              m_plus_one = m + 1
              itmp = ( m - mb - 1 ) / mb2
              ib_bottom = itmp * mb2 + mb + 1
              num_all_row_blocks = itmp + 2
              jb_t = num_all_row_blocks * n + 1
              do ib = ib_bottom, mb+1, -mb2
                 ! determine the block size imb for the current row block
                 ! in the matrix a.
                 imb = min( m_plus_one - ib, mb2 )
                 ! determine the column index jb_t for the current column block
                 ! in the matrix t.
                 jb_t = jb_t - n
                 ! apply column blocks of h in the row block from right to left.
                 ! kb is the column index of the current column block reflector
                 ! in the matrices t and v.
                 do kb = kb_last, 1, -nblocal
                    ! determine the size of the current column block knb in
                    ! the matrices t and v.
                    knb = min( nblocal, n - kb + 1 )
                    call stdlib_${ri}$larfb_gett( 'I', imb, n-kb+1, knb,t( 1, jb_t+kb-1 ), ldt, a( kb, &
                              kb ), lda,a( ib, kb ), lda, work, knb )
                 end do
              end do
           end if
           ! (2) top row block of a.
           ! note: if mb>=m, then we have only one row block of a of size m
           ! and we work on the entire matrix a.
           mb1 = min( mb, m )
           ! apply column blocks of h in the top row block from right to left.
           ! kb is the column index of the current block reflector in
           ! the matrices t and v.
           do kb = kb_last, 1, -nblocal
              ! determine the size of the current column block knb in
              ! the matrices t and v.
              knb = min( nblocal, n - kb + 1 )
              if( mb1-kb-knb+1==0 ) then
                 ! in stdlib_dlarfb_gett parameters, when m=0, then the matrix b
                 ! does not exist, hence we need to pass a dummy array
                 ! reference dummy(1,1) to b with lddummy=1.
                 call stdlib_${ri}$larfb_gett( 'N', 0, n-kb+1, knb,t( 1, kb ), ldt, a( kb, kb ), lda,&
                           dummy( 1, 1 ), 1, work, knb )
              else
                 call stdlib_${ri}$larfb_gett( 'N', mb1-kb-knb+1, n-kb+1, knb,t( 1, kb ), ldt, a( kb, &
                           kb ), lda,a( kb+knb, kb), lda, work, knb )
              end if
           end do
           work( 1 ) = real( lworkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$orgtsqr_row


     pure subroutine stdlib_${ri}$orhr_col( m, n, nb, a, lda, t, ldt, d, info )
     !! DORHR_COL: takes an M-by-N real matrix Q_in with orthonormal columns
     !! as input, stored in A, and performs Householder Reconstruction (HR),
     !! i.e. reconstructs Householder vectors V(i) implicitly representing
     !! another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
     !! where S is an N-by-N diagonal matrix with diagonal entries
     !! equal to +1 or -1. The Householder vectors (columns V(i) of V) are
     !! stored in A on output, and the diagonal entries of S are stored in D.
     !! Block reflectors are also returned in T
     !! (same output format as DGEQRT).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iinfo, j, jb, jbtemp1, jbtemp2, jnb, nplusone
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( nb<1 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldt<max( 1, min( nb, n ) ) ) then
              info = -7
           end if
           ! handle error in the input parameters.
           if( info/=0 ) then
              call stdlib_xerbla( 'DORHR_COL', -info )
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              return
           end if
           ! on input, the m-by-n matrix a contains the orthogonal
           ! m-by-n matrix q_in.
           ! (1) compute the unit lower-trapezoidal v (ones on the diagonal
           ! are not stored) by performing the "modified" lu-decomposition.
           ! q_in - ( s ) = v * u = ( v1 ) * u,
                  ! ( 0 )           ( v2 )
           ! where 0 is an (m-n)-by-n zero matrix.
           ! (1-1) factor v1 and u.
           call stdlib_${ri}$laorhr_col_getrfnp( n, n, a, lda, d, iinfo )
           ! (1-2) solve for v2.
           if( m>n ) then
              call stdlib_${ri}$trsm( 'R', 'U', 'N', 'N', m-n, n, one, a, lda,a( n+1, 1 ), lda )
                        
           end if
           ! (2) reconstruct the block reflector t stored in t(1:nb, 1:n)
           ! as a sequence of upper-triangular blocks with nb-size column
           ! blocking.
           ! loop over the column blocks of size nb of the array a(1:m,1:n)
           ! and the array t(1:nb,1:n), jb is the column index of a column
           ! block, jnb is the column block size at each step jb.
           nplusone = n + 1
           do jb = 1, n, nb
              ! (2-0) determine the column block size jnb.
              jnb = min( nplusone-jb, nb )
              ! (2-1) copy the upper-triangular part of the current jnb-by-jnb
              ! diagonal block u(jb) (of the n-by-n matrix u) stored
              ! in a(jb:jb+jnb-1,jb:jb+jnb-1) into the upper-triangular part
              ! of the current jnb-by-jnb block t(1:jnb,jb:jb+jnb-1)
              ! column-by-column, total jnb*(jnb+1)/2 elements.
              jbtemp1 = jb - 1
              do j = jb, jb+jnb-1
                 call stdlib_${ri}$copy( j-jbtemp1, a( jb, j ), 1, t( 1, j ), 1 )
              end do
              ! (2-2) perform on the upper-triangular part of the current
              ! jnb-by-jnb diagonal block u(jb) (of the n-by-n matrix u) stored
              ! in t(1:jnb,jb:jb+jnb-1) the following operation in place:
              ! (-1)*u(jb)*s(jb), i.e the result will be stored in the upper-
              ! triangular part of t(1:jnb,jb:jb+jnb-1). this multiplication
              ! of the jnb-by-jnb diagonal block u(jb) by the jnb-by-jnb
              ! diagonal block s(jb) of the n-by-n sign matrix s from the
              ! right means changing the sign of each j-th column of the block
              ! u(jb) according to the sign of the diagonal element of the block
              ! s(jb), i.e. s(j,j) that is stored in the array element d(j).
              do j = jb, jb+jnb-1
                 if( d( j )==one ) then
                    call stdlib_${ri}$scal( j-jbtemp1, -one, t( 1, j ), 1 )
                 end if
              end do
              ! (2-3) perform the triangular solve for the current block
              ! matrix x(jb):
                     ! x(jb) * (a(jb)**t) = b(jb), where:
                     ! a(jb)**t  is a jnb-by-jnb unit upper-triangular
                               ! coefficient block, and a(jb)=v1(jb), which
                               ! is a jnb-by-jnb unit lower-triangular block
                               ! stored in a(jb:jb+jnb-1,jb:jb+jnb-1).
                               ! the n-by-n matrix v1 is the upper part
                               ! of the m-by-n lower-trapezoidal matrix v
                               ! stored in a(1:m,1:n);
                     ! b(jb)     is a jnb-by-jnb  upper-triangular right-hand
                               ! side block, b(jb) = (-1)*u(jb)*s(jb), and
                               ! b(jb) is stored in t(1:jnb,jb:jb+jnb-1);
                     ! x(jb)     is a jnb-by-jnb upper-triangular solution
                               ! block, x(jb) is the upper-triangular block
                               ! reflector t(jb), and x(jb) is stored
                               ! in t(1:jnb,jb:jb+jnb-1).
                   ! in other words, we perform the triangular solve for the
                   ! upper-triangular block t(jb):
                     ! t(jb) * (v1(jb)**t) = (-1)*u(jb)*s(jb).
                   ! even though the blocks x(jb) and b(jb) are upper-
                   ! triangular, the routine stdlib_${ri}$trsm will access all jnb**2
                   ! elements of the square t(1:jnb,jb:jb+jnb-1). therefore,
                   ! we need to set to zero the elements of the block
                   ! t(1:jnb,jb:jb+jnb-1) below the diagonal before the call
                   ! to stdlib_${ri}$trsm.
              ! (2-3a) set the elements to zero.
              jbtemp2 = jb - 2
              do j = jb, jb+jnb-2
                 do i = j-jbtemp2, nb
                    t( i, j ) = zero
                 end do
              end do
              ! (2-3b) perform the triangular solve.
              call stdlib_${ri}$trsm( 'R', 'L', 'T', 'U', jnb, jnb, one,a( jb, jb ), lda, t( 1, jb ), &
                        ldt )
           end do
           return
     end subroutine stdlib_${ri}$orhr_col


     pure subroutine stdlib_${ri}$orm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,work, lwork, info )
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: m, n, n1, n2, ldq, ldc, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: q(ldq,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           integer(ilp) :: i, ldwork, len, lwkopt, nb, nq, nw
           ! Intrinsic Functions 
           intrinsic :: real,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q;
           ! nw is the minimum dimension of work.
           if( left ) then
              nq = m
           else
              nq = n
           end if
           nw = nq
           if( n1==0 .or. n2==0 ) nw = 1
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( n1<0 .or. n1+n2/=nq ) then
              info = -5
           else if( n2<0 ) then
              info = -6
           else if( ldq<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              lwkopt = m*n
              work( 1 ) = real( lwkopt,KIND=${rk}$)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORM22', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! degenerate cases (n1 = 0 or n2 = 0) are handled using stdlib_${ri}$trmm.
           if( n1==0 ) then
              call stdlib_${ri}$trmm( side, 'UPPER', trans, 'NON-UNIT', m, n, one,q, ldq, c, ldc )
                        
              work( 1 ) = one
              return
           else if( n2==0 ) then
              call stdlib_${ri}$trmm( side, 'LOWER', trans, 'NON-UNIT', m, n, one,q, ldq, c, ldc )
                        
              work( 1 ) = one
              return
           end if
           ! compute the largest chunk size available from the workspace.
           nb = max( 1, min( lwork, lwkopt ) / nq )
           if( left ) then
              if( notran ) then
                 do i = 1, n, nb
                    len = min( nb, n-i+1 )
                    ldwork = m
                    ! multiply bottom part of c by q12.
                    call stdlib_${ri}$lacpy( 'ALL', n1, len, c( n2+1, i ), ldc, work,ldwork )
                    call stdlib_${ri}$trmm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'NON-UNIT',n1, len, one, &
                              q( 1, n2+1 ), ldq, work,ldwork )
                    ! multiply top part of c by q11.
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n1, len, n2,one, q, ldq, c(&
                               1, i ), ldc, one, work,ldwork )
                    ! multiply top part of c by q21.
                    call stdlib_${ri}$lacpy( 'ALL', n2, len, c( 1, i ), ldc,work( n1+1 ), ldwork )
                              
                    call stdlib_${ri}$trmm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',n2, len, one, &
                              q( n1+1, 1 ), ldq,work( n1+1 ), ldwork )
                    ! multiply bottom part of c by q22.
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n2, len, n1,one, q( n1+1, &
                              n2+1 ), ldq, c( n2+1, i ), ldc,one, work( n1+1 ), ldwork )
                    ! copy everything back.
                    call stdlib_${ri}$lacpy( 'ALL', m, len, work, ldwork, c( 1, i ),ldc )
                 end do
              else
                 do i = 1, n, nb
                    len = min( nb, n-i+1 )
                    ldwork = m
                    ! multiply bottom part of c by q21**t.
                    call stdlib_${ri}$lacpy( 'ALL', n2, len, c( n1+1, i ), ldc, work,ldwork )
                    call stdlib_${ri}$trmm( 'LEFT', 'UPPER', 'TRANSPOSE', 'NON-UNIT',n2, len, one, q( &
                              n1+1, 1 ), ldq, work,ldwork )
                    ! multiply top part of c by q11**t.
                    call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', n2, len, n1,one, q, ldq, c( 1,&
                               i ), ldc, one, work,ldwork )
                    ! multiply top part of c by q12**t.
                    call stdlib_${ri}$lacpy( 'ALL', n1, len, c( 1, i ), ldc,work( n2+1 ), ldwork )
                              
                    call stdlib_${ri}$trmm( 'LEFT', 'LOWER', 'TRANSPOSE', 'NON-UNIT',n1, len, one, q( &
                              1, n2+1 ), ldq,work( n2+1 ), ldwork )
                    ! multiply bottom part of c by q22**t.
                    call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', n1, len, n2,one, q( n1+1, n2+&
                              1 ), ldq, c( n1+1, i ), ldc,one, work( n2+1 ), ldwork )
                    ! copy everything back.
                    call stdlib_${ri}$lacpy( 'ALL', m, len, work, ldwork, c( 1, i ),ldc )
                 end do
              end if
           else
              if( notran ) then
                 do i = 1, m, nb
                    len = min( nb, m-i+1 )
                    ldwork = len
                    ! multiply right part of c by q21.
                    call stdlib_${ri}$lacpy( 'ALL', len, n2, c( i, n1+1 ), ldc, work,ldwork )
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',len, n2, one, &
                              q( n1+1, 1 ), ldq, work,ldwork )
                    ! multiply left part of c by q11.
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', len, n2, n1,one, c( i, 1 ),&
                               ldc, q, ldq, one, work,ldwork )
                    ! multiply left part of c by q12.
                    call stdlib_${ri}$lacpy( 'ALL', len, n1, c( i, 1 ), ldc,work( 1 + n2*ldwork ), &
                              ldwork )
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'NON-UNIT',len, n1, one, &
                              q( 1, n2+1 ), ldq,work( 1 + n2*ldwork ), ldwork )
                    ! multiply right part of c by q22.
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', len, n1, n2,one, c( i, n1+&
                              1 ), ldc, q( n1+1, n2+1 ), ldq,one, work( 1 + n2*ldwork ), ldwork )
                    ! copy everything back.
                    call stdlib_${ri}$lacpy( 'ALL', len, n, work, ldwork, c( i, 1 ),ldc )
                 end do
              else
                 do i = 1, m, nb
                    len = min( nb, m-i+1 )
                    ldwork = len
                    ! multiply right part of c by q12**t.
                    call stdlib_${ri}$lacpy( 'ALL', len, n1, c( i, n2+1 ), ldc, work,ldwork )
                    call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE', 'NON-UNIT',len, n1, one, q( &
                              1, n2+1 ), ldq, work,ldwork )
                    ! multiply left part of c by q11**t.
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', len, n1, n2,one, c( i, 1 ), &
                              ldc, q, ldq, one, work,ldwork )
                    ! multiply left part of c by q21**t.
                    call stdlib_${ri}$lacpy( 'ALL', len, n2, c( i, 1 ), ldc,work( 1 + n1*ldwork ), &
                              ldwork )
                    call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'TRANSPOSE', 'NON-UNIT',len, n2, one, q( &
                              n1+1, 1 ), ldq,work( 1 + n1*ldwork ), ldwork )
                    ! multiply right part of c by q22**t.
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', len, n2, n1,one, c( i, n2+1 ),&
                               ldc, q( n1+1, n2+1 ), ldq,one, work( 1 + n1*ldwork ), ldwork )
                    ! copy everything back.
                    call stdlib_${ri}$lacpy( 'ALL', len, n, work, ldwork, c( i, 1 ),ldc )
                 end do
              end if
           end if
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$orm22


     pure subroutine stdlib_${ri}$orm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! DORM2L: overwrites the general real m by n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**T * C  if SIDE = 'L' and TRANS = 'T', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**T if SIDE = 'R' and TRANS = 'T',
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k) . . . H(2) H(1)
     !! as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, mi, ni, nq
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORM2L', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. notran ) .or. ( .not.left .and. .not.notran ) )then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
           else
              mi = m
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) is applied to c(1:m-k+i,1:n)
                 mi = m - k + i
              else
                 ! h(i) is applied to c(1:m,1:n-k+i)
                 ni = n - k + i
              end if
              ! apply h(i)
              aii = a( nq-k+i, i )
              a( nq-k+i, i ) = one
              call stdlib_${ri}$larf( side, mi, ni, a( 1, i ), 1, tau( i ), c, ldc,work )
              a( nq-k+i, i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$orm2l


     pure subroutine stdlib_${ri}$orm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! DORM2R: overwrites the general real m by n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**T* C  if SIDE = 'L' and TRANS = 'T', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**T if SIDE = 'R' and TRANS = 'T',
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, ic, jc, mi, ni, nq
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORM2R', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. .not.notran ) .or. ( .not.left .and. notran ) )then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
              jc = 1
           else
              mi = m
              ic = 1
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) is applied to c(i:m,1:n)
                 mi = m - i + 1
                 ic = i
              else
                 ! h(i) is applied to c(1:m,i:n)
                 ni = n - i + 1
                 jc = i
              end if
              ! apply h(i)
              aii = a( i, i )
              a( i, i ) = one
              call stdlib_${ri}$larf( side, mi, ni, a( i, i ), 1, tau( i ), c( ic, jc ),ldc, work )
                        
              a( i, i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$orm2r


     pure subroutine stdlib_${ri}$ormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
     !! If VECT = 'Q', DORMBR: overwrites the general real M-by-N matrix C
     !! with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
     !! with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      P * C          C * P
     !! TRANS = 'T':      P**T * C       C * P**T
     !! Here Q and P**T are the orthogonal matrices determined by DGEBRD when
     !! reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
     !! P**T are defined as products of elementary reflectors H(i) and G(i)
     !! respectively.
     !! Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
     !! order of the orthogonal matrix Q or P**T that is applied.
     !! If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
     !! if nq >= k, Q = H(1) H(2) . . . H(k);
     !! if nq < k, Q = H(1) H(2) . . . H(nq-1).
     !! If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
     !! if k < nq, P = G(1) G(2) . . . G(k);
     !! if k >= nq, P = G(1) G(2) . . . G(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: applyq, left, lquery, notran
           character :: transt
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           applyq = stdlib_lsame( vect, 'Q' )
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q or p and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.applyq .and. .not.stdlib_lsame( vect, 'P' ) ) then
              info = -1
           else if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( k<0 ) then
              info = -6
           else if( ( applyq .and. lda<max( 1, nq ) ) .or.( .not.applyq .and. lda<max( 1, min( nq,&
                      k ) ) ) )then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( applyq ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMLQ', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMLQ', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMBR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           work( 1 ) = 1
           if( m==0 .or. n==0 )return
           if( applyq ) then
              ! apply q
              if( nq>=k ) then
                 ! q was determined by a call to stdlib_${ri}$gebrd with nq >= k
                 call stdlib_${ri}$ormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, iinfo &
                           )
              else if( nq>1 ) then
                 ! q was determined by a call to stdlib_${ri}$gebrd with nq < k
                 if( left ) then
                    mi = m - 1
                    ni = n
                    i1 = 2
                    i2 = 1
                 else
                    mi = m
                    ni = n - 1
                    i1 = 1
                    i2 = 2
                 end if
                 call stdlib_${ri}$ormqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), &
                           ldc, work, lwork, iinfo )
              end if
           else
              ! apply p
              if( notran ) then
                 transt = 'T'
              else
                 transt = 'N'
              end if
              if( nq>k ) then
                 ! p was determined by a call to stdlib_${ri}$gebrd with nq > k
                 call stdlib_${ri}$ormlq( side, transt, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                           iinfo )
              else if( nq>1 ) then
                 ! p was determined by a call to stdlib_${ri}$gebrd with nq <= k
                 if( left ) then
                    mi = m - 1
                    ni = n
                    i1 = 2
                    i2 = 1
                 else
                    mi = m
                    ni = n - 1
                    i1 = 1
                    i2 = 2
                 end if
                 call stdlib_${ri}$ormlq( side, transt, mi, ni, nq-1, a( 1, 2 ), lda,tau, c( i1, i2 ), &
                           ldc, work, lwork, iinfo )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormbr


     pure subroutine stdlib_${ri}$ormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! DORMHR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_${ri}$ormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormhr


     pure subroutine stdlib_${ri}$orml2( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! DORML2: overwrites the general real m by n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**T* C  if SIDE = 'L' and TRANS = 'T', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**T if SIDE = 'R' and TRANS = 'T',
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k) . . . H(2) H(1)
     !! as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, ic, jc, mi, ni, nq
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORML2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. notran ) .or. ( .not.left .and. .not.notran ) )then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
              jc = 1
           else
              mi = m
              ic = 1
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) is applied to c(i:m,1:n)
                 mi = m - i + 1
                 ic = i
              else
                 ! h(i) is applied to c(1:m,i:n)
                 ni = n - i + 1
                 jc = i
              end if
              ! apply h(i)
              aii = a( i, i )
              a( i, i ) = one
              call stdlib_${ri}$larf( side, mi, ni, a( i, i ), lda, tau( i ),c( ic, jc ), ldc, work )
                        
              a( i, i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$orml2


     pure subroutine stdlib_${ri}$ormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! DORMLQ: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k) . . . H(2) H(1)
     !! as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           character :: transt
           integer(ilp) :: i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork, lwkopt, mi, nb, nbmin, &
                     ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DORMLQ', side // trans, m, n, k,-1 ) )
              lwkopt = nw*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMLQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DORMLQ', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_${ri}$orml2( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. notran ) .or.( .not.left .and. .not.notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              if( notran ) then
                 transt = 'T'
              else
                 transt = 'N'
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i) h(i+1) . . . h(i+ib-1)
                 call stdlib_${ri}$larft( 'FORWARD', 'ROWWISE', nq-i+1, ib, a( i, i ),lda, tau( i ), &
                           work( iwt ), ldt )
                 if( left ) then
                    ! h or h**t is applied to c(i:m,1:n)
                    mi = m - i + 1
                    ic = i
                 else
                    ! h or h**t is applied to c(1:m,i:n)
                    ni = n - i + 1
                    jc = i
                 end if
                 ! apply h or h**t
                 call stdlib_${ri}$larfb( side, transt, 'FORWARD', 'ROWWISE', mi, ni, ib,a( i, i ), &
                           lda, work( iwt ), ldt,c( ic, jc ), ldc, work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormlq


     pure subroutine stdlib_${ri}$ormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! DORMQL: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k) . . . H(2) H(1)
     !! as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           integer(ilp) :: i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt, mi, nb, nbmin, ni, nq, &
                     nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'DORMQL', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMQL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DORMQL', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_${ri}$orm2l( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. notran ) .or.( .not.left .and. .not.notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i+ib-1) . . . h(i+1) h(i)
                 call stdlib_${ri}$larft( 'BACKWARD', 'COLUMNWISE', nq-k+i+ib-1, ib,a( 1, i ), lda, &
                           tau( i ), work( iwt ), ldt )
                 if( left ) then
                    ! h or h**t is applied to c(1:m-k+i+ib-1,1:n)
                    mi = m - k + i + ib - 1
                 else
                    ! h or h**t is applied to c(1:m,1:n-k+i+ib-1)
                    ni = n - k + i + ib - 1
                 end if
                 ! apply h or h**t
                 call stdlib_${ri}$larfb( side, trans, 'BACKWARD', 'COLUMNWISE', mi, ni,ib, a( 1, i ), &
                           lda, work( iwt ), ldt, c, ldc,work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormql


     pure subroutine stdlib_${ri}$ormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! DORMQR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           integer(ilp) :: i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork, lwkopt, mi, nb, nbmin, &
                     ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DORMQR', side // trans, m, n, k,-1 ) )
              lwkopt = nw*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMQR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DORMQR', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_${ri}$orm2r( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. .not.notran ) .or.( .not.left .and. notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i) h(i+1) . . . h(i+ib-1)
                 call stdlib_${ri}$larft( 'FORWARD', 'COLUMNWISE', nq-i+1, ib, a( i, i ),lda, tau( i ),&
                            work( iwt ), ldt )
                 if( left ) then
                    ! h or h**t is applied to c(i:m,1:n)
                    mi = m - i + 1
                    ic = i
                 else
                    ! h or h**t is applied to c(1:m,i:n)
                    ni = n - i + 1
                    jc = i
                 end if
                 ! apply h or h**t
                 call stdlib_${ri}$larfb( side, trans, 'FORWARD', 'COLUMNWISE', mi, ni,ib, a( i, i ), &
                           lda, work( iwt ), ldt,c( ic, jc ), ldc, work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormqr


     pure subroutine stdlib_${ri}$ormr2( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! DORMR2: overwrites the general real m by n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**T* C  if SIDE = 'L' and TRANS = 'T', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**T if SIDE = 'R' and TRANS = 'T',
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by DGERQF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, mi, ni, nq
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMR2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. .not.notran ) .or. ( .not.left .and. notran ) )then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
           else
              mi = m
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) is applied to c(1:m-k+i,1:n)
                 mi = m - k + i
              else
                 ! h(i) is applied to c(1:m,1:n-k+i)
                 ni = n - k + i
              end if
              ! apply h(i)
              aii = a( i, nq-k+i )
              a( i, nq-k+i ) = one
              call stdlib_${ri}$larf( side, mi, ni, a( i, 1 ), lda, tau( i ), c, ldc,work )
              a( i, nq-k+i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$ormr2


     pure subroutine stdlib_${ri}$ormr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, info )
     !! DORMR3: overwrites the general real m by n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**T* C  if SIDE = 'L' and TRANS = 'C', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**T if SIDE = 'R' and TRANS = 'C',
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by DTZRZF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, l, lda, ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), tau(*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, ic, ja, jc, mi, ni, nq
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( l<0 .or. ( left .and. ( l>m ) ) .or.( .not.left .and. ( l>n ) ) ) then
              info = -6
           else if( lda<max( 1, k ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMR3', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. .not.notran .or. .not.left .and. notran ) ) then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
              ja = m - l + 1
              jc = 1
           else
              mi = m
              ja = n - l + 1
              ic = 1
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) or h(i)**t is applied to c(i:m,1:n)
                 mi = m - i + 1
                 ic = i
              else
                 ! h(i) or h(i)**t is applied to c(1:m,i:n)
                 ni = n - i + 1
                 jc = i
              end if
              ! apply h(i) or h(i)**t
              call stdlib_${ri}$larz( side, mi, ni, l, a( i, ja ), lda, tau( i ),c( ic, jc ), ldc, &
                        work )
           end do
           return
     end subroutine stdlib_${ri}$ormr3


     pure subroutine stdlib_${ri}$ormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! DORMRQ: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           character :: transt
           integer(ilp) :: i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt, mi, nb, nbmin, ni, nq, &
                     nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'DORMRQ', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMRQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DORMRQ', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_${ri}$ormr2( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. .not.notran ) .or.( .not.left .and. notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              if( notran ) then
                 transt = 'T'
              else
                 transt = 'N'
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i+ib-1) . . . h(i+1) h(i)
                 call stdlib_${ri}$larft( 'BACKWARD', 'ROWWISE', nq-k+i+ib-1, ib,a( i, 1 ), lda, tau( &
                           i ), work( iwt ), ldt )
                 if( left ) then
                    ! h or h**t is applied to c(1:m-k+i+ib-1,1:n)
                    mi = m - k + i + ib - 1
                 else
                    ! h or h**t is applied to c(1:m,1:n-k+i+ib-1)
                    ni = n - k + i + ib - 1
                 end if
                 ! apply h or h**t
                 call stdlib_${ri}$larfb( side, transt, 'BACKWARD', 'ROWWISE', mi, ni,ib, a( i, 1 ), &
                           lda, work( iwt ), ldt, c, ldc,work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormrq


     pure subroutine stdlib_${ri}$ormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
     !! DORMRZ: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, l, lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           character :: transt
           integer(ilp) :: i, i1, i2, i3, ib, ic, iinfo, iwt, ja, jc, ldwork, lwkopt, mi, nb, &
                     nbmin, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( l<0 .or. ( left .and. ( l>m ) ) .or.( .not.left .and. ( l>n ) ) ) then
              info = -6
           else if( lda<max( 1, k ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'DORMRQ', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMRZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DORMRQ', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_${ri}$ormr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, iinfo )
                        
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. .not.notran ) .or.( .not.left .and. notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
                 jc = 1
                 ja = m - l + 1
              else
                 mi = m
                 ic = 1
                 ja = n - l + 1
              end if
              if( notran ) then
                 transt = 'T'
              else
                 transt = 'N'
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i+ib-1) . . . h(i+1) h(i)
                 call stdlib_${ri}$larzt( 'BACKWARD', 'ROWWISE', l, ib, a( i, ja ), lda,tau( i ), work(&
                            iwt ), ldt )
                 if( left ) then
                    ! h or h**t is applied to c(i:m,1:n)
                    mi = m - i + 1
                    ic = i
                 else
                    ! h or h**t is applied to c(1:m,i:n)
                    ni = n - i + 1
                    jc = i
                 end if
                 ! apply h or h**t
                 call stdlib_${ri}$larzb( side, transt, 'BACKWARD', 'ROWWISE', mi, ni,ib, l, a( i, ja )&
                           , lda, work( iwt ), ldt,c( ic, jc ), ldc, work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormrz


     pure subroutine stdlib_${ri}$ormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! DORMTR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by DSYTRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'u'
              call stdlib_${ri}$ormql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_${ri}$ormqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormtr


     pure subroutine stdlib_${ri}$pbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )
     !! DPBCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric positive definite band matrix using the
     !! Cholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           character :: normin
           integer(ilp) :: ix, kase
           real(${rk}$) :: ainvnm, scale, scalel, scaleu, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! estimate the 1-norm of the inverse.
           kase = 0
           normin = 'N'
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( upper ) then
                 ! multiply by inv(u**t).
                 call stdlib_${ri}$latbs( 'UPPER', 'TRANSPOSE', 'NON-UNIT', normin, n,kd, ab, ldab, &
                           work, scalel, work( 2*n+1 ),info )
                 normin = 'Y'
                 ! multiply by inv(u).
                 call stdlib_${ri}$latbs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,kd, ab, ldab, &
                           work, scaleu, work( 2*n+1 ),info )
              else
                 ! multiply by inv(l).
                 call stdlib_${ri}$latbs( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,kd, ab, ldab, &
                           work, scalel, work( 2*n+1 ),info )
                 normin = 'Y'
                 ! multiply by inv(l**t).
                 call stdlib_${ri}$latbs( 'LOWER', 'TRANSPOSE', 'NON-UNIT', normin, n,kd, ab, ldab, &
                           work, scaleu, work( 2*n+1 ),info )
              end if
              ! multiply by 1/scale if doing so will not cause overflow.
              scale = scalel*scaleu
              if( scale/=one ) then
                 ix = stdlib_i${ri}$amax( n, work, 1 )
                 if( scale<abs( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_${ri}$rscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_${ri}$pbcon


     pure subroutine stdlib_${ri}$pbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
     !! DPBEQU: computes row and column scalings intended to equilibrate a
     !! symmetric positive definite band matrix A and reduce its condition
     !! number (with respect to the two-norm).  S contains the scale factors,
     !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     !! choice of S puts the condition number of B within a factor N of the
     !! smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(${rk}$), intent(out) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: s(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j
           real(${rk}$) :: smin
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBEQU', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           if( upper ) then
              j = kd + 1
           else
              j = 1
           end if
           ! initialize smin and amax.
           s( 1 ) = ab( j, 1 )
           smin = s( 1 )
           amax = s( 1 )
           ! find the minimum and maximum diagonal elements.
           do i = 2, n
              s( i ) = ab( j, i )
              smin = min( smin, s( i ) )
              amax = max( amax, s( i ) )
           end do
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = one / sqrt( s( i ) )
              end do
              ! compute scond = min(s(i)) / max(s(i))
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_${ri}$pbequ


     pure subroutine stdlib_${ri}$pbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, ferr, &
     !! DPBRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric positive definite
     !! and banded, and provides error bounds and backward error estimates
     !! for the solution.
               berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldafb, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ab(ldab,*), afb(ldafb,*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, l, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldafb<kd+1 ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = min( n+1, 2*kd+2 )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$sbmv( uplo, n, kd, -one, ab, ldab, x( 1, j ), 1, one,work( n+1 ), 1 )
                        
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    l = kd + 1 - k
                    do i = max( 1, k-kd ), k - 1
                       work( i ) = work( i ) + abs( ab( l+i, k ) )*xk
                       s = s + abs( ab( l+i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + abs( ab( kd+1, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( ab( 1, k ) )*xk
                    l = 1 - k
                    do i = k + 1, min( n, k+kd )
                       work( i ) = work( i ) + abs( ab( l+i, k ) )*xk
                       s = s + abs( ab( l+i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$pbtrs( uplo, n, kd, 1, afb, ldafb, work( n+1 ), n,info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$pbtrs( uplo, n, kd, 1, afb, ldafb, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( n+i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( n+i )*work( i )
                    end do
                    call stdlib_${ri}$pbtrs( uplo, n, kd, 1, afb, ldafb, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$pbrfs


     pure subroutine stdlib_${ri}$pbstf( uplo, n, kd, ab, ldab, info )
     !! DPBSTF: computes a split Cholesky factorization of a real
     !! symmetric positive definite band matrix A.
     !! This routine is designed to be used in conjunction with DSBGST.
     !! The factorization has the form  A = S**T*S  where S is a band matrix
     !! of the same bandwidth as A and the following structure:
     !! S = ( U    )
     !! ( M  L )
     !! where U is upper triangular of order m = (n+kd)/2, and L is lower
     !! triangular of order n-m.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, kld, km, m
           real(${rk}$) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBSTF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           kld = max( 1, ldab-1 )
           ! set the splitting point m.
           m = ( n+kd ) / 2
           if( upper ) then
              ! factorize a(m+1:n,m+1:n) as l**t*l, and update a(1:m,1:m).
              do j = n, m + 1, -1
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = ab( kd+1, j )
                 if( ajj<=zero )go to 50
                 ajj = sqrt( ajj )
                 ab( kd+1, j ) = ajj
                 km = min( j-1, kd )
                 ! compute elements j-km:j-1 of the j-th column and update the
                 ! the leading submatrix within the band.
                 call stdlib_${ri}$scal( km, one / ajj, ab( kd+1-km, j ), 1 )
                 call stdlib_${ri}$syr( 'UPPER', km, -one, ab( kd+1-km, j ), 1,ab( kd+1, j-km ), kld )
                           
              end do
              ! factorize the updated submatrix a(1:m,1:m) as u**t*u.
              do j = 1, m
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = ab( kd+1, j )
                 if( ajj<=zero )go to 50
                 ajj = sqrt( ajj )
                 ab( kd+1, j ) = ajj
                 km = min( kd, m-j )
                 ! compute elements j+1:j+km of the j-th row and update the
                 ! trailing submatrix within the band.
                 if( km>0 ) then
                    call stdlib_${ri}$scal( km, one / ajj, ab( kd, j+1 ), kld )
                    call stdlib_${ri}$syr( 'UPPER', km, -one, ab( kd, j+1 ), kld,ab( kd+1, j+1 ), kld )
                              
                 end if
              end do
           else
              ! factorize a(m+1:n,m+1:n) as l**t*l, and update a(1:m,1:m).
              do j = n, m + 1, -1
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = ab( 1, j )
                 if( ajj<=zero )go to 50
                 ajj = sqrt( ajj )
                 ab( 1, j ) = ajj
                 km = min( j-1, kd )
                 ! compute elements j-km:j-1 of the j-th row and update the
                 ! trailing submatrix within the band.
                 call stdlib_${ri}$scal( km, one / ajj, ab( km+1, j-km ), kld )
                 call stdlib_${ri}$syr( 'LOWER', km, -one, ab( km+1, j-km ), kld,ab( 1, j-km ), kld )
                           
              end do
              ! factorize the updated submatrix a(1:m,1:m) as u**t*u.
              do j = 1, m
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = ab( 1, j )
                 if( ajj<=zero )go to 50
                 ajj = sqrt( ajj )
                 ab( 1, j ) = ajj
                 km = min( kd, m-j )
                 ! compute elements j+1:j+km of the j-th column and update the
                 ! trailing submatrix within the band.
                 if( km>0 ) then
                    call stdlib_${ri}$scal( km, one / ajj, ab( 2, j ), 1 )
                    call stdlib_${ri}$syr( 'LOWER', km, -one, ab( 2, j ), 1,ab( 1, j+1 ), kld )
                 end if
              end do
           end if
           return
           50 continue
           info = j
           return
     end subroutine stdlib_${ri}$pbstf


     pure subroutine stdlib_${ri}$pbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! DPBSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_${ri}$pbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$pbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$pbsv


     subroutine stdlib_${ri}$pbsvx( fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb,equed, s, b, ldb, x, &
     !! DPBSVX: uses the Cholesky factorization A = U**T*U or A = L*L**T to
     !! compute the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ldx, rcond, ferr, berr,work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldafb, ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), afb(ldafb,*), b(ldb,*), s(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: equil, nofact, rcequ, upper
           integer(ilp) :: i, infequ, j, j1, j2
           real(${rk}$) :: amax, anorm, bignum, scond, smax, smin, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           upper = stdlib_lsame( uplo, 'U' )
           if( nofact .or. equil ) then
              equed = 'N'
              rcequ = .false.
           else
              rcequ = stdlib_lsame( equed, 'Y' )
              smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldab<kd+1 ) then
              info = -7
           else if( ldafb<kd+1 ) then
              info = -9
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rcequ .or. stdlib_lsame( equed, 'N' ) )&
                      ) then
              info = -10
           else
              if( rcequ ) then
                 smin = bignum
                 smax = zero
                 do j = 1, n
                    smin = min( smin, s( j ) )
                    smax = max( smax, s( j ) )
                 end do
                 if( smin<=zero ) then
                    info = -11
                 else if( n>0 ) then
                    scond = max( smin, smlnum ) / min( smax, bignum )
                 else
                    scond = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -13
                 else if( ldx<max( 1, n ) ) then
                    info = -15
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_${ri}$pbequ( uplo, n, kd, ab, ldab, s, scond, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_${ri}$laqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                 rcequ = stdlib_lsame( equed, 'Y' )
              end if
           end if
           ! scale the right-hand side.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = s( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the cholesky factorization a = u**t *u or a = l*l**t.
              if( upper ) then
                 do j = 1, n
                    j1 = max( j-kd, 1 )
                    call stdlib_${ri}$copy( j-j1+1, ab( kd+1-j+j1, j ), 1,afb( kd+1-j+j1, j ), 1 )
                              
                 end do
              else
                 do j = 1, n
                    j2 = min( j+kd, n )
                    call stdlib_${ri}$copy( j2-j+1, ab( 1, j ), 1, afb( 1, j ), 1 )
                 end do
              end if
              call stdlib_${ri}$pbtrf( uplo, n, kd, afb, ldafb, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansb( '1', uplo, n, kd, ab, ldab, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$pbcon( uplo, n, kd, afb, ldafb, anorm, rcond, work, iwork,info )
           ! compute the solution matrix x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$pbtrs( uplo, n, kd, nrhs, afb, ldafb, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_${ri}$pbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x,ldx, ferr, berr,&
                      work, iwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = s( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / scond
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$pbsvx


     pure subroutine stdlib_${ri}$pbtf2( uplo, n, kd, ab, ldab, info )
     !! DPBTF2: computes the Cholesky factorization of a real symmetric
     !! positive definite band matrix A.
     !! The factorization has the form
     !! A = U**T * U ,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix, U**T is the transpose of U, and
     !! L is lower triangular.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, kld, kn
           real(${rk}$) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBTF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           kld = max( 1, ldab-1 )
           if( upper ) then
              ! compute the cholesky factorization a = u**t*u.
              do j = 1, n
                 ! compute u(j,j) and test for non-positive-definiteness.
                 ajj = ab( kd+1, j )
                 if( ajj<=zero )go to 30
                 ajj = sqrt( ajj )
                 ab( kd+1, j ) = ajj
                 ! compute elements j+1:j+kn of row j and update the
                 ! trailing submatrix within the band.
                 kn = min( kd, n-j )
                 if( kn>0 ) then
                    call stdlib_${ri}$scal( kn, one / ajj, ab( kd, j+1 ), kld )
                    call stdlib_${ri}$syr( 'UPPER', kn, -one, ab( kd, j+1 ), kld,ab( kd+1, j+1 ), kld )
                              
                 end if
              end do
           else
              ! compute the cholesky factorization a = l*l**t.
              do j = 1, n
                 ! compute l(j,j) and test for non-positive-definiteness.
                 ajj = ab( 1, j )
                 if( ajj<=zero )go to 30
                 ajj = sqrt( ajj )
                 ab( 1, j ) = ajj
                 ! compute elements j+1:j+kn of column j and update the
                 ! trailing submatrix within the band.
                 kn = min( kd, n-j )
                 if( kn>0 ) then
                    call stdlib_${ri}$scal( kn, one / ajj, ab( 2, j ), 1 )
                    call stdlib_${ri}$syr( 'LOWER', kn, -one, ab( 2, j ), 1,ab( 1, j+1 ), kld )
                 end if
              end do
           end if
           return
           30 continue
           info = j
           return
     end subroutine stdlib_${ri}$pbtf2


     pure subroutine stdlib_${ri}$pbtrf( uplo, n, kd, ab, ldab, info )
     !! DPBTRF: computes the Cholesky factorization of a real symmetric
     !! positive definite band matrix A.
     !! The factorization has the form
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 32
           integer(ilp), parameter :: ldwork = nbmax+1
           
           
           ! Local Scalars 
           integer(ilp) :: i, i2, i3, ib, ii, j, jj, nb
           ! Local Arrays 
           real(${rk}$) :: work(ldwork,nbmax)
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( ( .not.stdlib_lsame( uplo, 'U' ) ) .and.( .not.stdlib_lsame( uplo, 'L' ) ) ) &
                     then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment
           nb = stdlib_ilaenv( 1, 'DPBTRF', uplo, n, kd, -1, -1 )
           ! the block size must not exceed the semi-bandwidth kd, and must not
           ! exceed the limit set by the size of the local array work.
           nb = min( nb, nbmax )
           if( nb<=1 .or. nb>kd ) then
              ! use unblocked code
              call stdlib_${ri}$pbtf2( uplo, n, kd, ab, ldab, info )
           else
              ! use blocked code
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! compute the cholesky factorization of a symmetric band
                 ! matrix, given the upper triangle of the matrix in band
                 ! storage.
                 ! zero the upper triangle of the work array.
                 do j = 1, nb
                    do i = 1, j - 1
                       work( i, j ) = zero
                    end do
                 end do
                 ! process the band matrix one diagonal block at a time.
                 loop_70: do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    ! factorize the diagonal block
                    call stdlib_${ri}$potf2( uplo, ib, ab( kd+1, i ), ldab-1, ii )
                    if( ii/=0 ) then
                       info = i + ii - 1
                       go to 150
                    end if
                    if( i+ib<=n ) then
                       ! update the relevant part of the trailing submatrix.
                       ! if a11 denotes the diagonal block which has just been
                       ! factorized, then we need to update the remaining
                       ! blocks in the diagram:
                          ! a11   a12   a13
                                ! a22   a23
                                      ! a33
                       ! the numbers of rows and columns in the partitioning
                       ! are ib, i2, i3 respectively. the blocks a12, a22 and
                       ! a23 are empty if ib = kd. the upper triangle of a13
                       ! lies outside the band.
                       i2 = min( kd-ib, n-i-ib+1 )
                       i3 = min( ib, n-i-kd+1 )
                       if( i2>0 ) then
                          ! update a12
                          call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'TRANSPOSE','NON-UNIT', ib, i2, one,&
                                     ab( kd+1, i ),ldab-1, ab( kd+1-ib, i+ib ), ldab-1 )
                          ! update a22
                          call stdlib_${ri}$syrk( 'UPPER', 'TRANSPOSE', i2, ib, -one,ab( kd+1-ib, i+ib &
                                    ), ldab-1, one,ab( kd+1, i+ib ), ldab-1 )
                       end if
                       if( i3>0 ) then
                          ! copy the lower triangle of a13 into the work array.
                          do jj = 1, i3
                             do ii = jj, ib
                                work( ii, jj ) = ab( ii-jj+1, jj+i+kd-1 )
                             end do
                          end do
                          ! update a13 (in the work array).
                          call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'TRANSPOSE','NON-UNIT', ib, i3, one,&
                                     ab( kd+1, i ),ldab-1, work, ldwork )
                          ! update a23
                          if( i2>0 )call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', i2, i3,ib, -&
                          one, ab( kd+1-ib, i+ib ),ldab-1, work, ldwork, one,ab( 1+ib, i+kd ), &
                                    ldab-1 )
                          ! update a33
                          call stdlib_${ri}$syrk( 'UPPER', 'TRANSPOSE', i3, ib, -one,work, ldwork, one,&
                                     ab( kd+1, i+kd ),ldab-1 )
                          ! copy the lower triangle of a13 back into place.
                          do jj = 1, i3
                             do ii = jj, ib
                                ab( ii-jj+1, jj+i+kd-1 ) = work( ii, jj )
                             end do
                          end do
                       end if
                    end if
                 end do loop_70
              else
                 ! compute the cholesky factorization of a symmetric band
                 ! matrix, given the lower triangle of the matrix in band
                 ! storage.
                 ! zero the lower triangle of the work array.
                 do j = 1, nb
                    do i = j + 1, nb
                       work( i, j ) = zero
                    end do
                 end do
                 ! process the band matrix one diagonal block at a time.
                 loop_140: do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    ! factorize the diagonal block
                    call stdlib_${ri}$potf2( uplo, ib, ab( 1, i ), ldab-1, ii )
                    if( ii/=0 ) then
                       info = i + ii - 1
                       go to 150
                    end if
                    if( i+ib<=n ) then
                       ! update the relevant part of the trailing submatrix.
                       ! if a11 denotes the diagonal block which has just been
                       ! factorized, then we need to update the remaining
                       ! blocks in the diagram:
                          ! a11
                          ! a21   a22
                          ! a31   a32   a33
                       ! the numbers of rows and columns in the partitioning
                       ! are ib, i2, i3 respectively. the blocks a21, a22 and
                       ! a32 are empty if ib = kd. the lower triangle of a31
                       ! lies outside the band.
                       i2 = min( kd-ib, n-i-ib+1 )
                       i3 = min( ib, n-i-kd+1 )
                       if( i2>0 ) then
                          ! update a21
                          call stdlib_${ri}$trsm( 'RIGHT', 'LOWER', 'TRANSPOSE','NON-UNIT', i2, ib, &
                                    one, ab( 1, i ),ldab-1, ab( 1+ib, i ), ldab-1 )
                          ! update a22
                          call stdlib_${ri}$syrk( 'LOWER', 'NO TRANSPOSE', i2, ib, -one,ab( 1+ib, i ), &
                                    ldab-1, one,ab( 1, i+ib ), ldab-1 )
                       end if
                       if( i3>0 ) then
                          ! copy the upper triangle of a31 into the work array.
                          do jj = 1, ib
                             do ii = 1, min( jj, i3 )
                                work( ii, jj ) = ab( kd+1-jj+ii, jj+i-1 )
                             end do
                          end do
                          ! update a31 (in the work array).
                          call stdlib_${ri}$trsm( 'RIGHT', 'LOWER', 'TRANSPOSE','NON-UNIT', i3, ib, &
                                    one, ab( 1, i ),ldab-1, work, ldwork )
                          ! update a32
                          if( i2>0 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', i3, i2,ib, -&
                          one, work, ldwork,ab( 1+ib, i ), ldab-1, one,ab( 1+kd-ib, i+ib ), ldab-&
                                    1 )
                          ! update a33
                          call stdlib_${ri}$syrk( 'LOWER', 'NO TRANSPOSE', i3, ib, -one,work, ldwork, &
                                    one, ab( 1, i+kd ),ldab-1 )
                          ! copy the upper triangle of a31 back into place.
                          do jj = 1, ib
                             do ii = 1, min( jj, i3 )
                                ab( kd+1-jj+ii, jj+i-1 ) = work( ii, jj )
                             end do
                          end do
                       end if
                    end if
                 end do loop_140
              end if
           end if
           return
           150 continue
           return
     end subroutine stdlib_${ri}$pbtrf


     pure subroutine stdlib_${ri}$pbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! DPBTRS: solves a system of linear equations A*X = B with a symmetric
     !! positive definite band matrix A using the Cholesky factorization
     !! A = U**T*U or A = L*L**T computed by DPBTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b where a = u**t *u.
              do j = 1, nrhs
                 ! solve u**t *x = b, overwriting b with x.
                 call stdlib_${ri}$tbsv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, kd, ab,ldab, b( 1, j ), &
                           1 )
                 ! solve u*x = b, overwriting b with x.
                 call stdlib_${ri}$tbsv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, kd, ab,ldab, b( 1, j )&
                           , 1 )
              end do
           else
              ! solve a*x = b where a = l*l**t.
              do j = 1, nrhs
                 ! solve l*x = b, overwriting b with x.
                 call stdlib_${ri}$tbsv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', n, kd, ab,ldab, b( 1, j )&
                           , 1 )
                 ! solve l**t *x = b, overwriting b with x.
                 call stdlib_${ri}$tbsv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', n, kd, ab,ldab, b( 1, j ), &
                           1 )
              end do
           end if
           return
     end subroutine stdlib_${ri}$pbtrs


     pure subroutine stdlib_${ri}$pftrf( transr, uplo, n, a, info )
     !! DPFTRF: computes the Cholesky factorization of a real symmetric
     !! positive definite matrix A.
     !! The factorization has the form
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the block version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(in) :: n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(0:*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPFTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
           else
              nisodd = .true.
           end if
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1)
                    call stdlib_${ri}$potrf( 'L', n1, a( 0 ), n, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'R', 'L', 'T', 'N', n2, n1, one, a( 0 ), n,a( n1 ), n )
                              
                    call stdlib_${ri}$syrk( 'U', 'N', n2, n1, -one, a( n1 ), n, one,a( n ), n )
                    call stdlib_${ri}$potrf( 'U', n2, a( n ), n, info )
                    if( info>0 )info = info + n1
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    call stdlib_${ri}$potrf( 'L', n1, a( n2 ), n, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'L', 'L', 'N', 'N', n1, n2, one, a( n2 ), n,a( 0 ), n )
                              
                    call stdlib_${ri}$syrk( 'U', 'T', n2, n1, -one, a( 0 ), n, one,a( n1 ), n )
                    call stdlib_${ri}$potrf( 'U', n2, a( n1 ), n, info )
                    if( info>0 )info = info + n1
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    call stdlib_${ri}$potrf( 'U', n1, a( 0 ), n1, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'L', 'U', 'T', 'N', n1, n2, one, a( 0 ), n1,a( n1*n1 ), n1 &
                              )
                    call stdlib_${ri}$syrk( 'L', 'T', n2, n1, -one, a( n1*n1 ), n1, one,a( 1 ), n1 )
                              
                    call stdlib_${ri}$potrf( 'L', n2, a( 1 ), n1, info )
                    if( info>0 )info = info + n1
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda = n2
                    call stdlib_${ri}$potrf( 'U', n1, a( n2*n2 ), n2, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'R', 'U', 'N', 'N', n2, n1, one, a( n2*n2 ),n2, a( 0 ), n2 &
                              )
                    call stdlib_${ri}$syrk( 'L', 'N', n2, n1, -one, a( 0 ), n2, one,a( n1*n2 ), n2 )
                              
                    call stdlib_${ri}$potrf( 'L', n2, a( n1*n2 ), n2, info )
                    if( info>0 )info = info + n1
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    call stdlib_${ri}$potrf( 'L', k, a( 1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'R', 'L', 'T', 'N', k, k, one, a( 1 ), n+1,a( k+1 ), n+1 )
                              
                    call stdlib_${ri}$syrk( 'U', 'N', k, k, -one, a( k+1 ), n+1, one,a( 0 ), n+1 )
                              
                    call stdlib_${ri}$potrf( 'U', k, a( 0 ), n+1, info )
                    if( info>0 )info = info + k
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    call stdlib_${ri}$potrf( 'L', k, a( k+1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'L', 'L', 'N', 'N', k, k, one, a( k+1 ),n+1, a( 0 ), n+1 )
                              
                    call stdlib_${ri}$syrk( 'U', 'T', k, k, -one, a( 0 ), n+1, one,a( k ), n+1 )
                              
                    call stdlib_${ri}$potrf( 'U', k, a( k ), n+1, info )
                    if( info>0 )info = info + k
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    call stdlib_${ri}$potrf( 'U', k, a( 0+k ), k, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'L', 'U', 'T', 'N', k, k, one, a( k ), n1,a( k*( k+1 ) ), &
                              k )
                    call stdlib_${ri}$syrk( 'L', 'T', k, k, -one, a( k*( k+1 ) ), k, one,a( 0 ), k )
                              
                    call stdlib_${ri}$potrf( 'L', k, a( 0 ), k, info )
                    if( info>0 )info = info + k
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    call stdlib_${ri}$potrf( 'U', k, a( k*( k+1 ) ), k, info )
                    if( info>0 )return
                    call stdlib_${ri}$trsm( 'R', 'U', 'N', 'N', k, k, one,a( k*( k+1 ) ), k, a( 0 ), k &
                              )
                    call stdlib_${ri}$syrk( 'L', 'N', k, k, -one, a( 0 ), k, one,a( k*k ), k )
                    call stdlib_${ri}$potrf( 'L', k, a( k*k ), k, info )
                    if( info>0 )info = info + k
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$pftrf


     pure subroutine stdlib_${ri}$pftri( transr, uplo, n, a, info )
     !! DPFTRI: computes the inverse of a (real) symmetric positive definite
     !! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
     !! computed by DPFTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(0:*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPFTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! invert the triangular cholesky factor u or l.
           call stdlib_${ri}$tftri( transr, uplo, 'N', n, a, info )
           if( info>0 )return
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
           else
              nisodd = .true.
           end if
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! start execution of triangular matrix multiply: inv(u)*inv(u)^c or
           ! inv(l)^c*inv(l). there are eight cases.
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                    ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                    ! t1 -> a(0), t2 -> a(n), s -> a(n1)
                    call stdlib_${ri}$lauum( 'L', n1, a( 0 ), n, info )
                    call stdlib_${ri}$syrk( 'L', 'T', n1, n2, one, a( n1 ), n, one,a( 0 ), n )
                    call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', n2, n1, one, a( n ), n,a( n1 ), n )
                              
                    call stdlib_${ri}$lauum( 'U', n2, a( n ), n, info )
                 else
                    ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                    ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                    ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    call stdlib_${ri}$lauum( 'L', n1, a( n2 ), n, info )
                    call stdlib_${ri}$syrk( 'L', 'N', n1, n2, one, a( 0 ), n, one,a( n2 ), n )
                    call stdlib_${ri}$trmm( 'R', 'U', 'T', 'N', n1, n2, one, a( n1 ), n,a( 0 ), n )
                              
                    call stdlib_${ri}$lauum( 'U', n2, a( n1 ), n, info )
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose, and n is odd
                    ! t1 -> a(0), t2 -> a(1), s -> a(0+n1*n1)
                    call stdlib_${ri}$lauum( 'U', n1, a( 0 ), n1, info )
                    call stdlib_${ri}$syrk( 'U', 'N', n1, n2, one, a( n1*n1 ), n1, one,a( 0 ), n1 )
                              
                    call stdlib_${ri}$trmm( 'R', 'L', 'N', 'N', n1, n2, one, a( 1 ), n1,a( n1*n1 ), n1 &
                              )
                    call stdlib_${ri}$lauum( 'L', n2, a( 1 ), n1, info )
                 else
                    ! srpa for upper, transpose, and n is odd
                    ! t1 -> a(0+n2*n2), t2 -> a(0+n1*n2), s -> a(0)
                    call stdlib_${ri}$lauum( 'U', n1, a( n2*n2 ), n2, info )
                    call stdlib_${ri}$syrk( 'U', 'T', n1, n2, one, a( 0 ), n2, one,a( n2*n2 ), n2 )
                              
                    call stdlib_${ri}$trmm( 'L', 'L', 'T', 'N', n2, n1, one, a( n1*n2 ),n2, a( 0 ), n2 &
                              )
                    call stdlib_${ri}$lauum( 'L', n2, a( n1*n2 ), n2, info )
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    call stdlib_${ri}$lauum( 'L', k, a( 1 ), n+1, info )
                    call stdlib_${ri}$syrk( 'L', 'T', k, k, one, a( k+1 ), n+1, one,a( 1 ), n+1 )
                              
                    call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', k, k, one, a( 0 ), n+1,a( k+1 ), n+1 )
                              
                    call stdlib_${ri}$lauum( 'U', k, a( 0 ), n+1, info )
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    call stdlib_${ri}$lauum( 'L', k, a( k+1 ), n+1, info )
                    call stdlib_${ri}$syrk( 'L', 'N', k, k, one, a( 0 ), n+1, one,a( k+1 ), n+1 )
                              
                    call stdlib_${ri}$trmm( 'R', 'U', 'T', 'N', k, k, one, a( k ), n+1,a( 0 ), n+1 )
                              
                    call stdlib_${ri}$lauum( 'U', k, a( k ), n+1, info )
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose, and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1),
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    call stdlib_${ri}$lauum( 'U', k, a( k ), k, info )
                    call stdlib_${ri}$syrk( 'U', 'N', k, k, one, a( k*( k+1 ) ), k, one,a( k ), k )
                              
                    call stdlib_${ri}$trmm( 'R', 'L', 'N', 'N', k, k, one, a( 0 ), k,a( k*( k+1 ) ), k &
                              )
                    call stdlib_${ri}$lauum( 'L', k, a( 0 ), k, info )
                 else
                    ! srpa for upper, transpose, and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0),
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    call stdlib_${ri}$lauum( 'U', k, a( k*( k+1 ) ), k, info )
                    call stdlib_${ri}$syrk( 'U', 'T', k, k, one, a( 0 ), k, one,a( k*( k+1 ) ), k )
                              
                    call stdlib_${ri}$trmm( 'L', 'L', 'T', 'N', k, k, one, a( k*k ), k,a( 0 ), k )
                              
                    call stdlib_${ri}$lauum( 'L', k, a( k*k ), k, info )
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$pftri


     pure subroutine stdlib_${ri}$pftrs( transr, uplo, n, nrhs, a, b, ldb, info )
     !! DPFTRS: solves a system of linear equations A*X = B with a symmetric
     !! positive definite matrix A using the Cholesky factorization
     !! A = U**T*U or A = L*L**T computed by DPFTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(0:*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, normaltransr
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPFTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! start execution: there are two triangular solves
           if( lower ) then
              call stdlib_${ri}$tfsm( transr, 'L', uplo, 'N', 'N', n, nrhs, one, a, b,ldb )
              call stdlib_${ri}$tfsm( transr, 'L', uplo, 'T', 'N', n, nrhs, one, a, b,ldb )
           else
              call stdlib_${ri}$tfsm( transr, 'L', uplo, 'T', 'N', n, nrhs, one, a, b,ldb )
              call stdlib_${ri}$tfsm( transr, 'L', uplo, 'N', 'N', n, nrhs, one, a, b,ldb )
           end if
           return
     end subroutine stdlib_${ri}$pftrs


     pure subroutine stdlib_${ri}$pocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
     !! DPOCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric positive definite matrix using the
     !! Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           character :: normin
           integer(ilp) :: ix, kase
           real(${rk}$) :: ainvnm, scale, scalel, scaleu, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! estimate the 1-norm of inv(a).
           kase = 0
           normin = 'N'
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( upper ) then
                 ! multiply by inv(u**t).
                 call stdlib_${ri}$latrs( 'UPPER', 'TRANSPOSE', 'NON-UNIT', normin, n, a,lda, work, &
                           scalel, work( 2*n+1 ), info )
                 normin = 'Y'
                 ! multiply by inv(u).
                 call stdlib_${ri}$latrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,a, lda, work, &
                           scaleu, work( 2*n+1 ), info )
              else
                 ! multiply by inv(l).
                 call stdlib_${ri}$latrs( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,a, lda, work, &
                           scalel, work( 2*n+1 ), info )
                 normin = 'Y'
                 ! multiply by inv(l**t).
                 call stdlib_${ri}$latrs( 'LOWER', 'TRANSPOSE', 'NON-UNIT', normin, n, a,lda, work, &
                           scaleu, work( 2*n+1 ), info )
              end if
              ! multiply by 1/scale if doing so will not cause overflow.
              scale = scalel*scaleu
              if( scale/=one ) then
                 ix = stdlib_i${ri}$amax( n, work, 1 )
                 if( scale<abs( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_${ri}$rscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_${ri}$pocon


     pure subroutine stdlib_${ri}$poequ( n, a, lda, s, scond, amax, info )
     !! DPOEQU: computes row and column scalings intended to equilibrate a
     !! symmetric positive definite matrix A and reduce its condition number
     !! (with respect to the two-norm).  S contains the scale factors,
     !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     !! choice of S puts the condition number of B within a factor N of the
     !! smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: smin
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( lda<max( 1, n ) ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOEQU', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           ! find the minimum and maximum diagonal elements.
           s( 1 ) = a( 1, 1 )
           smin = s( 1 )
           amax = s( 1 )
           do i = 2, n
              s( i ) = a( i, i )
              smin = min( smin, s( i ) )
              amax = max( amax, s( i ) )
           end do
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = one / sqrt( s( i ) )
              end do
              ! compute scond = min(s(i)) / max(s(i))
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_${ri}$poequ


     pure subroutine stdlib_${ri}$poequb( n, a, lda, s, scond, amax, info )
     !! DPOEQUB: computes row and column scalings intended to equilibrate a
     !! symmetric positive definite matrix A and reduce its condition number
     !! (with respect to the two-norm).  S contains the scale factors,
     !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     !! choice of S puts the condition number of B within a factor N of the
     !! smallest possible condition number over all possible diagonal
     !! scalings.
     !! This routine differs from DPOEQU by restricting the scaling factors
     !! to a power of the radix.  Barring over- and underflow, scaling by
     !! these factors introduces no additional rounding errors.  However, the
     !! scaled diagonal entries are no longer approximately 1 but lie
     !! between sqrt(radix) and 1/sqrt(radix).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: smin, base, tmp
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt,log,int
           ! Executable Statements 
           ! test the input parameters.
           ! positive definite only performs 1 pass of equilibration.
           info = 0
           if( n<0 ) then
              info = -1
           else if( lda<max( 1, n ) ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOEQUB', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           base = stdlib_${ri}$lamch( 'B' )
           tmp = -0.5e+0_${rk}$ / log ( base )
           ! find the minimum and maximum diagonal elements.
           s( 1 ) = a( 1, 1 )
           smin = s( 1 )
           amax = s( 1 )
           do i = 2, n
              s( i ) = a( i, i )
              smin = min( smin, s( i ) )
              amax = max( amax, s( i ) )
           end do
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = base ** int( tmp * log( s( i ) ),KIND=ilp)
              end do
              ! compute scond = min(s(i)) / max(s(i)).
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_${ri}$poequb


     pure subroutine stdlib_${ri}$porfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr, &
     !! DPORFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric positive definite,
     !! and provides error bounds and backward error estimates for the
     !! solution.
               work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPORFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$symv( uplo, n, -one, a, lda, x( 1, j ), 1, one,work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + abs( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( a( k, k ) )*xk
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$potrs( uplo, n, 1, af, ldaf, work( n+1 ), n, info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$potrs( uplo, n, 1, af, ldaf, work( n+1 ), n, info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$potrs( uplo, n, 1, af, ldaf, work( n+1 ), n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$porfs


     pure subroutine stdlib_${ri}$posv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! DPOSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_${ri}$potrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$potrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$posv


     subroutine stdlib_${ri}$posvx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,s, b, ldb, x, ldx, &
     !! DPOSVX: uses the Cholesky factorization A = U**T*U or A = L*L**T to
     !! compute the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               rcond, ferr, berr, work,iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), af(ldaf,*), b(ldb,*), s(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: equil, nofact, rcequ
           integer(ilp) :: i, infequ, j
           real(${rk}$) :: amax, anorm, bignum, scond, smax, smin, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           if( nofact .or. equil ) then
              equed = 'N'
              rcequ = .false.
           else
              rcequ = stdlib_lsame( equed, 'Y' )
              smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rcequ .or. stdlib_lsame( equed, 'N' ) )&
                      ) then
              info = -9
           else
              if( rcequ ) then
                 smin = bignum
                 smax = zero
                 do j = 1, n
                    smin = min( smin, s( j ) )
                    smax = max( smax, s( j ) )
                 end do
                 if( smin<=zero ) then
                    info = -10
                 else if( n>0 ) then
                    scond = max( smin, smlnum ) / min( smax, bignum )
                 else
                    scond = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -12
                 else if( ldx<max( 1, n ) ) then
                    info = -14
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_${ri}$poequ( n, a, lda, s, scond, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_${ri}$laqsy( uplo, n, a, lda, s, scond, amax, equed )
                 rcequ = stdlib_lsame( equed, 'Y' )
              end if
           end if
           ! scale the right hand side.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = s( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the cholesky factorization a = u**t *u or a = l*l**t.
              call stdlib_${ri}$lacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_${ri}$potrf( uplo, n, af, ldaf, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansy( '1', uplo, n, a, lda, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$pocon( uplo, n, af, ldaf, anorm, rcond, work, iwork, info )
           ! compute the solution matrix x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$potrs( uplo, n, nrhs, af, ldaf, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_${ri}$porfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx,ferr, berr, work, &
                     iwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = s( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / scond
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$posvx


     pure subroutine stdlib_${ri}$potf2( uplo, n, a, lda, info )
     !! DPOTF2: computes the Cholesky factorization of a real symmetric
     !! positive definite matrix A.
     !! The factorization has the form
     !! A = U**T * U ,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j
           real(${rk}$) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOTF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! compute the cholesky factorization a = u**t *u.
              do j = 1, n
                 ! compute u(j,j) and test for non-positive-definiteness.
                 ajj = a( j, j ) - stdlib_${ri}$dot( j-1, a( 1, j ), 1, a( 1, j ), 1 )
                 if( ajj<=zero.or.stdlib_${ri}$isnan( ajj ) ) then
                    a( j, j ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of row j.
                 if( j<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', j-1, n-j, -one, a( 1, j+1 ),lda, a( 1, j ), 1,&
                               one, a( j, j+1 ), lda )
                    call stdlib_${ri}$scal( n-j, one / ajj, a( j, j+1 ), lda )
                 end if
              end do
           else
              ! compute the cholesky factorization a = l*l**t.
              do j = 1, n
                 ! compute l(j,j) and test for non-positive-definiteness.
                 ajj = a( j, j ) - stdlib_${ri}$dot( j-1, a( j, 1 ), lda, a( j, 1 ),lda )
                 if( ajj<=zero.or.stdlib_${ri}$isnan( ajj ) ) then
                    a( j, j ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of column j.
                 if( j<n ) then
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-j, j-1, -one, a( j+1, 1 ),lda, a( j, 1 ),&
                               lda, one, a( j+1, j ), 1 )
                    call stdlib_${ri}$scal( n-j, one / ajj, a( j+1, j ), 1 )
                 end if
              end do
           end if
           go to 40
           30 continue
           info = j
           40 continue
           return
     end subroutine stdlib_${ri}$potf2


     pure subroutine stdlib_${ri}$potrf( uplo, n, a, lda, info )
     !! DPOTRF: computes the Cholesky factorization of a real symmetric
     !! positive definite matrix A.
     !! The factorization has the form
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the block version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'DPOTRF', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code.
              call stdlib_${ri}$potrf2( uplo, n, a, lda, info )
           else
              ! use blocked code.
              if( upper ) then
                 ! compute the cholesky factorization a = u**t*u.
                 do j = 1, n, nb
                    ! update and factorize the current diagonal block and test
                    ! for non-positive-definiteness.
                    jb = min( nb, n-j+1 )
                    call stdlib_${ri}$syrk( 'UPPER', 'TRANSPOSE', jb, j-1, -one,a( 1, j ), lda, one, a(&
                               j, j ), lda )
                    call stdlib_${ri}$potrf2( 'UPPER', jb, a( j, j ), lda, info )
                    if( info/=0 )go to 30
                    if( j+jb<=n ) then
                       ! compute the current block row.
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', jb, n-j-jb+1,j-1, -one, a( &
                                 1, j ), lda, a( 1, j+jb ),lda, one, a( j, j+jb ), lda )
                       call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'TRANSPOSE', 'NON-UNIT',jb, n-j-jb+1, &
                                 one, a( j, j ), lda,a( j, j+jb ), lda )
                    end if
                 end do
              else
                 ! compute the cholesky factorization a = l*l**t.
                 do j = 1, n, nb
                    ! update and factorize the current diagonal block and test
                    ! for non-positive-definiteness.
                    jb = min( nb, n-j+1 )
                    call stdlib_${ri}$syrk( 'LOWER', 'NO TRANSPOSE', jb, j-1, -one,a( j, 1 ), lda, one,&
                               a( j, j ), lda )
                    call stdlib_${ri}$potrf2( 'LOWER', jb, a( j, j ), lda, info )
                    if( info/=0 )go to 30
                    if( j+jb<=n ) then
                       ! compute the current block column.
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,j-1, -one, a( &
                                 j+jb, 1 ), lda, a( j, 1 ),lda, one, a( j+jb, j ), lda )
                       call stdlib_${ri}$trsm( 'RIGHT', 'LOWER', 'TRANSPOSE', 'NON-UNIT',n-j-jb+1, jb, &
                                 one, a( j, j ), lda,a( j+jb, j ), lda )
                    end if
                 end do
              end if
           end if
           go to 40
           30 continue
           info = info + j - 1
           40 continue
           return
     end subroutine stdlib_${ri}$potrf


     pure recursive subroutine stdlib_${ri}$potrf2( uplo, n, a, lda, info )
     !! DPOTRF2: computes the Cholesky factorization of a real symmetric
     !! positive definite matrix A using the recursive algorithm.
     !! The factorization has the form
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the recursive version of the algorithm. It divides
     !! the matrix into four submatrices:
     !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
     !! A = [ -----|----- ]  with n1 = n/2
     !! [  A21 | A22  ]       n2 = n-n1
     !! The subroutine calls itself to factor A11. Update and scale A21
     !! or A12, update A22 then calls itself to factor A22.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: n1, n2, iinfo
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOTRF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! n=1 case
           if( n==1 ) then
              ! test for non-positive-definiteness
              if( a( 1, 1 )<=zero.or.stdlib_${ri}$isnan( a( 1, 1 ) ) ) then
                 info = 1
                 return
              end if
              ! factor
              a( 1, 1 ) = sqrt( a( 1, 1 ) )
           ! use recursive code
           else
              n1 = n/2
              n2 = n-n1
              ! factor a11
              call stdlib_${ri}$potrf2( uplo, n1, a( 1, 1 ), lda, iinfo )
              if ( iinfo/=0 ) then
                 info = iinfo
                 return
              end if
              ! compute the cholesky factorization a = u**t*u
              if( upper ) then
                 ! update and scale a12
                 call stdlib_${ri}$trsm( 'L', 'U', 'T', 'N', n1, n2, one,a( 1, 1 ), lda, a( 1, n1+1 ), &
                           lda )
                 ! update and factor a22
                 call stdlib_${ri}$syrk( uplo, 'T', n2, n1, -one, a( 1, n1+1 ), lda,one, a( n1+1, n1+1 &
                           ), lda )
                 call stdlib_${ri}$potrf2( uplo, n2, a( n1+1, n1+1 ), lda, iinfo )
                 if ( iinfo/=0 ) then
                    info = iinfo + n1
                    return
                 end if
              ! compute the cholesky factorization a = l*l**t
              else
                 ! update and scale a21
                 call stdlib_${ri}$trsm( 'R', 'L', 'T', 'N', n2, n1, one,a( 1, 1 ), lda, a( n1+1, 1 ), &
                           lda )
                 ! update and factor a22
                 call stdlib_${ri}$syrk( uplo, 'N', n2, n1, -one, a( n1+1, 1 ), lda,one, a( n1+1, n1+1 &
                           ), lda )
                 call stdlib_${ri}$potrf2( uplo, n2, a( n1+1, n1+1 ), lda, iinfo )
                 if ( iinfo/=0 ) then
                    info = iinfo + n1
                    return
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$potrf2


     pure subroutine stdlib_${ri}$potri( uplo, n, a, lda, info )
     !! DPOTRI: computes the inverse of a real symmetric positive definite
     !! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
     !! computed by DPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! invert the triangular cholesky factor u or l.
           call stdlib_${ri}$trtri( uplo, 'NON-UNIT', n, a, lda, info )
           if( info>0 )return
           ! form inv(u) * inv(u)**t or inv(l)**t * inv(l).
           call stdlib_${ri}$lauum( uplo, n, a, lda, info )
           return
     end subroutine stdlib_${ri}$potri


     pure subroutine stdlib_${ri}$potrs( uplo, n, nrhs, a, lda, b, ldb, info )
     !! DPOTRS: solves a system of linear equations A*X = B with a symmetric
     !! positive definite matrix A using the Cholesky factorization
     !! A = U**T*U or A = L*L**T computed by DPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b where a = u**t *u.
              ! solve u**t *x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, nrhs,one, a, lda, b,&
                         ldb )
              ! solve u*x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n,nrhs, one, a, lda,&
                         b, ldb )
           else
              ! solve a*x = b where a = l*l**t.
              ! solve l*x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', n,nrhs, one, a, lda,&
                         b, ldb )
              ! solve l**t *x = b, overwriting b with x.
              call stdlib_${ri}$trsm( 'LEFT', 'LOWER', 'TRANSPOSE', 'NON-UNIT', n, nrhs,one, a, lda, b,&
                         ldb )
           end if
           return
     end subroutine stdlib_${ri}$potrs


     pure subroutine stdlib_${ri}$ppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
     !! DPPCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric positive definite packed matrix using
     !! the Cholesky factorization A = U**T*U or A = L*L**T computed by
     !! DPPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           character :: normin
           integer(ilp) :: ix, kase
           real(${rk}$) :: ainvnm, scale, scalel, scaleu, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! estimate the 1-norm of the inverse.
           kase = 0
           normin = 'N'
           10 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( upper ) then
                 ! multiply by inv(u**t).
                 call stdlib_${ri}$latps( 'UPPER', 'TRANSPOSE', 'NON-UNIT', normin, n,ap, work, scalel,&
                            work( 2*n+1 ), info )
                 normin = 'Y'
                 ! multiply by inv(u).
                 call stdlib_${ri}$latps( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,ap, work, &
                           scaleu, work( 2*n+1 ), info )
              else
                 ! multiply by inv(l).
                 call stdlib_${ri}$latps( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,ap, work, &
                           scalel, work( 2*n+1 ), info )
                 normin = 'Y'
                 ! multiply by inv(l**t).
                 call stdlib_${ri}$latps( 'LOWER', 'TRANSPOSE', 'NON-UNIT', normin, n,ap, work, scaleu,&
                            work( 2*n+1 ), info )
              end if
              ! multiply by 1/scale if doing so will not cause overflow.
              scale = scalel*scaleu
              if( scale/=one ) then
                 ix = stdlib_i${ri}$amax( n, work, 1 )
                 if( scale<abs( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_${ri}$rscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_${ri}$ppcon


     pure subroutine stdlib_${ri}$ppequ( uplo, n, ap, s, scond, amax, info )
     !! DPPEQU: computes row and column scalings intended to equilibrate a
     !! symmetric positive definite matrix A in packed storage and reduce
     !! its condition number (with respect to the two-norm).  S contains the
     !! scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
     !! B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
     !! This choice of S puts the condition number of B within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(out) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: s(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, jj
           real(${rk}$) :: smin
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPEQU', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           ! initialize smin and amax.
           s( 1 ) = ap( 1 )
           smin = s( 1 )
           amax = s( 1 )
           if( upper ) then
              ! uplo = 'u':  upper triangle of a is stored.
              ! find the minimum and maximum diagonal elements.
              jj = 1
              do i = 2, n
                 jj = jj + i
                 s( i ) = ap( jj )
                 smin = min( smin, s( i ) )
                 amax = max( amax, s( i ) )
              end do
           else
              ! uplo = 'l':  lower triangle of a is stored.
              ! find the minimum and maximum diagonal elements.
              jj = 1
              do i = 2, n
                 jj = jj + n - i + 2
                 s( i ) = ap( jj )
                 smin = min( smin, s( i ) )
                 amax = max( amax, s( i ) )
              end do
           end if
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = one / sqrt( s( i ) )
              end do
              ! compute scond = min(s(i)) / max(s(i))
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_${ri}$ppequ


     pure subroutine stdlib_${ri}$pprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
     !! DPPRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric positive definite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
               iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: afp(*), ap(*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldx<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$spmv( uplo, n, -one, ap, x( 1, j ), 1, one, work( n+1 ),1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + abs( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$pptrs( uplo, n, 1, afp, work( n+1 ), n, info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$pptrs( uplo, n, 1, afp, work( n+1 ), n, info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$pptrs( uplo, n, 1, afp, work( n+1 ), n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$pprfs


     pure subroutine stdlib_${ri}$ppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! DPPSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_${ri}$pptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$pptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$ppsv


     subroutine stdlib_${ri}$ppsvx( fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb,x, ldx, rcond, ferr,&
     !! DPPSVX: uses the Cholesky factorization A = U**T*U or A = L*L**T to
     !! compute the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                berr, work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: afp(*), ap(*), b(ldb,*), s(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: equil, nofact, rcequ
           integer(ilp) :: i, infequ, j
           real(${rk}$) :: amax, anorm, bignum, scond, smax, smin, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           if( nofact .or. equil ) then
              equed = 'N'
              rcequ = .false.
           else
              rcequ = stdlib_lsame( equed, 'Y' )
              smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rcequ .or. stdlib_lsame( equed, 'N' ) )&
                      ) then
              info = -7
           else
              if( rcequ ) then
                 smin = bignum
                 smax = zero
                 do j = 1, n
                    smin = min( smin, s( j ) )
                    smax = max( smax, s( j ) )
                 end do
                 if( smin<=zero ) then
                    info = -8
                 else if( n>0 ) then
                    scond = max( smin, smlnum ) / min( smax, bignum )
                 else
                    scond = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -10
                 else if( ldx<max( 1, n ) ) then
                    info = -12
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_${ri}$ppequ( uplo, n, ap, s, scond, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_${ri}$laqsp( uplo, n, ap, s, scond, amax, equed )
                 rcequ = stdlib_lsame( equed, 'Y' )
              end if
           end if
           ! scale the right-hand side.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = s( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the cholesky factorization a = u**t * u or a = l * l**t.
              call stdlib_${ri}$copy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_${ri}$pptrf( uplo, n, afp, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansp( 'I', uplo, n, ap, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$ppcon( uplo, n, afp, anorm, rcond, work, iwork, info )
           ! compute the solution matrix x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$pptrs( uplo, n, nrhs, afp, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_${ri}$pprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr,work, iwork, &
                     info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = s( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / scond
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$ppsvx


     pure subroutine stdlib_${ri}$pptrf( uplo, n, ap, info )
     !! DPPTRF: computes the Cholesky factorization of a real symmetric
     !! positive definite matrix A stored in packed format.
     !! The factorization has the form
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, jc, jj
           real(${rk}$) :: ajj
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! compute the cholesky factorization a = u**t*u.
              jj = 0
              do j = 1, n
                 jc = jj + 1
                 jj = jj + j
                 ! compute elements 1:j-1 of column j.
                 if( j>1 )call stdlib_${ri}$tpsv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', j-1, ap,ap( jc ), &
                           1 )
                 ! compute u(j,j) and test for non-positive-definiteness.
                 ajj = ap( jj ) - stdlib_${ri}$dot( j-1, ap( jc ), 1, ap( jc ), 1 )
                 if( ajj<=zero ) then
                    ap( jj ) = ajj
                    go to 30
                 end if
                 ap( jj ) = sqrt( ajj )
              end do
           else
              ! compute the cholesky factorization a = l*l**t.
              jj = 1
              do j = 1, n
                 ! compute l(j,j) and test for non-positive-definiteness.
                 ajj = ap( jj )
                 if( ajj<=zero ) then
                    ap( jj ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 ap( jj ) = ajj
                 ! compute elements j+1:n of column j and update the trailing
                 ! submatrix.
                 if( j<n ) then
                    call stdlib_${ri}$scal( n-j, one / ajj, ap( jj+1 ), 1 )
                    call stdlib_${ri}$spr( 'LOWER', n-j, -one, ap( jj+1 ), 1,ap( jj+n-j+1 ) )
                    jj = jj + n - j + 1
                 end if
              end do
           end if
           go to 40
           30 continue
           info = j
           40 continue
           return
     end subroutine stdlib_${ri}$pptrf


     pure subroutine stdlib_${ri}$pptri( uplo, n, ap, info )
     !! DPPTRI: computes the inverse of a real symmetric positive definite
     !! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
     !! computed by DPPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, jc, jj, jjn
           real(${rk}$) :: ajj
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! invert the triangular cholesky factor u or l.
           call stdlib_${ri}$tptri( uplo, 'NON-UNIT', n, ap, info )
           if( info>0 )return
           if( upper ) then
              ! compute the product inv(u) * inv(u)**t.
              jj = 0
              do j = 1, n
                 jc = jj + 1
                 jj = jj + j
                 if( j>1 )call stdlib_${ri}$spr( 'UPPER', j-1, one, ap( jc ), 1, ap )
                 ajj = ap( jj )
                 call stdlib_${ri}$scal( j, ajj, ap( jc ), 1 )
              end do
           else
              ! compute the product inv(l)**t * inv(l).
              jj = 1
              do j = 1, n
                 jjn = jj + n - j + 1
                 ap( jj ) = stdlib_${ri}$dot( n-j+1, ap( jj ), 1, ap( jj ), 1 )
                 if( j<n )call stdlib_${ri}$tpmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', n-j,ap( jjn ), ap( &
                           jj+1 ), 1 )
                 jj = jjn
              end do
           end if
           return
     end subroutine stdlib_${ri}$pptri


     pure subroutine stdlib_${ri}$pptrs( uplo, n, nrhs, ap, b, ldb, info )
     !! DPPTRS: solves a system of linear equations A*X = B with a symmetric
     !! positive definite matrix A in packed storage using the Cholesky
     !! factorization A = U**T*U or A = L*L**T computed by DPPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b where a = u**t * u.
              do i = 1, nrhs
                 ! solve u**t *x = b, overwriting b with x.
                 call stdlib_${ri}$tpsv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, ap,b( 1, i ), 1 )
                 ! solve u*x = b, overwriting b with x.
                 call stdlib_${ri}$tpsv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, ap,b( 1, i ), 1 )
                           
              end do
           else
              ! solve a*x = b where a = l * l**t.
              do i = 1, nrhs
                 ! solve l*y = b, overwriting b with x.
                 call stdlib_${ri}$tpsv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', n, ap,b( 1, i ), 1 )
                           
                 ! solve l**t *x = y, overwriting b with x.
                 call stdlib_${ri}$tpsv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', n, ap,b( 1, i ), 1 )
              end do
           end if
           return
     end subroutine stdlib_${ri}$pptrs


     pure subroutine stdlib_${ri}$pstf2( uplo, n, a, lda, piv, rank, tol, work, info )
     !! DPSTF2: computes the Cholesky factorization with complete
     !! pivoting of a real symmetric positive semidefinite matrix A.
     !! The factorization has the form
     !! P**T * A * P = U**T * U ,  if UPLO = 'U',
     !! P**T * A * P = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular, and
     !! P is stored as vector PIV.
     !! This algorithm does not attempt to check that A is positive
     !! semidefinite. This version of the algorithm calls level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: tol
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, n
           character, intent(in) :: uplo
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(2*n)
           integer(ilp), intent(out) :: piv(n)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: ajj, dstop, dtemp
           integer(ilp) :: i, itemp, j, pvt
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: max,sqrt,maxloc
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPSTF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize piv
           do i = 1, n
              piv( i ) = i
           end do
           ! compute stopping value
           pvt = 1
           ajj = a( pvt, pvt )
           do i = 2, n
              if( a( i, i )>ajj ) then
                 pvt = i
                 ajj = a( pvt, pvt )
              end if
           end do
           if( ajj<=zero.or.stdlib_${ri}$isnan( ajj ) ) then
              rank = 0
              info = 1
              go to 170
           end if
           ! compute stopping value if not supplied
           if( tol<zero ) then
              dstop = n * stdlib_${ri}$lamch( 'EPSILON' ) * ajj
           else
              dstop = tol
           end if
           ! set first half of work to zero, holds dot products
           do i = 1, n
              work( i ) = 0
           end do
           if( upper ) then
              ! compute the cholesky factorization p**t * a * p = u**t * u
              loop_130: do j = 1, n
              ! find pivot, test for exit, else swap rows and columns
              ! update dot products, compute possible pivots which are
              ! stored in the second half of work
                 do i = j, n
                    if( j>1 ) then
                       work( i ) = work( i ) + a( j-1, i )**2
                    end if
                    work( n+i ) = a( i, i ) - work( i )
                 end do
                 if( j>1 ) then
                    itemp = maxloc( work( (n+j):(2*n) ), 1 )
                    pvt = itemp + j - 1
                    ajj = work( n+pvt )
                    if( ajj<=dstop.or.stdlib_${ri}$isnan( ajj ) ) then
                       a( j, j ) = ajj
                       go to 160
                    end if
                 end if
                 if( j/=pvt ) then
                    ! pivot ok, so can now swap pivot rows and columns
                    a( pvt, pvt ) = a( j, j )
                    call stdlib_${ri}$swap( j-1, a( 1, j ), 1, a( 1, pvt ), 1 )
                    if( pvt<n )call stdlib_${ri}$swap( n-pvt, a( j, pvt+1 ), lda,a( pvt, pvt+1 ), lda )
                              
                    call stdlib_${ri}$swap( pvt-j-1, a( j, j+1 ), lda, a( j+1, pvt ), 1 )
                    ! swap dot products and piv
                    dtemp = work( j )
                    work( j ) = work( pvt )
                    work( pvt ) = dtemp
                    itemp = piv( pvt )
                    piv( pvt ) = piv( j )
                    piv( j ) = itemp
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of row j
                 if( j<n ) then
                    call stdlib_${ri}$gemv( 'TRANS', j-1, n-j, -one, a( 1, j+1 ), lda,a( 1, j ), 1, &
                              one, a( j, j+1 ), lda )
                    call stdlib_${ri}$scal( n-j, one / ajj, a( j, j+1 ), lda )
                 end if
              end do loop_130
           else
              ! compute the cholesky factorization p**t * a * p = l * l**t
              loop_150: do j = 1, n
              ! find pivot, test for exit, else swap rows and columns
              ! update dot products, compute possible pivots which are
              ! stored in the second half of work
                 do i = j, n
                    if( j>1 ) then
                       work( i ) = work( i ) + a( i, j-1 )**2
                    end if
                    work( n+i ) = a( i, i ) - work( i )
                 end do
                 if( j>1 ) then
                    itemp = maxloc( work( (n+j):(2*n) ), 1 )
                    pvt = itemp + j - 1
                    ajj = work( n+pvt )
                    if( ajj<=dstop.or.stdlib_${ri}$isnan( ajj ) ) then
                       a( j, j ) = ajj
                       go to 160
                    end if
                 end if
                 if( j/=pvt ) then
                    ! pivot ok, so can now swap pivot rows and columns
                    a( pvt, pvt ) = a( j, j )
                    call stdlib_${ri}$swap( j-1, a( j, 1 ), lda, a( pvt, 1 ), lda )
                    if( pvt<n )call stdlib_${ri}$swap( n-pvt, a( pvt+1, j ), 1, a( pvt+1, pvt ),1 )
                              
                    call stdlib_${ri}$swap( pvt-j-1, a( j+1, j ), 1, a( pvt, j+1 ), lda )
                    ! swap dot products and piv
                    dtemp = work( j )
                    work( j ) = work( pvt )
                    work( pvt ) = dtemp
                    itemp = piv( pvt )
                    piv( pvt ) = piv( j )
                    piv( j ) = itemp
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of column j
                 if( j<n ) then
                    call stdlib_${ri}$gemv( 'NO TRANS', n-j, j-1, -one, a( j+1, 1 ), lda,a( j, 1 ), &
                              lda, one, a( j+1, j ), 1 )
                    call stdlib_${ri}$scal( n-j, one / ajj, a( j+1, j ), 1 )
                 end if
              end do loop_150
           end if
           ! ran to completion, a has full rank
           rank = n
           go to 170
           160 continue
           ! rank is number of steps completed.  set info = 1 to signal
           ! that the factorization cannot be used to solve a system.
           rank = j - 1
           info = 1
           170 continue
           return
     end subroutine stdlib_${ri}$pstf2


     pure subroutine stdlib_${ri}$pstrf( uplo, n, a, lda, piv, rank, tol, work, info )
     !! DPSTRF: computes the Cholesky factorization with complete
     !! pivoting of a real symmetric positive semidefinite matrix A.
     !! The factorization has the form
     !! P**T * A * P = U**T * U ,  if UPLO = 'U',
     !! P**T * A * P = L  * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular, and
     !! P is stored as vector PIV.
     !! This algorithm does not attempt to check that A is positive
     !! semidefinite. This version of the algorithm calls level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: tol
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, n
           character, intent(in) :: uplo
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(2*n)
           integer(ilp), intent(out) :: piv(n)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: ajj, dstop, dtemp
           integer(ilp) :: i, itemp, j, jb, k, nb, pvt
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt,maxloc
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPSTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get block size
           nb = stdlib_ilaenv( 1, 'DPOTRF', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_${ri}$pstf2( uplo, n, a( 1, 1 ), lda, piv, rank, tol, work,info )
              go to 200
           else
           ! initialize piv
              do i = 1, n
                 piv( i ) = i
              end do
           ! compute stopping value
              pvt = 1
              ajj = a( pvt, pvt )
              do i = 2, n
                 if( a( i, i )>ajj ) then
                    pvt = i
                    ajj = a( pvt, pvt )
                 end if
              end do
              if( ajj<=zero.or.stdlib_${ri}$isnan( ajj ) ) then
                 rank = 0
                 info = 1
                 go to 200
              end if
           ! compute stopping value if not supplied
              if( tol<zero ) then
                 dstop = n * stdlib_${ri}$lamch( 'EPSILON' ) * ajj
              else
                 dstop = tol
              end if
              if( upper ) then
                 ! compute the cholesky factorization p**t * a * p = u**t * u
                 loop_140: do k = 1, n, nb
                    ! account for last block not being nb wide
                    jb = min( nb, n-k+1 )
                    ! set relevant part of first half of work to zero,
                    ! holds dot products
                    do i = k, n
                       work( i ) = 0
                    end do
                    loop_130: do j = k, k + jb - 1
                    ! find pivot, test for exit, else swap rows and columns
                    ! update dot products, compute possible pivots which are
                    ! stored in the second half of work
                       do i = j, n
                          if( j>k ) then
                             work( i ) = work( i ) + a( j-1, i )**2
                          end if
                          work( n+i ) = a( i, i ) - work( i )
                       end do
                       if( j>1 ) then
                          itemp = maxloc( work( (n+j):(2*n) ), 1 )
                          pvt = itemp + j - 1
                          ajj = work( n+pvt )
                          if( ajj<=dstop.or.stdlib_${ri}$isnan( ajj ) ) then
                             a( j, j ) = ajj
                             go to 190
                          end if
                       end if
                       if( j/=pvt ) then
                          ! pivot ok, so can now swap pivot rows and columns
                          a( pvt, pvt ) = a( j, j )
                          call stdlib_${ri}$swap( j-1, a( 1, j ), 1, a( 1, pvt ), 1 )
                          if( pvt<n )call stdlib_${ri}$swap( n-pvt, a( j, pvt+1 ), lda,a( pvt, pvt+1 ),&
                                     lda )
                          call stdlib_${ri}$swap( pvt-j-1, a( j, j+1 ), lda,a( j+1, pvt ), 1 )
                          ! swap dot products and piv
                          dtemp = work( j )
                          work( j ) = work( pvt )
                          work( pvt ) = dtemp
                          itemp = piv( pvt )
                          piv( pvt ) = piv( j )
                          piv( j ) = itemp
                       end if
                       ajj = sqrt( ajj )
                       a( j, j ) = ajj
                       ! compute elements j+1:n of row j.
                       if( j<n ) then
                          call stdlib_${ri}$gemv( 'TRANS', j-k, n-j, -one, a( k, j+1 ),lda, a( k, j ), &
                                    1, one, a( j, j+1 ),lda )
                          call stdlib_${ri}$scal( n-j, one / ajj, a( j, j+1 ), lda )
                       end if
                    end do loop_130
                    ! update trailing matrix, j already incremented
                    if( k+jb<=n ) then
                       call stdlib_${ri}$syrk( 'UPPER', 'TRANS', n-j+1, jb, -one,a( k, j ), lda, one, &
                                 a( j, j ), lda )
                    end if
                 end do loop_140
              else
              ! compute the cholesky factorization p**t * a * p = l * l**t
                 loop_180: do k = 1, n, nb
                    ! account for last block not being nb wide
                    jb = min( nb, n-k+1 )
                    ! set relevant part of first half of work to zero,
                    ! holds dot products
                    do i = k, n
                       work( i ) = 0
                    end do
                    loop_170: do j = k, k + jb - 1
                    ! find pivot, test for exit, else swap rows and columns
                    ! update dot products, compute possible pivots which are
                    ! stored in the second half of work
                       do i = j, n
                          if( j>k ) then
                             work( i ) = work( i ) + a( i, j-1 )**2
                          end if
                          work( n+i ) = a( i, i ) - work( i )
                       end do
                       if( j>1 ) then
                          itemp = maxloc( work( (n+j):(2*n) ), 1 )
                          pvt = itemp + j - 1
                          ajj = work( n+pvt )
                          if( ajj<=dstop.or.stdlib_${ri}$isnan( ajj ) ) then
                             a( j, j ) = ajj
                             go to 190
                          end if
                       end if
                       if( j/=pvt ) then
                          ! pivot ok, so can now swap pivot rows and columns
                          a( pvt, pvt ) = a( j, j )
                          call stdlib_${ri}$swap( j-1, a( j, 1 ), lda, a( pvt, 1 ), lda )
                          if( pvt<n )call stdlib_${ri}$swap( n-pvt, a( pvt+1, j ), 1,a( pvt+1, pvt ), &
                                    1 )
                          call stdlib_${ri}$swap( pvt-j-1, a( j+1, j ), 1, a( pvt, j+1 ),lda )
                          ! swap dot products and piv
                          dtemp = work( j )
                          work( j ) = work( pvt )
                          work( pvt ) = dtemp
                          itemp = piv( pvt )
                          piv( pvt ) = piv( j )
                          piv( j ) = itemp
                       end if
                       ajj = sqrt( ajj )
                       a( j, j ) = ajj
                       ! compute elements j+1:n of column j.
                       if( j<n ) then
                          call stdlib_${ri}$gemv( 'NO TRANS', n-j, j-k, -one,a( j+1, k ), lda, a( j, k &
                                    ), lda, one,a( j+1, j ), 1 )
                          call stdlib_${ri}$scal( n-j, one / ajj, a( j+1, j ), 1 )
                       end if
                    end do loop_170
                    ! update trailing matrix, j already incremented
                    if( k+jb<=n ) then
                       call stdlib_${ri}$syrk( 'LOWER', 'NO TRANS', n-j+1, jb, -one,a( j, k ), lda, &
                                 one, a( j, j ), lda )
                    end if
                 end do loop_180
              end if
           end if
           ! ran to completion, a has full rank
           rank = n
           go to 200
           190 continue
           ! rank is the number of steps completed.  set info = 1 to signal
           ! that the factorization cannot be used to solve a system.
           rank = j - 1
           info = 1
           200 continue
           return
     end subroutine stdlib_${ri}$pstrf


     pure subroutine stdlib_${ri}$ptcon( n, d, e, anorm, rcond, work, info )
     !! DPTCON: computes the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric positive definite tridiagonal matrix
     !! using the factorization A = L*D*L**T or A = U**T*D*U computed by
     !! DPTTRF.
     !! Norm(inv(A)) is computed by a direct method, and the reciprocal of
     !! the condition number is computed as
     !! RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ix
           real(${rk}$) :: ainvnm
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           if( n<0 ) then
              info = -1
           else if( anorm<zero ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           ! check that d(1:n) is positive.
           do i = 1, n
              if( d( i )<=zero )return
           end do
           ! solve m(a) * x = e, where m(a) = (m(i,j)) is given by
              ! m(i,j) =  abs(a(i,j)), i = j,
              ! m(i,j) = -abs(a(i,j)), i .ne. j,
           ! and e = [ 1, 1, ..., 1 ]**t.  note m(a) = m(l)*d*m(l)**t.
           ! solve m(l) * x = e.
           work( 1 ) = one
           do i = 2, n
              work( i ) = one + work( i-1 )*abs( e( i-1 ) )
           end do
           ! solve d * m(l)**t * x = b.
           work( n ) = work( n ) / d( n )
           do i = n - 1, 1, -1
              work( i ) = work( i ) / d( i ) + work( i+1 )*abs( e( i ) )
           end do
           ! compute ainvnm = max(x(i)), 1<=i<=n.
           ix = stdlib_i${ri}$amax( n, work, 1 )
           ainvnm = abs( work( ix ) )
           ! compute the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$ptcon


     pure subroutine stdlib_${ri}$pteqr( compz, n, d, e, z, ldz, work, info )
     !! DPTEQR: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using DPTTRF, and then calling DBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band symmetric positive definite matrix
     !! can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to
     !! reduce this matrix to tridiagonal form. (The reduction to tridiagonal
     !! form, however, may preclude the possibility of obtaining high
     !! relative accuracy in the small eigenvalues of the original matrix, if
     !! these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Arrays 
           real(${rk}$) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = one
              return
           end if
           if( icompz==2 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! call stdlib_${ri}$pttrf to factor the matrix.
           call stdlib_${ri}$pttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_${ri}$bdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_${ri}$bdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_${ri}$pteqr


     pure subroutine stdlib_${ri}$ptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, info )
     !! DPTRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric positive definite
     !! and tridiagonal, and provides error bounds and backward error
     !! estimates for the solution.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(ldb,*), d(*), df(*), e(*), ef(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: count, i, ix, j, nz
           real(${rk}$) :: bi, cx, dx, eps, ex, lstres, s, safe1, safe2, safmin
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = 4
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_90: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x.  also compute
              ! abs(a)*abs(x) + abs(b) for use in the backward error bound.
              if( n==1 ) then
                 bi = b( 1, j )
                 dx = d( 1 )*x( 1, j )
                 work( n+1 ) = bi - dx
                 work( 1 ) = abs( bi ) + abs( dx )
              else
                 bi = b( 1, j )
                 dx = d( 1 )*x( 1, j )
                 ex = e( 1 )*x( 2, j )
                 work( n+1 ) = bi - dx - ex
                 work( 1 ) = abs( bi ) + abs( dx ) + abs( ex )
                 do i = 2, n - 1
                    bi = b( i, j )
                    cx = e( i-1 )*x( i-1, j )
                    dx = d( i )*x( i, j )
                    ex = e( i )*x( i+1, j )
                    work( n+i ) = bi - cx - dx - ex
                    work( i ) = abs( bi ) + abs( cx ) + abs( dx ) + abs( ex )
                 end do
                 bi = b( n, j )
                 cx = e( n-1 )*x( n-1, j )
                 dx = d( n )*x( n, j )
                 work( n+n ) = bi - cx - dx
                 work( n ) = abs( bi ) + abs( cx ) + abs( dx )
              end if
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$pttrs( n, 1, df, ef, work( n+1 ), n, info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              ix = stdlib_i${ri}$amax( n, work, 1 )
              ferr( j ) = work( ix )
              ! estimate the norm of inv(a).
              ! solve m(a) * x = e, where m(a) = (m(i,j)) is given by
                 ! m(i,j) =  abs(a(i,j)), i = j,
                 ! m(i,j) = -abs(a(i,j)), i .ne. j,
              ! and e = [ 1, 1, ..., 1 ]**t.  note m(a) = m(l)*d*m(l)**t.
              ! solve m(l) * x = e.
              work( 1 ) = one
              do i = 2, n
                 work( i ) = one + work( i-1 )*abs( ef( i-1 ) )
              end do
              ! solve d * m(l)**t * x = b.
              work( n ) = work( n ) / df( n )
              do i = n - 1, 1, -1
                 work( i ) = work( i ) / df( i ) + work( i+1 )*abs( ef( i ) )
              end do
              ! compute norm(inv(a)) = max(x(i)), 1<=i<=n.
              ix = stdlib_i${ri}$amax( n, work, 1 )
              ferr( j ) = ferr( j )*abs( work( ix ) )
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_90
           return
     end subroutine stdlib_${ri}$ptrfs


     pure subroutine stdlib_${ri}$ptsv( n, nrhs, d, e, b, ldb, info )
     !! DPTSV: computes the solution to a real system of linear equations
     !! A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**T, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: b(ldb,*), d(*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTSV ', -info )
              return
           end if
           ! compute the l*d*l**t (or u**t*d*u) factorization of a.
           call stdlib_${ri}$pttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$pttrs( n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$ptsv


     pure subroutine stdlib_${ri}$ptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! DPTSVX: uses the factorization A = L*D*L**T to compute the solution
     !! to a real system of linear equations A*X = B, where A is an N-by-N
     !! symmetric positive definite tridiagonal matrix and X and B are
     !! N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(ldb,*), d(*), e(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
           real(${rk}$), intent(inout) :: df(*), ef(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**t (or u**t*d*u) factorization of a.
              call stdlib_${ri}$copy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_${ri}$copy( n-1, e, 1, ef, 1 )
              call stdlib_${ri}$pttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lanst( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$ptcon( n, df, ef, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$pttrs( n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$ptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr,work, info )
                     
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$ptsvx


     pure subroutine stdlib_${ri}$pttrf( n, d, e, info )
     !! DPTTRF: computes the L*D*L**T factorization of a real symmetric
     !! positive definite tridiagonal matrix A.  The factorization may also
     !! be regarded as having the form A = U**T*D*U.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i4
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DPTTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the l*d*l**t (or u**t*d*u) factorization of a.
           i4 = mod( n-1, 4 )
           do i = 1, i4
              if( d( i )<=zero ) then
                 info = i
                 go to 30
              end if
              ei = e( i )
              e( i ) = ei / d( i )
              d( i+1 ) = d( i+1 ) - e( i )*ei
           end do
           loop_20: do i = i4 + 1, n - 4, 4
              ! drop out of the loop if d(i) <= 0: the matrix is not positive
              ! definite.
              if( d( i )<=zero ) then
                 info = i
                 go to 30
              end if
              ! solve for e(i) and d(i+1).
              ei = e( i )
              e( i ) = ei / d( i )
              d( i+1 ) = d( i+1 ) - e( i )*ei
              if( d( i+1 )<=zero ) then
                 info = i + 1
                 go to 30
              end if
              ! solve for e(i+1) and d(i+2).
              ei = e( i+1 )
              e( i+1 ) = ei / d( i+1 )
              d( i+2 ) = d( i+2 ) - e( i+1 )*ei
              if( d( i+2 )<=zero ) then
                 info = i + 2
                 go to 30
              end if
              ! solve for e(i+2) and d(i+3).
              ei = e( i+2 )
              e( i+2 ) = ei / d( i+2 )
              d( i+3 ) = d( i+3 ) - e( i+2 )*ei
              if( d( i+3 )<=zero ) then
                 info = i + 3
                 go to 30
              end if
              ! solve for e(i+3) and d(i+4).
              ei = e( i+3 )
              e( i+3 ) = ei / d( i+3 )
              d( i+4 ) = d( i+4 ) - e( i+3 )*ei
           end do loop_20
           ! check d(n) for positive definiteness.
           if( d( n )<=zero )info = n
           30 continue
           return
     end subroutine stdlib_${ri}$pttrf


     pure subroutine stdlib_${ri}$pttrs( n, nrhs, d, e, b, ldb, info )
     !! DPTTRS: solves a tridiagonal system of the form
     !! A * X = B
     !! using the L*D*L**T factorization of A computed by DPTTRF.  D is a
     !! diagonal matrix specified in the vector D, L is a unit bidiagonal
     !! matrix whose subdiagonal is specified in the vector E, and X and B
     !! are N by NRHS matrices.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(in) :: d(*), e(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! determine the number of right-hand sides to solve at a time.
           if( nrhs==1 ) then
              nb = 1
           else
              nb = max( 1, stdlib_ilaenv( 1, 'DPTTRS', ' ', n, nrhs, -1, -1 ) )
           end if
           if( nb>=nrhs ) then
              call stdlib_${ri}$ptts2( n, nrhs, d, e, b, ldb )
           else
              do j = 1, nrhs, nb
                 jb = min( nrhs-j+1, nb )
                 call stdlib_${ri}$ptts2( n, jb, d, e, b( 1, j ), ldb )
              end do
           end if
           return
     end subroutine stdlib_${ri}$pttrs


     pure subroutine stdlib_${ri}$ptts2( n, nrhs, d, e, b, ldb )
     !! DPTTS2: solves a tridiagonal system of the form
     !! A * X = B
     !! using the L*D*L**T factorization of A computed by DPTTRF.  D is a
     !! diagonal matrix specified in the vector D, L is a unit bidiagonal
     !! matrix whose subdiagonal is specified in the vector E, and X and B
     !! are N by NRHS matrices.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(in) :: d(*), e(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 ) then
              if( n==1 )call stdlib_${ri}$scal( nrhs, 1._${rk}$ / d( 1 ), b, ldb )
              return
           end if
           ! solve a * x = b using the factorization a = l*d*l**t,
           ! overwriting each right hand side vector with its solution.
           do j = 1, nrhs
                 ! solve l * x = b.
              do i = 2, n
                 b( i, j ) = b( i, j ) - b( i-1, j )*e( i-1 )
              end do
                 ! solve d * l**t * x = b.
              b( n, j ) = b( n, j ) / d( n )
              do i = n - 1, 1, -1
                 b( i, j ) = b( i, j ) / d( i ) - b( i+1, j )*e( i )
              end do
           end do
           return
     end subroutine stdlib_${ri}$ptts2


     pure subroutine stdlib_${ri}$rscl( n, sa, sx, incx )
     !! DRSCL: multiplies an n-element real vector x by the real scalar 1/a.
     !! This is done without overflow or underflow as long as
     !! the final result x/a does not overflow or underflow.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           real(${rk}$), intent(in) :: sa
           ! Array Arguments 
           real(${rk}$), intent(inout) :: sx(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: done
           real(${rk}$) :: bignum, cden, cden1, cnum, cnum1, mul, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           ! get machine parameters
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ! initialize the denominator to sa and the numerator to 1.
           cden = sa
           cnum = one
           10 continue
           cden1 = cden*smlnum
           cnum1 = cnum / bignum
           if( abs( cden1 )>abs( cnum ) .and. cnum/=zero ) then
              ! pre-multiply x by smlnum if cden is large compared to cnum.
              mul = smlnum
              done = .false.
              cden = cden1
           else if( abs( cnum1 )>abs( cden ) ) then
              ! pre-multiply x by bignum if cden is small compared to cnum.
              mul = bignum
              done = .false.
              cnum = cnum1
           else
              ! multiply x by cnum / cden and return.
              mul = cnum / cden
              done = .true.
           end if
           ! scale the vector x by mul
           call stdlib_${ri}$scal( n, mul, sx, incx )
           if( .not.done )go to 10
           return
     end subroutine stdlib_${ri}$rscl


     pure subroutine  stdlib_${ri}$sb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! DSB2ST_KERNELS: is an internal routine used by the DSYTRD_SB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           real(${rk}$) :: ctmp
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = ( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = zero
                   end do
                   ctmp = ( a( ofdpos, st ) )
                   call stdlib_${ri}$larfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_${ri}$larfx( 'LEFT', ln, lm, v( vpos ),( tau( taupos ) ),a( dpos-nb,&
                                  j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )          =( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = zero
                       end do
                       ctmp = ( a( dpos-nb, j1 ) )
                       call stdlib_${ri}$larfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_${ri}$larfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = zero
                   end do
                   call stdlib_${ri}$larfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_${ri}$larfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = zero
                       end do
                       call stdlib_${ri}$larfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_${ri}$larfx( 'LEFT', lm, ln-1, v( vpos ),( tau( taupos ) ),a( dpos+&
                                 nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_${ri}$sb2st_kernels


     subroutine stdlib_${ri}$sbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
     !! DSBEV: computes all the eigenvalues and, optionally, eigenvectors of
     !! a real symmetric band matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, wantz
           integer(ilp) :: iinfo, imax, inde, indwrk, iscale
           real(${rk}$) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( lower ) then
                 w( 1 ) = ab( 1, 1 )
              else
                 w( 1 ) = ab( kd+1, 1 )
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_${ri}$lansb( 'M', uplo, n, kd, ab, ldab, work )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 call stdlib_${ri}$lascl( 'B', kd, kd, one, sigma, n, n, ab, ldab, info )
              else
                 call stdlib_${ri}$lascl( 'Q', kd, kd, one, sigma, n, n, ab, ldab, info )
              end if
           end if
           ! call stdlib_${ri}$sbtrd to reduce symmetric band matrix to tridiagonal form.
           inde = 1
           indwrk = inde + n
           call stdlib_${ri}$sbtrd( jobz, uplo, n, kd, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, call stdlib_dsteqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$steqr( jobz, n, w, work( inde ), z, ldz, work( indwrk ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           return
     end subroutine stdlib_${ri}$sbev


     subroutine stdlib_${ri}$sbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, liwork, &
     !! DSBEVD: computes all the eigenvalues and, optionally, eigenvectors of
     !! a real symmetric band matrix A. If eigenvectors are desired, it uses
     !! a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, lquery, wantz
           integer(ilp) :: iinfo, inde, indwk2, indwrk, iscale, liwmin, llwrk2, lwmin
           real(${rk}$) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              liwmin = 1
              lwmin = 1
           else
              if( wantz ) then
                 liwmin = 3 + 5*n
                 lwmin = 1 + 5*n + 2*n**2
              else
                 liwmin = 1
                 lwmin = 2*n
              end if
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -11
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = ab( 1, 1 )
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_${ri}$lansb( 'M', uplo, n, kd, ab, ldab, work )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 call stdlib_${ri}$lascl( 'B', kd, kd, one, sigma, n, n, ab, ldab, info )
              else
                 call stdlib_${ri}$lascl( 'Q', kd, kd, one, sigma, n, n, ab, ldab, info )
              end if
           end if
           ! call stdlib_${ri}$sbtrd to reduce symmetric band matrix to tridiagonal form.
           inde = 1
           indwrk = inde + n
           indwk2 = indwrk + n*n
           llwrk2 = lwork - indwk2 + 1
           call stdlib_${ri}$sbtrd( jobz, uplo, n, kd, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, call stdlib_dstedc.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$stedc( 'I', n, w, work( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, iwork, liwork, info )
              call stdlib_${ri}$gemm( 'N', 'N', n, n, n, one, z, ldz, work( indwrk ), n,zero, work( &
                        indwk2 ), n )
              call stdlib_${ri}$lacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_${ri}$scal( n, one / sigma, w, 1 )
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$sbevd


     subroutine stdlib_${ri}$sbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
     !! DSBEVX: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric band matrix A.  Eigenvalues and eigenvectors can
     !! be selected by specifying either a range of values or a range of
     !! indices for the desired eigenvalues.
               m, w, z, ldz, work, iwork,ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lower, test, valeig, wantz
           character :: order
           integer(ilp) :: i, iinfo, imax, indd, inde, indee, indibl, indisp, indiwo, indwrk, &
                     iscale, itmp1, j, jj, nsplit
           real(${rk}$) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lower = stdlib_lsame( uplo, 'L' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( ldab<kd+1 ) then
              info = -7
           else if( wantz .and. ldq<max( 1, n ) ) then
              info = -9
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -11
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -12
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -13
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              m = 1
              if( lower ) then
                 tmp1 = ab( 1, 1 )
              else
                 tmp1 = ab( kd+1, 1 )
              end if
              if( valeig ) then
                 if( .not.( vl<tmp1 .and. vu>=tmp1 ) )m = 0
              end if
              if( m==1 ) then
                 w( 1 ) = tmp1
                 if( wantz )z( 1, 1 ) = one
              end if
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           end if
           anrm = stdlib_${ri}$lansb( 'M', uplo, n, kd, ab, ldab, work )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 call stdlib_${ri}$lascl( 'B', kd, kd, one, sigma, n, n, ab, ldab, info )
              else
                 call stdlib_${ri}$lascl( 'Q', kd, kd, one, sigma, n, n, ab, ldab, info )
              end if
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! call stdlib_${ri}$sbtrd to reduce symmetric band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indwrk = inde + n
           call stdlib_${ri}$sbtrd( jobz, uplo, n, kd, ab, ldab, work( indd ),work( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_${ri}$sterf or stdlib_dsteqr.  if this fails for some
           ! eigenvalue, then try stdlib_${ri}$stebz.
           test = .false.
           if (indeig) then
              if (il==1 .and. iu==n) then
                 test = .true.
              end if
           end if
           if ((alleig .or. test) .and. (abstol<=zero)) then
              call stdlib_${ri}$copy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              if( .not.wantz ) then
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$sterf( n, w, work( indee ), info )
              else
                 call stdlib_${ri}$lacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$steqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstll,work( indd ), work( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info &
                     )
           if( wantz ) then
              call stdlib_${ri}$stein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply orthogonal matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stein.
              do j = 1, m
                 call stdlib_${ri}$copy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_${ri}$gemv( 'N', n, n, one, q, ldq, work, 1, zero,z( 1, j ), 1 )
              end do
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           30 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$sbevx


     pure subroutine stdlib_${ri}$sbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, info )
     !! DSBGST: reduces a real symmetric-definite banded generalized
     !! eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
     !! such that C has the same bandwidth as A.
     !! B must have been previously factorized as S**T*S by DPBSTF, using a
     !! split Cholesky factorization. A is overwritten by C = X**T*A*X, where
     !! X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
     !! bandwidth of A.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(in) :: bb(ldbb,*)
           real(${rk}$), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: update, upper, wantx
           integer(ilp) :: i, i0, i1, i2, inca, j, j1, j1t, j2, j2t, k, ka1, kb1, kbt, l, m, nr, &
                     nrt, nx
           real(${rk}$) :: bii, ra, ra1, t
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           wantx = stdlib_lsame( vect, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           ka1 = ka + 1
           kb1 = kb + 1
           info = 0
           if( .not.wantx .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldx<1 .or. wantx .and. ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGST', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           inca = ldab*ka1
           ! initialize x to the unit matrix, if needed
           if( wantx )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, x, ldx )
           ! set m to the splitting point m. it must be the same value as is
           ! used in stdlib_${ri}$pbstf. the chosen value allows the arrays work and rwork
           ! to be of dimension (n).
           m = ( n+kb ) / 2
           ! the routine works in two phases, corresponding to the two halves
           ! of the split cholesky factorization of b as s**t*s where
           ! s = ( u    )
               ! ( m  l )
           ! with u upper triangular of order m, and l lower triangular of
           ! order n-m. s has the same bandwidth as b.
           ! s is treated as a product of elementary matrices:
           ! s = s(m)*s(m-1)*...*s(2)*s(1)*s(m+1)*s(m+2)*...*s(n-1)*s(n)
           ! where s(i) is determined by the i-th row of s.
           ! in phase 1, the index i takes the values n, n-1, ... , m+1;
           ! in phase 2, it takes the values 1, 2, ... , m.
           ! for each value of i, the current matrix a is updated by forming
           ! inv(s(i))**t*a*inv(s(i)). this creates a triangular bulge outside
           ! the band of a. the bulge is then pushed down toward the bottom of
           ! a in phase 1, and up toward the top of a in phase 2, by applying
           ! plane rotations.
           ! there are kb*(kb+1)/2 elements in the bulge, but at most 2*kb-1
           ! of them are linearly independent, so annihilating a bulge requires
           ! only 2*kb-1 plane rotations. the rotations are divided into a 1st
           ! set of kb-1 rotations, and a 2nd set of kb rotations.
           ! wherever possible, rotations are generated and applied in vector
           ! operations of length nr between the indices j1 and j2 (sometimes
           ! replaced by modified values nrt, j1t or j2t).
           ! the cosines and sines of the rotations are stored in the array
           ! work. the cosines of the 1st set of rotations are stored in
           ! elements n+2:n+m-kb-1 and the sines of the 1st set in elements
           ! 2:m-kb-1; the cosines of the 2nd set are stored in elements
           ! n+m-kb+1:2*n and the sines of the second set in elements m-kb+1:n.
           ! the bulges are not formed explicitly; nonzero elements outside the
           ! band are created only when they are required for generating new
           ! rotations; they are stored in the array work, in positions where
           ! they are later overwritten by the sines of the rotations which
           ! annihilate them.
           ! **************************** phase 1 *****************************
           ! the logical structure of this phase is:
           ! update = .true.
           ! do i = n, m + 1, -1
              ! use s(i) to update a and create a new bulge
              ! apply rotations to push all bulges ka positions downward
           ! end do
           ! update = .false.
           ! do i = m + ka + 1, n - 1
              ! apply rotations to push all bulges ka positions downward
           ! end do
           ! to avoid duplicating code, the two loops are merged.
           update = .true.
           i = n + 1
           10 continue
           if( update ) then
              i = i - 1
              kbt = min( kb, i-1 )
              i0 = i - 1
              i1 = min( n, i+ka )
              i2 = i - kbt + ka1
              if( i<m+1 ) then
                 update = .false.
                 i = i + 1
                 i0 = m
                 if( ka==0 )go to 480
                 go to 10
              end if
           else
              i = i + ka
              if( i>n-1 )go to 480
           end if
           if( upper ) then
              ! transform a, working with the upper triangle
              if( update ) then
                 ! form  inv(s(i))**t * a * inv(s(i))
                 bii = bb( kb1, i )
                 do j = i, i1
                    ab( i-j+ka1, j ) = ab( i-j+ka1, j ) / bii
                 end do
                 do j = max( 1, i-ka ), i
                    ab( j-i+ka1, i ) = ab( j-i+ka1, i ) / bii
                 end do
                 do k = i - kbt, i - 1
                    do j = i - kbt, k
                       ab( j-k+ka1, k ) = ab( j-k+ka1, k ) -bb( j-i+kb1, i )*ab( k-i+ka1, i ) -bb(&
                        k-i+kb1, i )*ab( j-i+ka1, i ) +ab( ka1, i )*bb( j-i+kb1, i )*bb( k-i+kb1, &
                                  i )
                    end do
                    do j = max( 1, i-ka ), i - kbt - 1
                       ab( j-k+ka1, k ) = ab( j-k+ka1, k ) -bb( k-i+kb1, i )*ab( j-i+ka1, i )
                                 
                    end do
                 end do
                 do j = i, i1
                    do k = max( j-ka, i-kbt ), i - 1
                       ab( k-j+ka1, j ) = ab( k-j+ka1, j ) -bb( k-i+kb1, i )*ab( i-j+ka1, j )
                                 
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_${ri}$scal( n-m, one / bii, x( m+1, i ), 1 )
                    if( kbt>0 )call stdlib_${ri}$ger( n-m, kbt, -one, x( m+1, i ), 1,bb( kb1-kbt, i ), &
                              1, x( m+1, i-kbt ), ldx )
                 end if
                 ! store a(i,i1) in ra1 for use in next loop over k
                 ra1 = ab( i-i1+ka1, i1 )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions down toward the bottom of the
              ! band
              loop_130: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i-k+ka<n .and. i-k>1 ) then
                       ! generate rotation to annihilate a(i,i-k+ka+1)
                       call stdlib_${ri}$lartg( ab( k+1, i-k+ka ), ra1,work( n+i-k+ka-m ), work( i-k+&
                                 ka-m ),ra )
                       ! create nonzero element a(i-k,i-k+ka+1) outside the
                       ! band and store it in work(i-k)
                       t = -bb( kb1-k, i )*ra1
                       work( i-k ) = work( n+i-k+ka-m )*t -work( i-k+ka-m )*ab( 1, i-k+ka )
                                 
                       ab( 1, i-k+ka ) = work( i-k+ka-m )*t +work( n+i-k+ka-m )*ab( 1, i-k+ka )
                                 
                       ra1 = ra
                    end if
                 end if
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( update ) then
                    j2t = max( j2, i+2*ka-k+1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( n-j2t+ka ) / ka1
                 do j = j2t, j1, ka1
                    ! create nonzero element a(j-ka,j+1) outside the band
                    ! and store it in work(j-m)
                    work( j-m ) = work( j-m )*ab( 1, j+1 )
                    ab( 1, j+1 ) = work( n+j-m )*ab( 1, j+1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_${ri}$largv( nrt, ab( 1, j2t ), inca, work( j2t-m ), ka1,work( &
                           n+j2t-m ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the right
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( ka1-l, j2 ), inca,ab( ka-l, j2+1 ), inca, work(&
                                  n+j2-m ),work( j2-m ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( ka1, j2 ), ab( ka1, j2+1 ),ab( ka, j2+1 ), inca, &
                              work( n+j2-m ),work( j2-m ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j2+ka1-l ), inca,ab( l+1, j2+ka1-l &
                              ), inca,work( n+j2-m ), work( j2-m ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j2, j1, ka1
                       call stdlib_${ri}$rot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,work( n+j-m ), &
                                 work( j-m ) )
                    end do
                 end if
              end do loop_130
              if( update ) then
                 if( i2<=n .and. kbt>0 ) then
                    ! create nonzero element a(i-kbt,i-kbt+ka+1) outside the
                    ! band and store it in work(i-kbt)
                    work( i-kbt ) = -bb( kb1-kbt, i )*ra1
                 end if
              end if
              loop_170: do k = kb, 1, -1
                 if( update ) then
                    j2 = i - k - 1 + max( 2, k-i0+1 )*ka1
                 else
                    j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the left
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+ka+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j2-l+1 ), inca,ab( l+1, j2-l+1 ), &
                              inca, work( n+j2-ka ),work( j2-ka ), ka1 )
                 end do
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 do j = j1, j2, -ka1
                    work( j ) = work( j-ka )
                    work( n+j ) = work( n+j-ka )
                 end do
                 do j = j2, j1, ka1
                    ! create nonzero element a(j-ka,j+1) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( 1, j+1 )
                    ab( 1, j+1 ) = work( n+j )*ab( 1, j+1 )
                 end do
                 if( update ) then
                    if( i-k<n-ka .and. k<=kbt )work( i-k+ka ) = work( i-k )
                 end if
              end do loop_170
              loop_210: do k = kb, 1, -1
                 j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_${ri}$largv( nr, ab( 1, j2 ), inca, work( j2 ), ka1,work( n+j2 ), ka1 )
                              
                    ! apply rotations in 2nd set from the right
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( ka1-l, j2 ), inca,ab( ka-l, j2+1 ), inca, work(&
                                  n+j2 ),work( j2 ), ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( ka1, j2 ), ab( ka1, j2+1 ),ab( ka, j2+1 ), inca, &
                              work( n+j2 ),work( j2 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j2+ka1-l ), inca,ab( l+1, j2+ka1-l &
                              ), inca, work( n+j2 ),work( j2 ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j2, j1, ka1
                       call stdlib_${ri}$rot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,work( n+j ), work( &
                                 j ) )
                    end do
                 end if
              end do loop_210
              do k = 1, kb - 1
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 ! finish applying rotations in 1st set from the left
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j2+ka1-l ), inca,ab( l+1, j2+ka1-l &
                              ), inca,work( n+j2-m ), work( j2-m ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = n - 1, i - kb + 2*ka + 1, -1
                    work( n+j-m ) = work( n+j-ka-m )
                    work( j-m ) = work( j-ka-m )
                 end do
              end if
           else
              ! transform a, working with the lower triangle
              if( update ) then
                 ! form  inv(s(i))**t * a * inv(s(i))
                 bii = bb( 1, i )
                 do j = i, i1
                    ab( j-i+1, i ) = ab( j-i+1, i ) / bii
                 end do
                 do j = max( 1, i-ka ), i
                    ab( i-j+1, j ) = ab( i-j+1, j ) / bii
                 end do
                 do k = i - kbt, i - 1
                    do j = i - kbt, k
                       ab( k-j+1, j ) = ab( k-j+1, j ) -bb( i-j+1, j )*ab( i-k+1, k ) -bb( i-k+1, &
                                 k )*ab( i-j+1, j ) +ab( 1, i )*bb( i-j+1, j )*bb( i-k+1, k )
                    end do
                    do j = max( 1, i-ka ), i - kbt - 1
                       ab( k-j+1, j ) = ab( k-j+1, j ) -bb( i-k+1, k )*ab( i-j+1, j )
                    end do
                 end do
                 do j = i, i1
                    do k = max( j-ka, i-kbt ), i - 1
                       ab( j-k+1, k ) = ab( j-k+1, k ) -bb( i-k+1, k )*ab( j-i+1, i )
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_${ri}$scal( n-m, one / bii, x( m+1, i ), 1 )
                    if( kbt>0 )call stdlib_${ri}$ger( n-m, kbt, -one, x( m+1, i ), 1,bb( kbt+1, i-kbt )&
                              , ldbb-1,x( m+1, i-kbt ), ldx )
                 end if
                 ! store a(i1,i) in ra1 for use in next loop over k
                 ra1 = ab( i1-i+1, i )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions down toward the bottom of the
              ! band
              loop_360: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i-k+ka<n .and. i-k>1 ) then
                       ! generate rotation to annihilate a(i-k+ka+1,i)
                       call stdlib_${ri}$lartg( ab( ka1-k, i ), ra1, work( n+i-k+ka-m ),work( i-k+ka-m &
                                 ), ra )
                       ! create nonzero element a(i-k+ka+1,i-k) outside the
                       ! band and store it in work(i-k)
                       t = -bb( k+1, i-k )*ra1
                       work( i-k ) = work( n+i-k+ka-m )*t -work( i-k+ka-m )*ab( ka1, i-k )
                       ab( ka1, i-k ) = work( i-k+ka-m )*t +work( n+i-k+ka-m )*ab( ka1, i-k )
                                 
                       ra1 = ra
                    end if
                 end if
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( update ) then
                    j2t = max( j2, i+2*ka-k+1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( n-j2t+ka ) / ka1
                 do j = j2t, j1, ka1
                    ! create nonzero element a(j+1,j-ka) outside the band
                    ! and store it in work(j-m)
                    work( j-m ) = work( j-m )*ab( ka1, j-ka+1 )
                    ab( ka1, j-ka+1 ) = work( n+j-m )*ab( ka1, j-ka+1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_${ri}$largv( nrt, ab( ka1, j2t-ka ), inca, work( j2t-m ),ka1, &
                           work( n+j2t-m ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the left
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( l+1, j2-l ), inca,ab( l+2, j2-l ), inca, work( &
                                 n+j2-m ),work( j2-m ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( 1, j2 ), ab( 1, j2+1 ), ab( 2, j2 ),inca, work( n+&
                              j2-m ), work( j2-m ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j2 ), inca,ab( ka1-l, j2+1 ),&
                               inca, work( n+j2-m ),work( j2-m ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j2, j1, ka1
                       call stdlib_${ri}$rot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,work( n+j-m ), &
                                 work( j-m ) )
                    end do
                 end if
              end do loop_360
              if( update ) then
                 if( i2<=n .and. kbt>0 ) then
                    ! create nonzero element a(i-kbt+ka+1,i-kbt) outside the
                    ! band and store it in work(i-kbt)
                    work( i-kbt ) = -bb( kbt+1, i-kbt )*ra1
                 end if
              end if
              loop_400: do k = kb, 1, -1
                 if( update ) then
                    j2 = i - k - 1 + max( 2, k-i0+1 )*ka1
                 else
                    j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the right
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+ka+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j2-ka ), inca,ab( ka1-l, j2-&
                              ka+1 ), inca,work( n+j2-ka ), work( j2-ka ), ka1 )
                 end do
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 do j = j1, j2, -ka1
                    work( j ) = work( j-ka )
                    work( n+j ) = work( n+j-ka )
                 end do
                 do j = j2, j1, ka1
                    ! create nonzero element a(j+1,j-ka) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( ka1, j-ka+1 )
                    ab( ka1, j-ka+1 ) = work( n+j )*ab( ka1, j-ka+1 )
                 end do
                 if( update ) then
                    if( i-k<n-ka .and. k<=kbt )work( i-k+ka ) = work( i-k )
                 end if
              end do loop_400
              loop_440: do k = kb, 1, -1
                 j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_${ri}$largv( nr, ab( ka1, j2-ka ), inca, work( j2 ), ka1,work( n+j2 ), &
                              ka1 )
                    ! apply rotations in 2nd set from the left
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( l+1, j2-l ), inca,ab( l+2, j2-l ), inca, work( &
                                 n+j2 ),work( j2 ), ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( 1, j2 ), ab( 1, j2+1 ), ab( 2, j2 ),inca, work( n+&
                              j2 ), work( j2 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j2 ), inca,ab( ka1-l, j2+1 ),&
                               inca, work( n+j2 ),work( j2 ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j2, j1, ka1
                       call stdlib_${ri}$rot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,work( n+j ), work( &
                                 j ) )
                    end do
                 end if
              end do loop_440
              do k = 1, kb - 1
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 ! finish applying rotations in 1st set from the right
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j2 ), inca,ab( ka1-l, j2+1 ),&
                               inca, work( n+j2-m ),work( j2-m ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = n - 1, i - kb + 2*ka + 1, -1
                    work( n+j-m ) = work( n+j-ka-m )
                    work( j-m ) = work( j-ka-m )
                 end do
              end if
           end if
           go to 10
           480 continue
           ! **************************** phase 2 *****************************
           ! the logical structure of this phase is:
           ! update = .true.
           ! do i = 1, m
              ! use s(i) to update a and create a new bulge
              ! apply rotations to push all bulges ka positions upward
           ! end do
           ! update = .false.
           ! do i = m - ka - 1, 2, -1
              ! apply rotations to push all bulges ka positions upward
           ! end do
           ! to avoid duplicating code, the two loops are merged.
           update = .true.
           i = 0
           490 continue
           if( update ) then
              i = i + 1
              kbt = min( kb, m-i )
              i0 = i + 1
              i1 = max( 1, i-ka )
              i2 = i + kbt - ka1
              if( i>m ) then
                 update = .false.
                 i = i - 1
                 i0 = m + 1
                 if( ka==0 )return
                 go to 490
              end if
           else
              i = i - ka
              if( i<2 )return
           end if
           if( i<m-kbt ) then
              nx = m
           else
              nx = n
           end if
           if( upper ) then
              ! transform a, working with the upper triangle
              if( update ) then
                 ! form  inv(s(i))**t * a * inv(s(i))
                 bii = bb( kb1, i )
                 do j = i1, i
                    ab( j-i+ka1, i ) = ab( j-i+ka1, i ) / bii
                 end do
                 do j = i, min( n, i+ka )
                    ab( i-j+ka1, j ) = ab( i-j+ka1, j ) / bii
                 end do
                 do k = i + 1, i + kbt
                    do j = k, i + kbt
                       ab( k-j+ka1, j ) = ab( k-j+ka1, j ) -bb( i-j+kb1, j )*ab( i-k+ka1, k ) -bb(&
                        i-k+kb1, k )*ab( i-j+ka1, j ) +ab( ka1, i )*bb( i-j+kb1, j )*bb( i-k+kb1, &
                                  k )
                    end do
                    do j = i + kbt + 1, min( n, i+ka )
                       ab( k-j+ka1, j ) = ab( k-j+ka1, j ) -bb( i-k+kb1, k )*ab( i-j+ka1, j )
                                 
                    end do
                 end do
                 do j = i1, i
                    do k = i + 1, min( j+ka, i+kbt )
                       ab( j-k+ka1, k ) = ab( j-k+ka1, k ) -bb( i-k+kb1, k )*ab( j-i+ka1, i )
                                 
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_${ri}$scal( nx, one / bii, x( 1, i ), 1 )
                    if( kbt>0 )call stdlib_${ri}$ger( nx, kbt, -one, x( 1, i ), 1, bb( kb, i+1 ),ldbb-&
                              1, x( 1, i+1 ), ldx )
                 end if
                 ! store a(i1,i) in ra1 for use in next loop over k
                 ra1 = ab( i1-i+ka1, i )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions up toward the top of the band
              loop_610: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i+k-ka1>0 .and. i+k<m ) then
                       ! generate rotation to annihilate a(i+k-ka-1,i)
                       call stdlib_${ri}$lartg( ab( k+1, i ), ra1, work( n+i+k-ka ),work( i+k-ka ), ra &
                                 )
                       ! create nonzero element a(i+k-ka-1,i+k) outside the
                       ! band and store it in work(m-kb+i+k)
                       t = -bb( kb1-k, i+k )*ra1
                       work( m-kb+i+k ) = work( n+i+k-ka )*t -work( i+k-ka )*ab( 1, i+k )
                       ab( 1, i+k ) = work( i+k-ka )*t +work( n+i+k-ka )*ab( 1, i+k )
                       ra1 = ra
                    end if
                 end if
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( update ) then
                    j2t = min( j2, i-2*ka+k-1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( j2t+ka-1 ) / ka1
                 do j = j1, j2t, ka1
                    ! create nonzero element a(j-1,j+ka) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( 1, j+ka-1 )
                    ab( 1, j+ka-1 ) = work( n+j )*ab( 1, j+ka-1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_${ri}$largv( nrt, ab( 1, j1+ka ), inca, work( j1 ), ka1,work( &
                           n+j1 ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the left
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( ka1-l, j1+l ), inca,ab( ka-l, j1+l ), inca, &
                                 work( n+j1 ),work( j1 ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( ka1, j1 ), ab( ka1, j1-1 ),ab( ka, j1 ), inca, &
                              work( n+j1 ),work( j1 ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j1t ), inca,ab( l+1, j1t-1 ), inca,&
                               work( n+j1t ),work( j1t ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j1, j2, ka1
                       call stdlib_${ri}$rot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,work( n+j ), work( j ) )
                                 
                    end do
                 end if
              end do loop_610
              if( update ) then
                 if( i2>0 .and. kbt>0 ) then
                    ! create nonzero element a(i+kbt-ka-1,i+kbt) outside the
                    ! band and store it in work(m-kb+i+kbt)
                    work( m-kb+i+kbt ) = -bb( kb1-kbt, i+kbt )*ra1
                 end if
              end if
              loop_650: do k = kb, 1, -1
                 if( update ) then
                    j2 = i + k + 1 - max( 2, k+i0-m )*ka1
                 else
                    j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the right
                 do l = kb - k, 1, -1
                    nrt = ( j2+ka+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j1t+ka ), inca,ab( l+1, j1t+ka-1 ),&
                               inca,work( n+m-kb+j1t+ka ),work( m-kb+j1t+ka ), ka1 )
                 end do
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 do j = j1, j2, ka1
                    work( m-kb+j ) = work( m-kb+j+ka )
                    work( n+m-kb+j ) = work( n+m-kb+j+ka )
                 end do
                 do j = j1, j2, ka1
                    ! create nonzero element a(j-1,j+ka) outside the band
                    ! and store it in work(m-kb+j)
                    work( m-kb+j ) = work( m-kb+j )*ab( 1, j+ka-1 )
                    ab( 1, j+ka-1 ) = work( n+m-kb+j )*ab( 1, j+ka-1 )
                 end do
                 if( update ) then
                    if( i+k>ka1 .and. k<=kbt )work( m-kb+i+k-ka ) = work( m-kb+i+k )
                 end if
              end do loop_650
              loop_690: do k = kb, 1, -1
                 j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_${ri}$largv( nr, ab( 1, j1+ka ), inca, work( m-kb+j1 ),ka1, work( n+m-&
                              kb+j1 ), ka1 )
                    ! apply rotations in 2nd set from the left
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( ka1-l, j1+l ), inca,ab( ka-l, j1+l ), inca,&
                                 work( n+m-kb+j1 ), work( m-kb+j1 ), ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( ka1, j1 ), ab( ka1, j1-1 ),ab( ka, j1 ), inca, &
                              work( n+m-kb+j1 ),work( m-kb+j1 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j1t ), inca,ab( l+1, j1t-1 ), inca,&
                              work( n+m-kb+j1t ), work( m-kb+j1t ),ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j1, j2, ka1
                       call stdlib_${ri}$rot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,work( n+m-kb+j ), work( &
                                 m-kb+j ) )
                    end do
                 end if
              end do loop_690
              do k = 1, kb - 1
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 ! finish applying rotations in 1st set from the right
                 do l = kb - k, 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l, j1t ), inca,ab( l+1, j1t-1 ), inca,&
                               work( n+j1t ),work( j1t ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = 2, min( i+kb, m ) - 2*ka - 1
                    work( n+j ) = work( n+j+ka )
                    work( j ) = work( j+ka )
                 end do
              end if
           else
              ! transform a, working with the lower triangle
              if( update ) then
                 ! form  inv(s(i))**t * a * inv(s(i))
                 bii = bb( 1, i )
                 do j = i1, i
                    ab( i-j+1, j ) = ab( i-j+1, j ) / bii
                 end do
                 do j = i, min( n, i+ka )
                    ab( j-i+1, i ) = ab( j-i+1, i ) / bii
                 end do
                 do k = i + 1, i + kbt
                    do j = k, i + kbt
                       ab( j-k+1, k ) = ab( j-k+1, k ) -bb( j-i+1, i )*ab( k-i+1, i ) -bb( k-i+1, &
                                 i )*ab( j-i+1, i ) +ab( 1, i )*bb( j-i+1, i )*bb( k-i+1, i )
                    end do
                    do j = i + kbt + 1, min( n, i+ka )
                       ab( j-k+1, k ) = ab( j-k+1, k ) -bb( k-i+1, i )*ab( j-i+1, i )
                    end do
                 end do
                 do j = i1, i
                    do k = i + 1, min( j+ka, i+kbt )
                       ab( k-j+1, j ) = ab( k-j+1, j ) -bb( k-i+1, i )*ab( i-j+1, j )
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_${ri}$scal( nx, one / bii, x( 1, i ), 1 )
                    if( kbt>0 )call stdlib_${ri}$ger( nx, kbt, -one, x( 1, i ), 1, bb( 2, i ), 1,x( 1, &
                              i+1 ), ldx )
                 end if
                 ! store a(i,i1) in ra1 for use in next loop over k
                 ra1 = ab( i-i1+1, i1 )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions up toward the top of the band
              loop_840: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i+k-ka1>0 .and. i+k<m ) then
                       ! generate rotation to annihilate a(i,i+k-ka-1)
                       call stdlib_${ri}$lartg( ab( ka1-k, i+k-ka ), ra1,work( n+i+k-ka ), work( i+k-&
                                 ka ), ra )
                       ! create nonzero element a(i+k,i+k-ka-1) outside the
                       ! band and store it in work(m-kb+i+k)
                       t = -bb( k+1, i )*ra1
                       work( m-kb+i+k ) = work( n+i+k-ka )*t -work( i+k-ka )*ab( ka1, i+k-ka )
                                 
                       ab( ka1, i+k-ka ) = work( i+k-ka )*t +work( n+i+k-ka )*ab( ka1, i+k-ka )
                                 
                       ra1 = ra
                    end if
                 end if
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( update ) then
                    j2t = min( j2, i-2*ka+k-1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( j2t+ka-1 ) / ka1
                 do j = j1, j2t, ka1
                    ! create nonzero element a(j+ka,j-1) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( ka1, j-1 )
                    ab( ka1, j-1 ) = work( n+j )*ab( ka1, j-1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_${ri}$largv( nrt, ab( ka1, j1 ), inca, work( j1 ), ka1,work( n+&
                           j1 ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the right
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( l+1, j1 ), inca, ab( l+2, j1-1 ),inca, work( n+&
                                 j1 ), work( j1 ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( 1, j1 ), ab( 1, j1-1 ),ab( 2, j1-1 ), inca, work( &
                              n+j1 ),work( j1 ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j1t-ka1+l ), inca,ab( ka1-l, &
                              j1t-ka1+l ), inca,work( n+j1t ), work( j1t ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j1, j2, ka1
                       call stdlib_${ri}$rot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,work( n+j ), work( j ) )
                                 
                    end do
                 end if
              end do loop_840
              if( update ) then
                 if( i2>0 .and. kbt>0 ) then
                    ! create nonzero element a(i+kbt,i+kbt-ka-1) outside the
                    ! band and store it in work(m-kb+i+kbt)
                    work( m-kb+i+kbt ) = -bb( kbt+1, i )*ra1
                 end if
              end if
              loop_880: do k = kb, 1, -1
                 if( update ) then
                    j2 = i + k + 1 - max( 2, k+i0-m )*ka1
                 else
                    j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the left
                 do l = kb - k, 1, -1
                    nrt = ( j2+ka+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j1t+l-1 ), inca,ab( ka1-l, &
                              j1t+l-1 ), inca,work( n+m-kb+j1t+ka ),work( m-kb+j1t+ka ), ka1 )
                 end do
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 do j = j1, j2, ka1
                    work( m-kb+j ) = work( m-kb+j+ka )
                    work( n+m-kb+j ) = work( n+m-kb+j+ka )
                 end do
                 do j = j1, j2, ka1
                    ! create nonzero element a(j+ka,j-1) outside the band
                    ! and store it in work(m-kb+j)
                    work( m-kb+j ) = work( m-kb+j )*ab( ka1, j-1 )
                    ab( ka1, j-1 ) = work( n+m-kb+j )*ab( ka1, j-1 )
                 end do
                 if( update ) then
                    if( i+k>ka1 .and. k<=kbt )work( m-kb+i+k-ka ) = work( m-kb+i+k )
                 end if
              end do loop_880
              loop_920: do k = kb, 1, -1
                 j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_${ri}$largv( nr, ab( ka1, j1 ), inca, work( m-kb+j1 ),ka1, work( n+m-&
                              kb+j1 ), ka1 )
                    ! apply rotations in 2nd set from the right
                    do l = 1, ka - 1
                       call stdlib_${ri}$lartv( nr, ab( l+1, j1 ), inca, ab( l+2, j1-1 ),inca, work( n+&
                                 m-kb+j1 ), work( m-kb+j1 ),ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_${ri}$lar2v( nr, ab( 1, j1 ), ab( 1, j1-1 ),ab( 2, j1-1 ), inca, work( &
                              n+m-kb+j1 ),work( m-kb+j1 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j1t-ka1+l ), inca,ab( ka1-l, &
                              j1t-ka1+l ), inca,work( n+m-kb+j1t ), work( m-kb+j1t ),ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j1, j2, ka1
                       call stdlib_${ri}$rot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,work( n+m-kb+j ), work( &
                                 m-kb+j ) )
                    end do
                 end if
              end do loop_920
              do k = 1, kb - 1
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 ! finish applying rotations in 1st set from the left
                 do l = kb - k, 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( ka1-l+1, j1t-ka1+l ), inca,ab( ka1-l, &
                              j1t-ka1+l ), inca,work( n+j1t ), work( j1t ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = 2, min( i+kb, m ) - 2*ka - 1
                    work( n+j ) = work( n+j+ka )
                    work( j ) = work( j+ka )
                 end do
              end if
           end if
           go to 490
     end subroutine stdlib_${ri}$sbgst


     pure subroutine stdlib_${ri}$sbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! DSBGV: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ri}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_${ri}$sbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work( indwrk ), &
                     iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ri}$sbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, call stdlib_dsteqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$steqr( jobz, n, w, work( inde ), z, ldz, work( indwrk ),info )
           end if
           return
     end subroutine stdlib_${ri}$sbgv


     pure subroutine stdlib_${ri}$sbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! DSBGVD: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of the
     !! form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
     !! banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llwrk2, lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              liwmin = 1
              lwmin = 1
           else if( wantz ) then
              liwmin = 3 + 5*n
              lwmin = 1 + 5*n + 2*n**2
           else
              liwmin = 1
              lwmin = 2*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ri}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = indwrk + n*n
           llwrk2 = lwork - indwk2 + 1
           call stdlib_${ri}$sbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, iinfo )
                     
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ri}$sbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf. for eigenvectors, call stdlib_dstedc.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$stedc( 'I', n, w, work( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, iwork, liwork, info )
              call stdlib_${ri}$gemm( 'N', 'N', n, n, n, one, z, ldz, work( indwrk ), n,zero, work( &
                        indwk2 ), n )
              call stdlib_${ri}$lacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$sbgvd


     pure subroutine stdlib_${ri}$sbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! DSBGVX: computes selected eigenvalues, and optionally, eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwo, indwrk, itmp1, j, &
                     jj, nsplit
           real(${rk}$) :: tmp1
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ri}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_${ri}$sbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, iinfo )
                     
           ! reduce symmetric band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indwrk = inde + n
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ri}$sbtrd( vect, uplo, n, ka, ab, ldab, work( indd ),work( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_${ri}$sterf or stdlib_dsteqr.  if this fails for some
           ! eigenvalue, then try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_${ri}$copy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_${ri}$sterf( n, w, work( indee ), info )
              else
                 call stdlib_${ri}$lacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_${ri}$steqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired,
           ! call stdlib_${ri}$stein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vl, vu, il, iu, abstol,work( indd ), work( inde ),&
            m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info )
                      
           if( wantz ) then
              call stdlib_${ri}$stein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply transformation matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stein.
              do j = 1, m
                 call stdlib_${ri}$copy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_${ri}$gemv( 'N', n, n, one, q, ldq, work, 1, zero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$sbgvx


     pure subroutine stdlib_${ri}$sbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! DSBTRD: reduces a real symmetric band matrix A to symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(${rk}$), intent(out) :: d(*), e(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the cosines and sines of the plane rotations are stored in the
           ! arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_${ri}$largv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_${ri}$lartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_${ri}$rot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_${ri}$lartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_${ri}$rot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_${ri}$lar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_${ri}$rot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_${ri}$rot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_${ri}$rot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_${ri}$rot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( kd, i+1 )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( kd1, i )
              end do
           else
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_${ri}$largv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_${ri}$lartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_${ri}$rot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_${ri}$lartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_${ri}$rot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_${ri}$lar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                       if( nr>0 ) then
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_${ri}$rot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_${ri}$rot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_${ri}$rot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_${ri}$rot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( 2, i )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( 1, i )
              end do
           end if
           return
     end subroutine stdlib_${ri}$sbtrd


     pure subroutine stdlib_${ri}$sfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
     !! Level 3 BLAS like routine for C in RFP Format.
     !! DSFRK: performs one of the symmetric rank--k operations
     !! C := alpha*A*A**T + beta*C,
     !! or
     !! C := alpha*A**T*A + beta*C,
     !! where alpha and beta are real scalars, C is an n--by--n symmetric
     !! matrix and A is an n--by--k matrix in the first case and a k--by--n
     !! matrix in the second case.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, n
           character, intent(in) :: trans, transr, uplo
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: c(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, normaltransr, nisodd, notrans
           integer(ilp) :: info, nrowa, j, nk, n1, n2
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           notrans = stdlib_lsame( trans, 'N' )
           if( notrans ) then
              nrowa = n
           else
              nrowa = k
           end if
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( .not.notrans .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 ) then
              info = -5
           else if( lda<max( 1, nrowa ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSFRK ', -info )
              return
           end if
           ! quick return if possible.
           ! the quick return case: ((alpha==0).and.(beta/=zero)) is not
           ! done (it is in stdlib_${ri}$syrk for example) and left in the general case.
           if( ( n==0 ) .or. ( ( ( alpha==zero ) .or. ( k==0 ) ) .and.( beta==one ) ) )&
                     return
           if( ( alpha==zero ) .and. ( beta==zero ) ) then
              do j = 1, ( ( n*( n+1 ) ) / 2 )
                 c( j ) = zero
              end do
              return
           end if
           ! c is n-by-n.
           ! if n is odd, set nisodd = .true., and n1 and n2.
           ! if n is even, nisodd = .false., and nk.
           if( mod( n, 2 )==0 ) then
              nisodd = .false.
              nk = n / 2
           else
              nisodd = .true.
              if( lower ) then
                 n2 = n / 2
                 n1 = n - n2
              else
                 n1 = n / 2
                 n2 = n - n1
              end if
           end if
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! n is odd, transr = 'n', and uplo = 'l'
                    if( notrans ) then
                       ! n is odd, transr = 'n', uplo = 'l', and trans = 'n'
                       call stdlib_${ri}$syrk( 'L', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n )
                                 
                       call stdlib_${ri}$syrk( 'U', 'N', n2, k, alpha, a( n1+1, 1 ), lda,beta, c( n+1 )&
                                 , n )
                       call stdlib_${ri}$gemm( 'N', 'T', n2, n1, k, alpha, a( n1+1, 1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( n1+1 ), n )
                    else
                       ! n is odd, transr = 'n', uplo = 'l', and trans = 't'
                       call stdlib_${ri}$syrk( 'L', 'T', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n )
                                 
                       call stdlib_${ri}$syrk( 'U', 'T', n2, k, alpha, a( 1, n1+1 ), lda,beta, c( n+1 )&
                                 , n )
                       call stdlib_${ri}$gemm( 'T', 'N', n2, n1, k, alpha, a( 1, n1+1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( n1+1 ), n )
                    end if
                 else
                    ! n is odd, transr = 'n', and uplo = 'u'
                    if( notrans ) then
                       ! n is odd, transr = 'n', uplo = 'u', and trans = 'n'
                       call stdlib_${ri}$syrk( 'L', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2+1 ), &
                                 n )
                       call stdlib_${ri}$syrk( 'U', 'N', n2, k, alpha, a( n2, 1 ), lda,beta, c( n1+1 ),&
                                  n )
                       call stdlib_${ri}$gemm( 'N', 'T', n1, n2, k, alpha, a( 1, 1 ),lda, a( n2, 1 ), &
                                 lda, beta, c( 1 ), n )
                    else
                       ! n is odd, transr = 'n', uplo = 'u', and trans = 't'
                       call stdlib_${ri}$syrk( 'L', 'T', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2+1 ), &
                                 n )
                       call stdlib_${ri}$syrk( 'U', 'T', n2, k, alpha, a( 1, n2 ), lda,beta, c( n1+1 ),&
                                  n )
                       call stdlib_${ri}$gemm( 'T', 'N', n1, n2, k, alpha, a( 1, 1 ),lda, a( 1, n2 ), &
                                 lda, beta, c( 1 ), n )
                    end if
                 end if
              else
                 ! n is odd, and transr = 't'
                 if( lower ) then
                    ! n is odd, transr = 't', and uplo = 'l'
                    if( notrans ) then
                       ! n is odd, transr = 't', uplo = 'l', and trans = 'n'
                       call stdlib_${ri}$syrk( 'U', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n1 &
                                 )
                       call stdlib_${ri}$syrk( 'L', 'N', n2, k, alpha, a( n1+1, 1 ), lda,beta, c( 2 ), &
                                 n1 )
                       call stdlib_${ri}$gemm( 'N', 'T', n1, n2, k, alpha, a( 1, 1 ),lda, a( n1+1, 1 ),&
                                  lda, beta,c( n1*n1+1 ), n1 )
                    else
                       ! n is odd, transr = 't', uplo = 'l', and trans = 't'
                       call stdlib_${ri}$syrk( 'U', 'T', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n1 &
                                 )
                       call stdlib_${ri}$syrk( 'L', 'T', n2, k, alpha, a( 1, n1+1 ), lda,beta, c( 2 ), &
                                 n1 )
                       call stdlib_${ri}$gemm( 'T', 'N', n1, n2, k, alpha, a( 1, 1 ),lda, a( 1, n1+1 ),&
                                  lda, beta,c( n1*n1+1 ), n1 )
                    end if
                 else
                    ! n is odd, transr = 't', and uplo = 'u'
                    if( notrans ) then
                       ! n is odd, transr = 't', uplo = 'u', and trans = 'n'
                       call stdlib_${ri}$syrk( 'U', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2*n2+1 &
                                 ), n2 )
                       call stdlib_${ri}$syrk( 'L', 'N', n2, k, alpha, a( n1+1, 1 ), lda,beta, c( &
                                 n1*n2+1 ), n2 )
                       call stdlib_${ri}$gemm( 'N', 'T', n2, n1, k, alpha, a( n1+1, 1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( 1 ), n2 )
                    else
                       ! n is odd, transr = 't', uplo = 'u', and trans = 't'
                       call stdlib_${ri}$syrk( 'U', 'T', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2*n2+1 &
                                 ), n2 )
                       call stdlib_${ri}$syrk( 'L', 'T', n2, k, alpha, a( 1, n1+1 ), lda,beta, c( &
                                 n1*n2+1 ), n2 )
                       call stdlib_${ri}$gemm( 'T', 'N', n2, n1, k, alpha, a( 1, n1+1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( 1 ), n2 )
                    end if
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! n is even, transr = 'n', and uplo = 'l'
                    if( notrans ) then
                       ! n is even, transr = 'n', uplo = 'l', and trans = 'n'
                       call stdlib_${ri}$syrk( 'L', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( 2 ), n+&
                                 1 )
                       call stdlib_${ri}$syrk( 'U', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( 1 ), &
                                 n+1 )
                       call stdlib_${ri}$gemm( 'N', 'T', nk, nk, k, alpha, a( nk+1, 1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( nk+2 ),n+1 )
                    else
                       ! n is even, transr = 'n', uplo = 'l', and trans = 't'
                       call stdlib_${ri}$syrk( 'L', 'T', nk, k, alpha, a( 1, 1 ), lda,beta, c( 2 ), n+&
                                 1 )
                       call stdlib_${ri}$syrk( 'U', 'T', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( 1 ), &
                                 n+1 )
                       call stdlib_${ri}$gemm( 'T', 'N', nk, nk, k, alpha, a( 1, nk+1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( nk+2 ),n+1 )
                    end if
                 else
                    ! n is even, transr = 'n', and uplo = 'u'
                    if( notrans ) then
                       ! n is even, transr = 'n', uplo = 'u', and trans = 'n'
                       call stdlib_${ri}$syrk( 'L', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+2 ), &
                                 n+1 )
                       call stdlib_${ri}$syrk( 'U', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( nk+1 &
                                 ), n+1 )
                       call stdlib_${ri}$gemm( 'N', 'T', nk, nk, k, alpha, a( 1, 1 ),lda, a( nk+1, 1 ),&
                                  lda, beta, c( 1 ),n+1 )
                    else
                       ! n is even, transr = 'n', uplo = 'u', and trans = 't'
                       call stdlib_${ri}$syrk( 'L', 'T', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+2 ), &
                                 n+1 )
                       call stdlib_${ri}$syrk( 'U', 'T', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( nk+1 &
                                 ), n+1 )
                       call stdlib_${ri}$gemm( 'T', 'N', nk, nk, k, alpha, a( 1, 1 ),lda, a( 1, nk+1 ),&
                                  lda, beta, c( 1 ),n+1 )
                    end if
                 end if
              else
                 ! n is even, and transr = 't'
                 if( lower ) then
                    ! n is even, transr = 't', and uplo = 'l'
                    if( notrans ) then
                       ! n is even, transr = 't', uplo = 'l', and trans = 'n'
                       call stdlib_${ri}$syrk( 'U', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+1 ), &
                                 nk )
                       call stdlib_${ri}$syrk( 'L', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( 1 ), &
                                 nk )
                       call stdlib_${ri}$gemm( 'N', 'T', nk, nk, k, alpha, a( 1, 1 ),lda, a( nk+1, 1 ),&
                                  lda, beta,c( ( ( nk+1 )*nk )+1 ), nk )
                    else
                       ! n is even, transr = 't', uplo = 'l', and trans = 't'
                       call stdlib_${ri}$syrk( 'U', 'T', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+1 ), &
                                 nk )
                       call stdlib_${ri}$syrk( 'L', 'T', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( 1 ), &
                                 nk )
                       call stdlib_${ri}$gemm( 'T', 'N', nk, nk, k, alpha, a( 1, 1 ),lda, a( 1, nk+1 ),&
                                  lda, beta,c( ( ( nk+1 )*nk )+1 ), nk )
                    end if
                 else
                    ! n is even, transr = 't', and uplo = 'u'
                    if( notrans ) then
                       ! n is even, transr = 't', uplo = 'u', and trans = 'n'
                       call stdlib_${ri}$syrk( 'U', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk*( nk+&
                                 1 )+1 ), nk )
                       call stdlib_${ri}$syrk( 'L', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( &
                                 nk*nk+1 ), nk )
                       call stdlib_${ri}$gemm( 'N', 'T', nk, nk, k, alpha, a( nk+1, 1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( 1 ), nk )
                    else
                       ! n is even, transr = 't', uplo = 'u', and trans = 't'
                       call stdlib_${ri}$syrk( 'U', 'T', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk*( nk+&
                                 1 )+1 ), nk )
                       call stdlib_${ri}$syrk( 'L', 'T', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( &
                                 nk*nk+1 ), nk )
                       call stdlib_${ri}$gemm( 'T', 'N', nk, nk, k, alpha, a( 1, nk+1 ),lda, a( 1, 1 ),&
                                  lda, beta, c( 1 ), nk )
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$sfrk


     subroutine stdlib_${ri}$sgesv( n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work,swork, iter, info )
     !! DSGESV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
     !! DSGESV first attempts to factorize the matrix in SINGLE PRECISION
     !! and use this factorization within an iterative refinement procedure
     !! to produce a solution with DOUBLE PRECISION normwise backward error
     !! quality (see below). If the approach fails the method switches to a
     !! DOUBLE PRECISION factorization and solve.
     !! The iterative refinement is not going to be a winning strategy if
     !! the ratio SINGLE PRECISION performance over DOUBLE PRECISION
     !! performance is too small. A reasonable strategy should take the
     !! number of right-hand sides and the size of the matrix into account.
     !! This might be done with a call to ILAENV in the future. Up to now, we
     !! always try iterative refinement.
     !! The iterative refinement process is stopped if
     !! ITER > ITERMAX
     !! or for all the RHS we have:
     !! RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
     !! where
     !! o ITER is the number of the current iteration in the iterative
     !! refinement process
     !! o RNRM is the infinity-norm of the residual
     !! o XNRM is the infinity-norm of the solution
     !! o ANRM is the infinity-operator-norm of the matrix A
     !! o EPS is the machine epsilon returned by DLAMCH('Epsilon')
     !! The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
     !! respectively.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, iter
           integer(ilp), intent(in) :: lda, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(out) :: swork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: b(ldb,*)
           real(${rk}$), intent(out) :: work(n,*), x(ldx,*)
        ! =====================================================================
           ! Parameters 
           logical(lk), parameter :: doitref = .true.
           integer(ilp), parameter :: itermax = 30
           real(${rk}$), parameter :: bwdmax = 1.0e+00_${rk}$
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, iiter, ptsa, ptsx
           real(${rk}$) :: anrm, cte, eps, rnrm, xnrm
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,sqrt
           ! Executable Statements 
           info = 0
           iter = 0
           ! test the input parameters.
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldx<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSGESV', -info )
              return
           end if
           ! quick return if (n==0).
           if( n==0 )return
           ! skip double precision iterative refinement if a priori slower
           ! than quad precision factorization.
           if( .not.doitref ) then
              iter = -1
              go to 40
           end if
           ! compute some constants.
           anrm = stdlib_${ri}$lange( 'I', n, n, a, lda, work )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           cte = anrm*eps*sqrt( real( n,KIND=${rk}$) )*bwdmax
           ! set the indices ptsa, ptsx for referencing sa and sx in swork.
           ptsa = 1
           ptsx = ptsa + n*n
           ! convert b from quad precision to double precision and store the
           ! result in sx.
           call stdlib_${ri}$lag2s( n, nrhs, b, ldb, swork( ptsx ), n, info )
           if( info/=0 ) then
              iter = -2
              go to 40
           end if
           ! convert a from quad precision to double precision and store the
           ! result in sa.
           call stdlib_${ri}$lag2s( n, n, a, lda, swork( ptsa ), n, info )
           if( info/=0 ) then
              iter = -2
              go to 40
           end if
           ! compute the lu factorization of sa.
           call stdlib_dgetrf( n, n, swork( ptsa ), n, ipiv, info )
           if( info/=0 ) then
              iter = -3
              go to 40
           end if
           ! solve the system sa*sx = sb.
           call stdlib_dgetrs( 'NO TRANSPOSE', n, nrhs, swork( ptsa ), n, ipiv,swork( ptsx ), n, &
                     info )
           ! convert sx back to quad precision
           call stdlib_dlag2${ri}$( n, nrhs, swork( ptsx ), n, x, ldx, info )
           ! compute r = b - ax (r is work).
           call stdlib_${ri}$lacpy( 'ALL', n, nrhs, b, ldb, work, n )
           call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n, nrhs, n, negone, a,lda, x, ldx, &
                     one, work, n )
           ! check whether the nrhs normwise backward errors satisfy the
           ! stopping criterion. if yes, set iter=0 and return.
           do i = 1, nrhs
              xnrm = abs( x( stdlib_i${ri}$amax( n, x( 1, i ), 1 ), i ) )
              rnrm = abs( work( stdlib_i${ri}$amax( n, work( 1, i ), 1 ), i ) )
              if( rnrm>xnrm*cte )go to 10
           end do
           ! if we are here, the nrhs normwise backward errors satisfy the
           ! stopping criterion. we are good to exit.
           iter = 0
           return
           10 continue
           loop_30: do iiter = 1, itermax
              ! convert r (in work) from quad precision to double precision
              ! and store the result in sx.
              call stdlib_${ri}$lag2s( n, nrhs, work, n, swork( ptsx ), n, info )
              if( info/=0 ) then
                 iter = -2
                 go to 40
              end if
              ! solve the system sa*sx = sr.
              call stdlib_dgetrs( 'NO TRANSPOSE', n, nrhs, swork( ptsa ), n, ipiv,swork( ptsx ), &
                        n, info )
              ! convert sx back to quad precision and update the current
              ! iterate.
              call stdlib_dlag2${ri}$( n, nrhs, swork( ptsx ), n, work, n, info )
              do i = 1, nrhs
                 call stdlib_${ri}$axpy( n, one, work( 1, i ), 1, x( 1, i ), 1 )
              end do
              ! compute r = b - ax (r is work).
              call stdlib_${ri}$lacpy( 'ALL', n, nrhs, b, ldb, work, n )
              call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n, nrhs, n, negone,a, lda, x, &
                        ldx, one, work, n )
              ! check whether the nrhs normwise backward errors satisfy the
              ! stopping criterion. if yes, set iter=iiter>0 and return.
              do i = 1, nrhs
                 xnrm = abs( x( stdlib_i${ri}$amax( n, x( 1, i ), 1 ), i ) )
                 rnrm = abs( work( stdlib_i${ri}$amax( n, work( 1, i ), 1 ), i ) )
                 if( rnrm>xnrm*cte )go to 20
              end do
              ! if we are here, the nrhs normwise backward errors satisfy the
              ! stopping criterion, we are good to exit.
              iter = iiter
              return
              20 continue
           end do loop_30
           ! if we are at this place of the code, this is because we have
           ! performed iter=itermax iterations and never satisfied the
           ! stopping criterion, set up the iter flag accordingly and follow up
           ! on quad precision routine.
           iter = -itermax - 1
           40 continue
           ! single-precision iterative refinement failed to converge to a
           ! satisfactory solution, so we resort to quad precision.
           call stdlib_${ri}$getrf( n, n, a, lda, ipiv, info )
           if( info/=0 )return
           call stdlib_${ri}$lacpy( 'ALL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$getrs( 'NO TRANSPOSE', n, nrhs, a, lda, ipiv, x, ldx,info )
           return
     end subroutine stdlib_${ri}$sgesv


     pure subroutine stdlib_${ri}$spcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
     !! DSPCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric packed matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ri}$sptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$spcon


     subroutine stdlib_${ri}$spev( jobz, uplo, n, ap, w, z, ldz, work, info )
     !! DSPEV: computes all the eigenvalues and, optionally, eigenvectors of a
     !! real symmetric matrix A in packed storage.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantz
           integer(ilp) :: iinfo, imax, inde, indtau, indwrk, iscale
           real(${rk}$) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = ap( 1 )
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_${ri}$lansp( 'M', uplo, n, ap, work )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( ( n*( n+1 ) ) / 2, sigma, ap, 1 )
           end if
           ! call stdlib_${ri}$sptrd to reduce symmetric packed matrix to tridiagonal form.
           inde = 1
           indtau = inde + n
           call stdlib_${ri}$sptrd( uplo, n, ap, w, work( inde ), work( indtau ), iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, first call
           ! stdlib_${ri}$opgtr to generate the orthogonal matrix, then call stdlib_${ri}$steqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              indwrk = indtau + n
              call stdlib_${ri}$opgtr( uplo, n, ap, work( indtau ), z, ldz,work( indwrk ), iinfo )
                        
              call stdlib_${ri}$steqr( jobz, n, w, work( inde ), z, ldz, work( indtau ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           return
     end subroutine stdlib_${ri}$spev


     subroutine stdlib_${ri}$spevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )
     !! DSPEVD: computes all the eigenvalues and, optionally, eigenvectors
     !! of a real symmetric matrix A in packed storage. If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantz
           integer(ilp) :: iinfo, inde, indtau, indwrk, iscale, liwmin, llwork, lwmin
           real(${rk}$) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -7
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 liwmin = 1
                 lwmin = 1
              else
                 if( wantz ) then
                    liwmin = 3 + 5*n
                    lwmin = 1 + 6*n + n**2
                 else
                    liwmin = 1
                    lwmin = 2*n
                 end if
              end if
              iwork( 1 ) = liwmin
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -9
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = ap( 1 )
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_${ri}$lansp( 'M', uplo, n, ap, work )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( ( n*( n+1 ) ) / 2, sigma, ap, 1 )
           end if
           ! call stdlib_${ri}$sptrd to reduce symmetric packed matrix to tridiagonal form.
           inde = 1
           indtau = inde + n
           call stdlib_${ri}$sptrd( uplo, n, ap, w, work( inde ), work( indtau ), iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, first call
           ! stdlib_${ri}$stedc to generate the eigenvector matrix, work(indwrk), of the
           ! tridiagonal matrix, then call stdlib_${ri}$opmtr to multiply it by the
           ! householder transformations represented in ap.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              indwrk = indtau + n
              llwork = lwork - indwrk + 1
              call stdlib_${ri}$stedc( 'I', n, w, work( inde ), z, ldz, work( indwrk ),llwork, iwork, &
                        liwork, info )
              call stdlib_${ri}$opmtr( 'L', uplo, 'N', n, n, ap, work( indtau ), z, ldz,work( indwrk ),&
                         iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_${ri}$scal( n, one / sigma, w, 1 )
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$spevd


     subroutine stdlib_${ri}$spevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! DSPEVX: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric matrix A in packed storage.  Eigenvalues/vectors
     !! can be selected by specifying either a range of values or a range of
     !! indices for the desired eigenvalues.
               work, iwork, ifail,info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, valeig, wantz
           character :: order
           integer(ilp) :: i, iinfo, imax, indd, inde, indee, indibl, indisp, indiwo, indtau, &
                     indwrk, iscale, itmp1, j, jj, nsplit
           real(${rk}$) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( stdlib_lsame( uplo, 'L' ) .or. stdlib_lsame( uplo, 'U' ) ) )&
                     then
              info = -3
           else if( n<0 ) then
              info = -4
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = ap( 1 )
              else
                 if( vl<ap( 1 ) .and. vu>=ap( 1 ) ) then
                    m = 1
                    w( 1 ) = ap( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           end if
           anrm = stdlib_${ri}$lansp( 'M', uplo, n, ap, work )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( ( n*( n+1 ) ) / 2, sigma, ap, 1 )
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! call stdlib_${ri}$sptrd to reduce symmetric packed matrix to tridiagonal form.
           indtau = 1
           inde = indtau + n
           indd = inde + n
           indwrk = indd + n
           call stdlib_${ri}$sptrd( uplo, n, ap, work( indd ), work( inde ),work( indtau ), iinfo )
                     
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_${ri}$sterf or stdlib_${ri}$opgtr and stdlib_dsteqr.  if this fails
           ! for some eigenvalue, then try stdlib_${ri}$stebz.
           test = .false.
           if (indeig) then
              if (il==1 .and. iu==n) then
                 test = .true.
              end if
           end if
           if ((alleig .or. test) .and. (abstol<=zero)) then
              call stdlib_${ri}$copy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              if( .not.wantz ) then
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$sterf( n, w, work( indee ), info )
              else
                 call stdlib_${ri}$opgtr( uplo, n, ap, work( indtau ), z, ldz,work( indwrk ), iinfo )
                           
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$steqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 20
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstll,work( indd ), work( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info &
                     )
           if( wantz ) then
              call stdlib_${ri}$stein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply orthogonal matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stein.
              call stdlib_${ri}$opmtr( 'L', uplo, 'N', n, m, ap, work( indtau ), z, ldz,work( indwrk ),&
                         iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           20 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$spevx


     pure subroutine stdlib_${ri}$spgst( itype, uplo, n, ap, bp, info )
     !! DSPGST: reduces a real symmetric-definite generalized eigenproblem
     !! to standard form, using packed storage.
     !! If ITYPE = 1, the problem is A*x = lambda*B*x,
     !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
     !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
     !! B must have been previously factorized as U**T*U or L*L**T by DPPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(in) :: bp(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, j1, j1j1, jj, k, k1, k1k1, kk
           real(${rk}$) :: ajj, akk, bjj, bkk, ct
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPGST', -info )
              return
           end if
           if( itype==1 ) then
              if( upper ) then
                 ! compute inv(u**t)*a*inv(u)
                 ! j1 and jj are the indices of a(1,j) and a(j,j)
                 jj = 0
                 do j = 1, n
                    j1 = jj + 1
                    jj = jj + j
                    ! compute the j-th column of the upper triangle of a
                    bjj = bp( jj )
                    call stdlib_${ri}$tpsv( uplo, 'TRANSPOSE', 'NONUNIT', j, bp,ap( j1 ), 1 )
                    call stdlib_${ri}$spmv( uplo, j-1, -one, ap, bp( j1 ), 1, one,ap( j1 ), 1 )
                    call stdlib_${ri}$scal( j-1, one / bjj, ap( j1 ), 1 )
                    ap( jj ) = ( ap( jj )-stdlib_${ri}$dot( j-1, ap( j1 ), 1, bp( j1 ),1 ) ) / &
                              bjj
                 end do
              else
                 ! compute inv(l)*a*inv(l**t)
                 ! kk and k1k1 are the indices of a(k,k) and a(k+1,k+1)
                 kk = 1
                 do k = 1, n
                    k1k1 = kk + n - k + 1
                    ! update the lower triangle of a(k:n,k:n)
                    akk = ap( kk )
                    bkk = bp( kk )
                    akk = akk / bkk**2
                    ap( kk ) = akk
                    if( k<n ) then
                       call stdlib_${ri}$scal( n-k, one / bkk, ap( kk+1 ), 1 )
                       ct = -half*akk
                       call stdlib_${ri}$axpy( n-k, ct, bp( kk+1 ), 1, ap( kk+1 ), 1 )
                       call stdlib_${ri}$spr2( uplo, n-k, -one, ap( kk+1 ), 1,bp( kk+1 ), 1, ap( k1k1 )&
                                  )
                       call stdlib_${ri}$axpy( n-k, ct, bp( kk+1 ), 1, ap( kk+1 ), 1 )
                       call stdlib_${ri}$tpsv( uplo, 'NO TRANSPOSE', 'NON-UNIT', n-k,bp( k1k1 ), ap( &
                                 kk+1 ), 1 )
                    end if
                    kk = k1k1
                 end do
              end if
           else
              if( upper ) then
                 ! compute u*a*u**t
                 ! k1 and kk are the indices of a(1,k) and a(k,k)
                 kk = 0
                 do k = 1, n
                    k1 = kk + 1
                    kk = kk + k
                    ! update the upper triangle of a(1:k,1:k)
                    akk = ap( kk )
                    bkk = bp( kk )
                    call stdlib_${ri}$tpmv( uplo, 'NO TRANSPOSE', 'NON-UNIT', k-1, bp,ap( k1 ), 1 )
                              
                    ct = half*akk
                    call stdlib_${ri}$axpy( k-1, ct, bp( k1 ), 1, ap( k1 ), 1 )
                    call stdlib_${ri}$spr2( uplo, k-1, one, ap( k1 ), 1, bp( k1 ), 1,ap )
                    call stdlib_${ri}$axpy( k-1, ct, bp( k1 ), 1, ap( k1 ), 1 )
                    call stdlib_${ri}$scal( k-1, bkk, ap( k1 ), 1 )
                    ap( kk ) = akk*bkk**2
                 end do
              else
                 ! compute l**t *a*l
                 ! jj and j1j1 are the indices of a(j,j) and a(j+1,j+1)
                 jj = 1
                 do j = 1, n
                    j1j1 = jj + n - j + 1
                    ! compute the j-th column of the lower triangle of a
                    ajj = ap( jj )
                    bjj = bp( jj )
                    ap( jj ) = ajj*bjj + stdlib_${ri}$dot( n-j, ap( jj+1 ), 1,bp( jj+1 ), 1 )
                    call stdlib_${ri}$scal( n-j, bjj, ap( jj+1 ), 1 )
                    call stdlib_${ri}$spmv( uplo, n-j, one, ap( j1j1 ), bp( jj+1 ), 1,one, ap( jj+1 ), &
                              1 )
                    call stdlib_${ri}$tpmv( uplo, 'TRANSPOSE', 'NON-UNIT', n-j+1,bp( jj ), ap( jj ), 1 &
                              )
                    jj = j1j1
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$spgst


     subroutine stdlib_${ri}$spgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
     !! DSPGV: computes all the eigenvalues and, optionally, the eigenvectors
     !! of a real generalized symmetric-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     !! Here A and B are assumed to be symmetric, stored in packed format,
     !! and B is also positive definite.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*), bp(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: trans
           integer(ilp) :: j, neig
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_${ri}$pptrf( uplo, n, bp, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_${ri}$spgst( itype, uplo, n, ap, bp, info )
           call stdlib_${ri}$spev( jobz, uplo, n, ap, w, z, ldz, work, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              neig = n
              if( info>0 )neig = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**t*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'T'
                 end if
                 do j = 1, neig
                    call stdlib_${ri}$tpsv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**t*y
                 if( upper ) then
                    trans = 'T'
                 else
                    trans = 'N'
                 end if
                 do j = 1, neig
                    call stdlib_${ri}$tpmv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$spgv


     subroutine stdlib_${ri}$spgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, liwork,&
     !! DSPGVD: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     !! B are assumed to be symmetric, stored in packed format, and B is also
     !! positive definite.
     !! If eigenvectors are desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
                info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ap(*), bp(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: trans
           integer(ilp) :: j, liwmin, lwmin, neig
           ! Intrinsic Functions 
           intrinsic :: real,max
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 liwmin = 1
                 lwmin = 1
              else
                 if( wantz ) then
                    liwmin = 3 + 5*n
                    lwmin = 1 + 6*n + 2*n**2
                 else
                    liwmin = 1
                    lwmin = 2*n
                 end if
              end if
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -11
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of bp.
           call stdlib_${ri}$pptrf( uplo, n, bp, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_${ri}$spgst( itype, uplo, n, ap, bp, info )
           call stdlib_${ri}$spevd( jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork,liwork, info )
                     
           lwmin = max( real( lwmin,KIND=${rk}$), real( work( 1 ),KIND=${rk}$) )
           liwmin = max( real( liwmin,KIND=${rk}$), real( iwork( 1 ),KIND=${rk}$) )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              neig = n
              if( info>0 )neig = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**t *y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'T'
                 end if
                 do j = 1, neig
                    call stdlib_${ri}$tpsv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**t *y
                 if( upper ) then
                    trans = 'T'
                 else
                    trans = 'N'
                 end if
                 do j = 1, neig
                    call stdlib_${ri}$tpmv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              end if
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$spgvd


     subroutine stdlib_${ri}$spgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
     !! DSPGVX: computes selected eigenvalues, and optionally, eigenvectors
     !! of a real generalized symmetric-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
     !! and B are assumed to be symmetric, stored in packed storage, and B
     !! is also positive definite.  Eigenvalues and eigenvectors can be
     !! selected by specifying either a range of values or a range of indices
     !! for the desired eigenvalues.
               z, ldz, work, iwork,ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, itype, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ap(*), bp(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: alleig, indeig, upper, valeig, wantz
           character :: trans
           integer(ilp) :: j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! test the input parameters.
           upper = stdlib_lsame( uplo, 'U' )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -3
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl ) then
                    info = -9
                 end if
              else if( indeig ) then
                 if( il<1 ) then
                    info = -10
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -11
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_${ri}$pptrf( uplo, n, bp, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_${ri}$spgst( itype, uplo, n, ap, bp, info )
           call stdlib_${ri}$spevx( jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m,w, z, ldz, &
                     work, iwork, ifail, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              if( info>0 )m = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**t*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'T'
                 end if
                 do j = 1, m
                    call stdlib_${ri}$tpsv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**t*y
                 if( upper ) then
                    trans = 'T'
                 else
                    trans = 'N'
                 end if
                 do j = 1, m
                    call stdlib_${ri}$tpmv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$spgvx


     subroutine stdlib_${ri}$sposv( uplo, n, nrhs, a, lda, b, ldb, x, ldx, work,swork, iter, info )
     !! DSPOSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! DSPOSV first attempts to factorize the matrix in SINGLE PRECISION
     !! and use this factorization within an iterative refinement procedure
     !! to produce a solution with DOUBLE PRECISION normwise backward error
     !! quality (see below). If the approach fails the method switches to a
     !! DOUBLE PRECISION factorization and solve.
     !! The iterative refinement is not going to be a winning strategy if
     !! the ratio SINGLE PRECISION performance over DOUBLE PRECISION
     !! performance is too small. A reasonable strategy should take the
     !! number of right-hand sides and the size of the matrix into account.
     !! This might be done with a call to ILAENV in the future. Up to now, we
     !! always try iterative refinement.
     !! The iterative refinement process is stopped if
     !! ITER > ITERMAX
     !! or for all the RHS we have:
     !! RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX
     !! where
     !! o ITER is the number of the current iteration in the iterative
     !! refinement process
     !! o RNRM is the infinity-norm of the residual
     !! o XNRM is the infinity-norm of the solution
     !! o ANRM is the infinity-operator-norm of the matrix A
     !! o EPS is the machine epsilon returned by DLAMCH('Epsilon')
     !! The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00
     !! respectively.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, iter
           integer(ilp), intent(in) :: lda, ldb, ldx, n, nrhs
           ! Array Arguments 
           real(dp), intent(out) :: swork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: b(ldb,*)
           real(${rk}$), intent(out) :: work(n,*), x(ldx,*)
        ! =====================================================================
           ! Parameters 
           logical(lk), parameter :: doitref = .true.
           integer(ilp), parameter :: itermax = 30
           real(${rk}$), parameter :: bwdmax = 1.0e+00_${rk}$
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, iiter, ptsa, ptsx
           real(${rk}$) :: anrm, cte, eps, rnrm, xnrm
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,sqrt
           ! Executable Statements 
           info = 0
           iter = 0
           ! test the input parameters.
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldx<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPOSV', -info )
              return
           end if
           ! quick return if (n==0).
           if( n==0 )return
           ! skip double precision iterative refinement if a priori slower
           ! than quad precision factorization.
           if( .not.doitref ) then
              iter = -1
              go to 40
           end if
           ! compute some constants.
           anrm = stdlib_${ri}$lansy( 'I', uplo, n, a, lda, work )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           cte = anrm*eps*sqrt( real( n,KIND=${rk}$) )*bwdmax
           ! set the indices ptsa, ptsx for referencing sa and sx in swork.
           ptsa = 1
           ptsx = ptsa + n*n
           ! convert b from quad precision to double precision and store the
           ! result in sx.
           call stdlib_${ri}$lag2s( n, nrhs, b, ldb, swork( ptsx ), n, info )
           if( info/=0 ) then
              iter = -2
              go to 40
           end if
           ! convert a from quad precision to double precision and store the
           ! result in sa.
           call stdlib_${ri}$lat2s( uplo, n, a, lda, swork( ptsa ), n, info )
           if( info/=0 ) then
              iter = -2
              go to 40
           end if
           ! compute the cholesky factorization of sa.
           call stdlib_dpotrf( uplo, n, swork( ptsa ), n, info )
           if( info/=0 ) then
              iter = -3
              go to 40
           end if
           ! solve the system sa*sx = sb.
           call stdlib_dpotrs( uplo, n, nrhs, swork( ptsa ), n, swork( ptsx ), n,info )
           ! convert sx back to quad precision
           call stdlib_dlag2${ri}$( n, nrhs, swork( ptsx ), n, x, ldx, info )
           ! compute r = b - ax (r is work).
           call stdlib_${ri}$lacpy( 'ALL', n, nrhs, b, ldb, work, n )
           call stdlib_${ri}$symm( 'LEFT', uplo, n, nrhs, negone, a, lda, x, ldx, one,work, n )
           ! check whether the nrhs normwise backward errors satisfy the
           ! stopping criterion. if yes, set iter=0 and return.
           do i = 1, nrhs
              xnrm = abs( x( stdlib_i${ri}$amax( n, x( 1, i ), 1 ), i ) )
              rnrm = abs( work( stdlib_i${ri}$amax( n, work( 1, i ), 1 ), i ) )
              if( rnrm>xnrm*cte )go to 10
           end do
           ! if we are here, the nrhs normwise backward errors satisfy the
           ! stopping criterion. we are good to exit.
           iter = 0
           return
           10 continue
           loop_30: do iiter = 1, itermax
              ! convert r (in work) from quad precision to double precision
              ! and store the result in sx.
              call stdlib_${ri}$lag2s( n, nrhs, work, n, swork( ptsx ), n, info )
              if( info/=0 ) then
                 iter = -2
                 go to 40
              end if
              ! solve the system sa*sx = sr.
              call stdlib_dpotrs( uplo, n, nrhs, swork( ptsa ), n, swork( ptsx ), n,info )
              ! convert sx back to quad precision and update the current
              ! iterate.
              call stdlib_dlag2${ri}$( n, nrhs, swork( ptsx ), n, work, n, info )
              do i = 1, nrhs
                 call stdlib_${ri}$axpy( n, one, work( 1, i ), 1, x( 1, i ), 1 )
              end do
              ! compute r = b - ax (r is work).
              call stdlib_${ri}$lacpy( 'ALL', n, nrhs, b, ldb, work, n )
              call stdlib_${ri}$symm( 'L', uplo, n, nrhs, negone, a, lda, x, ldx, one,work, n )
              ! check whether the nrhs normwise backward errors satisfy the
              ! stopping criterion. if yes, set iter=iiter>0 and return.
              do i = 1, nrhs
                 xnrm = abs( x( stdlib_i${ri}$amax( n, x( 1, i ), 1 ), i ) )
                 rnrm = abs( work( stdlib_i${ri}$amax( n, work( 1, i ), 1 ), i ) )
                 if( rnrm>xnrm*cte )go to 20
              end do
              ! if we are here, the nrhs normwise backward errors satisfy the
              ! stopping criterion, we are good to exit.
              iter = iiter
              return
              20 continue
           end do loop_30
           ! if we are at this place of the code, this is because we have
           ! performed iter=itermax iterations and never satisfied the
           ! stopping criterion, set up the iter flag accordingly and follow
           ! up on quad precision routine.
           iter = -itermax - 1
           40 continue
           ! single-precision iterative refinement failed to converge to a
           ! satisfactory solution, so we resort to quad precision.
           call stdlib_${ri}$potrf( uplo, n, a, lda, info )
           if( info/=0 )return
           call stdlib_${ri}$lacpy( 'ALL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$potrs( uplo, n, nrhs, a, lda, x, ldx, info )
           return
     end subroutine stdlib_${ri}$sposv


     pure subroutine stdlib_${ri}$sprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! DSPRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: afp(*), ap(*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$spmv( uplo, n, -one, ap, x( 1, j ), 1, one, work( n+1 ),1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + abs( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$sptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n, info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$sptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$sptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$sprfs


     pure subroutine stdlib_${ri}$spsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$spsv


     subroutine stdlib_${ri}$spsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! DSPSVX: uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: afp(*)
           real(${rk}$), intent(in) :: ap(*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_${ri}$copy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_${ri}$sptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansp( 'I', uplo, n, ap, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$spcon( uplo, n, afp, ipiv, anorm, rcond, work, iwork, info )
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$sptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$sprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$spsvx


     pure subroutine stdlib_${ri}$sptrd( uplo, n, ap, d, e, tau, info )
     !! DSPTRD: reduces a real symmetric matrix A stored in packed form to
     !! symmetric tridiagonal form T by an orthogonal similarity
     !! transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           real(${rk}$) :: alpha, taui
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_${ri}$larfg( i, ap( i1+i-1 ), ap( i1 ), 1, taui )
                 e( i ) = ap( i1+i-1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_${ri}$spmv( uplo, i, taui, ap, ap( i1 ), 1, zero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_${ri}$axpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$spr2( uplo, i, -one, ap( i1 ), 1, tau, 1, ap )
                    ap( i1+i-1 ) = e( i )
                 end if
                 d( i+1 ) = ap( i1+i )
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = ap( 1 )
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_${ri}$larfg( n-i, ap( ii+1 ), ap( ii+2 ), 1, taui )
                 e( i ) = ap( ii+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_${ri}$spmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,zero, tau( i ), &
                              1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_${ri}$axpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$spr2( uplo, n-i, -one, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                    ap( ii+1 ) = e( i )
                 end if
                 d( i ) = ap( ii )
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = ap( ii )
           end if
           return
     end subroutine stdlib_${ri}$sptrd


     pure subroutine stdlib_${ri}$sptrf( uplo, n, ap, ipiv, info )
     !! DSPTRF: computes the factorization of a real symmetric matrix A stored
     !! in packed format using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, ap( kc ), 1 )
                 colmax = abs( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_i${ri}$amax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ri}$swap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / ap( kc+k-1 )
                    call stdlib_${ri}$spr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_${ri}$scal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, ap( kc+1 ), 1 )
                 colmax = abs( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ri}$amax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = one / ap( kc )
                       call stdlib_${ri}$spr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_${ri}$scal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_${ri}$sptrf


     pure subroutine stdlib_${ri}$sptri( uplo, n, ap, ipiv, work, info )
     !! DSPTRI: computes the inverse of a real symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(${rk}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_${ri}$dot( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_${ri}$dot( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_${ri}$dot( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_${ri}$copy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, k-1, -one, ap, work, 1, zero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_${ri}$dot( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_${ri}$swap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, n-k, -one, ap( kc+n-k+1 ), work, 1,zero, ap( kc+1 ), &
                              1 )
                    ap( kc ) = ap( kc ) - stdlib_${ri}$dot( n-k, work, 1, ap( kc+1 ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( kc+&
                              1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_${ri}$dot( n-k, work, 1, ap( kc+1 ), 1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_${ri}$dot( n-k, ap( kc+1 ), 1,ap( kcnext+2 &
                              ), 1 )
                    call stdlib_${ri}$copy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_${ri}$dot( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_${ri}$swap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_${ri}$sptri


     pure subroutine stdlib_${ri}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPTRS: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$ger( k-1, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ri}$ger( k-2, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_${ri}$ger( k-2, nrhs, -one, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, 1 &
                           ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,ap( kc+k ), 1, one, b( k+&
                           1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$ger( n-k, nrhs, -one, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+1,&
                            1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, 1 )&
                              , ldb )
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc+1 ), &
                              1, one, b( k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ri}$sptrs


     pure subroutine stdlib_${ri}$stebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
     !! DSTEBZ: computes the eigenvalues of a symmetric tridiagonal
     !! matrix T.  The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               iblock, isplit, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(${rk}$), intent(in) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fudge = 2.1_${rk}$
           real(${rk}$), parameter :: relfac = 2.0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iorder, &
                     iout, irange, itmax, itmp1, iw, iwoff, j, jb, jdisc, je, nb, nwl, nwu
           real(${rk}$) :: atoli, bnorm, gl, gu, pivmin, rtoli, safemn, tmp1, tmp2, tnorm, ulp, wkill,&
                      wl, wlu, wu, wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,min,sqrt
           ! Executable Statements 
           info = 0
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = 1
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = 2
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = 3
           else
              irange = 0
           end if
           ! decode order
           if( stdlib_lsame( order, 'B' ) ) then
              iorder = 2
           else if( stdlib_lsame( order, 'E' ) ) then
              iorder = 1
           else
              iorder = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( iorder<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==2 ) then
              if( vl>=vu )info = -5
           else if( irange==3 .and. ( il<1 .or. il>max( 1, n ) ) )then
              info = -6
           else if( irange==3 .and. ( iu<min( n, il ) .or. iu>n ) )then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEBZ', -info )
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! simplifications:
           if( irange==3 .and. il==1 .and. iu==n )irange = 1
           ! get machine constants
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           safemn = stdlib_${ri}$lamch( 'S' )
           ulp = stdlib_${ri}$lamch( 'P' )
           rtoli = ulp*relfac
           nb = stdlib_ilaenv( 1, 'DSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 )nb = 0
           ! special case when n=1
           if( n==1 ) then
              nsplit = 1
              isplit( 1 ) = 1
              if( irange==2 .and. ( vl>=d( 1 ) .or. vu<d( 1 ) ) ) then
                 m = 0
              else
                 w( 1 ) = d( 1 )
                 iblock( 1 ) = 1
                 m = 1
              end if
              return
           end if
           ! compute splitting points
           nsplit = 1
           work( n ) = zero
           pivmin = one
           do j = 2, n
              tmp1 = e( j-1 )**2
              if( abs( d( j )*d( j-1 ) )*ulp**2+safemn>tmp1 ) then
                 isplit( nsplit ) = j - 1
                 nsplit = nsplit + 1
                 work( j-1 ) = zero
              else
                 work( j-1 ) = tmp1
                 pivmin = max( pivmin, tmp1 )
              end if
           end do
           isplit( nsplit ) = n
           pivmin = pivmin*safemn
           ! compute interval and atoli
           if( irange==3 ) then
              ! range='i': compute the interval containing eigenvalues
                         ! il through iu.
              ! compute gershgorin interval for entire (split) matrix
              ! and use it as the initial interval
              gu = d( 1 )
              gl = d( 1 )
              tmp1 = zero
              do j = 1, n - 1
                 tmp2 = sqrt( work( j ) )
                 gu = max( gu, d( j )+tmp1+tmp2 )
                 gl = min( gl, d( j )-tmp1-tmp2 )
                 tmp1 = tmp2
              end do
              gu = max( gu, d( n )+tmp1 )
              gl = min( gl, d( n )-tmp1 )
              tnorm = max( abs( gl ), abs( gu ) )
              gl = gl - fudge*tnorm*ulp*n - fudge*two*pivmin
              gu = gu + fudge*tnorm*ulp*n + fudge*pivmin
              ! compute iteration parameters
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_${ri}$laebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin, d, e,work, iwork( &
                        5 ), work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           else
              ! range='a' or 'v' -- set atoli
              tnorm = max( abs( d( 1 ) )+abs( e( 1 ) ),abs( d( n ) )+abs( e( n-1 ) ) )
              do j = 2, n - 1
                 tnorm = max( tnorm, abs( d( j ) )+abs( e( j-1 ) )+abs( e( j ) ) )
              end do
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              if( irange==2 ) then
                 wl = vl
                 wu = vu
              else
                 wl = zero
                 wu = zero
              end if
           end if
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jb = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jb )
              in = iend - ioff
              if( in==1 ) then
                 ! special case -- in=1
                 if( irange==1 .or. wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( irange==1 .or. wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==1 .or. ( wl<d( ibegin )-pivmin .and. wu>=d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    iblock( m ) = jb
                 end if
              else
                 ! general case -- in > 1
                 ! compute gershgorin interval
                 ! and use it as the initial interval
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend - 1
                    tmp2 = abs( e( j ) )
                    gu = max( gu, d( j )+tmp1+tmp2 )
                    gl = min( gl, d( j )-tmp1-tmp2 )
                    tmp1 = tmp2
                 end do
                 gu = max( gu, d( iend )+tmp1 )
                 gl = min( gl, d( iend )-tmp1 )
                 bnorm = max( abs( gl ), abs( gu ) )
                 gl = gl - fudge*bnorm*ulp*in - fudge*pivmin
                 gu = gu + fudge*bnorm*ulp*in + fudge*pivmin
                 ! compute atoli for the current submatrix
                 if( abstol<=zero ) then
                    atoli = ulp*max( abs( gl ), abs( gu ) )
                 else
                    atoli = abstol
                 end if
                 if( irange>1 ) then
                    if( gu<wl ) then
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! set up initial interval
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_${ri}$laebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 &
                           ), iblock( m+1 ), iinfo )
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_${ri}$laebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( &
                            m+1 ), iblock( m+1 ), iinfo )
                 ! copy eigenvalues into w and iblock
                 ! use -jb for block number for unconverged eigenvalues.
                 do j = 1, iout
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! flag non-convergence.
                    if( j>iout-iinfo ) then
                       ncnvrg = .true.
                       ib = -jb
                    else
                       ib = jb
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==3 ) then
              im = 0
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 .or. idiscu>0 ) then
                 do je = 1, m
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic:
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by simply finding the smallest/largest
                 ! eigenvalue(s).
                 ! (if n(w) is monotone non-decreasing, this should never
                     ! happen.)
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           ! if order='b', do nothing -- the eigenvalues are already sorted
              ! by block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( iorder==1 .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    itmp1 = iblock( ie )
                    w( ie ) = w( je )
                    iblock( ie ) = iblock( je )
                    w( je ) = tmp1
                    iblock( je ) = itmp1
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_${ri}$stebz


     pure subroutine stdlib_${ri}$stedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! DSTEDC: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band real symmetric matrix can also be
     !! found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLAED3 for details.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, lwmin, m, smlsiz, start, &
                     storez, strtrw
           real(${rk}$) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           intrinsic :: abs,real,int,log,max,mod,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'DSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 liwmin = 1
                 lwmin = 1
              else if( n<=smlsiz ) then
                 liwmin = 1
                 lwmin = 2*( n - 1 )
              else
                 lgn = int( log( real( n,KIND=${rk}$) )/log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 if( icompz==1 ) then
                    lwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                    liwmin = 6 + 6*n + 5*n*lgn
                 else if( icompz==2 ) then
                    lwmin = 1 + 4*n + n**2
                    liwmin = 3 + 5*n
                 end if
              end if
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not. lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not. lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEDC', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_${ri}$sterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_${ri}$sterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_${ri}$sterf( n, d, e, info )
              go to 50
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_${ri}$steqr( compz, n, d, e, z, ldz, work, info )
           else
              ! if compz = 'v', the z matrix must be stored elsewhere for later
              ! use.
              if( icompz==1 ) then
                 storez = 1 + n*n
              else
                 storez = 1
              end if
              if( icompz==2 ) then
                 call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
              end if
              ! scale.
              orgnrm = stdlib_${ri}$lanst( 'M', n, d, e )
              if( orgnrm==zero )go to 50
              eps = stdlib_${ri}$lamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              10 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 20 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 20
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m==1 ) then
                    start = finish + 1
                    go to 10
                 end if
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_${ri}$lanst( 'M', m, d( start ), e( start ) )
                    call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    if( icompz==1 ) then
                       strtrw = 1
                    else
                       strtrw = start
                    end if
                    call stdlib_${ri}$laed0( icompz, n, m, d( start ), e( start ),z( strtrw, start ), &
                              ldz, work( 1 ), n,work( storez ), iwork, info )
                    if( info/=0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 50
                    end if
                    ! scale back.
                    call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    if( icompz==1 ) then
                       ! since qr won't update a z matrix which is larger than
                       ! the length of d, we must solve the sub-problem in a
                       ! workspace and then multiply back into z.
                       call stdlib_${ri}$steqr( 'I', m, d( start ), e( start ), work, m,work( m*m+1 ), &
                                 info )
                       call stdlib_${ri}$lacpy( 'A', n, m, z( 1, start ), ldz,work( storez ), n )
                                 
                       call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one,work( storez ), n, work, m, zero,&
                                 z( 1, start ), ldz )
                    else if( icompz==2 ) then
                       call stdlib_${ri}$steqr( 'I', m, d( start ), e( start ),z( start, start ), ldz, &
                                 work, info )
                    else
                       call stdlib_${ri}$sterf( m, d( start ), e( start ), info )
                    end if
                    if( info/=0 ) then
                       info = start*( n+1 ) + finish
                       go to 50
                    end if
                 end if
                 start = finish + 1
                 go to 10
              end if
              ! endwhile
              if( icompz==0 ) then
                ! use quick sort
                call stdlib_${ri}$lasrt( 'I', n, d, info )
              else
                ! use selection sort to minimize swaps of eigenvectors
                do ii = 2, n
                   i = ii - 1
                   k = i
                   p = d( i )
                   do j = ii, n
                      if( d( j )<p ) then
                         k = j
                         p = d( j )
                      end if
                   end do
                   if( k/=i ) then
                      d( k ) = d( i )
                      d( i ) = p
                      call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, k ), 1 )
                   end if
                end do
              end if
           end if
           50 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stedc


     pure subroutine stdlib_${ri}$stegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! DSTEGR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! DSTEGR is a compatibility wrapper around the improved DSTEMR routine.
     !! See DSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : DSTEGR and DSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_${ri}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_${ri}$stegr


     pure subroutine stdlib_${ri}$stein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! DSTEIN: computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(in) :: d(*), e(*), w(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: odm3 = 1.0e-3_${rk}$
           real(${rk}$), parameter :: odm1 = 1.0e-1_${rk}$
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, nblk, nrmchk
           real(${rk}$) :: dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, tol, xj, xjm, &
                     ztr
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_${ri}$larnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_160: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              dtpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_150: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_160
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 120
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_${ri}$larnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_${ri}$copy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_${ri}$copy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_${ri}$copy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_${ri}$lagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 100
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_i${ri}$amax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_${ri}$scal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_${ri}$lagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 90
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ztr = -stdlib_${ri}$dot( blksiz, work( indrv1+1 ), 1, z( b1, i ),1 )
                       call stdlib_${ri}$axpy( blksiz, ztr, z( b1, i ), 1,work( indrv1+1 ), 1 )
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 90 continue
                 jmax = stdlib_i${ri}$amax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<dtpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 110
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 100 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 110 continue
                 scl = one / stdlib_${ri}$nrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_i${ri}$amax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_${ri}$scal( blksiz, scl, work( indrv1+1 ), 1 )
                 120 continue
                 do i = 1, n
                    z( i, j ) = zero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = work( indrv1+i )
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_150
           end do loop_160
           return
     end subroutine stdlib_${ri}$stein


     pure subroutine stdlib_${ri}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! DSTEMR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.DSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: minrgp = 1.0e-3_${rk}$
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(${rk}$) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_${ri}$stemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_${ri}$larre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_${ri}$larrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_${ri}$larre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_${ri}$larrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_${ri}$lae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_${ri}$laev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
           ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_${ri}$larrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_${ri}$scal( n, scale, d, 1 )
                 call stdlib_${ri}$scal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_${ri}$larre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_${ri}$larrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_${ri}$copy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_${ri}$larre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_${ri}$larre computes the eigenvalues to less than full precision.
                 ! stdlib_${ri}$larrv will refine the eigenvalue approximations, and we can
                 ! need less accurate initial bisection in stdlib_${ri}$larre.
                 ! note: these settings do only affect the subset case and stdlib_${ri}$larre
                 rtol1 = sqrt(eps)
                 rtol2 = max( sqrt(eps)*5.0e-3_${rk}$, four * eps )
              endif
              call stdlib_${ri}$larre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_${ri}$larre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_${ri}$larrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_${ri}$larre computes eigenvalues of the (shifted) root representation
                 ! stdlib_${ri}$larrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_${ri}$larre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_${ri}$larrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_${ri}$scal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_${ri}$lasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stemr


     pure subroutine stdlib_${ri}$steqr( compz, n, d, e, z, ldz, work, info )
     !! DSTEQR: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band symmetric matrix can also be found
     !! if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
     !! tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(${rk}$) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           intrinsic :: abs,max,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = one
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_${ri}$lamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_${ri}$lanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_${ri}$lae2 or stdlib_dlaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_${ri}$laev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_${ri}$lasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_${ri}$lae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_${ri}$lapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_${ri}$lartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_${ri}$lasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_${ri}$lae2 or stdlib_dlaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_${ri}$laev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_${ri}$lae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_${ri}$lapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_${ri}$lartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_${ri}$lasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 190
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_${ri}$lasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           190 continue
           return
     end subroutine stdlib_${ri}$steqr


     pure subroutine stdlib_${ri}$sterf( n, d, e, info )
     !! DSTERF: computes all eigenvalues of a symmetric tridiagonal matrix
     !! using the Pal-Walker-Kahan variant of the QL or QR algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, iscale, jtot, l, l1, lend, lendsv, lsv, m, nmaxit
           real(${rk}$) :: alpha, anorm, bb, c, eps, eps2, gamma, oldc, oldgam, p, r, rt1, rt2, rte, &
                     s, safmax, safmin, sigma, ssfmax, ssfmin, rmax
           ! Intrinsic Functions 
           intrinsic :: abs,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! quick return if possible
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DSTERF', -info )
              return
           end if
           if( n<=1 )return
           ! determine the unit roundoff for this environment.
           eps = stdlib_${ri}$lamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           rmax = stdlib_${ri}$lamch( 'O' )
           ! compute the eigenvalues of the tridiagonal matrix.
           nmaxit = n*maxit
           sigma = zero
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           10 continue
           if( l1>n )go to 170
           if( l1>1 )e( l1-1 ) = zero
           do m = l1, n - 1
              if( abs( e( m ) )<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) &
                        then
                 e( m ) = zero
                 go to 30
              end if
           end do
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_${ri}$lanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( (anorm>ssfmax) ) then
              iscale = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           do i = l, lend - 1
              e( i ) = e( i )**2
           end do
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>=l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              50 continue
              if( l/=lend ) then
                 do m = l, lend - 1
                    if( abs( e( m ) )<=eps2*abs( d( m )*d( m+1 ) ) )go to 70
                 end do
              end if
              m = lend
              70 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 90
              ! if remaining matrix is 2 by 2, use stdlib_${ri}$lae2 to compute its
              ! eigenvalues.
              if( m==l+1 ) then
                 rte = sqrt( e( l ) )
                 call stdlib_${ri}$lae2( d( l ), rte, d( l+1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 50
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l ) )
              sigma = ( d( l+1 )-p ) / ( two*rte )
              r = stdlib_${ri}$lapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m - 1, l, -1
                 bb = e( i )
                 r = p + bb
                 if( i/=m-1 )e( i+1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i+1 ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l ) = s*p
              d( l ) = sigma + gamma
              go to 50
              ! eigenvalue found.
              90 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 50
              go to 150
           else
              ! qr iteration
              ! look for small superdiagonal element.
              100 continue
              do m = l, lend + 1, -1
                 if( abs( e( m-1 ) )<=eps2*abs( d( m )*d( m-1 ) ) )go to 120
              end do
              m = lend
              120 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 140
              ! if remaining matrix is 2 by 2, use stdlib_${ri}$lae2 to compute its
              ! eigenvalues.
              if( m==l-1 ) then
                 rte = sqrt( e( l-1 ) )
                 call stdlib_${ri}$lae2( d( l ), rte, d( l-1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l-1 ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 100
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l-1 ) )
              sigma = ( d( l-1 )-p ) / ( two*rte )
              r = stdlib_${ri}$lapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m, l - 1
                 bb = e( i )
                 r = p + bb
                 if( i/=m )e( i-1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i+1 )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l-1 ) = s*p
              d( l ) = sigma + gamma
              go to 100
              ! eigenvalue found.
              140 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 100
              go to 150
           end if
           ! undo scaling if necessary
           150 continue
           if( iscale==1 )call stdlib_${ri}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           if( iscale==2 )call stdlib_${ri}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 180
           ! sort eigenvalues in increasing order.
           170 continue
           call stdlib_${ri}$lasrt( 'I', n, d, info )
           180 continue
           return
     end subroutine stdlib_${ri}$sterf


     pure subroutine stdlib_${ri}$stev( jobz, n, d, e, z, ldz, work, info )
     !! DSTEV: computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantz
           integer(ilp) :: imax, iscale
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvalues and
           ! eigenvectors, call stdlib_${ri}$steqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, d, e, info )
           else
              call stdlib_${ri}$steqr( 'I', n, d, e, z, ldz, work, info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, d, 1 )
           end if
           return
     end subroutine stdlib_${ri}$stev


     pure subroutine stdlib_${ri}$stevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! DSTEVD: computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix. If eigenvectors are desired, it
     !! uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantz
           integer(ilp) :: iscale, liwmin, lwmin
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           liwmin = 1
           lwmin = 1
           if( n>1 .and. wantz ) then
              lwmin = 1 + 4*n + n**2
              liwmin = 3 + 5*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvalues and
           ! eigenvectors, call stdlib_${ri}$stedc.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, d, e, info )
           else
              call stdlib_${ri}$stedc( 'I', n, d, e, z, ldz, work, lwork, iwork, liwork,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_${ri}$scal( n, one / sigma, d, 1 )
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stevd


     pure subroutine stdlib_${ri}$stevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! DSTEVR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
     !! Whenever possible, DSTEVR calls DSTEMR to compute the
     !! eigenspectrum using Relatively Robust Representations.  DSTEMR
     !! computes eigenvalues by the dqds algorithm, while orthogonal
     !! eigenvectors are computed from various "good" L D L^T representations
     !! (also known as Relatively Robust Representations). Gram-Schmidt
     !! orthogonalization is avoided as far as possible. More specifically,
     !! the various steps of the algorithm are as follows. For the i-th
     !! unreduced block of T,
     !! (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
     !! is a relatively robust representation,
     !! (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
     !! relative accuracy by the dqds algorithm,
     !! (c) If there is a cluster of close eigenvalues, "choose" sigma_i
     !! close to the cluster, and go to step (a),
     !! (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
     !! compute the corresponding eigenvector by forming a
     !! rank-revealing twisted factorization.
     !! The desired accuracy of the output can be specified by the input
     !! parameter ABSTOL.
     !! For more details, see "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
     !! Computer Science Division Technical Report No. UCB//CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested
     !! on machines which conform to the ieee-754 floating point standard.
     !! DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and
     !! when partial spectrum requests are made.
     !! Normal execution of DSTEMR may create NaNs and infinities and
     !! hence may abort due to a floating point exception in environments
     !! which do not handle NaNs and infinities in the ieee standard default
     !! manner.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, lquery, valeig, wantz, tryrac
           character :: order
           integer(ilp) :: i, ieeeok, imax, indibl, indifl, indisp, indiwo, iscale, itmp1, j, jj, &
                     liwmin, lwmin, nsplit
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           ieeeok = stdlib_ilaenv( 10, 'DSTEVR', 'N', 1, 2, 3, 4 )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ) .or. ( liwork==-1 ) )
           lwmin = max( 1, 20*n )
           liwmin = max( 1, 10*n )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -14
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -17
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -19
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           end if
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! initialize indices into workspaces.  note: these indices are used only
           ! if stdlib_${ri}$sterf or stdlib_${ri}$stemr fail.
           ! iwork(indibl:indibl+m-1) corresponds to iblock in stdlib_${ri}$stebz and
           ! stores the block indices of each of the m<=n eigenvalues.
           indibl = 1
           ! iwork(indisp:indisp+nsplit-1) corresponds to isplit in stdlib_${ri}$stebz and
           ! stores the starting and finishing indices of each block.
           indisp = indibl + n
           ! iwork(indifl:indifl+n-1) stores the indices of eigenvectors
           ! that corresponding to eigenvectors that fail to converge in
           ! stdlib_${ri}$stein.  this information is discarded; if any fail, the driver
           ! returns info > 0.
           indifl = indisp + n
           ! indiwo is the offset of the remaining integer workspace.
           indiwo = indisp + n
           ! if all eigenvalues are desired, then
           ! call stdlib_${ri}$sterf or stdlib_${ri}$stemr.  if this fails for some eigenvalue, then
           ! try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ieeeok==1 ) then
              call stdlib_${ri}$copy( n-1, e( 1 ), 1, work( 1 ), 1 )
              if( .not.wantz ) then
                 call stdlib_${ri}$copy( n, d, 1, w, 1 )
                 call stdlib_${ri}$sterf( n, w, work, info )
              else
                 call stdlib_${ri}$copy( n, d, 1, work( n+1 ), 1 )
                 if (abstol <= two*n*eps) then
                    tryrac = .true.
                 else
                    tryrac = .false.
                 end if
                 call stdlib_${ri}$stemr( jobz, 'A', n, work( n+1 ), work, vl, vu, il,iu, m, w, z, ldz,&
                            n, isuppz, tryrac,work( 2*n+1 ), lwork-2*n, iwork, liwork, info )
              end if
              if( info==0 ) then
                 m = n
                 go to 10
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_${ri}$stein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ), work,iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_${ri}$stein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work, &
                        iwork( indiwo ), iwork( indifl ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           10 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( i )
                    w( i ) = w( j )
                    iwork( i ) = iwork( j )
                    w( j ) = tmp1
                    iwork( j ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                 end if
              end do
           end if
            ! causes problems with tests 19
            ! if (wantz .and. indeig ) z( 1,1) = z(1,1) / 1.002_${rk}$ + .002
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stevr


     pure subroutine stdlib_${ri}$stevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! DSTEVX: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix A.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
               work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, valeig, wantz
           character :: order
           integer(ilp) :: i, imax, indibl, indisp, indiwo, indwrk, iscale, itmp1, j, jj, &
                     nsplit
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           end if
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! if all eigenvalues are desired and abstol is less than zero, then
           ! call stdlib_${ri}$sterf or stdlib_dsteqr.  if this fails for some eigenvalue, then
           ! try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_${ri}$copy( n, d, 1, w, 1 )
              call stdlib_${ri}$copy( n-1, e( 1 ), 1, work( 1 ), 1 )
              indwrk = n + 1
              if( .not.wantz ) then
                 call stdlib_${ri}$sterf( n, w, work, info )
              else
                 call stdlib_${ri}$steqr( 'I', n, w, work, z, ldz, work( indwrk ), info )
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 20
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indwrk = 1
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ),work( indwrk ), iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_${ri}$stein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work( &
                        indwrk ), iwork( indiwo ), ifail,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           20 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$stevx


     pure subroutine stdlib_${ri}$sycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! DSYCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ri}$sytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$sycon


     pure subroutine stdlib_${ri}$sycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! DSYCON_ROOK: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ri}$sytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$sycon_rook


     pure subroutine stdlib_${ri}$syconv( uplo, way, n, a, lda, ipiv, e, info )
     !! DSYCONV: convert A given by TRF into L and D and vice-versa.
     !! Get Non-diag elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           real(${rk}$) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
            ! a is upper
            ! convert a (a is upper)
              ! convert value
              if ( convert ) then
                 i=n
                 e(1)=zero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=zero
                       a(i-1,i)=zero
                       i=i-1
                    else
                       e(i)=zero
                    endif
                    i=i-1
                 end do
              ! convert permutations
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0) then
                    ip=ipiv(i)
                    if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                    endif
                 else
                   ip=-ipiv(i)
                    if( i < n) then
                  do j= i+1,n
                      temp=a(ip,j)
                      a(ip,j)=a(i-1,j)
                      a(i-1,j)=temp
                  end do
                     endif
                     i=i-1
                endif
                i=i-1
             end do
              else
            ! revert a (a is upper)
              ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
              ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
            ! a is lower
              if ( convert ) then
            ! convert a (a is lower)
              ! convert value
                 i=1
                 e(n)=zero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=zero
                       a(i+1,i)=zero
                       i=i+1
                    else
                       e(i)=zero
                    endif
                    i=i+1
                 end do
              ! convert permutations
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                    ip=ipiv(i)
                    if (i > 1) then
                    do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i,j)
                      a(i,j)=temp
                    end do
                    endif
                 else
                   ip=-ipiv(i)
                   if (i > 1) then
                   do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i+1,j)
                      a(i+1,j)=temp
                   end do
                   endif
                   i=i+1
                endif
                i=i+1
             end do
              else
            ! revert a (a is lower)
              ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
              ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$syconv


     pure subroutine stdlib_${ri}$syconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! DSYCONVF: converts the factorization output format used in
     !! DSYTRF provided on entry in parameter A into the factorization
     !! output format used in DSYTRF_RK (or DSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in DSYTRF into
     !! the format used in DSYTRF_RK (or DSYTRF_BK).
     !! If parameter WAY = 'R':
     !! DSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in DSYTRF_RK
     !! (or DSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in DSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in DSYTRF_RK
     !! (or DSYTRF_BK) into the format used in DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_${ri}$syconvf


     pure subroutine stdlib_${ri}$syconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! DSYCONVF_ROOK: converts the factorization output format used in
     !! DSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in DSYTRF_RK (or DSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for DSYTRF_ROOK and
     !! DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! DSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in DSYTRF_RK
     !! (or DSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in DSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for DSYTRF_ROOK and
     !! DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_${ri}$syconvf_rook


     pure subroutine stdlib_${ri}$syequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! DSYEQUB: computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(${rk}$) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'DSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_${rk}$ / s( j )
           end do
           tol = one / sqrt( 2.0_${rk}$ * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + s( i )*work( i )
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_${ri}$lassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = abs( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( work( i ) - t*si )
                 c0 = -(t*si)*si + 2*work( i )*si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + work( i ) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_${ri}$lamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_${ri}$lamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_${ri}$syequb


     subroutine stdlib_${ri}$syev( jobz, uplo, n, a, lda, w, work, lwork, info )
     !! DSYEV: computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, lquery, wantz
           integer(ilp) :: iinfo, imax, inde, indtau, indwrk, iscale, llwork, lwkopt, nb
           real(${rk}$) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           lquery = ( lwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, ( nb+2 )*n )
              work( 1 ) = lwkopt
              if( lwork<max( 1, 3*n-1 ) .and. .not.lquery )info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              return
           end if
           if( n==1 ) then
              w( 1 ) = a( 1, 1 )
              work( 1 ) = 2
              if( wantz )a( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_${ri}$lansy( 'M', uplo, n, a, lda, work )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 )call stdlib_${ri}$lascl( uplo, 0, 0, one, sigma, n, n, a, lda, info )
           ! call stdlib_${ri}$sytrd to reduce symmetric matrix to tridiagonal form.
           inde = 1
           indtau = inde + n
           indwrk = indtau + n
           llwork = lwork - indwrk + 1
           call stdlib_${ri}$sytrd( uplo, n, a, lda, w, work( inde ), work( indtau ),work( indwrk ), &
                     llwork, iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, first call
           ! stdlib_${ri}$orgtr to generate the orthogonal matrix, then call stdlib_${ri}$steqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$orgtr( uplo, n, a, lda, work( indtau ), work( indwrk ),llwork, iinfo )
                        
              call stdlib_${ri}$steqr( jobz, n, w, work( inde ), a, lda, work( indtau ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! set work(1) to optimal workspace size.
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$syev


     subroutine stdlib_${ri}$syevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )
     !! DSYEVD: computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric matrix A. If eigenvectors are desired, it uses a
     !! divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
     !! Because of large use of BLAS of level 3, DSYEVD needs N**2 more
     !! workspace than DSYEVX.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, lquery, wantz
           integer(ilp) :: iinfo, inde, indtau, indwk2, indwrk, iscale, liopt, liwmin, llwork, &
                     llwrk2, lopt, lwmin
           real(${rk}$) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 liwmin = 1
                 lwmin = 1
                 lopt = lwmin
                 liopt = liwmin
              else
                 if( wantz ) then
                    liwmin = 3 + 5*n
                    lwmin = 1 + 6*n + 2*n**2
                 else
                    liwmin = 1
                    lwmin = 2*n + 1
                 end if
                 lopt = max( lwmin, 2*n +stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 ) )
                           
                 liopt = liwmin
              end if
              work( 1 ) = lopt
              iwork( 1 ) = liopt
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = a( 1, 1 )
              if( wantz )a( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_${ri}$lansy( 'M', uplo, n, a, lda, work )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 )call stdlib_${ri}$lascl( uplo, 0, 0, one, sigma, n, n, a, lda, info )
           ! call stdlib_${ri}$sytrd to reduce symmetric matrix to tridiagonal form.
           inde = 1
           indtau = inde + n
           indwrk = indtau + n
           llwork = lwork - indwrk + 1
           indwk2 = indwrk + n*n
           llwrk2 = lwork - indwk2 + 1
           call stdlib_${ri}$sytrd( uplo, n, a, lda, w, work( inde ), work( indtau ),work( indwrk ), &
                     llwork, iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, first call
           ! stdlib_${ri}$stedc to generate the eigenvector matrix, work(indwrk), of the
           ! tridiagonal matrix, then call stdlib_${ri}$ormtr to multiply it by the
           ! householder transformations stored in a.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$stedc( 'I', n, w, work( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, iwork, liwork, info )
              call stdlib_${ri}$ormtr( 'L', uplo, 'N', n, n, a, lda, work( indtau ),work( indwrk ), n, &
                        work( indwk2 ), llwrk2, iinfo )
              call stdlib_${ri}$lacpy( 'A', n, n, work( indwrk ), n, a, lda )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_${ri}$scal( n, one / sigma, w, 1 )
           work( 1 ) = lopt
           iwork( 1 ) = liopt
           return
     end subroutine stdlib_${ri}$syevd


     subroutine stdlib_${ri}$syevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! DSYEVR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
     !! selected by specifying either a range of values or a range of
     !! indices for the desired eigenvalues.
     !! DSYEVR first reduces the matrix A to tridiagonal form T with a call
     !! to DSYTRD.  Then, whenever possible, DSYEVR calls DSTEMR to compute
     !! the eigenspectrum using Relatively Robust Representations.  DSTEMR
     !! computes eigenvalues by the dqds algorithm, while orthogonal
     !! eigenvectors are computed from various "good" L D L^T representations
     !! (also known as Relatively Robust Representations). Gram-Schmidt
     !! orthogonalization is avoided as far as possible. More specifically,
     !! the various steps of the algorithm are as follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! The desired accuracy of the output can be specified by the input
     !! parameter ABSTOL.
     !! For more details, see DSTEMR's documentation and:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested
     !! on machines which conform to the ieee-754 floating point standard.
     !! DSYEVR calls DSTEBZ and DSTEIN on non-ieee machines and
     !! when partial spectrum requests are made.
     !! Normal execution of DSTEMR may create NaNs and infinities and
     !! hence may abort due to a floating point exception in environments
     !! which do not handle NaNs and infinities in the ieee standard default
     !! manner.
               isuppz, work, lwork,iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, lda, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lower, lquery, valeig, wantz, tryrac
           character :: order
           integer(ilp) :: i, ieeeok, iinfo, imax, indd, inddd, inde, indee, indibl, indifl, &
           indisp, indiwo, indtau, indwk, indwkn, iscale, j, jj, liwmin, llwork, llwrkn, lwkopt, &
                     lwmin, nb, nsplit
           real(${rk}$) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           ieeeok = stdlib_ilaenv( 10, 'DSYEVR', 'N', 1, 2, 3, 4 )
           lower = stdlib_lsame( uplo, 'L' )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ) .or. ( liwork==-1 ) )
           lwmin = max( 1, 26*n )
           liwmin = max( 1, 10*n )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -8
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -9
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -10
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              nb = max( nb, stdlib_ilaenv( 1, 'DORMTR', uplo, n, -1, -1, -1 ) )
              lwkopt = max( ( nb+1 )*n, lwmin )
              work( 1 ) = lwkopt
              iwork( 1 ) = liwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYEVR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( n==1 ) then
              work( 1 ) = 7
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = a( 1, 1 )
              else
                 if( vl<a( 1, 1 ) .and. vu>=a( 1, 1 ) ) then
                    m = 1
                    w( 1 ) = a( 1, 1 )
                 end if
              end if
              if( wantz ) then
                 z( 1, 1 ) = one
                 isuppz( 1 ) = 1
                 isuppz( 2 ) = 1
              end if
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if (valeig) then
              vll = vl
              vuu = vu
           end if
           anrm = stdlib_${ri}$lansy( 'M', uplo, n, a, lda, work )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 do j = 1, n
                    call stdlib_${ri}$scal( n-j+1, sigma, a( j, j ), 1 )
                 end do
              else
                 do j = 1, n
                    call stdlib_${ri}$scal( j, sigma, a( 1, j ), 1 )
                 end do
              end if
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! initialize indices into workspaces.  note: the iwork indices are
           ! used only if stdlib_${ri}$sterf or stdlib_${ri}$stemr fail.
           ! work(indtau:indtau+n-1) stores the scalar factors of the
           ! elementary reflectors used in stdlib_${ri}$sytrd.
           indtau = 1
           ! work(indd:indd+n-1) stores the tridiagonal's diagonal entries.
           indd = indtau + n
           ! work(inde:inde+n-1) stores the off-diagonal entries of the
           ! tridiagonal matrix from stdlib_${ri}$sytrd.
           inde = indd + n
           ! work(inddd:inddd+n-1) is a copy of the diagonal entries over
           ! -written by stdlib_${ri}$stemr (the stdlib_${ri}$sterf path copies the diagonal to w).
           inddd = inde + n
           ! work(indee:indee+n-1) is a copy of the off-diagonal entries over
           ! -written while computing the eigenvalues in stdlib_${ri}$sterf and stdlib_${ri}$stemr.
           indee = inddd + n
           ! indwk is the starting offset of the left-over workspace, and
           ! llwork is the remaining workspace size.
           indwk = indee + n
           llwork = lwork - indwk + 1
           ! iwork(indibl:indibl+m-1) corresponds to iblock in stdlib_${ri}$stebz and
           ! stores the block indices of each of the m<=n eigenvalues.
           indibl = 1
           ! iwork(indisp:indisp+nsplit-1) corresponds to isplit in stdlib_${ri}$stebz and
           ! stores the starting and finishing indices of each block.
           indisp = indibl + n
           ! iwork(indifl:indifl+n-1) stores the indices of eigenvectors
           ! that corresponding to eigenvectors that fail to converge in
           ! stdlib_${ri}$stein.  this information is discarded; if any fail, the driver
           ! returns info > 0.
           indifl = indisp + n
           ! indiwo is the offset of the remaining integer workspace.
           indiwo = indifl + n
           ! call stdlib_${ri}$sytrd to reduce symmetric matrix to tridiagonal form.
           call stdlib_${ri}$sytrd( uplo, n, a, lda, work( indd ), work( inde ),work( indtau ), work( &
                     indwk ), llwork, iinfo )
           ! if all eigenvalues are desired
           ! then call stdlib_${ri}$sterf or stdlib_${ri}$stemr and stdlib_${ri}$ormtr.
           if( ( alleig .or. ( indeig .and. il==1 .and. iu==n ) ) .and.ieeeok==1 ) then
              if( .not.wantz ) then
                 call stdlib_${ri}$copy( n, work( indd ), 1, w, 1 )
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$sterf( n, w, work( indee ), info )
              else
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$copy( n, work( indd ), 1, work( inddd ), 1 )
                 if (abstol <= two*n*eps) then
                    tryrac = .true.
                 else
                    tryrac = .false.
                 end if
                 call stdlib_${ri}$stemr( jobz, 'A', n, work( inddd ), work( indee ),vl, vu, il, iu, m,&
                            w, z, ldz, n, isuppz,tryrac, work( indwk ), lwork, iwork, liwork,info )
              ! apply orthogonal matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stemr.
                 if( wantz .and. info==0 ) then
                    indwkn = inde
                    llwrkn = lwork - indwkn + 1
                    call stdlib_${ri}$ormtr( 'L', uplo, 'N', n, m, a, lda,work( indtau ), z, ldz, work(&
                               indwkn ),llwrkn, iinfo )
                 end if
              end if
              if( info==0 ) then
                 ! everything worked.  skip stdlib_${ri}$stebz/stdlib_${ri}$stein.  iwork(:) are
                 ! undefined.
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_${ri}$stein.
           ! also call stdlib_${ri}$stebz and stdlib_${ri}$stein if stdlib_${ri}$stemr fails.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstll,work( indd ), work( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwk ),iwork( indiwo ), info )
                     
           if( wantz ) then
              call stdlib_${ri}$stein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwk ), iwork( indiwo ), iwork( indifl ),info )
              ! apply orthogonal matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stein.
              indwkn = inde
              llwrkn = lwork - indwkn + 1
              call stdlib_${ri}$ormtr( 'L', uplo, 'N', n, m, a, lda, work( indtau ), z,ldz, work( &
                        indwkn ), llwrkn, iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
        ! jump here if stdlib_${ri}$stemr/stdlib_${ri}$stein succeeded.
        30 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.  note: we do not sort the ifail portion of iwork.
           ! it may not be initialized (if stdlib_${ri}$stemr/stdlib_${ri}$stein succeeded), and we do
           ! not return this detailed information to the user.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    w( i ) = w( j )
                    w( j ) = tmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                 end if
              end do
           end if
           ! set work(1) to optimal workspace size.
           work( 1 ) = lwkopt
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$syevr


     subroutine stdlib_${ri}$syevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! DSYEVX: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
     !! selected by specifying either a range of values or a range of indices
     !! for the desired eigenvalues.
               work, lwork, iwork,ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lower, lquery, test, valeig, wantz
           character :: order
           integer(ilp) :: i, iinfo, imax, indd, inde, indee, indibl, indisp, indiwo, indtau, &
           indwkn, indwrk, iscale, itmp1, j, jj, llwork, llwrkn, lwkmin, lwkopt, nb, &
                     nsplit
           real(${rk}$) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           lower = stdlib_lsame( uplo, 'L' )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( lwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -8
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -9
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -10
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -15
              end if
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwkmin = 1
                 work( 1 ) = lwkmin
              else
                 lwkmin = 8*n
                 nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
                 nb = max( nb, stdlib_ilaenv( 1, 'DORMTR', uplo, n, -1, -1, -1 ) )
                 lwkopt = max( lwkmin, ( nb + 3 )*n )
                 work( 1 ) = lwkopt
              end if
              if( lwork<lwkmin .and. .not.lquery )info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 ) then
              return
           end if
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = a( 1, 1 )
              else
                 if( vl<a( 1, 1 ) .and. vu>=a( 1, 1 ) ) then
                    m = 1
                    w( 1 ) = a( 1, 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if( valeig ) then
              vll = vl
              vuu = vu
           end if
           anrm = stdlib_${ri}$lansy( 'M', uplo, n, a, lda, work )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 do j = 1, n
                    call stdlib_${ri}$scal( n-j+1, sigma, a( j, j ), 1 )
                 end do
              else
                 do j = 1, n
                    call stdlib_${ri}$scal( j, sigma, a( 1, j ), 1 )
                 end do
              end if
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! call stdlib_${ri}$sytrd to reduce symmetric matrix to tridiagonal form.
           indtau = 1
           inde = indtau + n
           indd = inde + n
           indwrk = indd + n
           llwork = lwork - indwrk + 1
           call stdlib_${ri}$sytrd( uplo, n, a, lda, work( indd ), work( inde ),work( indtau ), work( &
                     indwrk ), llwork, iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal to
           ! zero, then call stdlib_${ri}$sterf or stdlib_${ri}$orgtr and stdlib_dsteqr.  if this fails for
           ! some eigenvalue, then try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_${ri}$copy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              if( .not.wantz ) then
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$sterf( n, w, work( indee ), info )
              else
                 call stdlib_${ri}$lacpy( 'A', n, n, a, lda, z, ldz )
                 call stdlib_${ri}$orgtr( uplo, n, z, ldz, work( indtau ),work( indwrk ), llwork, &
                           iinfo )
                 call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
                 call stdlib_${ri}$steqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 40
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstll,work( indd ), work( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info &
                     )
           if( wantz ) then
              call stdlib_${ri}$stein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply orthogonal matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stein.
              indwkn = inde
              llwrkn = lwork - indwkn + 1
              call stdlib_${ri}$ormtr( 'L', uplo, 'N', n, m, a, lda, work( indtau ), z,ldz, work( &
                        indwkn ), llwrkn, iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           40 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           ! set work(1) to optimal workspace size.
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$syevx


     pure subroutine stdlib_${ri}$sygs2( itype, uplo, n, a, lda, b, ldb, info )
     !! DSYGS2: reduces a real symmetric-definite generalized eigenproblem
     !! to standard form.
     !! If ITYPE = 1, the problem is A*x = lambda*B*x,
     !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
     !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T *A*L.
     !! B must have been previously factorized as U**T *U or L*L**T by DPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k
           real(${rk}$) :: akk, bkk, ct
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYGS2', -info )
              return
           end if
           if( itype==1 ) then
              if( upper ) then
                 ! compute inv(u**t)*a*inv(u)
                 do k = 1, n
                    ! update the upper triangle of a(k:n,k:n)
                    akk = a( k, k )
                    bkk = b( k, k )
                    akk = akk / bkk**2
                    a( k, k ) = akk
                    if( k<n ) then
                       call stdlib_${ri}$scal( n-k, one / bkk, a( k, k+1 ), lda )
                       ct = -half*akk
                       call stdlib_${ri}$axpy( n-k, ct, b( k, k+1 ), ldb, a( k, k+1 ),lda )
                       call stdlib_${ri}$syr2( uplo, n-k, -one, a( k, k+1 ), lda,b( k, k+1 ), ldb, a( &
                                 k+1, k+1 ), lda )
                       call stdlib_${ri}$axpy( n-k, ct, b( k, k+1 ), ldb, a( k, k+1 ),lda )
                       call stdlib_${ri}$trsv( uplo, 'TRANSPOSE', 'NON-UNIT', n-k,b( k+1, k+1 ), ldb, &
                                 a( k, k+1 ), lda )
                    end if
                 end do
              else
                 ! compute inv(l)*a*inv(l**t)
                 do k = 1, n
                    ! update the lower triangle of a(k:n,k:n)
                    akk = a( k, k )
                    bkk = b( k, k )
                    akk = akk / bkk**2
                    a( k, k ) = akk
                    if( k<n ) then
                       call stdlib_${ri}$scal( n-k, one / bkk, a( k+1, k ), 1 )
                       ct = -half*akk
                       call stdlib_${ri}$axpy( n-k, ct, b( k+1, k ), 1, a( k+1, k ), 1 )
                       call stdlib_${ri}$syr2( uplo, n-k, -one, a( k+1, k ), 1,b( k+1, k ), 1, a( k+1, &
                                 k+1 ), lda )
                       call stdlib_${ri}$axpy( n-k, ct, b( k+1, k ), 1, a( k+1, k ), 1 )
                       call stdlib_${ri}$trsv( uplo, 'NO TRANSPOSE', 'NON-UNIT', n-k,b( k+1, k+1 ), &
                                 ldb, a( k+1, k ), 1 )
                    end if
                 end do
              end if
           else
              if( upper ) then
                 ! compute u*a*u**t
                 do k = 1, n
                    ! update the upper triangle of a(1:k,1:k)
                    akk = a( k, k )
                    bkk = b( k, k )
                    call stdlib_${ri}$trmv( uplo, 'NO TRANSPOSE', 'NON-UNIT', k-1, b,ldb, a( 1, k ), 1 &
                              )
                    ct = half*akk
                    call stdlib_${ri}$axpy( k-1, ct, b( 1, k ), 1, a( 1, k ), 1 )
                    call stdlib_${ri}$syr2( uplo, k-1, one, a( 1, k ), 1, b( 1, k ), 1,a, lda )
                    call stdlib_${ri}$axpy( k-1, ct, b( 1, k ), 1, a( 1, k ), 1 )
                    call stdlib_${ri}$scal( k-1, bkk, a( 1, k ), 1 )
                    a( k, k ) = akk*bkk**2
                 end do
              else
                 ! compute l**t *a*l
                 do k = 1, n
                    ! update the lower triangle of a(1:k,1:k)
                    akk = a( k, k )
                    bkk = b( k, k )
                    call stdlib_${ri}$trmv( uplo, 'TRANSPOSE', 'NON-UNIT', k-1, b, ldb,a( k, 1 ), lda )
                              
                    ct = half*akk
                    call stdlib_${ri}$axpy( k-1, ct, b( k, 1 ), ldb, a( k, 1 ), lda )
                    call stdlib_${ri}$syr2( uplo, k-1, one, a( k, 1 ), lda, b( k, 1 ),ldb, a, lda )
                              
                    call stdlib_${ri}$axpy( k-1, ct, b( k, 1 ), ldb, a( k, 1 ), lda )
                    call stdlib_${ri}$scal( k-1, bkk, a( k, 1 ), lda )
                    a( k, k ) = akk*bkk**2
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$sygs2


     pure subroutine stdlib_${ri}$sygst( itype, uplo, n, a, lda, b, ldb, info )
     !! DSYGST: reduces a real symmetric-definite generalized eigenproblem
     !! to standard form.
     !! If ITYPE = 1, the problem is A*x = lambda*B*x,
     !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
     !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
     !! B must have been previously factorized as U**T*U or L*L**T by DPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYGST', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'DSYGST', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_${ri}$sygs2( itype, uplo, n, a, lda, b, ldb, info )
           else
              ! use blocked code
              if( itype==1 ) then
                 if( upper ) then
                    ! compute inv(u**t)*a*inv(u)
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the upper triangle of a(k:n,k:n)
                       call stdlib_${ri}$sygs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                       if( k+kb<=n ) then
                          call stdlib_${ri}$trsm( 'LEFT', uplo, 'TRANSPOSE', 'NON-UNIT',kb, n-k-kb+1, &
                                    one, b( k, k ), ldb,a( k, k+kb ), lda )
                          call stdlib_${ri}$symm( 'LEFT', uplo, kb, n-k-kb+1, -half,a( k, k ), lda, b( &
                                    k, k+kb ), ldb, one,a( k, k+kb ), lda )
                          call stdlib_${ri}$syr2k( uplo, 'TRANSPOSE', n-k-kb+1, kb, -one,a( k, k+kb ), &
                                    lda, b( k, k+kb ), ldb,one, a( k+kb, k+kb ), lda )
                          call stdlib_${ri}$symm( 'LEFT', uplo, kb, n-k-kb+1, -half,a( k, k ), lda, b( &
                                    k, k+kb ), ldb, one,a( k, k+kb ), lda )
                          call stdlib_${ri}$trsm( 'RIGHT', uplo, 'NO TRANSPOSE','NON-UNIT', kb, n-k-kb+&
                                    1, one,b( k+kb, k+kb ), ldb, a( k, k+kb ),lda )
                       end if
                    end do
                 else
                    ! compute inv(l)*a*inv(l**t)
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the lower triangle of a(k:n,k:n)
                       call stdlib_${ri}$sygs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                       if( k+kb<=n ) then
                          call stdlib_${ri}$trsm( 'RIGHT', uplo, 'TRANSPOSE', 'NON-UNIT',n-k-kb+1, kb, &
                                    one, b( k, k ), ldb,a( k+kb, k ), lda )
                          call stdlib_${ri}$symm( 'RIGHT', uplo, n-k-kb+1, kb, -half,a( k, k ), lda, b(&
                                     k+kb, k ), ldb, one,a( k+kb, k ), lda )
                          call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', n-k-kb+1, kb,-one, a( k+kb, k &
                                    ), lda, b( k+kb, k ),ldb, one, a( k+kb, k+kb ), lda )
                          call stdlib_${ri}$symm( 'RIGHT', uplo, n-k-kb+1, kb, -half,a( k, k ), lda, b(&
                                     k+kb, k ), ldb, one,a( k+kb, k ), lda )
                          call stdlib_${ri}$trsm( 'LEFT', uplo, 'NO TRANSPOSE','NON-UNIT', n-k-kb+1, &
                                    kb, one,b( k+kb, k+kb ), ldb, a( k+kb, k ),lda )
                       end if
                    end do
                 end if
              else
                 if( upper ) then
                    ! compute u*a*u**t
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the upper triangle of a(1:k+kb-1,1:k+kb-1)
                       call stdlib_${ri}$trmm( 'LEFT', uplo, 'NO TRANSPOSE', 'NON-UNIT',k-1, kb, one, &
                                 b, ldb, a( 1, k ), lda )
                       call stdlib_${ri}$symm( 'RIGHT', uplo, k-1, kb, half, a( k, k ),lda, b( 1, k ), &
                                 ldb, one, a( 1, k ), lda )
                       call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', k-1, kb, one,a( 1, k ), lda, b( &
                                 1, k ), ldb, one, a,lda )
                       call stdlib_${ri}$symm( 'RIGHT', uplo, k-1, kb, half, a( k, k ),lda, b( 1, k ), &
                                 ldb, one, a( 1, k ), lda )
                       call stdlib_${ri}$trmm( 'RIGHT', uplo, 'TRANSPOSE', 'NON-UNIT',k-1, kb, one, b( &
                                 k, k ), ldb, a( 1, k ),lda )
                       call stdlib_${ri}$sygs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                    end do
                 else
                    ! compute l**t*a*l
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the lower triangle of a(1:k+kb-1,1:k+kb-1)
                       call stdlib_${ri}$trmm( 'RIGHT', uplo, 'NO TRANSPOSE', 'NON-UNIT',kb, k-1, one, &
                                 b, ldb, a( k, 1 ), lda )
                       call stdlib_${ri}$symm( 'LEFT', uplo, kb, k-1, half, a( k, k ),lda, b( k, 1 ), &
                                 ldb, one, a( k, 1 ), lda )
                       call stdlib_${ri}$syr2k( uplo, 'TRANSPOSE', k-1, kb, one,a( k, 1 ), lda, b( k, &
                                 1 ), ldb, one, a,lda )
                       call stdlib_${ri}$symm( 'LEFT', uplo, kb, k-1, half, a( k, k ),lda, b( k, 1 ), &
                                 ldb, one, a( k, 1 ), lda )
                       call stdlib_${ri}$trmm( 'LEFT', uplo, 'TRANSPOSE', 'NON-UNIT', kb,k-1, one, b( &
                                 k, k ), ldb, a( k, 1 ), lda )
                       call stdlib_${ri}$sygs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$sygst


     subroutine stdlib_${ri}$sygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )
     !! DSYGV: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     !! Here A and B are assumed to be symmetric and B is also
     !! positive definite.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: trans
           integer(ilp) :: lwkmin, lwkopt, nb, neig
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info==0 ) then
              lwkmin = max( 1, 3*n - 1 )
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = max( lwkmin, ( nb + 2 )*n )
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYGV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_${ri}$potrf( uplo, n, b, ldb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_${ri}$sygst( itype, uplo, n, a, lda, b, ldb, info )
           call stdlib_${ri}$syev( jobz, uplo, n, a, lda, w, work, lwork, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              neig = n
              if( info>0 )neig = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**t*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'T'
                 end if
                 call stdlib_${ri}$trsm( 'LEFT', uplo, trans, 'NON-UNIT', n, neig, one,b, ldb, a, lda )
                           
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**t*y
                 if( upper ) then
                    trans = 'T'
                 else
                    trans = 'N'
                 end if
                 call stdlib_${ri}$trmm( 'LEFT', uplo, trans, 'NON-UNIT', n, neig, one,b, ldb, a, lda )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sygv


     subroutine stdlib_${ri}$sygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, liwork,&
     !! DSYGVD: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     !! B are assumed to be symmetric and B is also positive definite.
     !! If eigenvectors are desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
                info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: trans
           integer(ilp) :: liopt, liwmin, lopt, lwmin
           ! Intrinsic Functions 
           intrinsic :: real,max
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              liwmin = 1
              lwmin = 1
           else if( wantz ) then
              liwmin = 3 + 5*n
              lwmin = 1 + 6*n + 2*n**2
           else
              liwmin = 1
              lwmin = 2*n + 1
           end if
           lopt = lwmin
           liopt = liwmin
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info==0 ) then
              work( 1 ) = lopt
              iwork( 1 ) = liopt
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -11
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_${ri}$potrf( uplo, n, b, ldb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_${ri}$sygst( itype, uplo, n, a, lda, b, ldb, info )
           call stdlib_${ri}$syevd( jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork,info )
           lopt = max( real( lopt,KIND=${rk}$), real( work( 1 ),KIND=${rk}$) )
           liopt = max( real( liopt,KIND=${rk}$), real( iwork( 1 ),KIND=${rk}$) )
           if( wantz .and. info==0 ) then
              ! backtransform eigenvectors to the original problem.
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**t*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'T'
                 end if
                 call stdlib_${ri}$trsm( 'LEFT', uplo, trans, 'NON-UNIT', n, n, one,b, ldb, a, lda )
                           
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**t*y
                 if( upper ) then
                    trans = 'T'
                 else
                    trans = 'N'
                 end if
                 call stdlib_${ri}$trmm( 'LEFT', uplo, trans, 'NON-UNIT', n, n, one,b, ldb, a, lda )
                           
              end if
           end if
           work( 1 ) = lopt
           iwork( 1 ) = liopt
           return
     end subroutine stdlib_${ri}$sygvd


     subroutine stdlib_${ri}$sygvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
     !! DSYGVX: computes selected eigenvalues, and optionally, eigenvectors
     !! of a real generalized symmetric-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
     !! and B are assumed to be symmetric and B is also positive definite.
     !! Eigenvalues and eigenvectors can be selected by specifying either a
     !! range of values or a range of indices for the desired eigenvalues.
                m, w, z, ldz, work,lwork, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, upper, valeig, wantz
           character :: trans
           integer(ilp) :: lwkmin, lwkopt, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           upper = stdlib_lsame( uplo, 'U' )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( lwork==-1 )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -3
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -11
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -12
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -13
                 end if
              end if
           end if
           if (info==0) then
              if (ldz<1 .or. (wantz .and. ldz<n)) then
                 info = -18
              end if
           end if
           if( info==0 ) then
              lwkmin = max( 1, 8*n )
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = max( lwkmin, ( nb + 3 )*n )
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYGVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 ) then
              return
           end if
           ! form a cholesky factorization of b.
           call stdlib_${ri}$potrf( uplo, n, b, ldb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_${ri}$sygst( itype, uplo, n, a, lda, b, ldb, info )
           call stdlib_${ri}$syevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol,m, w, z, ldz, &
                     work, lwork, iwork, ifail, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              if( info>0 )m = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**t*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'T'
                 end if
                 call stdlib_${ri}$trsm( 'LEFT', uplo, trans, 'NON-UNIT', n, m, one, b,ldb, z, ldz )
                           
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**t*y
                 if( upper ) then
                    trans = 'T'
                 else
                    trans = 'N'
                 end if
                 call stdlib_${ri}$trmm( 'LEFT', uplo, trans, 'NON-UNIT', n, m, one, b,ldb, z, ldz )
                           
              end if
           end if
           ! set work(1) to optimal workspace size.
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sygvx


     pure subroutine stdlib_${ri}$syrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! DSYRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$symv( uplo, n, -one, a, lda, x( 1, j ), 1, one,work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + abs( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( a( k, k ) )*xk
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$sytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$sytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$sytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$syrfs


     pure subroutine stdlib_${ri}$sysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ri}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ri}$sytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv


     pure subroutine stdlib_${ri}$sysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_aa


     pure subroutine stdlib_${ri}$sysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! DSYSV_RK: computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine DSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ri}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_rk


     pure subroutine stdlib_${ri}$sysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV_ROOK: computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling DSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_${ri}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_rook


     subroutine stdlib_${ri}$sysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! DSYSVX: uses the diagonal pivoting factorization to compute the
     !! solution to a real system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: af(ldaf,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 3*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'DSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_${ri}$lacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_${ri}$sytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansy( 'I', uplo, n, a, lda, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$sycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, iwork,info )
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$sytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$syrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysvx


     pure subroutine stdlib_${ri}$syswapr( uplo, n, a, lda, i1, i2)
     !! DSYSWAPR: applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(${rk}$) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_${ri}$swap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_${ri}$swap( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_${ri}$syswapr


     pure subroutine stdlib_${ri}$sytd2( uplo, n, a, lda, d, e, tau, info )
     !! DSYTD2: reduces a real symmetric matrix A to symmetric tridiagonal
     !! form T by an orthogonal similarity transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(${rk}$) :: alpha, taui
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_${ri}$larfg( i, a( i, i+1 ), a( 1, i+1 ), 1, taui )
                 e( i ) = a( i, i+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = one
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_${ri}$symv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, zero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_${ri}$axpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$syr2( uplo, i, -one, a( 1, i+1 ), 1, tau, 1, a,lda )
                    a( i, i+1 ) = e( i )
                 end if
                 d( i+1 ) = a( i+1, i+1 )
                 tau( i ) = taui
              end do
              d( 1 ) = a( 1, 1 )
           else
              ! reduce the lower triangle of a
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_${ri}$larfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,taui )
                 e( i ) = a( i+1, i )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = one
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_${ri}$symv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_${ri}$axpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$syr2( uplo, n-i, -one, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 ),&
                               lda )
                    a( i+1, i ) = e( i )
                 end if
                 d( i ) = a( i, i )
                 tau( i ) = taui
              end do
              d( n ) = a( n, n )
           end if
           return
     end subroutine stdlib_${ri}$sytd2


     pure subroutine stdlib_${ri}$sytf2( uplo, n, a, lda, ipiv, info )
     !! DSYTF2: computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_${ri}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_i${ri}$amax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ri}$amax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ri}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / a( k, k )
                    call stdlib_${ri}$syr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_${ri}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_i${ri}$amax( imax-k, a( imax, k ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ri}$amax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_${ri}$swap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       d11 = one / a( k, k )
                       call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_${ri}$scal( n-k, d11, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( (a(k) a(k+1))*d(k)**(-1) ) * (a(k) a(k+1))**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ri}$sytf2


     pure subroutine stdlib_${ri}$sytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! DSYTF2_RK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, dtemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_${ri}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_${ri}$swap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ri}$swap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_${ri}$swap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ri}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ri}$scal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = zero
                    a( k-1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_${ri}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_${ri}$swap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ri}$swap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_${ri}$swap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ri}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ri}$scal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = zero
                    a( k+1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_${ri}$sytf2_rk


     pure subroutine stdlib_${ri}$sytf2_rook( uplo, n, a, lda, ipiv, info )
     !! DSYTF2_ROOK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, dtemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_${ri}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_${ri}$swap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_${ri}$swap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ri}$scal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_${ri}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_${ri}$swap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_${ri}$swap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ri}$scal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ri}$sytf2_rook


     pure subroutine stdlib_${ri}$sytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! DSYTRD: reduces a real symmetric matrix A to real symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'DSYTRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'DSYTRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_${ri}$latrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', i-1, nb, -one, a( 1, i ),lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_${ri}$sytd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_${ri}$latrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+ib:n,i+ib:n), using
                 ! an update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -one,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_${ri}$sytd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrd


     subroutine stdlib_${ri}$sytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
     !! DSYTRD_SB2ST: reduces a real symmetric band matrix A to real symmetric
     !! tridiagonal form T by a orthogonal similarity transformation:
     !! Q**T * A * Q = T.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: stage1, uplo, vect
           integer(ilp), intent(in) :: n, kd, ldab, lhous, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(out) :: d(*), e(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: hous(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: rzero = 0.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wantq, upper, afters1
           integer(ilp) :: i, m, k, ib, sweepid, myid, shift, stt, st, ed, stind, edind, &
           blklastind, colpt, thed, stepercol, grsiz, thgrsiz, thgrnb, thgrid, nbtiles, ttype, &
           tid, nthreads, debug, abdpos, abofdpos, dpos, ofdpos, awpos, inda, indw, apos, sizea, &
                     lda, indv, indtau, sidev, sizetau, ldv, lhmin, lwmin
           ! Intrinsic Functions 
           intrinsic :: min,max,ceiling,real
           ! Executable Statements 
           ! determine the minimal workspace size required.
           ! test the input parameters
           debug   = 0
           info    = 0
           afters1 = stdlib_lsame( stage1, 'Y' )
           wantq   = stdlib_lsame( vect, 'V' )
           upper   = stdlib_lsame( uplo, 'U' )
           lquery  = ( lwork==-1 ) .or. ( lhous==-1 )
           ! determine the block size, the workspace size and the hous size.
           ib     = stdlib_ilaenv2stage( 2, 'DSYTRD_SB2ST', vect, n, kd, -1, -1 )
           lhmin  = stdlib_ilaenv2stage( 3, 'DSYTRD_SB2ST', vect, n, kd, ib, -1 )
           lwmin  = stdlib_ilaenv2stage( 4, 'DSYTRD_SB2ST', vect, n, kd, ib, -1 )
           if( .not.afters1 .and. .not.stdlib_lsame( stage1, 'N' ) ) then
              info = -1
           else if( .not.stdlib_lsame( vect, 'N' ) ) then
              info = -2
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( ldab<(kd+1) ) then
              info = -7
           else if( lhous<lhmin .and. .not.lquery ) then
              info = -11
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              hous( 1 ) = lhmin
              work( 1 ) = lwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRD_SB2ST', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
               hous( 1 ) = 1
               work( 1 ) = 1
               return
           end if
           ! determine pointer position
           ldv      = kd + ib
           sizetau  = 2 * n
           sidev    = 2 * n
           indtau   = 1
           indv     = indtau + sizetau
           lda      = 2 * kd + 1
           sizea    = lda * n
           inda     = 1
           indw     = inda + sizea
           nthreads = 1
           tid      = 0
           if( upper ) then
               apos     = inda + kd
               awpos    = inda
               dpos     = apos + kd
               ofdpos   = dpos - 1
               abdpos   = kd + 1
               abofdpos = kd
           else
               apos     = inda
               awpos    = inda + kd + 1
               dpos     = apos
               ofdpos   = dpos + 1
               abdpos   = 1
               abofdpos = 2
           endif
           ! case kd=0:
           ! the matrix is diagonal. we just copy it (convert to "real" for
           ! real because d is double and the imaginary part should be 0)
           ! and store it in d. a sequential code here is better or
           ! in a parallel environment it might need two cores for d and e
           if( kd==0 ) then
               do i = 1, n
                   d( i ) = ( ab( abdpos, i ) )
               end do
               do i = 1, n-1
                   e( i ) = rzero
               end do
               hous( 1 ) = 1
               work( 1 ) = 1
               return
           end if
           ! case kd=1:
           ! the matrix is already tridiagonal. we have to make diagonal
           ! and offdiagonal elements real, and store them in d and e.
           ! for that, for real precision just copy the diag and offdiag
           ! to d and e while for the complex case the bulge chasing is
           ! performed to convert the hermetian tridiagonal to symmetric
           ! tridiagonal. a simpler conversion formula might be used, but then
           ! updating the q matrix will be required and based if q is generated
           ! or not this might complicate the story.
           if( kd==1 ) then
               do i = 1, n
                   d( i ) = ( ab( abdpos, i ) )
               end do
               if( upper ) then
                   do i = 1, n-1
                      e( i ) = ( ab( abofdpos, i+1 ) )
                   end do
               else
                   do i = 1, n-1
                      e( i ) = ( ab( abofdpos, i ) )
                   end do
               endif
               hous( 1 ) = 1
               work( 1 ) = 1
               return
           end if
           ! main code start here.
           ! reduce the symmetric band of a to a tridiagonal matrix.
           thgrsiz   = n
           grsiz     = 1
           shift     = 3
           nbtiles   = ceiling( real(n,KIND=${rk}$)/real(kd,KIND=${rk}$) )
           stepercol = ceiling( real(shift,KIND=${rk}$)/real(grsiz,KIND=${rk}$) )
           thgrnb    = ceiling( real(n-1,KIND=${rk}$)/real(thgrsiz,KIND=${rk}$) )
           call stdlib_${ri}$lacpy( "A", kd+1, n, ab, ldab, work( apos ), lda )
           call stdlib_${ri}$laset( "A", kd,   n, zero, zero, work( awpos ), lda )
           ! openmp parallelisation start here
           !$OMP PARALLEL PRIVATE( TID, THGRID, BLKLASTIND ) &
           !$OMP&         PRIVATE( THED, I, M, K, ST, ED, STT, SWEEPID ) &
           !$OMP&         PRIVATE( MYID, TTYPE, COLPT, STIND, EDIND ) &
           !$OMP&         SHARED ( UPLO, WANTQ, INDV, INDTAU, HOUS, WORK) &
           !$OMP&         SHARED ( N, KD, IB, NBTILES, LDA, LDV, INDA ) &
           !$OMP&         SHARED ( STEPERCOL, THGRNB, THGRSIZ, GRSIZ, SHIFT )
           !$OMP MASTER
           ! main bulge chasing loop
           loop_100: do thgrid = 1, thgrnb
               stt  = (thgrid-1)*thgrsiz+1
               thed = min( (stt + thgrsiz -1), (n-1))
               loop_110: do i = stt, n-1
                   ed = min( i, thed )
                   if( stt>ed ) exit
                   loop_120: do m = 1, stepercol
                       st = stt
                       loop_130: do sweepid = st, ed
                           loop_140: do k = 1, grsiz
                               myid  = (i-sweepid)*(stepercol*grsiz)+ (m-1)*grsiz + k
                               if ( myid==1 ) then
                                   ttype = 1
                               else
                                   ttype = mod( myid, 2 ) + 2
                               endif
                               if( ttype==2 ) then
                                   colpt      = (myid/2)*kd + sweepid
                                   stind      = colpt-kd+1
                                   edind      = min(colpt,n)
                                   blklastind = colpt
                               else
                                   colpt      = ((myid+1)/2)*kd + sweepid
                                   stind      = colpt-kd+1
                                   edind      = min(colpt,n)
                                   if( ( stind>=edind-1 ).and.( edind==n ) ) then
                                       blklastind = n
                                   else
                                       blklastind = 0
                                   endif
                               endif
                               ! call the kernel
                               !$ if( ttype/=1 ) then
                                   !$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1)) &
                                   !$OMP&     DEPEND(in:WORK(MYID-1)) &
                                   !$OMP&     DEPEND(out:WORK(MYID))
                                   !$ tid      = omp_get_thread_num()
                                   !$ call stdlib_${ri}$sb2st_kernels( uplo, wantq, ttype,stind, edind, &
                                   !$ sweepid, n, kd, ib,work ( inda ), lda,hous( indv ), hous( &
                                   !$ indtau ), ldv,work( indw + tid*kd ) )
                                   !$OMP END TASK
                               !$ else
                                   !$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1)) &
                                   !$OMP&     DEPEND(out:WORK(MYID))
                                   !$ tid      = omp_get_thread_num()
                                   call stdlib_${ri}$sb2st_kernels( uplo, wantq, ttype,stind, edind, &
                                   sweepid, n, kd, ib,work ( inda ), lda,hous( indv ), hous( &
                                             indtau ), ldv,work( indw + tid*kd ) )
                                   !$OMP END TASK
                               !$ endif
                               if ( blklastind>=(n-1) ) then
                                   stt = stt + 1
                                   exit
                               endif
                           end do loop_140
                       end do loop_130
                   end do loop_120
               end do loop_110
           end do loop_100
           !$OMP END MASTER
           !$OMP END PARALLEL
           ! copy the diagonal from a to d. note that d is real thus only
           ! the real part is needed, the imaginary part should be zero.
           do i = 1, n
               d( i ) = ( work( dpos+(i-1)*lda ) )
           end do
           ! copy the off diagonal from a to e. note that e is real thus only
           ! the real part is needed, the imaginary part should be zero.
           if( upper ) then
               do i = 1, n-1
                  e( i ) = ( work( ofdpos+i*lda ) )
               end do
           else
               do i = 1, n-1
                  e( i ) = ( work( ofdpos+(i-1)*lda ) )
               end do
           endif
           hous( 1 ) = lhmin
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$sytrd_sb2st


     subroutine stdlib_${ri}$sytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
     !! DSYTRD_SY2SB: reduces a real symmetric matrix A to real symmetric
     !! band-diagonal form AB by a orthogonal similarity transformation:
     !! Q**T * A * Q = AB.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldab, lwork, n, kd
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: ab(ldab,*), tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: rone = 1.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, j, iinfo, lwmin, pn, pk, llk, ldt, ldw, lds2, lds1, ls2, ls1, lw, lt,&
                      tpos, wpos, s2pos, s1pos
           ! Intrinsic Functions 
           intrinsic :: min,max
           ! Executable Statements 
           ! determine the minimal workspace size required
           ! and test the input parameters
           info   = 0
           upper  = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           lwmin  = stdlib_ilaenv2stage( 4, 'DSYTRD_SY2SB', '', n, kd, -1, -1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldab<max( 1, kd+1 ) ) then
              info = -7
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRD_SY2SB', -info )
              return
           else if( lquery ) then
              work( 1 ) = lwmin
              return
           end if
           ! quick return if possible
           ! copy the upper/lower portion of a into ab
           if( n<=kd+1 ) then
               if( upper ) then
                   do i = 1, n
                       llk = min( kd+1, i )
                       call stdlib_${ri}$copy( llk, a( i-llk+1, i ), 1,ab( kd+1-llk+1, i ), 1 )
                   end do
               else
                   do i = 1, n
                       llk = min( kd+1, n-i+1 )
                       call stdlib_${ri}$copy( llk, a( i, i ), 1, ab( 1, i ), 1 )
                   end do
               endif
               work( 1 ) = 1
               return
           end if
           ! determine the pointer position for the workspace
           ldt    = kd
           lds1   = kd
           lt     = ldt*kd
           lw     = n*kd
           ls1    = lds1*kd
           ls2    = lwmin - lt - lw - ls1
            ! ls2 = n*max(kd,factoptnb)
           tpos   = 1
           wpos   = tpos  + lt
           s1pos  = wpos  + lw
           s2pos  = s1pos + ls1
           if( upper ) then
               ldw    = kd
               lds2   = kd
           else
               ldw    = n
               lds2   = n
           endif
           ! set the workspace of the triangular matrix t to zero once such a
           ! way every time t is generated the upper/lower portion will be always zero
           call stdlib_${ri}$laset( "A", ldt, kd, zero, zero, work( tpos ), ldt )
           if( upper ) then
               do i = 1, n - kd, kd
                  pn = n-i-kd+1
                  pk = min( n-i-kd+1, kd )
                  ! compute the lq factorization of the current block
                  call stdlib_${ri}$gelqf( kd, pn, a( i, i+kd ), lda,tau( i ), work( s2pos ), ls2, &
                            iinfo )
                  ! copy the upper portion of a into ab
                  do j = i, i+pk-1
                     llk = min( kd, n-j ) + 1
                     call stdlib_${ri}$copy( llk, a( j, j ), lda, ab( kd+1, j ), ldab-1 )
                  end do
                  call stdlib_${ri}$laset( 'LOWER', pk, pk, zero, one,a( i, i+kd ), lda )
                  ! form the matrix t
                  call stdlib_${ri}$larft( 'FORWARD', 'ROWWISE', pn, pk,a( i, i+kd ), lda, tau( i ),&
                            work( tpos ), ldt )
                  ! compute w:
                  call stdlib_${ri}$gemm( 'CONJUGATE', 'NO TRANSPOSE', pk, pn, pk,one,  work( tpos ), &
                            ldt,a( i, i+kd ), lda,zero, work( s2pos ), lds2 )
                  call stdlib_${ri}$symm( 'RIGHT', uplo, pk, pn,one,  a( i+kd, i+kd ), lda,work( s2pos &
                            ), lds2,zero, work( wpos ), ldw )
                  call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'CONJUGATE', pk, pk, pn,one,  work( wpos ), &
                            ldw,work( s2pos ), lds2,zero, work( s1pos ), lds1 )
                  call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', pk, pn, pk,-half, work( &
                            s1pos ), lds1,a( i, i+kd ), lda,one,   work( wpos ), ldw )
                  ! update the unreduced submatrix a(i+kd:n,i+kd:n), using
                  ! an update of the form:  a := a - v'*w - w'*v
                  call stdlib_${ri}$syr2k( uplo, 'CONJUGATE', pn, pk,-one, a( i, i+kd ), lda,work( &
                            wpos ), ldw,rone, a( i+kd, i+kd ), lda )
               end do
              ! copy the upper band to ab which is the band storage matrix
              do j = n-kd+1, n
                 llk = min(kd, n-j) + 1
                 call stdlib_${ri}$copy( llk, a( j, j ), lda, ab( kd+1, j ), ldab-1 )
              end do
           else
               ! reduce the lower triangle of a to lower band matrix
               loop_40: do i = 1, n - kd, kd
                  pn = n-i-kd+1
                  pk = min( n-i-kd+1, kd )
                  ! compute the qr factorization of the current block
                  call stdlib_${ri}$geqrf( pn, kd, a( i+kd, i ), lda,tau( i ), work( s2pos ), ls2, &
                            iinfo )
                  ! copy the upper portion of a into ab
                  do j = i, i+pk-1
                     llk = min( kd, n-j ) + 1
                     call stdlib_${ri}$copy( llk, a( j, j ), 1, ab( 1, j ), 1 )
                  end do
                  call stdlib_${ri}$laset( 'UPPER', pk, pk, zero, one,a( i+kd, i ), lda )
                  ! form the matrix t
                  call stdlib_${ri}$larft( 'FORWARD', 'COLUMNWISE', pn, pk,a( i+kd, i ), lda, tau( i ),&
                            work( tpos ), ldt )
                  ! compute w:
                  call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', pn, pk, pk,one, a( i+kd, i ),&
                             lda,work( tpos ), ldt,zero, work( s2pos ), lds2 )
                  call stdlib_${ri}$symm( 'LEFT', uplo, pn, pk,one, a( i+kd, i+kd ), lda,work( s2pos ),&
                             lds2,zero, work( wpos ), ldw )
                  call stdlib_${ri}$gemm( 'CONJUGATE', 'NO TRANSPOSE', pk, pk, pn,one, work( s2pos ), &
                            lds2,work( wpos ), ldw,zero, work( s1pos ), lds1 )
                  call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', pn, pk, pk,-half, a( i+kd, i &
                            ), lda,work( s1pos ), lds1,one, work( wpos ), ldw )
                  ! update the unreduced submatrix a(i+kd:n,i+kd:n), using
                  ! an update of the form:  a := a - v*w' - w*v'
                  call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', pn, pk,-one, a( i+kd, i ), lda,work( &
                            wpos ), ldw,rone, a( i+kd, i+kd ), lda )
                  ! ==================================================================
                  ! restore a for comparison and checking to be removed
                   ! do 45 j = i, i+pk-1
                      ! llk = min( kd, n-j ) + 1
                      ! call stdlib_${ri}$copy( llk, ab( 1, j ), 1, a( j, j ), 1 )
                      45 continue
                  ! ==================================================================
               end do loop_40
              ! copy the lower band to ab which is the band storage matrix
              do j = n-kd+1, n
                 llk = min(kd, n-j) + 1
                 call stdlib_${ri}$copy( llk, a( j, j ), 1, ab( 1, j ), 1 )
              end do
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$sytrd_sy2sb


     pure subroutine stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! DSYTRF: computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U**T*D*U  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u**t*d*u using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ri}$lasyf( uplo, k, nb, kb, a, lda, ipiv, work, ldwork,iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ri}$sytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ri}$lasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, ldwork, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ri}$sytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf


     pure subroutine stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! DSYTRF_AA: computes the factorization of a real symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           real(${rk}$) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'DSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_${ri}$copy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ri}$lasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ri}$swap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = one
                    call stdlib_${ri}$copy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_${ri}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ri}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j1-k2, j3 ), 1,one, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_${ri}$gemm
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-one, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,one, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ri}$copy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_${ri}$copy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ri}$lasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ri}$swap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = one
                    call stdlib_${ri}$copy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_${ri}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ri}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j3, j1-k2 ), lda,one, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_${ri}$gemm
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-one, work(&
                                  j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,one, a( j3, j2 ), lda )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ri}$copy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf_aa


     pure subroutine stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! DSYTRF_RK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ri}$lasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ri}$sytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ri}$swap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ri}$lasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ri}$sytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ri}$swap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf_rk


     pure subroutine stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! DSYTRF_ROOK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ri}$lasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ri}$sytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ri}$lasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ri}$sytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf_rook


     pure subroutine stdlib_${ri}$sytri( uplo, n, a, lda, ipiv, work, info )
     !! DSYTRI: computes the inverse of a real symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(${rk}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ri}$dot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ri}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_${ri}$dot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ri}$dot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_${ri}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_${ri}$dot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_${ri}$sytri


     pure subroutine stdlib_${ri}$sytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! DSYTRI_ROOK: computes the inverse of a real symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by DSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(${rk}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ri}$dot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ri}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_${ri}$dot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ri}$dot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_${ri}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_${ri}$dot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_${ri}$sytri_rook


     pure subroutine stdlib_${ri}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! DSYTRS: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$ger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,a( 1, k+1 ), 1, one, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$ger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ri}$sytrs


     pure subroutine stdlib_${ri}$sytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! DSYTRS2: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF and converted by DSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_${ri}$syconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_${ri}$trsm('L','U','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_${ri}$trsm('L','U','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_${ri}$trsm('L','L','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_${ri}$trsm('L','L','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_${ri}$syconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_${ri}$sytrs2


     pure subroutine stdlib_${ri}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! DSYTRS_3: solves a system of linear equations A * X = B with a real
     !! symmetric matrix A using the factorization computed
     !! by DSYTRF_RK or DSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*), e(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_${ri}$trsm( 'L', 'U', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - one
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_${ri}$trsm( 'L', 'U', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_${ri}$trsm( 'L', 'L', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - one
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_${ri}$trsm('L', 'L', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_${ri}$sytrs_3


     pure subroutine stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! DSYTRS_AA: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by DSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_${ri}$trsm('L', 'U', 'T', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_${ri}$lacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_${ri}$gtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_${ri}$trsm( 'L', 'U', 'N', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (u \ (t \ (u**t \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_${ri}$trsm( 'L', 'L', 'N', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_${ri}$lacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_${ri}$gtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_${ri}$trsm( 'L', 'L', 'T', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$sytrs_aa


     pure subroutine stdlib_${ri}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! DSYTRS_ROOK: solves a system of linear equations A*X = B with
     !! a real symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$ger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ),&
                               ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, &
                           one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, one, b( &
                              k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k+1 ), 1, one, &
                              b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$ger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ri}$sytrs_rook


     subroutine stdlib_${ri}$tbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )
     !! DTBCON: estimates the reciprocal of the condition number of a
     !! triangular band matrix A, in either the 1-norm or the infinity-norm.
     !! The norm of A is computed and an estimate is obtained for
     !! norm(inv(A)), then the reciprocal of the condition number is
     !! computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, onenrm, upper
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(${rk}$) :: ainvnm, anorm, scale, smlnum, xnorm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,real,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( ldab<kd+1 ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTBCON', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              rcond = one
              return
           end if
           rcond = zero
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )*real( max( 1, n ),KIND=${rk}$)
           ! compute the norm of the triangular matrix a.
           anorm = stdlib_${ri}$lantb( norm, uplo, diag, n, kd, ab, ldab, work )
           ! continue only if anorm > 0.
           if( anorm>zero ) then
              ! estimate the norm of the inverse of a.
              ainvnm = zero
              normin = 'N'
              if( onenrm ) then
                 kase1 = 1
              else
                 kase1 = 2
              end if
              kase = 0
              10 continue
              call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
              if( kase/=0 ) then
                 if( kase==kase1 ) then
                    ! multiply by inv(a).
                    call stdlib_${ri}$latbs( uplo, 'NO TRANSPOSE', diag, normin, n, kd,ab, ldab, work, &
                              scale, work( 2*n+1 ), info )
                 else
                    ! multiply by inv(a**t).
                    call stdlib_${ri}$latbs( uplo, 'TRANSPOSE', diag, normin, n, kd, ab,ldab, work, &
                              scale, work( 2*n+1 ), info )
                 end if
                 normin = 'Y'
                 ! multiply by 1/scale if doing so will not cause overflow.
                 if( scale/=one ) then
                    ix = stdlib_i${ri}$amax( n, work, 1 )
                    xnorm = abs( work( ix ) )
                    if( scale<xnorm*smlnum .or. scale==zero )go to 20
                    call stdlib_${ri}$rscl( n, scale, work, 1 )
                 end if
                 go to 10
              end if
              ! compute the estimate of the reciprocal condition number.
              if( ainvnm/=zero )rcond = ( one / anorm ) / ainvnm
           end if
           20 continue
           return
     end subroutine stdlib_${ri}$tbcon


     pure subroutine stdlib_${ri}$tbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, ferr,&
     !! DTBRFS: provides error bounds and backward error estimates for the
     !! solution to a system of linear equations with a triangular band
     !! coefficient matrix.
     !! The solution matrix X must be computed by DTBTRS or some other
     !! means before entering this routine.  DTBRFS does not do iterative
     !! refinement because doing so cannot improve the backward error.
                berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ab(ldab,*), b(ldb,*), x(ldx,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           character :: transt
           integer(ilp) :: i, j, k, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( nrhs<0 ) then
              info = -6
           else if( ldab<kd+1 ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTBRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = kd + 2
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_250: do j = 1, nrhs
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a or a**t, depending on trans.
              call stdlib_${ri}$copy( n, x( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$tbmv( uplo, trans, diag, n, kd, ab, ldab, work( n+1 ),1 )
              call stdlib_${ri}$axpy( n, -one, b( 1, j ), 1, work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              if( notran ) then
                 ! compute abs(a)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = max( 1, k-kd ), k
                             work( i ) = work( i ) +abs( ab( kd+1+i-k, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = max( 1, k-kd ), k - 1
                             work( i ) = work( i ) +abs( ab( kd+1+i-k, k ) )*xk
                          end do
                          work( k ) = work( k ) + xk
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = k, min( n, k+kd )
                             work( i ) = work( i ) + abs( ab( 1+i-k, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = k + 1, min( n, k+kd )
                             work( i ) = work( i ) + abs( ab( 1+i-k, k ) )*xk
                          end do
                          work( k ) = work( k ) + xk
                       end do
                    end if
                 end if
              else
                 ! compute abs(a**t)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = max( 1, k-kd ), k
                             s = s + abs( ab( kd+1+i-k, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = abs( x( k, j ) )
                          do i = max( 1, k-kd ), k - 1
                             s = s + abs( ab( kd+1+i-k, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = k, min( n, k+kd )
                             s = s + abs( ab( 1+i-k, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = abs( x( k, j ) )
                          do i = k + 1, min( n, k+kd )
                             s = s + abs( ab( 1+i-k, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    end if
                 end if
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              210 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**t).
                    call stdlib_${ri}$tbsv( uplo, transt, diag, n, kd, ab, ldab,work( n+1 ), 1 )
                              
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$tbsv( uplo, trans, diag, n, kd, ab, ldab,work( n+1 ), 1 )
                 end if
                 go to 210
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_250
           return
     end subroutine stdlib_${ri}$tbrfs


     pure subroutine stdlib_${ri}$tbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )
     !! DTBTRS: solves a triangular system of the form
     !! A * X = B  or  A**T * X = B,
     !! where A is a triangular band matrix of order N, and B is an
     !! N-by NRHS matrix.  A check is made to verify that A is nonsingular.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: ab(ldab,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nounit = stdlib_lsame( diag, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) .and. &
                     .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( nrhs<0 ) then
              info = -6
           else if( ldab<kd+1 ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTBTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity.
           if( nounit ) then
              if( upper ) then
                 do info = 1, n
                    if( ab( kd+1, info )==zero )return
                 end do
              else
                 do info = 1, n
                    if( ab( 1, info )==zero )return
                 end do
              end if
           end if
           info = 0
           ! solve a * x = b  or  a**t * x = b.
           do j = 1, nrhs
              call stdlib_${ri}$tbsv( uplo, trans, diag, n, kd, ab, ldab, b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ri}$tbtrs


     pure subroutine stdlib_${ri}$tfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )
     !! Level 3 BLAS like routine for A in RFP Format.
     !! DTFSM:  solves the matrix equation
     !! op( A )*X = alpha*B  or  X*op( A ) = alpha*B
     !! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
     !! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
     !! op( A ) = A   or   op( A ) = A**T.
     !! A is in Rectangular Full Packed (RFP) Format.
     !! The matrix X is overwritten on B.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, diag, side, trans, uplo
           integer(ilp), intent(in) :: ldb, m, n
           real(${rk}$), intent(in) :: alpha
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(0:*)
           real(${rk}$), intent(inout) :: b(0:ldb-1,0:*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, lside, misodd, nisodd, normaltransr, notrans
           integer(ilp) :: m1, m2, n1, n2, k, info, i, j
           ! Intrinsic Functions 
           intrinsic :: max,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lside = stdlib_lsame( side, 'L' )
           lower = stdlib_lsame( uplo, 'L' )
           notrans = stdlib_lsame( trans, 'N' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lside .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -2
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -3
           else if( .not.notrans .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -4
           else if( .not.stdlib_lsame( diag, 'N' ) .and. .not.stdlib_lsame( diag, 'U' ) )&
                     then
              info = -5
           else if( m<0 ) then
              info = -6
           else if( n<0 ) then
              info = -7
           else if( ldb<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTFSM ', -info )
              return
           end if
           ! quick return when ( (n==0).or.(m==0) )
           if( ( m==0 ) .or. ( n==0 ) )return
           ! quick return when alpha==(0e+0_${rk}$)
           if( alpha==zero ) then
              do j = 0, n - 1
                 do i = 0, m - 1
                    b( i, j ) = zero
                 end do
              end do
              return
           end if
           if( lside ) then
              ! side = 'l'
              ! a is m-by-m.
              ! if m is odd, set nisodd = .true., and m1 and m2.
              ! if m is even, nisodd = .false., and m.
              if( mod( m, 2 )==0 ) then
                 misodd = .false.
                 k = m / 2
              else
                 misodd = .true.
                 if( lower ) then
                    m2 = m / 2
                    m1 = m - m2
                 else
                    m1 = m / 2
                    m2 = m - m1
                 end if
              end if
              if( misodd ) then
                 ! side = 'l' and n is odd
                 if( normaltransr ) then
                    ! side = 'l', n is odd, and transr = 'n'
                    if( lower ) then
                       ! side  ='l', n is odd, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 'n'
                          if( m==1 ) then
                             call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, m1, n, alpha,a, m, b, ldb )
                                       
                          else
                             call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, m1, n, alpha,a( 0 ), m, b, &
                                       ldb )
                             call stdlib_${ri}$gemm( 'N', 'N', m2, n, m1, -one, a( m1 ),m, b, ldb, &
                                       alpha, b( m1, 0 ), ldb )
                             call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, m2, n, one,a( m ), m, b( m1, &
                                       0 ), ldb )
                          end if
                       else
                          ! side  ='l', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 't'
                          if( m==1 ) then
                             call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, m1, n, alpha,a( 0 ), m, b, &
                                       ldb )
                          else
                             call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, m2, n, alpha,a( m ), m, b( &
                                       m1, 0 ), ldb )
                             call stdlib_${ri}$gemm( 'T', 'N', m1, n, m2, -one, a( m1 ),m, b( m1, 0 ), &
                                       ldb, alpha, b, ldb )
                             call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, m1, n, one,a( 0 ), m, b, ldb &
                                       )
                          end if
                       end if
                    else
                       ! side  ='l', n is odd, transr = 'n', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, m1, n, alpha,a( m2 ), m, b, ldb &
                                    )
                          call stdlib_${ri}$gemm( 'T', 'N', m2, n, m1, -one, a( 0 ), m,b, ldb, alpha, &
                                    b( m1, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, m2, n, one,a( m1 ), m, b( m1, 0 &
                                    ), ldb )
                       else
                          ! side  ='l', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 't'
                          call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, m2, n, alpha,a( m1 ), m, b( m1, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m1, n, m2, -one, a( 0 ), m,b( m1, 0 ), ldb,&
                                     alpha, b, ldb )
                          call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, m1, n, one,a( m2 ), m, b, ldb )
                                    
                       end if
                    end if
                 else
                    ! side = 'l', n is odd, and transr = 't'
                    if( lower ) then
                       ! side  ='l', n is odd, transr = 't', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is odd, transr = 't', uplo = 'l', and
                          ! trans = 'n'
                          if( m==1 ) then
                             call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, m1, n, alpha,a( 0 ), m1, b, &
                                       ldb )
                          else
                             call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, m1, n, alpha,a( 0 ), m1, b, &
                                       ldb )
                             call stdlib_${ri}$gemm( 'T', 'N', m2, n, m1, -one,a( m1*m1 ), m1, b, ldb, &
                                       alpha,b( m1, 0 ), ldb )
                             call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, m2, n, one,a( 1 ), m1, b( m1,&
                                        0 ), ldb )
                          end if
                       else
                          ! side  ='l', n is odd, transr = 't', uplo = 'l', and
                          ! trans = 't'
                          if( m==1 ) then
                             call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, m1, n, alpha,a( 0 ), m1, b, &
                                       ldb )
                          else
                             call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, m2, n, alpha,a( 1 ), m1, b( &
                                       m1, 0 ), ldb )
                             call stdlib_${ri}$gemm( 'N', 'N', m1, n, m2, -one,a( m1*m1 ), m1, b( m1, &
                                       0 ), ldb,alpha, b, ldb )
                             call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, m1, n, one,a( 0 ), m1, b, &
                                       ldb )
                          end if
                       end if
                    else
                       ! side  ='l', n is odd, transr = 't', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is odd, transr = 't', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, m1, n, alpha,a( m2*m2 ), m2, b, &
                                    ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m2, n, m1, -one, a( 0 ), m2,b, ldb, alpha, &
                                    b( m1, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, m2, n, one,a( m1*m2 ), m2, b( &
                                    m1, 0 ), ldb )
                       else
                          ! side  ='l', n is odd, transr = 't', uplo = 'u', and
                          ! trans = 't'
                          call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, m2, n, alpha,a( m1*m2 ), m2, b( &
                                    m1, 0 ), ldb )
                          call stdlib_${ri}$gemm( 'T', 'N', m1, n, m2, -one, a( 0 ), m2,b( m1, 0 ), &
                                    ldb, alpha, b, ldb )
                          call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, m1, n, one,a( m2*m2 ), m2, b, &
                                    ldb )
                       end if
                    end if
                 end if
              else
                 ! side = 'l' and n is even
                 if( normaltransr ) then
                    ! side = 'l', n is even, and transr = 'n'
                    if( lower ) then
                       ! side  ='l', n is even, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, k, n, alpha,a( 1 ), m+1, b, ldb &
                                    )
                          call stdlib_${ri}$gemm( 'N', 'N', k, n, k, -one, a( k+1 ),m+1, b, ldb, alpha,&
                                     b( k, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, k, n, one,a( 0 ), m+1, b( k, 0 )&
                                    , ldb )
                       else
                          ! side  ='l', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, k, n, alpha,a( 0 ), m+1, b( k, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'T', 'N', k, n, k, -one, a( k+1 ),m+1, b( k, 0 ), &
                                    ldb, alpha, b, ldb )
                          call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, k, n, one,a( 1 ), m+1, b, ldb )
                                    
                       end if
                    else
                       ! side  ='l', n is even, transr = 'n', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, k, n, alpha,a( k+1 ), m+1, b, &
                                    ldb )
                          call stdlib_${ri}$gemm( 'T', 'N', k, n, k, -one, a( 0 ), m+1,b, ldb, alpha, &
                                    b( k, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, k, n, one,a( k ), m+1, b( k, 0 )&
                                    , ldb )
                       else
                          ! side  ='l', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, k, n, alpha,a( k ), m+1, b( k, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', k, n, k, -one, a( 0 ), m+1,b( k, 0 ), ldb, &
                                    alpha, b, ldb )
                          call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, k, n, one,a( k+1 ), m+1, b, ldb &
                                    )
                       end if
                    end if
                 else
                    ! side = 'l', n is even, and transr = 't'
                    if( lower ) then
                       ! side  ='l', n is even, transr = 't', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is even, transr = 't', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, k, n, alpha,a( k ), k, b, ldb )
                                    
                          call stdlib_${ri}$gemm( 'T', 'N', k, n, k, -one,a( k*( k+1 ) ), k, b, ldb, &
                                    alpha,b( k, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, k, n, one,a( 0 ), k, b( k, 0 ), &
                                    ldb )
                       else
                          ! side  ='l', n is even, transr = 't', uplo = 'l',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, k, n, alpha,a( 0 ), k, b( k, 0 )&
                                    , ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', k, n, k, -one,a( k*( k+1 ) ), k, b( k, 0 ),&
                                     ldb,alpha, b, ldb )
                          call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, k, n, one,a( k ), k, b, ldb )
                                    
                       end if
                    else
                       ! side  ='l', n is even, transr = 't', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is even, transr = 't', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'L', 'U', 'T', diag, k, n, alpha,a( k*( k+1 ) ), k, &
                                    b, ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', k, n, k, -one, a( 0 ), k, b,ldb, alpha, b( &
                                    k, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'L', 'L', 'N', diag, k, n, one,a( k*k ), k, b( k, 0 )&
                                    , ldb )
                       else
                          ! side  ='l', n is even, transr = 't', uplo = 'u',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'L', 'L', 'T', diag, k, n, alpha,a( k*k ), k, b( k, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'T', 'N', k, n, k, -one, a( 0 ), k,b( k, 0 ), ldb, &
                                    alpha, b, ldb )
                          call stdlib_${ri}$trsm( 'L', 'U', 'N', diag, k, n, one,a( k*( k+1 ) ), k, b, &
                                    ldb )
                       end if
                    end if
                 end if
              end if
           else
              ! side = 'r'
              ! a is n-by-n.
              ! if n is odd, set nisodd = .true., and n1 and n2.
              ! if n is even, nisodd = .false., and k.
              if( mod( n, 2 )==0 ) then
                 nisodd = .false.
                 k = n / 2
              else
                 nisodd = .true.
                 if( lower ) then
                    n2 = n / 2
                    n1 = n - n2
                 else
                    n1 = n / 2
                    n2 = n - n1
                 end if
              end if
              if( nisodd ) then
                 ! side = 'r' and n is odd
                 if( normaltransr ) then
                    ! side = 'r', n is odd, and transr = 'n'
                    if( lower ) then
                       ! side  ='r', n is odd, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, n2, alpha,a( n ), n, b( 0, &
                                    n1 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, n1, n2, -one, b( 0, n1 ),ldb, a( n1 ), &
                                    n, alpha, b( 0, 0 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, n1, one,a( 0 ), n, b( 0, 0 ),&
                                     ldb )
                       else
                          ! side  ='r', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, n1, alpha,a( 0 ), n, b( 0, 0 &
                                    ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, n2, n1, -one, b( 0, 0 ),ldb, a( n1 ), n,&
                                     alpha, b( 0, n1 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, n2, one,a( n ), n, b( 0, n1 )&
                                    , ldb )
                       end if
                    else
                       ! side  ='r', n is odd, transr = 'n', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, n1, alpha,a( n2 ), n, b( 0, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, n2, n1, -one, b( 0, 0 ),ldb, a( 0 ), n, &
                                    alpha, b( 0, n1 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, n2, one,a( n1 ), n, b( 0, n1 &
                                    ), ldb )
                       else
                          ! side  ='r', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, n2, alpha,a( n1 ), n, b( 0, &
                                    n1 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, n1, n2, -one, b( 0, n1 ),ldb, a( 0 ), n,&
                                     alpha, b( 0, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, n1, one,a( n2 ), n, b( 0, 0 )&
                                    , ldb )
                       end if
                    end if
                 else
                    ! side = 'r', n is odd, and transr = 't'
                    if( lower ) then
                       ! side  ='r', n is odd, transr = 't', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 't', uplo = 'l', and
                          ! trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, n2, alpha,a( 1 ), n1, b( 0, &
                                    n1 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, n1, n2, -one, b( 0, n1 ),ldb, a( n1*n1 )&
                                    , n1, alpha, b( 0, 0 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, n1, one,a( 0 ), n1, b( 0, 0 )&
                                    , ldb )
                       else
                          ! side  ='r', n is odd, transr = 't', uplo = 'l', and
                          ! trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, n1, alpha,a( 0 ), n1, b( 0, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, n2, n1, -one, b( 0, 0 ),ldb, a( n1*n1 ),&
                                     n1, alpha, b( 0, n1 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, n2, one,a( 1 ), n1, b( 0, n1 &
                                    ), ldb )
                       end if
                    else
                       ! side  ='r', n is odd, transr = 't', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 't', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, n1, alpha,a( n2*n2 ), n2, b( &
                                    0, 0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, n2, n1, -one, b( 0, 0 ),ldb, a( 0 ), n2,&
                                     alpha, b( 0, n1 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, n2, one,a( n1*n2 ), n2, b( 0,&
                                     n1 ), ldb )
                       else
                          ! side  ='r', n is odd, transr = 't', uplo = 'u', and
                          ! trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, n2, alpha,a( n1*n2 ), n2, b( &
                                    0, n1 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, n1, n2, -one, b( 0, n1 ),ldb, a( 0 ), &
                                    n2, alpha, b( 0, 0 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, n1, one,a( n2*n2 ), n2, b( 0,&
                                     0 ), ldb )
                       end if
                    end if
                 end if
              else
                 ! side = 'r' and n is even
                 if( normaltransr ) then
                    ! side = 'r', n is even, and transr = 'n'
                    if( lower ) then
                       ! side  ='r', n is even, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, k, alpha,a( 0 ), n+1, b( 0, &
                                    k ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, k, k, -one, b( 0, k ),ldb, a( k+1 ), n+&
                                    1, alpha, b( 0, 0 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, k, one,a( 1 ), n+1, b( 0, 0 )&
                                    , ldb )
                       else
                          ! side  ='r', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, k, alpha,a( 1 ), n+1, b( 0, &
                                    0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, k, k, -one, b( 0, 0 ),ldb, a( k+1 ), n+&
                                    1, alpha, b( 0, k ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, k, one,a( 0 ), n+1, b( 0, k )&
                                    , ldb )
                       end if
                    else
                       ! side  ='r', n is even, transr = 'n', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, k, alpha,a( k+1 ), n+1, b( 0,&
                                     0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, k, k, -one, b( 0, 0 ),ldb, a( 0 ), n+1, &
                                    alpha, b( 0, k ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, k, one,a( k ), n+1, b( 0, k )&
                                    , ldb )
                       else
                          ! side  ='r', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, k, alpha,a( k ), n+1, b( 0, &
                                    k ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, k, k, -one, b( 0, k ),ldb, a( 0 ), n+1, &
                                    alpha, b( 0, 0 ),ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, k, one,a( k+1 ), n+1, b( 0, &
                                    0 ), ldb )
                       end if
                    end if
                 else
                    ! side = 'r', n is even, and transr = 't'
                    if( lower ) then
                       ! side  ='r', n is even, transr = 't', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 't', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, k, alpha,a( 0 ), k, b( 0, k )&
                                    , ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, k, k, -one, b( 0, k ),ldb, a( ( k+1 )*k &
                                    ), k, alpha,b( 0, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, k, one,a( k ), k, b( 0, 0 ), &
                                    ldb )
                       else
                          ! side  ='r', n is even, transr = 't', uplo = 'l',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, k, alpha,a( k ), k, b( 0, 0 )&
                                    , ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, k, k, -one, b( 0, 0 ),ldb, a( ( k+1 )*k &
                                    ), k, alpha,b( 0, k ), ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, k, one,a( 0 ), k, b( 0, k ), &
                                    ldb )
                       end if
                    else
                       ! side  ='r', n is even, transr = 't', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 't', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_${ri}$trsm( 'R', 'U', 'N', diag, m, k, alpha,a( ( k+1 )*k ), k, &
                                    b( 0, 0 ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'T', m, k, k, -one, b( 0, 0 ),ldb, a( 0 ), k, &
                                    alpha, b( 0, k ), ldb )
                          call stdlib_${ri}$trsm( 'R', 'L', 'T', diag, m, k, one,a( k*k ), k, b( 0, k )&
                                    , ldb )
                       else
                          ! side  ='r', n is even, transr = 't', uplo = 'u',
                          ! and trans = 't'
                          call stdlib_${ri}$trsm( 'R', 'L', 'N', diag, m, k, alpha,a( k*k ), k, b( 0, &
                                    k ), ldb )
                          call stdlib_${ri}$gemm( 'N', 'N', m, k, k, -one, b( 0, k ),ldb, a( 0 ), k, &
                                    alpha, b( 0, 0 ), ldb )
                          call stdlib_${ri}$trsm( 'R', 'U', 'T', diag, m, k, one,a( ( k+1 )*k ), k, b( &
                                    0, 0 ), ldb )
                       end if
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$tfsm


     pure subroutine stdlib_${ri}$tftri( transr, uplo, diag, n, a, info )
     !! DTFTRI: computes the inverse of a triangular matrix A stored in RFP
     !! format.
     !! This is a Level 3 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo, diag
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(0:*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( .not.stdlib_lsame( diag, 'N' ) .and. .not.stdlib_lsame( diag, 'U' ) )&
                     then
              info = -3
           else if( n<0 ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTFTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
           else
              nisodd = .true.
           end if
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1)
                    call stdlib_${ri}$trtri( 'L', diag, n1, a( 0 ), n, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'L', 'N', diag, n2, n1, -one, a( 0 ),n, a( n1 ), n )
                              
                    call stdlib_${ri}$trtri( 'U', diag, n2, a( n ), n, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'U', 'T', diag, n2, n1, one, a( n ), n,a( n1 ), n )
                              
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    call stdlib_${ri}$trtri( 'L', diag, n1, a( n2 ), n, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'L', 'T', diag, n1, n2, -one, a( n2 ),n, a( 0 ), n )
                              
                    call stdlib_${ri}$trtri( 'U', diag, n2, a( n1 ), n, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'U', 'N', diag, n1, n2, one, a( n1 ),n, a( 0 ), n )
                              
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0), t2 -> a(1), s -> a(0+n1*n1)
                    call stdlib_${ri}$trtri( 'U', diag, n1, a( 0 ), n1, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'U', 'N', diag, n1, n2, -one, a( 0 ),n1, a( n1*n1 ), &
                              n1 )
                    call stdlib_${ri}$trtri( 'L', diag, n2, a( 1 ), n1, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'L', 'T', diag, n1, n2, one, a( 1 ),n1, a( n1*n1 ), &
                              n1 )
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0+n2*n2), t2 -> a(0+n1*n2), s -> a(0)
                    call stdlib_${ri}$trtri( 'U', diag, n1, a( n2*n2 ), n2, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'U', 'T', diag, n2, n1, -one,a( n2*n2 ), n2, a( 0 ), &
                              n2 )
                    call stdlib_${ri}$trtri( 'L', diag, n2, a( n1*n2 ), n2, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'L', 'N', diag, n2, n1, one,a( n1*n2 ), n2, a( 0 ), &
                              n2 )
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    call stdlib_${ri}$trtri( 'L', diag, k, a( 1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'L', 'N', diag, k, k, -one, a( 1 ),n+1, a( k+1 ), n+1 &
                              )
                    call stdlib_${ri}$trtri( 'U', diag, k, a( 0 ), n+1, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'U', 'T', diag, k, k, one, a( 0 ), n+1,a( k+1 ), n+1 )
                              
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    call stdlib_${ri}$trtri( 'L', diag, k, a( k+1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'L', 'T', diag, k, k, -one, a( k+1 ),n+1, a( 0 ), n+1 &
                              )
                    call stdlib_${ri}$trtri( 'U', diag, k, a( k ), n+1, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'U', 'N', diag, k, k, one, a( k ), n+1,a( 0 ), n+1 )
                              
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    call stdlib_${ri}$trtri( 'U', diag, k, a( k ), k, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'U', 'N', diag, k, k, -one, a( k ), k,a( k*( k+1 ) ), &
                              k )
                    call stdlib_${ri}$trtri( 'L', diag, k, a( 0 ), k, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'L', 'T', diag, k, k, one, a( 0 ), k,a( k*( k+1 ) ), &
                              k )
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    call stdlib_${ri}$trtri( 'U', diag, k, a( k*( k+1 ) ), k, info )
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'R', 'U', 'T', diag, k, k, -one,a( k*( k+1 ) ), k, a( 0 ), &
                              k )
                    call stdlib_${ri}$trtri( 'L', diag, k, a( k*k ), k, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_${ri}$trmm( 'L', 'L', 'N', diag, k, k, one, a( k*k ), k,a( 0 ), k )
                              
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$tftri


     pure subroutine stdlib_${ri}$tfttp( transr, uplo, n, arf, ap, info )
     !! DTFTTP: copies a triangular matrix A from rectangular full packed
     !! format (TF) to standard packed format (TP).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(out) :: ap(0:*)
           real(${rk}$), intent(in) :: arf(0:*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k, nt
           integer(ilp) :: i, j, ij
           integer(ilp) :: ijp, jp, lda, js
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTFTTP', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( normaltransr ) then
                 ap( 0 ) = arf( 0 )
              else
                 ap( 0 ) = arf( 0 )
              end if
              return
           end if
           ! size of array arf(0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           ! set lda of arf^c; arf^c is (0:(n+1)/2-1,0:n-noe)
           ! where noe = 0 if n is even, noe = 1 if n is odd
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              lda = n + 1
           else
              nisodd = .true.
              lda = n
           end if
           ! arf^c has lda rows and n+1-noe cols
           if( .not.normaltransr )lda = ( n+1 ) / 2
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1); lda = n
                    ijp = 0
                    jp = 0
                    do j = 0, n2
                       do i = j, n - 1
                          ij = i + jp
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, n2 - 1
                       do j = 1 + i, n2
                          ij = i + j*lda
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    ijp = 0
                    do j = 0, n1 - 1
                       ij = n2 + j
                       do i = 0, j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = n1, n - 1
                       ij = js
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    ijp = 0
                    do i = 0, n2
                       do ij = i*( lda+1 ), n*lda - 1, lda
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 1
                    do j = 0, n2 - 1
                       do ij = js, js + n2 - j - 1
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda = n2
                    ijp = 0
                    js = n2*lda
                    do j = 0, n1 - 1
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, n1
                       do ij = i, i + ( n1+i )*lda, lda
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    ijp = 0
                    jp = 0
                    do j = 0, k - 1
                       do i = j, n - 1
                          ij = 1 + i + jp
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, k - 1
                       do j = i, k - 1
                          ij = i + j*lda
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    ijp = 0
                    do j = 0, k - 1
                       ij = k + 1 + j
                       do i = 0, j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = k, n - 1
                       ij = js
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    ijp = 0
                    do i = 0, k - 1
                       do ij = i + ( i+1 )*lda, ( n+1 )*lda - 1, lda
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 0
                    do j = 0, k - 1
                       do ij = js, js + k - j - 1
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    ijp = 0
                    js = ( k+1 )*lda
                    do j = 0, k - 1
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, k - 1
                       do ij = i, i + ( k+i )*lda, lda
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$tfttp


     pure subroutine stdlib_${ri}$tfttr( transr, uplo, n, arf, a, lda, info )
     !! DTFTTR: copies a triangular matrix A from rectangular full packed
     !! format (TF) to standard full format (TR).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           real(${rk}$), intent(out) :: a(0:lda-1,0:*)
           real(${rk}$), intent(in) :: arf(0:*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k, nt, nx2, np1x2
           integer(ilp) :: i, j, l, ij
           ! Intrinsic Functions 
           intrinsic :: max,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTFTTR', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 ) then
              if( n==1 ) then
                 a( 0, 0 ) = arf( 0 )
              end if
              return
           end if
           ! size of array arf(0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower: for n even n1=n2=k
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true., lda=n+1 and a is (n+1)--by--k2.
           ! if n is even, set k = n/2 and nisodd = .false., lda=n and a is
           ! n--by--(n+1)/2.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              if( .not.lower )np1x2 = n + n + 2
           else
              nisodd = .true.
              if( .not.lower )nx2 = n + n
           end if
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! n is odd, transr = 'n', and uplo = 'l'
                    ij = 0
                    do j = 0, n2
                       do i = n1, n2 + j
                          a( n2+j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is odd, transr = 'n', and uplo = 'u'
                    ij = nt - n
                    do j = n - 1, n1, -1
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = j - n1, n1 - 1
                          a( j-n1, l ) = arf( ij )
                          ij = ij + 1
                       end do
                       ij = ij - nx2
                    end do
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! n is odd, transr = 't', and uplo = 'l'
                    ij = 0
                    do j = 0, n2 - 1
                       do i = 0, j
                          a( j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                       do i = n1 + j, n - 1
                          a( i, n1+j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    do j = n2, n - 1
                       do i = 0, n1 - 1
                          a( j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is odd, transr = 't', and uplo = 'u'
                    ij = 0
                    do j = 0, n1
                       do i = n1, n - 1
                          a( j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, n1 - 1
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = n2 + j, n - 1
                          a( n2+j, l ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! n is even, transr = 'n', and uplo = 'l'
                    ij = 0
                    do j = 0, k - 1
                       do i = k, k + j
                          a( k+j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is even, transr = 'n', and uplo = 'u'
                    ij = nt - n - 1
                    do j = n - 1, k, -1
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = j - k, k - 1
                          a( j-k, l ) = arf( ij )
                          ij = ij + 1
                       end do
                       ij = ij - np1x2
                    end do
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! n is even, transr = 't', and uplo = 'l'
                    ij = 0
                    j = k
                    do i = k, n - 1
                       a( i, j ) = arf( ij )
                       ij = ij + 1
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          a( j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                       do i = k + 1 + j, n - 1
                          a( i, k+1+j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    do j = k - 1, n - 1
                       do i = 0, k - 1
                          a( j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is even, transr = 't', and uplo = 'u'
                    ij = 0
                    do j = 0, k
                       do i = k, n - 1
                          a( j, i ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = k + 1 + j, n - 1
                          a( k+1+j, l ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    ! note that here, on exit of the loop, j = k-1
                    do i = 0, j
                       a( i, j ) = arf( ij )
                       ij = ij + 1
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$tfttr


     pure subroutine stdlib_${ri}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! DTGEVC: computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by DGGHRD + DHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${rk}$), intent(in) :: p(ldp,*), s(lds,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: safety = 1.0e+2_${rk}$
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(${rk}$) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(${rk}$) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_${ri}$labad( safmin, big )
           ulp = stdlib_${ri}$lamch( 'EPSILON' )*stdlib_${ri}$lamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_${ri}$lag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_${ri}$laln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_${ri}$gemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_${ri}$lacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_${ri}$lacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_${ri}$lag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_${ri}$laln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_${ri}$tgevc


     pure subroutine stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! DTGEX2: swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(${rk}$), parameter :: twenty = 2.0e+01_${rk}$
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(${rk}$) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(${rk}$) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( 1, n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( 1, n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_${ri}$lacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_${ri}$lassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_${ri}$lacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_${ri}$lassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_${ri}$lartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_${ri}$rot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_${ri}$rot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_${ri}$lartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_${ri}$lartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_${ri}$rot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_${ri}$rot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_${ri}$rot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_${ri}$rot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_${ri}$rot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_${ri}$rot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_${ri}$rot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_${ri}$tgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_${ri}$scal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_${ri}$geqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$org2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_${ri}$gerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$orgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_${ri}$gemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_${ri}$gemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_${ri}$gerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$ormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$ormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_${ri}$lassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_${ri}$geqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$orm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_${ri}$orm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_${ri}$lassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_${ri}$lacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              if (m>1) call stdlib_${ri}$laset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_${ri}$laset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_${ri}$lacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_${ri}$lacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_${ri}$laset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_${ri}$lagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_${ri}$lagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_${ri}$gemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_${ri}$gemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_${ri}$lacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_${ri}$gemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_${ri}$gemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_${ri}$lacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_${ri}$lacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_${ri}$lacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_${ri}$gemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_${ri}$lacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_${ri}$gemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_${ri}$lacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_${ri}$lacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_${ri}$gemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_${ri}$lacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_${ri}$tgex2


     pure subroutine stdlib_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! DTGEXC: reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgexc


     pure subroutine stdlib_${ri}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! DTGSEN: reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by DGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! DTGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, DTGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(${rk}$) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max,sign,sqrt
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*( n-m ) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_${ri}$lassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_${ri}$lassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_${ri}$lassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_${ri}$lassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_${ri}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_${ri}$lacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_${ri}$lacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ri}$tgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_${ri}$lacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_${ri}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ri}$tgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_80: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_${ri}$lag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_80
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$tgsen


     pure subroutine stdlib_${ri}$tgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
     !! DTGSJA: computes the generalized singular value decomposition (GSVD)
     !! of two real upper triangular (or trapezoidal) matrices A and B.
     !! On entry, it is assumed that matrices A and B have the following
     !! forms, which may be obtained by the preprocessing subroutine DGGSVP
     !! from a general M-by-N matrix A and P-by-N matrix B:
     !! N-K-L  K    L
     !! A =    K ( 0    A12  A13 ) if M-K-L >= 0;
     !! L ( 0     0   A23 )
     !! M-K-L ( 0     0    0  )
     !! N-K-L  K    L
     !! A =  K ( 0    A12  A13 ) if M-K-L < 0;
     !! M-K ( 0     0   A23 )
     !! N-K-L  K    L
     !! B =  L ( 0     0   B13 )
     !! P-L ( 0     0    0  )
     !! where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
     !! upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
     !! otherwise A23 is (M-K)-by-L upper trapezoidal.
     !! On exit,
     !! U**T *A*Q = D1*( 0 R ),    V**T *B*Q = D2*( 0 R ),
     !! where U, V and Q are orthogonal matrices.
     !! R is a nonsingular upper triangular matrix, and D1 and D2 are
     !! ``diagonal'' matrices, which are of the following structures:
     !! If M-K-L >= 0,
     !! K  L
     !! D1 =     K ( I  0 )
     !! L ( 0  C )
     !! M-K-L ( 0  0 )
     !! K  L
     !! D2 = L   ( 0  S )
     !! P-L ( 0  0 )
     !! N-K-L  K    L
     !! ( 0 R ) = K (  0   R11  R12 ) K
     !! L (  0    0   R22 ) L
     !! where
     !! C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
     !! S = diag( BETA(K+1),  ... , BETA(K+L) ),
     !! C**2 + S**2 = I.
     !! R is stored in A(1:K+L,N-K-L+1:N) on exit.
     !! If M-K-L < 0,
     !! K M-K K+L-M
     !! D1 =   K ( I  0    0   )
     !! M-K ( 0  C    0   )
     !! K M-K K+L-M
     !! D2 =   M-K ( 0  S    0   )
     !! K+L-M ( 0  0    I   )
     !! P-L ( 0  0    0   )
     !! N-K-L  K   M-K  K+L-M
     !! ( 0 R ) =    K ( 0    R11  R12  R13  )
     !! M-K ( 0     0   R22  R23  )
     !! K+L-M ( 0     0    0   R33  )
     !! where
     !! C = diag( ALPHA(K+1), ... , ALPHA(M) ),
     !! S = diag( BETA(K+1),  ... , BETA(M) ),
     !! C**2 + S**2 = I.
     !! R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
     !! (  0  R22 R23 )
     !! in B(M-K+1:L,N+M-K-L+1:N) on exit.
     !! The computation of the orthogonal transformation matrices U, V or Q
     !! is optional.  These matrices may either be formed explicitly, or they
     !! may be postmultiplied into input matrices U1, V1, or Q1.
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobq, jobu, jobv
           integer(ilp), intent(out) :: info, ncycle
           integer(ilp), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(${rk}$), intent(in) :: tola, tolb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           real(${rk}$), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 40
           real(${rk}$), parameter :: hugenum = huge(zero)
           
           
           ! Local Scalars 
           logical(lk) :: initq, initu, initv, upper, wantq, wantu, wantv
           integer(ilp) :: i, j, kcycle
           real(${rk}$) :: a1, a2, a3, b1, b2, b3, csq, csu, csv, error, gamma, rwk, snq, snu, snv, &
                     ssmin
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,huge
           ! Executable Statements 
           ! decode and test the input parameters
           initu = stdlib_lsame( jobu, 'I' )
           wantu = initu .or. stdlib_lsame( jobu, 'U' )
           initv = stdlib_lsame( jobv, 'I' )
           wantv = initv .or. stdlib_lsame( jobv, 'V' )
           initq = stdlib_lsame( jobq, 'I' )
           wantq = initq .or. stdlib_lsame( jobq, 'Q' )
           info = 0
           if( .not.( initu .or. wantu .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -1
           else if( .not.( initv .or. wantv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -2
           else if( .not.( initq .or. wantq .or. stdlib_lsame( jobq, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( p<0 ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, m ) ) then
              info = -10
           else if( ldb<max( 1, p ) ) then
              info = -12
           else if( ldu<1 .or. ( wantu .and. ldu<m ) ) then
              info = -18
           else if( ldv<1 .or. ( wantv .and. ldv<p ) ) then
              info = -20
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -22
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSJA', -info )
              return
           end if
           ! initialize u, v and q, if necessary
           if( initu )call stdlib_${ri}$laset( 'FULL', m, m, zero, one, u, ldu )
           if( initv )call stdlib_${ri}$laset( 'FULL', p, p, zero, one, v, ldv )
           if( initq )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           ! loop until convergence
           upper = .false.
           loop_40: do kcycle = 1, maxit
              upper = .not.upper
              loop_20: do i = 1, l - 1
                 loop_10: do j = i + 1, l
                    a1 = zero
                    a2 = zero
                    a3 = zero
                    if( k+i<=m )a1 = a( k+i, n-l+i )
                    if( k+j<=m )a3 = a( k+j, n-l+j )
                    b1 = b( i, n-l+i )
                    b3 = b( j, n-l+j )
                    if( upper ) then
                       if( k+i<=m )a2 = a( k+i, n-l+j )
                       b2 = b( i, n-l+j )
                    else
                       if( k+j<=m )a2 = a( k+j, n-l+i )
                       b2 = b( j, n-l+i )
                    end if
                    call stdlib_${ri}$lags2( upper, a1, a2, a3, b1, b2, b3, csu, snu,csv, snv, csq, &
                              snq )
                    ! update (k+i)-th and (k+j)-th rows of matrix a: u**t *a
                    if( k+j<=m )call stdlib_${ri}$rot( l, a( k+j, n-l+1 ), lda, a( k+i, n-l+1 ),lda, &
                              csu, snu )
                    ! update i-th and j-th rows of matrix b: v**t *b
                    call stdlib_${ri}$rot( l, b( j, n-l+1 ), ldb, b( i, n-l+1 ), ldb,csv, snv )
                    ! update (n-l+i)-th and (n-l+j)-th columns of matrices
                    ! a and b: a*q and b*q
                    call stdlib_${ri}$rot( min( k+l, m ), a( 1, n-l+j ), 1,a( 1, n-l+i ), 1, csq, snq )
                              
                    call stdlib_${ri}$rot( l, b( 1, n-l+j ), 1, b( 1, n-l+i ), 1, csq,snq )
                    if( upper ) then
                       if( k+i<=m )a( k+i, n-l+j ) = zero
                       b( i, n-l+j ) = zero
                    else
                       if( k+j<=m )a( k+j, n-l+i ) = zero
                       b( j, n-l+i ) = zero
                    end if
                    ! update orthogonal matrices u, v, q, if desired.
                    if( wantu .and. k+j<=m )call stdlib_${ri}$rot( m, u( 1, k+j ), 1, u( 1, k+i ), 1, &
                              csu,snu )
                    if( wantv )call stdlib_${ri}$rot( p, v( 1, j ), 1, v( 1, i ), 1, csv, snv )
                    if( wantq )call stdlib_${ri}$rot( n, q( 1, n-l+j ), 1, q( 1, n-l+i ), 1, csq,snq )
                              
                 end do loop_10
              end do loop_20
              if( .not.upper ) then
                 ! the matrices a13 and b13 were lower triangular at the start
                 ! of the cycle, and are now upper triangular.
                 ! convergence test: test the parallelism of the corresponding
                 ! rows of a and b.
                 error = zero
                 do i = 1, min( l, m-k )
                    call stdlib_${ri}$copy( l-i+1, a( k+i, n-l+i ), lda, work, 1 )
                    call stdlib_${ri}$copy( l-i+1, b( i, n-l+i ), ldb, work( l+1 ), 1 )
                    call stdlib_${ri}$lapll( l-i+1, work, 1, work( l+1 ), 1, ssmin )
                    error = max( error, ssmin )
                 end do
                 if( abs( error )<=min( tola, tolb ) )go to 50
              end if
              ! end of cycle loop
           end do loop_40
           ! the algorithm has not converged after maxit cycles.
           info = 1
           go to 100
           50 continue
           ! if error <= min(tola,tolb), then the algorithm has converged.
           ! compute the generalized singular value pairs (alpha, beta), and
           ! set the triangular matrix r to array a.
           do i = 1, k
              alpha( i ) = one
              beta( i ) = zero
           end do
           do i = 1, min( l, m-k )
              a1 = a( k+i, n-l+i )
              b1 = b( i, n-l+i )
              gamma = b1 / a1
              if( (gamma<=hugenum).and.(gamma>=-hugenum) ) then
                 ! change sign if necessary
                 if( gamma<zero ) then
                    call stdlib_${ri}$scal( l-i+1, -one, b( i, n-l+i ), ldb )
                    if( wantv )call stdlib_${ri}$scal( p, -one, v( 1, i ), 1 )
                 end if
                 call stdlib_${ri}$lartg( abs( gamma ), one, beta( k+i ), alpha( k+i ),rwk )
                 if( alpha( k+i )>=beta( k+i ) ) then
                    call stdlib_${ri}$scal( l-i+1, one / alpha( k+i ), a( k+i, n-l+i ),lda )
                 else
                    call stdlib_${ri}$scal( l-i+1, one / beta( k+i ), b( i, n-l+i ),ldb )
                    call stdlib_${ri}$copy( l-i+1, b( i, n-l+i ), ldb, a( k+i, n-l+i ),lda )
                 end if
              else
                 alpha( k+i ) = zero
                 beta( k+i ) = one
                 call stdlib_${ri}$copy( l-i+1, b( i, n-l+i ), ldb, a( k+i, n-l+i ),lda )
              end if
           end do
           ! post-assignment
           do i = m + 1, k + l
              alpha( i ) = zero
              beta( i ) = one
           end do
           if( k+l<n ) then
              do i = k + l + 1, n
                 alpha( i ) = zero
                 beta( i ) = zero
              end do
           end if
           100 continue
           ncycle = kcycle
           return
     end subroutine stdlib_${ri}$tgsja


     pure subroutine stdlib_${ri}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! DTGSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by DGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(${rk}$) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(${rk}$) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_${ri}$lapy2( uhav, uhavi )
                    uhbv = stdlib_${ri}$lapy2( uhbv, uhbvi )
                    cond = stdlib_${ri}$lapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_${ri}$lapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_${ri}$lapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_${ri}$lag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_${rk}$*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_${ri}$lacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_${ri}$lacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_${ri}$tgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_${ri}$tgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgsna


     pure subroutine stdlib_${ri}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSY2: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with DLACON.
     !! DTGSY2 also (IJOB >= 1) contributes to the computation in DTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! DTGSYL. See DTGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(${rk}$), intent(inout) :: rdscal, rdsum
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(${rk}$) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(${rk}$) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_${ri}$axpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_${ri}$axpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$axpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$ger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_${ri}$ger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$axpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_${ri}$axpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_${ri}$gemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$ger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_${ri}$ger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_${ri}$laset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_${ri}$copy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_${ri}$copy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork ( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_${ri}$axpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_${ri}$axpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_${ri}$axpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_${ri}$axpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$axpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$ger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_${ri}$ger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$ger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_${ri}$ger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$gemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_${ri}$gemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_${ri}$laset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_${ri}$copy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_${ri}$copy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_${ri}$tgsy2


     pure subroutine stdlib_${ri}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSYL: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using DLACON.
     !! If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(${rk}$) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           intrinsic :: real,max,sqrt
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'DTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'DTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_${ri}$tgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ri}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ri}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ri}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ri}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_${ri}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_${ri}$scal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_${ri}$scal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_${ri}$scal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ri}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ri}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ri}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ri}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_${ri}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_${ri}$scal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_${ri}$scal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_${ri}$scal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgsyl


     subroutine stdlib_${ri}$tpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
     !! DTPCON: estimates the reciprocal of the condition number of a packed
     !! triangular matrix A, in either the 1-norm or the infinity-norm.
     !! The norm of A is computed and an estimate is obtained for
     !! norm(inv(A)), then the reciprocal of the condition number is
     !! computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, onenrm, upper
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(${rk}$) :: ainvnm, anorm, scale, smlnum, xnorm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,real,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPCON', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              rcond = one
              return
           end if
           rcond = zero
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )*real( max( 1, n ),KIND=${rk}$)
           ! compute the norm of the triangular matrix a.
           anorm = stdlib_${ri}$lantp( norm, uplo, diag, n, ap, work )
           ! continue only if anorm > 0.
           if( anorm>zero ) then
              ! estimate the norm of the inverse of a.
              ainvnm = zero
              normin = 'N'
              if( onenrm ) then
                 kase1 = 1
              else
                 kase1 = 2
              end if
              kase = 0
              10 continue
              call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
              if( kase/=0 ) then
                 if( kase==kase1 ) then
                    ! multiply by inv(a).
                    call stdlib_${ri}$latps( uplo, 'NO TRANSPOSE', diag, normin, n, ap,work, scale, &
                              work( 2*n+1 ), info )
                 else
                    ! multiply by inv(a**t).
                    call stdlib_${ri}$latps( uplo, 'TRANSPOSE', diag, normin, n, ap,work, scale, work( &
                              2*n+1 ), info )
                 end if
                 normin = 'Y'
                 ! multiply by 1/scale if doing so will not cause overflow.
                 if( scale/=one ) then
                    ix = stdlib_i${ri}$amax( n, work, 1 )
                    xnorm = abs( work( ix ) )
                    if( scale<xnorm*smlnum .or. scale==zero )go to 20
                    call stdlib_${ri}$rscl( n, scale, work, 1 )
                 end if
                 go to 10
              end if
              ! compute the estimate of the reciprocal condition number.
              if( ainvnm/=zero )rcond = ( one / anorm ) / ainvnm
           end if
           20 continue
           return
     end subroutine stdlib_${ri}$tpcon


     pure subroutine stdlib_${ri}$tplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
     !! DTPLQT: computes a blocked LQ factorization of a real
     !! "triangular-pentagonal" matrix C, which is composed of a
     !! triangular block A and pentagonal block B, using the compact
     !! WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l, mb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ib, lb, nb, iinfo
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. (l>min(m,n) .and. min(m,n)>=0)) then
              info = -3
           else if( mb<1 .or. (mb>m .and. m>0)) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldb<max( 1, m ) ) then
              info = -8
           else if( ldt<mb ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPLQT', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) return
           do i = 1, m, mb
           ! compute the qr factorization of the current block
              ib = min( m-i+1, mb )
              nb = min( n-l+i+ib-1, n )
              if( i>=l ) then
                 lb = 0
              else
                 lb = nb-n+l-i+1
              end if
              call stdlib_${ri}$tplqt2( ib, nb, lb, a(i,i), lda, b( i, 1 ), ldb,t(1, i ), ldt, iinfo )
                        
           ! update by applying h**t to b(i+ib:m,:) from the right
              if( i+ib<=m ) then
                 call stdlib_${ri}$tprfb( 'R', 'N', 'F', 'R', m-i-ib+1, nb, ib, lb,b( i, 1 ), ldb, t( &
                           1, i ), ldt,a( i+ib, i ), lda, b( i+ib, 1 ), ldb,work, m-i-ib+1)
              end if
           end do
           return
     end subroutine stdlib_${ri}$tplqt


     pure subroutine stdlib_${ri}$tplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
     !! DTPLQT2: computes a LQ a factorization of a real "triangular-pentagonal"
     !! matrix C, which is composed of a triangular block A and pentagonal block B,
     !! using the compact WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, p, mp, np
           real(${rk}$) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. l>min(m,n) ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, m ) ) then
              info = -7
           else if( ldt<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPLQT2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) return
           do i = 1, m
              ! generate elementary reflector h(i) to annihilate b(i,:)
              p = n-l+min( l, i )
              call stdlib_${ri}$larfg( p+1, a( i, i ), b( i, 1 ), ldb, t( 1, i ) )
              if( i<m ) then
                 ! w(m-i:1) := c(i+1:m,i:n) * c(i,i:n) [use w = t(m,:)]
                 do j = 1, m-i
                    t( m, j ) = (a( i+j, i ))
                 end do
                 call stdlib_${ri}$gemv( 'N', m-i, p, one, b( i+1, 1 ), ldb,b( i, 1 ), ldb, one, t( m, &
                           1 ), ldt )
                 ! c(i+1:m,i:n) = c(i+1:m,i:n) + alpha * c(i,i:n)*w(m-1:1)^h
                 alpha = -(t( 1, i ))
                 do j = 1, m-i
                    a( i+j, i ) = a( i+j, i ) + alpha*(t( m, j ))
                 end do
                 call stdlib_${ri}$ger( m-i, p, alpha,  t( m, 1 ), ldt,b( i, 1 ), ldb, b( i+1, 1 ), &
                           ldb )
              end if
           end do
           do i = 2, m
              ! t(i,1:i-1) := c(i:i-1,1:n) * (alpha * c(i,i:n)^h)
              alpha = -t( 1, i )
              do j = 1, i-1
                 t( i, j ) = zero
              end do
              p = min( i-1, l )
              np = min( n-l+1, n )
              mp = min( p+1, m )
              ! triangular part of b2
              do j = 1, p
                 t( i, j ) = alpha*b( i, n-l+j )
              end do
              call stdlib_${ri}$trmv( 'L', 'N', 'N', p, b( 1, np ), ldb,t( i, 1 ), ldt )
              ! rectangular part of b2
              call stdlib_${ri}$gemv( 'N', i-1-p, l,  alpha, b( mp, np ), ldb,b( i, np ), ldb, zero, t(&
                         i,mp ), ldt )
              ! b1
              call stdlib_${ri}$gemv( 'N', i-1, n-l, alpha, b, ldb, b( i, 1 ), ldb,one, t( i, 1 ), ldt &
                        )
              ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(i,1:i-1)
             call stdlib_${ri}$trmv( 'L', 'T', 'N', i-1, t, ldt, t( i, 1 ), ldt )
              ! t(i,i) = tau(i)
              t( i, i ) = t( 1, i )
              t( 1, i ) = zero
           end do
           do i=1,m
              do j= i+1,m
                 t(i,j)=t(j,i)
                 t(j,i)= zero
              end do
           end do
     end subroutine stdlib_${ri}$tplqt2


     pure subroutine stdlib_${ri}$tpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, ldb, &
     !! DTPMQRT applies a real orthogonal matrix Q obtained from a
     !! "triangular-pentagonal" real block reflector H to a general
     !! real matrix C, which consists of two blocks A and B.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, lda, ldb, m, n, l, mb, ldt
           ! Array Arguments 
           real(${rk}$), intent(in) :: v(ldv,*), t(ldt,*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, nb, lb, kf, ldaq
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'T' )
           notran = stdlib_lsame( trans, 'N' )
           if ( left ) then
              ldaq = max( 1, k )
           else if ( right ) then
              ldaq = max( 1, m )
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 ) then
              info = -5
           else if( l<0 .or. l>k ) then
              info = -6
           else if( mb<1 .or. (mb>k .and. k>0) ) then
              info = -7
           else if( ldv<k ) then
              info = -9
           else if( ldt<mb ) then
              info = -11
           else if( lda<ldaq ) then
              info = -13
           else if( ldb<max( 1, m ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPMLQT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. notran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 nb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = 0
                 end if
                 call stdlib_${ri}$tprfb( 'L', 'T', 'F', 'R', nb, n, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. tran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 nb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = nb-n+l-i+1
                 end if
                 call stdlib_${ri}$tprfb( 'R', 'N', 'F', 'R', m, nb, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           else if( left .and. tran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 nb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = 0
                 end if
                 call stdlib_${ri}$tprfb( 'L', 'N', 'F', 'R', nb, n, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. notran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 nb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = nb-n+l-i+1
                 end if
                 call stdlib_${ri}$tprfb( 'R', 'T', 'F', 'R', m, nb, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           end if
           return
     end subroutine stdlib_${ri}$tpmlqt


     pure subroutine stdlib_${ri}$tpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, ldb, &
     !! DTPMQRT: applies a real orthogonal matrix Q obtained from a
     !! "triangular-pentagonal" real block reflector H to a general
     !! real matrix C, which consists of two blocks A and B.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, lda, ldb, m, n, l, nb, ldt
           ! Array Arguments 
           real(${rk}$), intent(in) :: v(ldv,*), t(ldt,*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, mb, lb, kf, ldaq, ldvq
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'T' )
           notran = stdlib_lsame( trans, 'N' )
           if ( left ) then
              ldvq = max( 1, m )
              ldaq = max( 1, k )
           else if ( right ) then
              ldvq = max( 1, n )
              ldaq = max( 1, m )
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 ) then
              info = -5
           else if( l<0 .or. l>k ) then
              info = -6
           else if( nb<1 .or. (nb>k .and. k>0) ) then
              info = -7
           else if( ldv<ldvq ) then
              info = -9
           else if( ldt<nb ) then
              info = -11
           else if( lda<ldaq ) then
              info = -13
           else if( ldb<max( 1, m ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPMQRT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. tran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 mb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-m+l-i+1
                 end if
                 call stdlib_${ri}$tprfb( 'L', 'T', 'F', 'C', mb, n, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. notran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 mb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-n+l-i+1
                 end if
                 call stdlib_${ri}$tprfb( 'R', 'N', 'F', 'C', m, mb, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           else if( left .and. notran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 mb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-m+l-i+1
                 end if
                 call stdlib_${ri}$tprfb( 'L', 'N', 'F', 'C', mb, n, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. tran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 mb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-n+l-i+1
                 end if
                 call stdlib_${ri}$tprfb( 'R', 'T', 'F', 'C', m, mb, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           end if
           return
     end subroutine stdlib_${ri}$tpmqrt


     pure subroutine stdlib_${ri}$tpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
     !! DTPQRT: computes a blocked QR factorization of a real
     !! "triangular-pentagonal" matrix C, which is composed of a
     !! triangular block A and pentagonal block B, using the compact
     !! WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ib, lb, mb, iinfo
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. (l>min(m,n) .and. min(m,n)>=0)) then
              info = -3
           else if( nb<1 .or. (nb>n .and. n>0)) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, m ) ) then
              info = -8
           else if( ldt<nb ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPQRT', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) return
           do i = 1, n, nb
           ! compute the qr factorization of the current block
              ib = min( n-i+1, nb )
              mb = min( m-l+i+ib-1, m )
              if( i>=l ) then
                 lb = 0
              else
                 lb = mb-m+l-i+1
              end if
              call stdlib_${ri}$tpqrt2( mb, ib, lb, a(i,i), lda, b( 1, i ), ldb,t(1, i ), ldt, iinfo )
                        
           ! update by applying h**t to b(:,i+ib:n) from the left
              if( i+ib<=n ) then
                 call stdlib_${ri}$tprfb( 'L', 'T', 'F', 'C', mb, n-i-ib+1, ib, lb,b( 1, i ), ldb, t( &
                           1, i ), ldt,a( i, i+ib ), lda, b( 1, i+ib ), ldb,work, ib )
              end if
           end do
           return
     end subroutine stdlib_${ri}$tpqrt


     pure subroutine stdlib_${ri}$tpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
     !! DTPQRT2: computes a QR factorization of a real "triangular-pentagonal"
     !! matrix C, which is composed of a triangular block A and pentagonal block B,
     !! using the compact WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, p, mp, np
           real(${rk}$) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. l>min(m,n) ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, m ) ) then
              info = -7
           else if( ldt<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPQRT2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) return
           do i = 1, n
              ! generate elementary reflector h(i) to annihilate b(:,i)
              p = m-l+min( l, i )
              call stdlib_${ri}$larfg( p+1, a( i, i ), b( 1, i ), 1, t( i, 1 ) )
              if( i<n ) then
                 ! w(1:n-i) := c(i:m,i+1:n)^h * c(i:m,i) [use w = t(:,n)]
                 do j = 1, n-i
                    t( j, n ) = (a( i, i+j ))
                 end do
                 call stdlib_${ri}$gemv( 'T', p, n-i, one, b( 1, i+1 ), ldb,b( 1, i ), 1, one, t( 1, n &
                           ), 1 )
                 ! c(i:m,i+1:n) = c(i:m,i+1:n) + alpha*c(i:m,i)*w(1:n-1)^h
                 alpha = -(t( i, 1 ))
                 do j = 1, n-i
                    a( i, i+j ) = a( i, i+j ) + alpha*(t( j, n ))
                 end do
                 call stdlib_${ri}$ger( p, n-i, alpha, b( 1, i ), 1,t( 1, n ), 1, b( 1, i+1 ), ldb )
                           
              end if
           end do
           do i = 2, n
              ! t(1:i-1,i) := c(i:m,1:i-1)^h * (alpha * c(i:m,i))
              alpha = -t( i, 1 )
              do j = 1, i-1
                 t( j, i ) = zero
              end do
              p = min( i-1, l )
              mp = min( m-l+1, m )
              np = min( p+1, n )
              ! triangular part of b2
              do j = 1, p
                 t( j, i ) = alpha*b( m-l+j, i )
              end do
              call stdlib_${ri}$trmv( 'U', 'T', 'N', p, b( mp, 1 ), ldb,t( 1, i ), 1 )
              ! rectangular part of b2
              call stdlib_${ri}$gemv( 'T', l, i-1-p, alpha, b( mp, np ), ldb,b( mp, i ), 1, zero, t( &
                        np, i ), 1 )
              ! b1
              call stdlib_${ri}$gemv( 'T', m-l, i-1, alpha, b, ldb, b( 1, i ), 1,one, t( 1, i ), 1 )
                        
              ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(1:i-1,i)
              call stdlib_${ri}$trmv( 'U', 'N', 'N', i-1, t, ldt, t( 1, i ), 1 )
              ! t(i,i) = tau(i)
              t( i, i ) = t( i, 1 )
              t( i, 1 ) = zero
           end do
     end subroutine stdlib_${ri}$tpqrt2


     pure subroutine stdlib_${ri}$tprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
     !! DTPRFB: applies a real "triangular-pentagonal" block reflector H or its
     !! transpose H**T to a real matrix C, which is composed of two
     !! blocks A and B, either from the left or right.
               lda, b, ldb, work, ldwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, side, storev, trans
           integer(ilp), intent(in) :: k, l, lda, ldb, ldt, ldv, ldwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(in) :: t(ldt,*), v(ldv,*)
           real(${rk}$), intent(out) :: work(ldwork,*)
        ! ==========================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, mp, np, kp
           logical(lk) :: left, forward, column, right, backward, row
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 .or. k<=0 .or. l<0 ) return
           if( stdlib_lsame( storev, 'C' ) ) then
              column = .true.
              row = .false.
           else if ( stdlib_lsame( storev, 'R' ) ) then
              column = .false.
              row = .true.
           else
              column = .false.
              row = .false.
           end if
           if( stdlib_lsame( side, 'L' ) ) then
              left = .true.
              right = .false.
           else if( stdlib_lsame( side, 'R' ) ) then
              left = .false.
              right = .true.
           else
              left = .false.
              right = .false.
           end if
           if( stdlib_lsame( direct, 'F' ) ) then
              forward = .true.
              backward = .false.
           else if( stdlib_lsame( direct, 'B' ) ) then
              forward = .false.
              backward = .true.
           else
              forward = .false.
              backward = .false.
           end if
       ! ---------------------------------------------------------------------------
           if( column .and. forward .and. left  ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i ]    (k-by-k)
                        ! [ v ]    (m-by-k)
              ! form  h c  or  h**t c  where  c = [ a ]  (k-by-n)
                                                ! [ b ]  (m-by-n)
              ! h = i - w t w**t          or  h**t = i - w t**t w**t
              ! a = a -   t (a + v**t b)  or  a = a -   t**t (a + v**t b)
              ! b = b - v t (a + v**t b)  or  b = b - v t**t (a + v**t b)
       ! ---------------------------------------------------------------------------
              mp = min( m-l+1, m )
              kp = min( l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( i, j ) = b( m-l+i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'U', 'T', 'N', l, n, one, v( mp, 1 ), ldv,work, ldwork )
                        
              call stdlib_${ri}$gemm( 'T', 'N', l, n, m-l, one, v, ldv, b, ldb,one, work, ldwork )
                        
              call stdlib_${ri}$gemm( 'T', 'N', k-l, n, m, one, v( 1, kp ), ldv,b, ldb, zero, work( kp,&
                         1 ), ldwork )
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'U', trans, 'N', k, n, one, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'N', 'N', m-l, n, k, -one, v, ldv, work, ldwork,one, b, ldb )
                        
              call stdlib_${ri}$gemm( 'N', 'N', l, n, k-l, -one, v( mp, kp ), ldv,work( kp, 1 ), &
                        ldwork, one, b( mp, 1 ),  ldb )
              call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', l, n, one, v( mp, 1 ), ldv,work, ldwork )
                        
              do j = 1, n
                 do i = 1, l
                    b( m-l+i, j ) = b( m-l+i, j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( column .and. forward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i ]    (k-by-k)
                        ! [ v ]    (n-by-k)
              ! form  c h or  c h**t  where  c = [ a b ] (a is m-by-k, b is m-by-n)
              ! h = i - w t w**t          or  h**t = i - w t**t w**t
              ! a = a - (a + b v) t      or  a = a - (a + b v) t**t
              ! b = b - (a + b v) t v**t  or  b = b - (a + b v) t**t v**t
       ! ---------------------------------------------------------------------------
              np = min( n-l+1, n )
              kp = min( l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, j ) = b( i, n-l+j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'N', m, l, one, v( np, 1 ), ldv,work, ldwork )
                        
              call stdlib_${ri}$gemm( 'N', 'N', m, l, n-l, one, b, ldb,v, ldv, one, work, ldwork )
                        
              call stdlib_${ri}$gemm( 'N', 'N', m, k-l, n, one, b, ldb,v( 1, kp ), ldv, zero, work( 1, &
                        kp ), ldwork )
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'U', trans, 'N', m, k, one, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'N', 'T', m, n-l, k, -one, work, ldwork,v, ldv, one, b, ldb )
                        
              call stdlib_${ri}$gemm( 'N', 'T', m, l, k-l, -one, work( 1, kp ), ldwork,v( np, kp ), &
                        ldv, one, b( 1, np ), ldb )
              call stdlib_${ri}$trmm( 'R', 'U', 'T', 'N', m, l, one, v( np, 1 ), ldv,work, ldwork )
                        
              do j = 1, l
                 do i = 1, m
                    b( i, n-l+j ) = b( i, n-l+j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( column .and. backward .and. left ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v ]    (m-by-k)
                        ! [ i ]    (k-by-k)
              ! form  h c  or  h**t c  where  c = [ b ]  (m-by-n)
                                                ! [ a ]  (k-by-n)
              ! h = i - w t w**t          or  h**t = i - w t**t w**t
              ! a = a -   t (a + v**t b)  or  a = a -   t**t (a + v**t b)
              ! b = b - v t (a + v**t b)  or  b = b - v t**t (a + v**t b)
       ! ---------------------------------------------------------------------------
              mp = min( l+1, m )
              kp = min( k-l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( k-l+i, j ) = b( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'L', 'T', 'N', l, n, one, v( 1, kp ), ldv,work( kp, 1 ), &
                        ldwork )
              call stdlib_${ri}$gemm( 'T', 'N', l, n, m-l, one, v( mp, kp ), ldv,b( mp, 1 ), ldb, one, &
                        work( kp, 1 ), ldwork )
              call stdlib_${ri}$gemm( 'T', 'N', k-l, n, m, one, v, ldv,b, ldb, zero, work, ldwork )
                        
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'L', trans, 'N', k, n, one, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'N', 'N', m-l, n, k, -one, v( mp, 1 ), ldv,work, ldwork, one, b( &
                        mp, 1 ), ldb )
              call stdlib_${ri}$gemm( 'N', 'N', l, n, k-l, -one, v, ldv,work, ldwork, one, b,  ldb )
                        
              call stdlib_${ri}$trmm( 'L', 'L', 'N', 'N', l, n, one, v( 1, kp ), ldv,work( kp, 1 ), &
                        ldwork )
              do j = 1, n
                 do i = 1, l
                    b( i, j ) = b( i, j ) - work( k-l+i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( column .and. backward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v ]    (n-by-k)
                        ! [ i ]    (k-by-k)
              ! form  c h  or  c h**t  where  c = [ b a ] (b is m-by-n, a is m-by-k)
              ! h = i - w t w**t          or  h**t = i - w t**t w**t
              ! a = a - (a + b v) t      or  a = a - (a + b v) t**t
              ! b = b - (a + b v) t v**t  or  b = b - (a + b v) t**t v**t
       ! ---------------------------------------------------------------------------
              np = min( l+1, n )
              kp = min( k-l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, k-l+j ) = b( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'L', 'N', 'N', m, l, one, v( 1, kp ), ldv,work( 1, kp ), &
                        ldwork )
              call stdlib_${ri}$gemm( 'N', 'N', m, l, n-l, one, b( 1, np ), ldb,v( np, kp ), ldv, one, &
                        work( 1, kp ), ldwork )
              call stdlib_${ri}$gemm( 'N', 'N', m, k-l, n, one, b, ldb,v, ldv, zero, work, ldwork )
                        
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'L', trans, 'N', m, k, one, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'N', 'T', m, n-l, k, -one, work, ldwork,v( np, 1 ), ldv, one, b( &
                        1, np ), ldb )
              call stdlib_${ri}$gemm( 'N', 'T', m, l, k-l, -one, work, ldwork,v, ldv, one, b, ldb )
                        
              call stdlib_${ri}$trmm( 'R', 'L', 'T', 'N', m, l, one, v( 1, kp ), ldv,work( 1, kp ), &
                        ldwork )
              do j = 1, l
                 do i = 1, m
                    b( i, j ) = b( i, j ) - work( i, k-l+j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. forward .and. left ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i v ] ( i is k-by-k, v is k-by-m )
              ! form  h c  or  h**t c  where  c = [ a ]  (k-by-n)
                                                ! [ b ]  (m-by-n)
              ! h = i - w**t t w          or  h**t = i - w**t t**t w
              ! a = a -     t (a + v b)  or  a = a -     t**t (a + v b)
              ! b = b - v**t t (a + v b)  or  b = b - v**t t**t (a + v b)
       ! ---------------------------------------------------------------------------
              mp = min( m-l+1, m )
              kp = min( l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( i, j ) = b( m-l+i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'L', 'N', 'N', l, n, one, v( 1, mp ), ldv,work, ldb )
                        
              call stdlib_${ri}$gemm( 'N', 'N', l, n, m-l, one, v, ldv,b, ldb,one, work, ldwork )
                        
              call stdlib_${ri}$gemm( 'N', 'N', k-l, n, m, one, v( kp, 1 ), ldv,b, ldb, zero, work( kp,&
                         1 ), ldwork )
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'U', trans, 'N', k, n, one, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'T', 'N', m-l, n, k, -one, v, ldv, work, ldwork,one, b, ldb )
                        
              call stdlib_${ri}$gemm( 'T', 'N', l, n, k-l, -one, v( kp, mp ), ldv,work( kp, 1 ), &
                        ldwork, one, b( mp, 1 ), ldb )
              call stdlib_${ri}$trmm( 'L', 'L', 'T', 'N', l, n, one, v( 1, mp ), ldv,work, ldwork )
                        
              do j = 1, n
                 do i = 1, l
                    b( m-l+i, j ) = b( m-l+i, j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. forward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i v ] ( i is k-by-k, v is k-by-n )
              ! form  c h  or  c h**t  where  c = [ a b ] (a is m-by-k, b is m-by-n)
              ! h = i - w**t t w            or  h**t = i - w**t t**t w
              ! a = a - (a + b v**t) t      or  a = a - (a + b v**t) t**t
              ! b = b - (a + b v**t) t v    or  b = b - (a + b v**t) t**t v
       ! ---------------------------------------------------------------------------
              np = min( n-l+1, n )
              kp = min( l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, j ) = b( i, n-l+j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'L', 'T', 'N', m, l, one, v( 1, np ), ldv,work, ldwork )
                        
              call stdlib_${ri}$gemm( 'N', 'T', m, l, n-l, one, b, ldb, v, ldv,one, work, ldwork )
                        
              call stdlib_${ri}$gemm( 'N', 'T', m, k-l, n, one, b, ldb,v( kp, 1 ), ldv, zero, work( 1, &
                        kp ), ldwork )
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'U', trans, 'N', m, k, one, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'N', 'N', m, n-l, k, -one, work, ldwork,v, ldv, one, b, ldb )
                        
              call stdlib_${ri}$gemm( 'N', 'N', m, l, k-l, -one, work( 1, kp ), ldwork,v( kp, np ), &
                        ldv, one, b( 1, np ), ldb )
              call stdlib_${ri}$trmm( 'R', 'L', 'N', 'N', m, l, one, v( 1, np ), ldv,work, ldwork )
                        
              do j = 1, l
                 do i = 1, m
                    b( i, n-l+j ) = b( i, n-l+j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. backward .and. left ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v i ] ( i is k-by-k, v is k-by-m )
              ! form  h c  or  h**t c  where  c = [ b ]  (m-by-n)
                                                ! [ a ]  (k-by-n)
              ! h = i - w**t t w          or  h**t = i - w**t t**t w
              ! a = a -     t (a + v b)  or  a = a -     t**t (a + v b)
              ! b = b - v**t t (a + v b)  or  b = b - v**t t**t (a + v b)
       ! ---------------------------------------------------------------------------
              mp = min( l+1, m )
              kp = min( k-l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( k-l+i, j ) = b( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'U', 'N', 'N', l, n, one, v( kp, 1 ), ldv,work( kp, 1 ), &
                        ldwork )
              call stdlib_${ri}$gemm( 'N', 'N', l, n, m-l, one, v( kp, mp ), ldv,b( mp, 1 ), ldb, one, &
                        work( kp, 1 ), ldwork )
              call stdlib_${ri}$gemm( 'N', 'N', k-l, n, m, one, v, ldv, b, ldb,zero, work, ldwork )
                        
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'L', 'L ', trans, 'N', k, n, one, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'T', 'N', m-l, n, k, -one, v( 1, mp ), ldv,work, ldwork, one, b( &
                        mp, 1 ), ldb )
              call stdlib_${ri}$gemm( 'T', 'N', l, n, k-l, -one, v, ldv,work, ldwork, one, b, ldb )
                        
              call stdlib_${ri}$trmm( 'L', 'U', 'T', 'N', l, n, one, v( kp, 1 ), ldv,work( kp, 1 ), &
                        ldwork )
              do j = 1, n
                 do i = 1, l
                    b( i, j ) = b( i, j ) - work( k-l+i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. backward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v i ] ( i is k-by-k, v is k-by-n )
              ! form  c h  or  c h**t  where  c = [ b a ] (a is m-by-k, b is m-by-n)
              ! h = i - w**t t w            or  h**t = i - w**t t**t w
              ! a = a - (a + b v**t) t      or  a = a - (a + b v**t) t**t
              ! b = b - (a + b v**t) t v    or  b = b - (a + b v**t) t**t v
       ! ---------------------------------------------------------------------------
              np = min( l+1, n )
              kp = min( k-l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, k-l+j ) = b( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'U', 'T', 'N', m, l, one, v( kp, 1 ), ldv,work( 1, kp ), &
                        ldwork )
              call stdlib_${ri}$gemm( 'N', 'T', m, l, n-l, one, b( 1, np ), ldb,v( kp, np ), ldv, one, &
                        work( 1, kp ), ldwork )
              call stdlib_${ri}$gemm( 'N', 'T', m, k-l, n, one, b, ldb, v, ldv,zero, work, ldwork )
                        
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_${ri}$trmm( 'R', 'L', trans, 'N', m, k, one, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_${ri}$gemm( 'N', 'N', m, n-l, k, -one, work, ldwork,v( 1, np ), ldv, one, b( &
                        1, np ), ldb )
              call stdlib_${ri}$gemm( 'N', 'N', m, l, k-l , -one, work, ldwork,v, ldv, one, b, ldb )
                        
              call stdlib_${ri}$trmm( 'R', 'U', 'N', 'N', m, l, one, v( kp, 1 ), ldv,work( 1, kp ), &
                        ldwork )
              do j = 1, l
                 do i = 1, m
                    b( i, j ) = b( i, j ) - work( i, k-l+j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_${ri}$tprfb


     pure subroutine stdlib_${ri}$tprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
     !! DTPRFS: provides error bounds and backward error estimates for the
     !! solution to a system of linear equations with a triangular packed
     !! coefficient matrix.
     !! The solution matrix X must be computed by DTPTRS or some other
     !! means before entering this routine.  DTPRFS does not do iterative
     !! refinement because doing so cannot improve the backward error.
               work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ap(*), b(ldb,*), x(ldx,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           character :: transt
           integer(ilp) :: i, j, k, kase, kc, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_250: do j = 1, nrhs
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a or a**t, depending on trans.
              call stdlib_${ri}$copy( n, x( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$tpmv( uplo, trans, diag, n, ap, work( n+1 ), 1 )
              call stdlib_${ri}$axpy( n, -one, b( 1, j ), 1, work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              if( notran ) then
                 ! compute abs(a)*abs(x) + abs(b).
                 if( upper ) then
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = 1, k
                             work( i ) = work( i ) + abs( ap( kc+i-1 ) )*xk
                          end do
                          kc = kc + k
                       end do
                    else
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = 1, k - 1
                             work( i ) = work( i ) + abs( ap( kc+i-1 ) )*xk
                          end do
                          work( k ) = work( k ) + xk
                          kc = kc + k
                       end do
                    end if
                 else
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = k, n
                             work( i ) = work( i ) + abs( ap( kc+i-k ) )*xk
                          end do
                          kc = kc + n - k + 1
                       end do
                    else
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = k + 1, n
                             work( i ) = work( i ) + abs( ap( kc+i-k ) )*xk
                          end do
                          work( k ) = work( k ) + xk
                          kc = kc + n - k + 1
                       end do
                    end if
                 end if
              else
                 ! compute abs(a**t)*abs(x) + abs(b).
                 if( upper ) then
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = 1, k
                             s = s + abs( ap( kc+i-1 ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                          kc = kc + k
                       end do
                    else
                       do k = 1, n
                          s = abs( x( k, j ) )
                          do i = 1, k - 1
                             s = s + abs( ap( kc+i-1 ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                          kc = kc + k
                       end do
                    end if
                 else
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = k, n
                             s = s + abs( ap( kc+i-k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                          kc = kc + n - k + 1
                       end do
                    else
                       do k = 1, n
                          s = abs( x( k, j ) )
                          do i = k + 1, n
                             s = s + abs( ap( kc+i-k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                          kc = kc + n - k + 1
                       end do
                    end if
                 end if
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              210 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**t).
                    call stdlib_${ri}$tpsv( uplo, transt, diag, n, ap, work( n+1 ), 1 )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$tpsv( uplo, trans, diag, n, ap, work( n+1 ), 1 )
                 end if
                 go to 210
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_250
           return
     end subroutine stdlib_${ri}$tprfs


     pure subroutine stdlib_${ri}$tptri( uplo, diag, n, ap, info )
     !! DTPTRI: computes the inverse of a real upper or lower triangular
     !! matrix A stored in packed format.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j, jc, jclast, jj
           real(${rk}$) :: ajj
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPTRI', -info )
              return
           end if
           ! check for singularity if non-unit.
           if( nounit ) then
              if( upper ) then
                 jj = 0
                 do info = 1, n
                    jj = jj + info
                    if( ap( jj )==zero )return
                 end do
              else
                 jj = 1
                 do info = 1, n
                    if( ap( jj )==zero )return
                    jj = jj + n - info + 1
                 end do
              end if
              info = 0
           end if
           if( upper ) then
              ! compute inverse of upper triangular matrix.
              jc = 1
              do j = 1, n
                 if( nounit ) then
                    ap( jc+j-1 ) = one / ap( jc+j-1 )
                    ajj = -ap( jc+j-1 )
                 else
                    ajj = -one
                 end if
                 ! compute elements 1:j-1 of j-th column.
                 call stdlib_${ri}$tpmv( 'UPPER', 'NO TRANSPOSE', diag, j-1, ap,ap( jc ), 1 )
                 call stdlib_${ri}$scal( j-1, ajj, ap( jc ), 1 )
                 jc = jc + j
              end do
           else
              ! compute inverse of lower triangular matrix.
              jc = n*( n+1 ) / 2
              do j = n, 1, -1
                 if( nounit ) then
                    ap( jc ) = one / ap( jc )
                    ajj = -ap( jc )
                 else
                    ajj = -one
                 end if
                 if( j<n ) then
                    ! compute elements j+1:n of j-th column.
                    call stdlib_${ri}$tpmv( 'LOWER', 'NO TRANSPOSE', diag, n-j,ap( jclast ), ap( jc+1 )&
                              , 1 )
                    call stdlib_${ri}$scal( n-j, ajj, ap( jc+1 ), 1 )
                 end if
                 jclast = jc
                 jc = jc - n + j - 2
              end do
           end if
           return
     end subroutine stdlib_${ri}$tptri


     pure subroutine stdlib_${ri}$tptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
     !! DTPTRS: solves a triangular system of the form
     !! A * X = B  or  A**T * X = B,
     !! where A is a triangular matrix of order N stored in packed format,
     !! and B is an N-by-NRHS matrix.  A check is made to verify that A is
     !! nonsingular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j, jc
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) .and. &
                     .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity.
           if( nounit ) then
              if( upper ) then
                 jc = 1
                 do info = 1, n
                    if( ap( jc+info-1 )==zero )return
                    jc = jc + info
                 end do
              else
                 jc = 1
                 do info = 1, n
                    if( ap( jc )==zero )return
                    jc = jc + n - info + 1
                 end do
              end if
           end if
           info = 0
           ! solve a * x = b  or  a**t * x = b.
           do j = 1, nrhs
              call stdlib_${ri}$tpsv( uplo, trans, diag, n, ap, b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ri}$tptrs


     pure subroutine stdlib_${ri}$tpttf( transr, uplo, n, ap, arf, info )
     !! DTPTTF: copies a triangular matrix A from standard packed format (TP)
     !! to rectangular full packed format (TF).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(0:*)
           real(${rk}$), intent(out) :: arf(0:*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k, nt
           integer(ilp) :: i, j, ij
           integer(ilp) :: ijp, jp, lda, js
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPTTF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( normaltransr ) then
                 arf( 0 ) = ap( 0 )
              else
                 arf( 0 ) = ap( 0 )
              end if
              return
           end if
           ! size of array arf(0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           ! set lda of arf^c; arf^c is (0:(n+1)/2-1,0:n-noe)
           ! where noe = 0 if n is even, noe = 1 if n is odd
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              lda = n + 1
           else
              nisodd = .true.
              lda = n
           end if
           ! arf^c has lda rows and n+1-noe cols
           if( .not.normaltransr )lda = ( n+1 ) / 2
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! n is odd, transr = 'n', and uplo = 'l'
                    ijp = 0
                    jp = 0
                    do j = 0, n2
                       do i = j, n - 1
                          ij = i + jp
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, n2 - 1
                       do j = 1 + i, n2
                          ij = i + j*lda
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                    ! n is odd, transr = 'n', and uplo = 'u'
                    ijp = 0
                    do j = 0, n1 - 1
                       ij = n2 + j
                       do i = 0, j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = n1, n - 1
                       ij = js
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! n is odd, transr = 't', and uplo = 'l'
                    ijp = 0
                    do i = 0, n2
                       do ij = i*( lda+1 ), n*lda - 1, lda
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 1
                    do j = 0, n2 - 1
                       do ij = js, js + n2 - j - 1
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! n is odd, transr = 't', and uplo = 'u'
                    ijp = 0
                    js = n2*lda
                    do j = 0, n1 - 1
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, n1
                       do ij = i, i + ( n1+i )*lda, lda
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! n is even, transr = 'n', and uplo = 'l'
                    ijp = 0
                    jp = 0
                    do j = 0, k - 1
                       do i = j, n - 1
                          ij = 1 + i + jp
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, k - 1
                       do j = i, k - 1
                          ij = i + j*lda
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                    ! n is even, transr = 'n', and uplo = 'u'
                    ijp = 0
                    do j = 0, k - 1
                       ij = k + 1 + j
                       do i = 0, j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = k, n - 1
                       ij = js
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! n is even, transr = 't', and uplo = 'l'
                    ijp = 0
                    do i = 0, k - 1
                       do ij = i + ( i+1 )*lda, ( n+1 )*lda - 1, lda
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 0
                    do j = 0, k - 1
                       do ij = js, js + k - j - 1
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! n is even, transr = 't', and uplo = 'u'
                    ijp = 0
                    js = ( k+1 )*lda
                    do j = 0, k - 1
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, k - 1
                       do ij = i, i + ( k+i )*lda, lda
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$tpttf


     pure subroutine stdlib_${ri}$tpttr( uplo, n, ap, a, lda, info )
     !! DTPTTR: copies a triangular matrix A from standard packed format (TP)
     !! to standard full format (TR).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           real(${rk}$), intent(out) :: a(lda,*)
           real(${rk}$), intent(in) :: ap(*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower
           integer(ilp) :: i, j, k
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTPTTR', -info )
              return
           end if
           if( lower ) then
              k = 0
              do j = 1, n
                 do i = j, n
                    k = k + 1
                    a( i, j ) = ap( k )
                 end do
              end do
           else
              k = 0
              do j = 1, n
                 do i = 1, j
                    k = k + 1
                    a( i, j ) = ap( k )
                 end do
              end do
           end if
           return
     end subroutine stdlib_${ri}$tpttr


     subroutine stdlib_${ri}$trcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
     !! DTRCON: estimates the reciprocal of the condition number of a
     !! triangular matrix A, in either the 1-norm or the infinity-norm.
     !! The norm of A is computed and an estimate is obtained for
     !! norm(inv(A)), then the reciprocal of the condition number is
     !! computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, onenrm, upper
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(${rk}$) :: ainvnm, anorm, scale, smlnum, xnorm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,real,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRCON', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              rcond = one
              return
           end if
           rcond = zero
           smlnum = stdlib_${ri}$lamch( 'SAFE MINIMUM' )*real( max( 1, n ),KIND=${rk}$)
           ! compute the norm of the triangular matrix a.
           anorm = stdlib_${ri}$lantr( norm, uplo, diag, n, n, a, lda, work )
           ! continue only if anorm > 0.
           if( anorm>zero ) then
              ! estimate the norm of the inverse of a.
              ainvnm = zero
              normin = 'N'
              if( onenrm ) then
                 kase1 = 1
              else
                 kase1 = 2
              end if
              kase = 0
              10 continue
              call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
              if( kase/=0 ) then
                 if( kase==kase1 ) then
                    ! multiply by inv(a).
                    call stdlib_${ri}$latrs( uplo, 'NO TRANSPOSE', diag, normin, n, a,lda, work, scale,&
                               work( 2*n+1 ), info )
                 else
                    ! multiply by inv(a**t).
                    call stdlib_${ri}$latrs( uplo, 'TRANSPOSE', diag, normin, n, a, lda,work, scale, &
                              work( 2*n+1 ), info )
                 end if
                 normin = 'Y'
                 ! multiply by 1/scale if doing so will not cause overflow.
                 if( scale/=one ) then
                    ix = stdlib_i${ri}$amax( n, work, 1 )
                    xnorm = abs( work( ix ) )
                    if( scale<xnorm*smlnum .or. scale==zero )go to 20
                    call stdlib_${ri}$rscl( n, scale, work, 1 )
                 end if
                 go to 10
              end if
              ! compute the estimate of the reciprocal condition number.
              if( ainvnm/=zero )rcond = ( one / anorm ) / ainvnm
           end if
           20 continue
           return
     end subroutine stdlib_${ri}$trcon


     pure subroutine stdlib_${ri}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! DTREVC: computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(${rk}$) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Local Arrays 
           real(${rk}$) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${ri}$labad( unfl, ovfl )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_i${ri}$amax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_${ri}$gemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$copy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_${ri}$scal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t * x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]                ( work2 )
                          call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_i${ri}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_${ri}$gemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_${ri}$laln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_${ri}$scal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_${ri}$trevc


     pure subroutine stdlib_${ri}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! DTREVC3: computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(${rk}$) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Local Arrays 
           real(${rk}$) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'DTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_${ri}$laset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${ri}$labad( unfl, ovfl )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_${ri}$copy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_i${ri}$amax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_${ri}$gemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_${ri}$axpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_${ri}$axpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_${ri}$copy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_${ri}$copy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_${ri}$scal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_${ri}$gemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_i${ri}$amax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_${ri}$scal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ri}$lacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_${ri}$copy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_i${ri}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_${ri}$gemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_${ri}$laln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_${ri}$copy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_${ri}$copy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_${ri}$scal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_${ri}$gemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_i${ri}$amax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_${ri}$scal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ri}$lacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_${ri}$trevc3


     subroutine stdlib_${ri}$trexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
     !! DTREXC: reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
     !! moved to row ILST.
     !! The real Schur form T is reordered by an orthogonal similarity
     !! transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
     !! is updated by postmultiplying it with Z.
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldt, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: here, nbf, nbl, nbnext
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! decode and test the input arguments.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.wantq .and. .not.stdlib_lsame( compq, 'N' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of specified block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ifst>1 ) then
              if( t( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( t( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ilst>1 ) then
              if( t( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( t( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap block with next one below
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( t( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, nbf, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here+3<=n ) then
                    if( t( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here+1, 1, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1, nbnext,work, info )
                              
                    here = here + 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1,nbnext, work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here+1, 1, 1,work, info )
                                 
                       here = here + 2
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap block with next one above
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,nbf, work, &
                           info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,1, work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, nbnext, 1,work, info )
                              
                    here = here - 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-1, 2, 1,work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-1, 1, 1,work, info )
                                 
                       here = here - 2
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           return
     end subroutine stdlib_${ri}$trexc


     pure subroutine stdlib_${ri}$trrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, berr,&
     !! DTRRFS: provides error bounds and backward error estimates for the
     !! solution to a system of linear equations with a triangular
     !! coefficient matrix.
     !! The solution matrix X must be computed by DTRTRS or some other
     !! means before entering this routine.  DTRRFS does not do iterative
     !! refinement because doing so cannot improve the backward error.
                work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), x(ldx,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           character :: transt
           integer(ilp) :: i, j, k, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transt = 'T'
           else
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_250: do j = 1, nrhs
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a or a**t, depending on trans.
              call stdlib_${ri}$copy( n, x( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$trmv( uplo, trans, diag, n, a, lda, work( n+1 ), 1 )
              call stdlib_${ri}$axpy( n, -one, b( 1, j ), 1, work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              if( notran ) then
                 ! compute abs(a)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = 1, k
                             work( i ) = work( i ) + abs( a( i, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = 1, k - 1
                             work( i ) = work( i ) + abs( a( i, k ) )*xk
                          end do
                          work( k ) = work( k ) + xk
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = k, n
                             work( i ) = work( i ) + abs( a( i, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = abs( x( k, j ) )
                          do i = k + 1, n
                             work( i ) = work( i ) + abs( a( i, k ) )*xk
                          end do
                          work( k ) = work( k ) + xk
                       end do
                    end if
                 end if
              else
                 ! compute abs(a**t)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = 1, k
                             s = s + abs( a( i, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = abs( x( k, j ) )
                          do i = 1, k - 1
                             s = s + abs( a( i, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = k, n
                             s = s + abs( a( i, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = abs( x( k, j ) )
                          do i = k + 1, n
                             s = s + abs( a( i, k ) )*abs( x( i, j ) )
                          end do
                          work( k ) = work( k ) + s
                       end do
                    end if
                 end if
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              210 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**t).
                    call stdlib_${ri}$trsv( uplo, transt, diag, n, a, lda, work( n+1 ),1 )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$trsv( uplo, trans, diag, n, a, lda, work( n+1 ),1 )
                 end if
                 go to 210
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_250
           return
     end subroutine stdlib_${ri}$trrfs


     subroutine stdlib_${ri}$trsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
     !! DTRSEN: reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
     !! the leading diagonal blocks of the upper quasi-triangular matrix T,
     !! and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, liwork, lwork, n
           real(${rk}$), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, kk, ks, liwmin, lwmin, n1, n2, nn
           real(${rk}$) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else
              ! set m to the dimension of the specified invariant subspace,
              ! and test lwork and liwork.
              m = 0
              pair = .false.
              do k = 1, n
                 if( pair ) then
                    pair = .false.
                 else
                    if( k<n ) then
                       if( t( k+1, k )==zero ) then
                          if( select( k ) )m = m + 1
                       else
                          pair = .true.
                          if( select( k ) .or. select( k+1 ) )m = m + 2
                       end if
                    else
                       if( select( n ) )m = m + 1
                    end if
                 end if
              end do
              n1 = m
              n2 = n - m
              nn = n1*n2
              if( wantsp ) then
                 lwmin = max( 1, 2*nn )
                 liwmin = max( 1, nn )
              else if( stdlib_lsame( job, 'N' ) ) then
                 lwmin = max( 1, n )
                 liwmin = 1
              else if( stdlib_lsame( job, 'E' ) ) then
                 lwmin = max( 1, nn )
                 liwmin = 1
              end if
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -15
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -17
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_${ri}$lange( '1', n, n, t, ldt, work )
              go to 40
           end if
           ! collect the selected blocks at the top-left corner of t.
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( t( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ierr = 0
                    kk = k
                    if( k/=ks )call stdlib_${ri}$trexc( compq, n, t, ldt, q, ldq, kk, ks, work,ierr )
                              
                    if( ierr==1 .or. ierr==2 ) then
                       ! blocks too close to swap: exit.
                       info = 1
                       if( wants )s = zero
                       if( wantsp )sep = zero
                       go to 40
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_20
           if( wants ) then
              ! solve sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_${ri}$lacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_${ri}$trsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_${ri}$lange( 'F', n1, n2, work, n1, work )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_${ri}$lacn2( nn, work( nn+1 ), work, iwork, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve  t11*r - r*t22 = scale*x.
                    call stdlib_${ri}$trsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**t*r - r*t22**t = scale*x.
                    call stdlib_${ri}$trsyl( 'T', 'T', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! store the output eigenvalues in wr and wi.
           do k = 1, n
              wr( k ) = t( k, k )
              wi( k ) = zero
           end do
           do k = 1, n - 1
              if( t( k+1, k )/=zero ) then
                 wi( k ) = sqrt( abs( t( k, k+1 ) ) )*sqrt( abs( t( k+1, k ) ) )
                 wi( k+1 ) = -wi( k )
              end if
           end do
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$trsen


     subroutine stdlib_${ri}$trsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
     !! DTRSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a real upper
     !! quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
     !! orthogonal).
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               work, ldwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(${rk}$), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: pair, somcon, wantbh, wants, wantsp
           integer(ilp) :: i, ierr, ifst, ilst, j, k, kase, ks, n2, nn
           real(${rk}$) :: bignum, cond, cs, delta, dumm, eps, est, lnrm, mu, prod, prod1, prod2, &
                     rnrm, scale, smlnum, sn
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(${rk}$) :: dummy(1)
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( t( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -13
              else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ks = 0
           pair = .false.
           loop_60: do k = 1, n
              ! determine whether t(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_60
              else
                 if( k<n )pair = t( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_60
                 else
                    if( .not.select( k ) )cycle loop_60
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( .not.pair ) then
                    ! real eigenvalue.
                    prod = stdlib_${ri}$dot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    rnrm = stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 )
                    s( ks ) = abs( prod ) / ( rnrm*lnrm )
                 else
                    ! complex eigenvalue.
                    prod1 = stdlib_${ri}$dot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    prod1 = prod1 + stdlib_${ri}$dot( n, vr( 1, ks+1 ), 1, vl( 1, ks+1 ),1 )
                    prod2 = stdlib_${ri}$dot( n, vl( 1, ks ), 1, vr( 1, ks+1 ), 1 )
                    prod2 = prod2 - stdlib_${ri}$dot( n, vl( 1, ks+1 ), 1, vr( 1, ks ),1 )
                    rnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    cond = stdlib_${ri}$lapy2( prod1, prod2 ) / ( rnrm*lnrm )
                    s( ks ) = cond
                    s( ks+1 ) = cond
                 end if
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the diagonal
                 ! block beginning at t(k,k) to the (1,1) position.
                 call stdlib_${ri}$lacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 ifst = k
                 ilst = 1
                 call stdlib_${ri}$trexc( 'NO Q', n, work, ldwork, dummy, 1, ifst, ilst,work( 1, n+1 ),&
                            ierr )
                 if( ierr==1 .or. ierr==2 ) then
                    ! could not swap because blocks not well separated
                    scale = one
                    est = bignum
                 else
                    ! reordering successful
                    if( work( 2, 1 )==zero ) then
                       ! form c = t22 - lambda*i in work(2:n,2:n).
                       do i = 2, n
                          work( i, i ) = work( i, i ) - work( 1, 1 )
                       end do
                       n2 = 1
                       nn = n - 1
                    else
                       ! triangularize the 2 by 2 block by unitary
                       ! transformation u = [  cs   i*ss ]
                                          ! [ i*ss   cs  ].
                       ! such that the (1,1) position of work is complex
                       ! eigenvalue lambda with positive imaginary part. (2,2)
                       ! position of work is the complex eigenvalue lambda
                       ! with negative imaginary  part.
                       mu = sqrt( abs( work( 1, 2 ) ) )*sqrt( abs( work( 2, 1 ) ) )
                       delta = stdlib_${ri}$lapy2( mu, work( 2, 1 ) )
                       cs = mu / delta
                       sn = -work( 2, 1 ) / delta
                       ! form
                       ! c**t = work(2:n,2:n) + i*[rwork(1) ..... rwork(n-1) ]
                                                ! [   mu                     ]
                                                ! [         ..               ]
                                                ! [             ..           ]
                                                ! [                  mu      ]
                       ! where c**t is transpose of matrix c,
                       ! and rwork is stored starting in the n+1-st column of
                       ! work.
                       do j = 3, n
                          work( 2, j ) = cs*work( 2, j )
                          work( j, j ) = work( j, j ) - work( 1, 1 )
                       end do
                       work( 2, 2 ) = zero
                       work( 1, n+1 ) = two*mu
                       do i = 2, n - 1
                          work( i, n+1 ) = sn*work( 1, i+1 )
                       end do
                       n2 = 2
                       nn = 2*( n-1 )
                    end if
                    ! estimate norm(inv(c**t))
                    est = zero
                    kase = 0
                    50 continue
                    call stdlib_${ri}$lacn2( nn, work( 1, n+2 ), work( 1, n+4 ), iwork,est, kase, &
                              isave )
                    if( kase/=0 ) then
                       if( kase==1 ) then
                          if( n2==1 ) then
                             ! real eigenvalue: solve c**t*x = scale*c.
                             call stdlib_${ri}$laqtr( .true., .true., n-1, work( 2, 2 ),ldwork, dummy, &
                                       dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c**t*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_${ri}$laqtr( .true., .false., n-1, work( 2, 2 ),ldwork, work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       else
                          if( n2==1 ) then
                             ! real eigenvalue: solve c*x = scale*c.
                             call stdlib_${ri}$laqtr( .false., .true., n-1, work( 2, 2 ),ldwork, dummy,&
                                        dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_${ri}$laqtr( .false., .false., n-1,work( 2, 2 ), ldwork,work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       end if
                       go to 50
                    end if
                 end if
                 sep( ks ) = scale / max( est, smlnum )
                 if( pair )sep( ks+1 ) = sep( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_60
           return
     end subroutine stdlib_${ri}$trsna


     subroutine stdlib_${ri}$trsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! DTRSYL: solves the real Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**T, and  A and B are both upper quasi-
     !! triangular. A is M-by-M and B is N-by-N; the right hand side C and
     !! the solution X are M-by-N; and scale is an output scale factor, set
     !! <= 1 to avoid overflow in X.
     !! A and B must be in Schur canonical form (as returned by DHSEQR), that
     !! is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
     !! each 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: ierr, j, k, k1, k2, knext, l, l1, l2, lnext
           real(${rk}$) :: a11, bignum, da11, db, eps, scaloc, sgn, smin, smlnum, suml, sumr, &
                     xnorm
           ! Local Arrays 
           real(${rk}$) :: dum(1), vec(2,2), x(2,2)
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'T' ) .and. .not.stdlib_lsame( trana, &
                     'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'T' ) .and. .not.stdlib_lsame( &
                     tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=${rk}$) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_${ri}$lange( 'M', m, m, a, lda, dum ),eps*stdlib_${ri}$lange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
               ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                        ! m                         l-1
              ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)].
                      ! i=k+1                       j=1
              ! start column loop (index = l)
              ! l1 (l2) : column index of the first (first) row of x(k,l).
              lnext = 1
              loop_60: do l = 1, n
                 if( l<lnext )cycle loop_60
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l).
                 knext = m
                 loop_50: do k = m, 1, -1
                    if( k>knext )cycle loop_50
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .false., .false., isgn, 2, 2,a( k1, k1 ), lda, b( l1, &
                                 l1 ), ldb, vec,2, scaloc, x, 2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_50
              end do loop_60
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**t *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1        t                    l-1
                ! r(k,l) = sum [a(i,k)**t*x(i,l)] +isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                          j=1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = 1
              loop_120: do l = 1, n
                 if( l<lnext )cycle loop_120
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_110: do k = 1, m
                    if( k<knext )cycle loop_110
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .true., .false., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_110
              end do loop_120
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**t*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! top-right corner column by column by
                 ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                           ! k-1                            n
                  ! r(k,l) = sum [a(i,k)**t*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                           ! i=1                          j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_180: do l = n, 1, -1
                 if( l>lnext )cycle loop_180
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_170: do k = 1, m
                    if( k<knext )cycle loop_170
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .true., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, l1 &
                                 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_170
              end do loop_180
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-right corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                            ! m                          n
                  ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                          ! i=k+1                      j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_240: do l = n, 1, -1
                 if( l>lnext )cycle loop_240
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = m
                 loop_230: do k = m, 1, -1
                    if( k>knext )cycle loop_230
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .false., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_230
              end do loop_240
           end if
           return
     end subroutine stdlib_${ri}$trsyl


     pure subroutine stdlib_${ri}$trti2( uplo, diag, n, a, lda, info )
     !! DTRTI2: computes the inverse of a real upper or lower triangular
     !! matrix.
     !! This is the Level 2 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j
           real(${rk}$) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRTI2', -info )
              return
           end if
           if( upper ) then
              ! compute inverse of upper triangular matrix.
              do j = 1, n
                 if( nounit ) then
                    a( j, j ) = one / a( j, j )
                    ajj = -a( j, j )
                 else
                    ajj = -one
                 end if
                 ! compute elements 1:j-1 of j-th column.
                 call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', diag, j-1, a, lda,a( 1, j ), 1 )
                           
                 call stdlib_${ri}$scal( j-1, ajj, a( 1, j ), 1 )
              end do
           else
              ! compute inverse of lower triangular matrix.
              do j = n, 1, -1
                 if( nounit ) then
                    a( j, j ) = one / a( j, j )
                    ajj = -a( j, j )
                 else
                    ajj = -one
                 end if
                 if( j<n ) then
                    ! compute elements j+1:n of j-th column.
                    call stdlib_${ri}$trmv( 'LOWER', 'NO TRANSPOSE', diag, n-j,a( j+1, j+1 ), lda, a( &
                              j+1, j ), 1 )
                    call stdlib_${ri}$scal( n-j, ajj, a( j+1, j ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$trti2


     pure subroutine stdlib_${ri}$trtri( uplo, diag, n, a, lda, info )
     !! DTRTRI: computes the inverse of a real upper or lower triangular
     !! matrix A.
     !! This is the Level 3 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j, jb, nb, nn
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity if non-unit.
           if( nounit ) then
              do info = 1, n
                 if( a( info, info )==zero )return
              end do
              info = 0
           end if
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'DTRTRI', uplo // diag, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_${ri}$trti2( uplo, diag, n, a, lda, info )
           else
              ! use blocked code
              if( upper ) then
                 ! compute inverse of upper triangular matrix
                 do j = 1, n, nb
                    jb = min( nb, n-j+1 )
                    ! compute rows 1:j-1 of current block column
                    call stdlib_${ri}$trmm( 'LEFT', 'UPPER', 'NO TRANSPOSE', diag, j-1,jb, one, a, lda,&
                               a( 1, j ), lda )
                    call stdlib_${ri}$trsm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', diag, j-1,jb, -one, a( j,&
                               j ), lda, a( 1, j ), lda )
                    ! compute inverse of current diagonal block
                    call stdlib_${ri}$trti2( 'UPPER', diag, jb, a( j, j ), lda, info )
                 end do
              else
                 ! compute inverse of lower triangular matrix
                 nn = ( ( n-1 ) / nb )*nb + 1
                 do j = nn, 1, -nb
                    jb = min( nb, n-j+1 )
                    if( j+jb<=n ) then
                       ! compute rows j+jb:n of current block column
                       call stdlib_${ri}$trmm( 'LEFT', 'LOWER', 'NO TRANSPOSE', diag,n-j-jb+1, jb, one,&
                                  a( j+jb, j+jb ), lda,a( j+jb, j ), lda )
                       call stdlib_${ri}$trsm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', diag,n-j-jb+1, jb, -&
                                 one, a( j, j ), lda,a( j+jb, j ), lda )
                    end if
                    ! compute inverse of current diagonal block
                    call stdlib_${ri}$trti2( 'LOWER', diag, jb, a( j, j ), lda, info )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$trtri


     pure subroutine stdlib_${ri}$trtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
     !! DTRTRS: solves a triangular system of the form
     !! A * X = B  or  A**T * X = B,
     !! where A is a triangular matrix of order N, and B is an N-by-NRHS
     !! matrix.  A check is made to verify that A is nonsingular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) .and. &
                     .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity.
           if( nounit ) then
              do info = 1, n
                 if( a( info, info )==zero )return
              end do
           end if
           info = 0
           ! solve a * x = b  or  a**t * x = b.
           call stdlib_${ri}$trsm( 'LEFT', uplo, trans, diag, n, nrhs, one, a, lda, b,ldb )
           return
     end subroutine stdlib_${ri}$trtrs


     pure subroutine stdlib_${ri}$trttf( transr, uplo, n, a, lda, arf, info )
     !! DTRTTF: copies a triangular matrix A from standard full format (TR)
     !! to rectangular full packed format (TF) .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(0:lda-1,0:*)
           real(${rk}$), intent(out) :: arf(0:*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: i, ij, j, k, l, n1, n2, nt, nx2, np1x2
           ! Intrinsic Functions 
           intrinsic :: max,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'T' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRTTF', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 ) then
              if( n==1 ) then
                 arf( 0 ) = a( 0, 0 )
              end if
              return
           end if
           ! size of array arf(0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower: for n even n1=n2=k
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true., lda=n+1 and a is (n+1)--by--k2.
           ! if n is even, set k = n/2 and nisodd = .false., lda=n and a is
           ! n--by--(n+1)/2.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              if( .not.lower )np1x2 = n + n + 2
           else
              nisodd = .true.
              if( .not.lower )nx2 = n + n
           end if
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! n is odd, transr = 'n', and uplo = 'l'
                    ij = 0
                    do j = 0, n2
                       do i = n1, n2 + j
                          arf( ij ) = a( n2+j, i )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is odd, transr = 'n', and uplo = 'u'
                    ij = nt - n
                    do j = n - 1, n1, -1
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = j - n1, n1 - 1
                          arf( ij ) = a( j-n1, l )
                          ij = ij + 1
                       end do
                       ij = ij - nx2
                    end do
                 end if
              else
                 ! n is odd and transr = 't'
                 if( lower ) then
                    ! n is odd, transr = 't', and uplo = 'l'
                    ij = 0
                    do j = 0, n2 - 1
                       do i = 0, j
                          arf( ij ) = a( j, i )
                          ij = ij + 1
                       end do
                       do i = n1 + j, n - 1
                          arf( ij ) = a( i, n1+j )
                          ij = ij + 1
                       end do
                    end do
                    do j = n2, n - 1
                       do i = 0, n1 - 1
                          arf( ij ) = a( j, i )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is odd, transr = 't', and uplo = 'u'
                    ij = 0
                    do j = 0, n1
                       do i = n1, n - 1
                          arf( ij ) = a( j, i )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, n1 - 1
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = n2 + j, n - 1
                          arf( ij ) = a( n2+j, l )
                          ij = ij + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! n is even, transr = 'n', and uplo = 'l'
                    ij = 0
                    do j = 0, k - 1
                       do i = k, k + j
                          arf( ij ) = a( k+j, i )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is even, transr = 'n', and uplo = 'u'
                    ij = nt - n - 1
                    do j = n - 1, k, -1
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = j - k, k - 1
                          arf( ij ) = a( j-k, l )
                          ij = ij + 1
                       end do
                       ij = ij - np1x2
                    end do
                 end if
              else
                 ! n is even and transr = 't'
                 if( lower ) then
                    ! n is even, transr = 't', and uplo = 'l'
                    ij = 0
                    j = k
                    do i = k, n - 1
                       arf( ij ) = a( i, j )
                       ij = ij + 1
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          arf( ij ) = a( j, i )
                          ij = ij + 1
                       end do
                       do i = k + 1 + j, n - 1
                          arf( ij ) = a( i, k+1+j )
                          ij = ij + 1
                       end do
                    end do
                    do j = k - 1, n - 1
                       do i = 0, k - 1
                          arf( ij ) = a( j, i )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! n is even, transr = 't', and uplo = 'u'
                    ij = 0
                    do j = 0, k
                       do i = k, n - 1
                          arf( ij ) = a( j, i )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = k + 1 + j, n - 1
                          arf( ij ) = a( k+1+j, l )
                          ij = ij + 1
                       end do
                    end do
                    ! note that here, on exit of the loop, j = k-1
                    do i = 0, j
                       arf( ij ) = a( i, j )
                       ij = ij + 1
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$trttf


     pure subroutine stdlib_${ri}$trttp( uplo, n, a, lda, ap, info )
     !! DTRTTP: copies a triangular matrix A from full format (TR) to standard
     !! packed format (TP).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: ap(*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower
           integer(ilp) :: i, j, k
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRTTP', -info )
              return
           end if
           if( lower ) then
              k = 0
              do j = 1, n
                 do i = j, n
                    k = k + 1
                    ap( k ) = a( i, j )
                 end do
              end do
           else
              k = 0
              do j = 1, n
                 do i = 1, j
                    k = k + 1
                    ap( k ) = a( i, j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_${ri}$trttp


     pure subroutine stdlib_${ri}$tzrzf( m, n, a, lda, tau, work, lwork, info )
     !! DTZRZF: reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
     !! to upper triangular form by means of orthogonal transformations.
     !! The upper trapezoidal matrix A is factored as
     !! A = ( R  0 ) * Z,
     !! where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
     !! triangular matrix.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iws, ki, kk, ldwork, lwkmin, lwkopt, m1, mu, nb, nbmin, &
                     nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              if( m==0 .or. m==n ) then
                 lwkopt = 1
                 lwkmin = 1
              else
                 ! determine the block size.
                 nb = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
                 lwkopt = m*nb
                 lwkmin = max( 1, m )
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -7
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTZRZF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 ) then
              return
           else if( m==n ) then
              do i = 1, n
                 tau( i ) = zero
              end do
              return
           end if
           nbmin = 2
           nx = 1
           iws = m
           if( nb>1 .and. nb<m ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'DGERQF', ' ', m, n, -1, -1 ) )
              if( nx<m ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGERQF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<m .and. nx<m ) then
              ! use blocked code initially.
              ! the last kk rows are handled by the block method.
              m1 = min( m+1, n )
              ki = ( ( m-nx-1 ) / nb )*nb
              kk = min( m, ki+nb )
              do i = m - kk + ki + 1, m - kk + 1, -nb
                 ib = min( m-i+1, nb )
                 ! compute the tz factorization of the current block
                 ! a(i:i+ib-1,i:n)
                 call stdlib_${ri}$latrz( ib, n-i+1, n-m, a( i, i ), lda, tau( i ),work )
                 if( i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_${ri}$larzt( 'BACKWARD', 'ROWWISE', n-m, ib, a( i, m1 ),lda, tau( i ), &
                              work, ldwork )
                    ! apply h to a(1:i-1,i:n) from the right
                    call stdlib_${ri}$larzb( 'RIGHT', 'NO TRANSPOSE', 'BACKWARD','ROWWISE', i-1, n-i+1,&
                     ib, n-m, a( i, m1 ),lda, work, ldwork, a( 1, i ), lda,work( ib+1 ), ldwork )
                               
                 end if
              end do
              mu = i + nb - 1
           else
              mu = m
           end if
           ! use unblocked code to factor the last or only block
           if( mu>0 )call stdlib_${ri}$latrz( mu, n, n-m, a, lda, tau, work )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$tzrzf


     pure real(${rk}$) function stdlib_${ri}$zsum1( n, cx, incx )
     !! DZSUM1: takes the sum of the absolute values of a complex
     !! vector and returns a quad precision result.
     !! Based on DZASUM from the Level 1 BLAS.
     !! The change is to use the 'genuine' absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           ! Array Arguments 
           complex(${rk}$), intent(in) :: cx(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, nincx
           real(${rk}$) :: stemp
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           stdlib_${ri}$zsum1 = zero
           stemp = zero
           if( n<=0 )return
           if( incx==1 )go to 20
           ! code for increment not equal to 1
           nincx = n*incx
           do i = 1, nincx, incx
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_${ri}$zsum1 = stemp
           return
           ! code for increment equal to 1
           20 continue
           do i = 1, n
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_${ri}$zsum1 = stemp
           return
     end function stdlib_${ri}$zsum1

     pure subroutine stdlib_dlag2${ri}$( m, n, sa, ldsa, a, lda, info )
     !! DLAG2Q converts a DOUBLE PRECISION matrix, SA, to an EXTENDED
     !! PRECISION matrix, A.
     !! Note that while it is possible to overflow while converting
     !! from double to single, it is not possible to overflow when
     !! converting from single to double.
     !! This is an auxiliary routine so there is no argument checking.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldsa, m, n
           ! Array Arguments 
           real(dp), intent(in) :: sa(ldsa,*)
           real(${rk}$), intent(out) :: a(lda,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Executable Statements 
           info = 0
           do j = 1, n
              do i = 1, m
                 a( i, j ) = sa( i, j )
              end do
           end do
           return
     end subroutine stdlib_dlag2${ri}$

end module stdlib_linalg_lapack_${ri}$

#:endif
#:endfor
