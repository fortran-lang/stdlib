#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set KINDS_TYPES = R_KINDS_TYPES+C_KINDS_TYPES
submodule(stdlib_spatial) stdlib_spatial_kabsch

contains
    #:for k, t, s in (KINDS_TYPES)
    module subroutine kabsch_${s}$(P, Q, R, t, c, rmsd, W, scale)
        !> Reference point set (d × N)
        ${t}$, intent(in) :: P(:, :)
        !> Target point set (d × N)
        ${t}$, intent(in) :: Q(:, :)
        !> Optimal rotation matrix (d × d)
        ${t}$, intent(out) :: R(:,:)
        !> Translation vector (d)
        ${t}$, intent(out) :: t(:)
        !> Scale factor
        ${t}$, intent(out) :: c
        !> Root-mean-square deviation
        real(${k}$), intent(out) :: rmsd
        !> Optional weights
        real(${k}$), intent(in), optional :: W(:)
        !> Enable scaling
        logical, intent(in), optional :: scale

        ! Internal variables.
        integer(ilp) :: i, j, point, d, N
        ${t}$, allocatable :: c_P(:), c_Q(:), covariance(:,:), U(:,:), Vt(:,:), B(:,:), vec(:)
        ${t}$ ::  vp, vq
        real(${k}$) :: sum_w, variance_p
        real(${k}$), allocatable :: S(:)
        logical :: scale_
        #:if t.startswith('complex')
        ${t}$ :: detR
        #:endif

        ! Dimension checks
        if(size(P,dim=1)/=size(Q,dim=1) .or. size(P,dim=1)/=size(R,dim=1) .or. size(P,dim=1)/=size(R,dim=2) &
                    .or. size(P,dim=1)/=size(t)) then
            error stop "array sizes do not match"
        end if
        if(size(P,dim=2)/=size(Q,dim=2)) then
            error stop "array sizes do not match"
        end if
        if (present(W)) then
            if (size(W) /= size(P,dim=2)) then
                error stop "array sizes do not match"
            end if
        end if
        d = size(P,dim=1)
        N = size(P,dim=2)
        scale_ = .true.
        if(present(scale)) scale_ = scale

        sum_w = one_${k}$ / N
        if(present(W)) sum_w = one_${k}$ / stdlib_sum(W)

        #:if t.startswith('complex')
        allocate(c_P(d), source=zero_c${k}$)
        allocate(c_Q(d), source=zero_c${k}$)
        #:else
        allocate(c_P(d), source=zero_${k}$)
        allocate(c_Q(d), source=zero_${k}$)
        #:endif

        ! Compute centroids of P and Q
        if(present(W)) then
            do point = 1, N
                c_P(1:d) = c_P(1:d) + P(1:d,point)*W(point)
                c_Q(1:d) = c_Q(1:d) + Q(1:d,point)*W(point)
            end do
        else
            do point = 1, N
                c_P(1:d) = c_P(1:d) + P(1:d,point)
                c_Q(1:d) = c_Q(1:d) + Q(1:d,point)
            end do
        end if
        c_P = c_P * sum_w
        c_Q = c_Q * sum_w

        ! Compute covariance matrix H = (P - c_P) * (Q - c_Q)^T and variance of P
        #:if t.startswith('complex')
        allocate(covariance(d,d), source=zero_c${k}$)
        #:else
        allocate(covariance(d,d), source=zero_${k}$)
        #:endif
        variance_p = zero_${k}$

        if (present(W)) then
            do point = 1, N
                do i = 1, d
                    vp = P(i,point) - c_P(i)
                    #:if t.startswith('complex')
                    variance_p = variance_p + conjg(vp)*vp * W(point)
                    #:else
                    variance_p = variance_p + vp*vp * W(point)
                    #:endif
                end do
                do j = 1, d
                    vq = Q(j,point) - c_Q(j)
                    do i = 1, d
                        vp = P(i,point) - c_P(i)
                        #:if t.startswith('complex')
                        covariance(i,j) = covariance(i,j) + vp*conjg(vq) * W(point)
                        #:else
                        covariance(i,j) = covariance(i,j) + vp*vq * W(point)
                        #:endif
                    end do
                end do
            end do
        else
            do point = 1, N
                do i = 1, d
                    vp = P(i,point) - c_P(i)
                    #:if t.startswith('complex')
                    variance_p = variance_p + conjg(vp)*vp
                    #:else
                    variance_p = variance_p + vp*vp
                    #:endif
                end do
                do j = 1, d
                    vq = Q(j,point) - c_Q(j)
                    do i = 1, d
                        vp = P(i,point) - c_P(i)
                        #:if t.startswith('complex')
                        covariance(i,j) = covariance(i,j) + vp*conjg(vq)
                        #:else
                        covariance(i,j) = covariance(i,j) + vp*vq
                        #:endif
                    end do
                end do
            end do
        end if

        covariance = covariance * sum_w
        variance_p = variance_p * sum_w

        #:if t.startswith('complex')
        allocate(U(d,d), source=zero_c${k}$)
        allocate(Vt(d,d), source=zero_c${k}$)
        #:else
        allocate(U(d,d), source=zero_${k}$)
        allocate(Vt(d,d), source=zero_${k}$)
        #:endif
        allocate(S(d), source=zero_${k}$)

        ! SVD of covariance matrix H -> H = U * S * Vt
        call svd(covariance, S, U, Vt)

        #:if t.startswith('complex')
        allocate(B(d,d), source=zero_c${k}$)
        #:else
        allocate(B(d,d), source=zero_${k}$)
        #:endif

        ! Optimal rotation matrix.
        R = matmul(U, Vt)

        ! Scaling factor
        c = variance_p / (sum(S(1:d)))
        if (.not. scale_) c = one_${k}$

        ! Translation vector
        t = c_P - c*matmul(R , c_Q )

        ! Compute RMSD
        #:if t.startswith('complex')
        allocate(vec(d), source=zero_c${k}$)
        #:else
        allocate(vec(d), source=zero_${k}$)
        #:endif
        rmsd = zero_${k}$
        do i = 1, N
            vec(1:d) = c * matmul(R , Q(1:d,i))
            vec(1:d) = vec(1:d) + t(1:d)
            vec(1:d) = vec(1:d) - P(1:d,i)
            #:if t.startswith('complex')
            rmsd = rmsd + real(dot_product(vec, vec), kind=${k}$)
            #:else
            rmsd = rmsd + dot_product(vec, vec)
            #:endif
        end do
        rmsd = sqrt(rmsd * sum_w)
    end subroutine
    #:endfor
end submodule stdlib_spatial_kabsch